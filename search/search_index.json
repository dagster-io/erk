{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"<code>erk</code> Documentation","text":"<p>erk is a CLI tool for plan-oriented agentic engineering\u2014a workflow where AI agents create implementation plans, execute them in isolated worktrees, and ship code via automated PR workflows.</p> <p>For the philosophy and design principles behind erk, see The TAO of erk.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>New to erk? Start here:</p> <ol> <li>Prerequisites - Tools you need installed</li> <li>Installation - Install and configure erk</li> <li>Your First Plan - Complete tutorial from plan to PR</li> </ol>"},{"location":"#features","title":"Features","text":"<ul> <li>Plan-First Workflow: AI agents create detailed implementation plans before writing code</li> <li>Worktree Isolation: Each implementation runs in its own isolated git worktree</li> <li>Agent-Driven Development: Automated PR workflows powered by Claude Code</li> <li>Documentation as Code: Agent-generated documentation lives alongside the codebase</li> </ul>"},{"location":"#documentation-sections","title":"Documentation Sections","text":""},{"location":"#tutorials","title":"Tutorials","text":"<p>Step-by-step lessons to get you started.</p> <ul> <li>Prerequisites - Required tools and versions</li> <li>Installation - Installing and initializing erk</li> <li>Your First Plan - End-to-end tutorial</li> </ul>"},{"location":"#topics","title":"Topics","text":"<p>Core concepts that explain how erk works.</p> <ul> <li>Worktrees - Parallel development with git worktrees</li> <li>Graphite Integration - Stacked PR workflows with Graphite</li> <li>Plan Mode - Claude Code's planning workflow</li> <li>The Workflow - From idea to merged PR</li> <li>Plan-Oriented Engineering - The philosophy behind erk</li> <li>Why GitHub Issues for Plans - Why plans are stored as issues</li> </ul>"},{"location":"#how-to-guides","title":"How-to Guides","text":"<p>Task-focused recipes for specific goals.</p> <ul> <li>Use the Local Workflow - Plan, implement, and ship locally</li> <li>Run Remote Execution - Run implementations in GitHub Actions</li> <li>Checkout and Sync PRs - Review and iterate on PRs</li> <li>Automatic Merge Conflict Resolution - Handle merge conflicts with AI assistance</li> <li>Work Without Plans - Quick changes without formal plans</li> <li>Extract Documentation - Capture patterns for future agents</li> </ul>"},{"location":"#reference","title":"Reference","text":"<p>Complete technical reference.</p> <ul> <li>CLI Command Reference - All CLI commands</li> <li>Slash Command Reference - Claude Code slash commands</li> <li>Configuration Reference - Config files and options</li> <li>File Location Reference - Where erk stores data</li> </ul>"},{"location":"#faq","title":"FAQ","text":"<p>Common questions and solutions.</p>"},{"location":"#common-user-journeys","title":"Common User Journeys","text":"<p>\"I want to start using erk\" \u2192 Prerequisites \u2192 Installation \u2192 Your First Plan</p> <p>\"I want to understand how erk works\" \u2192 The Workflow \u2192 Plan-Oriented Engineering</p> <p>\"I'm reviewing a teammate's PR\" \u2192 Checkout and Sync PRs</p> <p>\"My rebase has conflicts\" \u2192 Automatic Merge Conflict Resolution</p> <p>\"I need quick iteration without planning\" \u2192 Work Without Plans</p>"},{"location":"#other-documentation","title":"Other Documentation","text":"Directory Audience Purpose <code>docs/learned/</code> AI agents Agent-generated patterns and conventions <code>docs/developer/</code> Contributors Internal development docs"},{"location":"TAO/","title":"The TAO of <code>erk</code>","text":"<p><code>erk</code> is a CLI tool built for the orchestration and management of plan-oriented agentic engineering.</p>"},{"location":"TAO/#what-is-plan-oriented-agentic-engineering","title":"What is Plan-Oriented Agentic Engineering?","text":"<p>AI is transforming software development. What started with in-IDE copilots, intelligent typeaheads, and standalone conversational chat interfaces is now evolving into an entire new generation of tooling.</p> <p>Planning has become an increasingly important modality. Widely popularized by Claude Code, it is now getting incorporated into other popular tools such as Cursor.</p> <p><code>erk</code> believes that planning is the foundational skill of agentic engineering and will remain essential for the foreseeable future, even as model capabilities increase.</p> <p>Planning enables larger units of work to execute with higher quality outcomes. This property also means massive increases in throughput through parallelization. Without planning, you are limited to making serial chains of work more productive via typeaheads or synchronous code generation steps.</p> <p>More problematically, without planning you are unlikely to provide sufficient context to a model, leaving your instructions too open for interpretation. This is often interpreted as a hallucination. But the reality is that if insufficient context was given, there is no way for the model to fulfill your requirements: It will be forced to invent them.</p> <p>Put another way: no matter how powerful they become, models cannot solve the \"Garbage-In-Garbage-Out\" problem. Planning is the right tool in professional software engineering to ensure that the right context is provided to the agent.</p>"},{"location":"TAO/#the-gap-no-engineering-process-tooling-or-workflows-around-plans","title":"The Gap: No Engineering Process, Tooling, or Workflows Around Plans","text":"<p>Claude Code popularized \"plan mode\" as a first-class capability in agentic engineering tools. Other tools, such as Cursor and Windsurf, have since followed suit. The ecosystem clearly sees a lot of uptake and progress in the technique.</p> <p>Yet despite this recognition, planning remains poorly integrated into actual developer workflows in practice. The primitives exist, but there is no coherent process that ties them together.</p> <p>Engineers who want to work in a plan-oriented way face significant friction. Plans are saved as markdown files and must be managed manually, or exist only ephemerally in agent context. There is no system of record. Plans cannot be queried, tracked, or closed. They are not attached to any automation or workflow.</p> <p>Parallel execution is similarly ad-hoc. Git worktrees provide isolation, but management around them is primitive and tedious. Developers have to manually bookkeep locations, environments, and so forth.</p> <p>Many tools and companies working on parts of this problem, but usually in a way that is more about \"vibecoding\" rather than professional software engineering. Siloed tools, poor integration with native engineering workflows, and lack of true automation are non-starters for engineers working on at-scale, complex systems.</p> <p>This is a solveable problem. It just requires a renewed embrace of engineering process and better tools.</p>"},{"location":"TAO/#the-solution-erk","title":"The Solution: <code>erk</code>","text":"<p><code>erk</code> is a tool centered around an opinionated workflow that unifies plans, worktrees, and compute into a coherent engineering process. It is uncompromisingly plan-oriented: you create plans, you implement plans, and complete plans, often without touching an IDE.</p>"},{"location":"TAO/#plans-as-system-of-record","title":"Plans as System of Record","text":"<p>In <code>erk</code>, plans are not files on disk or ephemeral context in an agent session. They are persisted in a system of record. In this initial version, that system is GitHub issues. This means plans:</p> <ul> <li>Can be saved, listed, and tracked for bookkeeping</li> <li>Integrate directly into engineering workflows such as code review</li> <li>Can be opened, closed, and attached to pull requests</li> <li>Are hubs of context that build up the memory of an engineering organization</li> </ul>"},{"location":"TAO/#worktrees-are-first-class","title":"Worktrees Are First-Class","text":"<p>Worktrees are essential to high-output agentic engineering. Without worktrees (or a similar abstraction), you cannot parallelize work across multiple agents, eliminating much of the promise of the technology.</p> <p><code>erk</code> believes that worktrees should be as first-class as branches in modern engineering workflows. The only reason they aren't right now is tooling quality.</p> <p>In tools like <code>git</code> and <code>gt</code>\u2014which <code>erk</code> is built on\u2014you checkout branches. In <code>erk</code>, you checkout worktrees, which are created ephemerally and tied to a branch and an environment.</p> <p>In the initial version, the toolchain is <code>gt</code>, <code>git</code>, <code>uv</code> (Python environment management), and <code>gh</code> (for issues and automation). When you checkout a worktree, it creates or switches to:</p> <ul> <li>A worktree</li> <li>A branch</li> <li>A virtual environment (which it syncs and activates)</li> </ul> <p>Additionally there is typically a single plan associated with that worktree.</p> <p>With those things in place, agents can author code in parallel in an orderly, controlled fashion. The process is seamless.</p> <p>With <code>erk</code> creating a worktree, switching between them, and activating the correct environment happens seamlessly\u2014as easily as checking out a branch. <code>erk</code> integrates with Graphite for stacked PRs and uv for instant virtual environment activation. The friction that normally prevents parallel local execution is removed.</p>"},{"location":"TAO/#compute","title":"Compute","text":"<p>Agents need compute and environments to autonomously and safely execute in parallel.</p> <p>By default, <code>erk</code> provides isolation at the worktree and virtual environment level on your machine. This enables parallelization but does not solve security and safety issues. Each agent has full access to the file system, and most agentic systems have permissions in place to prompt users when potentially destructive operations could occur. This severely limits autonomy.</p> <p>Remote, sandboxed execution is the solution to this. In those environments the coding agents can operate in \"dangerous\" mode and bypass the permission system entirely. <code>erk</code> supports this natively.</p> <p>As an initial remote execution engine, <code>erk</code> uses GitHub Actions. You can submit work to the <code>erk</code> queue as easily as executing on your own machine. You are no longer limited by monitoring permissions (just turn them off) nor are you limited by the compute capacity of your laptop (you can infinitely scale). You are only limited by your ability to generate plans and manage workflows.</p>"},{"location":"TAO/#putting-it-all-together-the-workflow","title":"Putting It All Together: The Workflow","text":"<p>Plan \u2192 Save \u2192 Implement \u2192 Review and Iterate \u2192 Ship</p> <ol> <li> <p>Plan: Within an agentic tool\u2014in this case, Claude Code\u2014you construct a plan. This is where context leaves your head and enters the system.</p> </li> <li> <p>Save: The plan is saved to the system of record. In <code>erk</code>, this is a slash command within <code>claude</code> that creates a tool-managed GitHub issue. The plan is now trackable, queryable, and attached to your engineering workflow.</p> </li> <li> <p>Implement: Execute the plan locally with <code>erk implement</code> or dispatch it remotely with <code>erk plan submit</code>. Local execution creates a worktree, activates the environment, and invokes <code>claude</code>. Remote execution triggers a <code>gh</code> action that creates a PR. All of this is tracked and managed by <code>erk</code>.</p> </li> <li> <p>Review and Iterate: Review the code. If the output is close but not complete, comment on the PR use that to bootstrap a follow up coding session. You can seamlessly check out the worktree locally and iterate.</p> </li> <li> <p>Ship: Merge the PR. The plan closes automatically, leaving the issue and the PR as a permanent record of what was planned, what was done, and any discussion along the way. Clean up your mess and build up the engineering organization's memory over time.</p> </li> </ol>"},{"location":"TAO/#current-scope","title":"Current Scope","text":"<p><code>erk</code> is an internal tool developed at Dagster Labs. It reflects our beliefs about how agentic engineering should work and how we want to work ourselves.</p> <p>The philosophy is general, but the current implementation is opinionated and specific. To use <code>erk</code> effectively today, you need:</p> <ul> <li><code>python</code>: Programming Language</li> <li><code>claude</code>: Claude Code</li> <li><code>uv</code>: Fast Python Environment Management</li> <li><code>gt</code>: Graphite for stacked PRs</li> <li><code>gh</code>: Github for issues, PRs, and Actions</li> </ul> <p>This is the toolchain we use internally. <code>erk</code> is designed to be extensible to other languages, systems of record, and compute backends. Our next toolchain will be TypeScript-focused. Beyond that, we have no plans for additional stacks.</p> <p>If you're outside Dagster Labs and find this useful, you're welcome to explore, but you will likely have challenges using the tool in your environment.</p> <p>This is also meant to be a showcase and a place to interact with collaborators where we have deep partnerships and context. For the broader public, we will not actively fix bugs, work on features, or accept contributions that do not directly apply to the work at Dagster Labs.</p>"},{"location":"contributing/writing-documentation/","title":"Writing Documentation","text":"<p>This guide explains how to write and organize documentation for erk using the Divio Documentation System.</p>"},{"location":"contributing/writing-documentation/#the-divio-framework","title":"The Divio Framework","text":"<p><code>erk</code>'s documentation follows the Divio Documentation System, which organizes content into four categories based on user intent:</p> Category Purpose User Intent Directory Tutorials Learning-oriented \"Teach me\" <code>tutorials/</code> Topics Understanding \"Explain this\" <code>topics/</code> How-to Goal-oriented \"Help me do X\" <code>howto/</code> Reference Information-oriented \"Look up Y\" <code>ref/</code> <p>This system is used by Django, NumPy, Cloudflare Workers, and many other projects.</p>"},{"location":"contributing/writing-documentation/#category-definitions","title":"Category Definitions","text":""},{"location":"contributing/writing-documentation/#tutorials","title":"Tutorials","text":"<p>Purpose: Learning-oriented lessons that guide beginners through a series of steps.</p> <p>Characteristics:</p> <ul> <li>Step-by-step instructions</li> <li>Focus on learning, not accomplishing a task</li> <li>Explain what's happening and why</li> <li>Build toward a working result</li> </ul> <p>Title pattern: Use descriptive names (no special prefix)</p> <p>Example: \"Your First Plan\" guides users through creating and executing their first plan.</p> <p>Test question: Does this teach a skill through hands-on practice?</p>"},{"location":"contributing/writing-documentation/#topics","title":"Topics","text":"<p>Purpose: Understanding-oriented explanations of concepts and ideas.</p> <p>Characteristics:</p> <ul> <li>Explain \"why\" and \"how things work\"</li> <li>Provide context and background</li> <li>Connect concepts to each other</li> <li>Don't require following along</li> </ul> <p>Title pattern: Noun phrases describing the concept</p> <p>Example: \"Worktrees\" explains what git worktrees are and why erk uses them.</p> <p>Test question: Does this help someone understand a concept?</p>"},{"location":"contributing/writing-documentation/#how-to-guides","title":"How-to Guides","text":"<p>Purpose: Goal-oriented instructions for accomplishing specific tasks.</p> <p>Characteristics:</p> <ul> <li>Task-focused, not learning-focused</li> <li>Assume basic knowledge</li> <li>Get to the point quickly</li> <li>Cover one specific goal</li> </ul> <p>Title pattern: Must work as \"How to [title]\"</p> Title How to... Use the Local Workflow How to use the local workflow Resolve Merge Conflicts How to resolve merge conflicts Work Without Plans How to work without plans <p>Test question: Does this help someone accomplish a specific goal?</p>"},{"location":"contributing/writing-documentation/#reference","title":"Reference","text":"<p>Purpose: Information-oriented technical specifications.</p> <p>Characteristics:</p> <ul> <li>Complete and accurate</li> <li>Consistent structure</li> <li>No explanation or guidance</li> <li>Optimized for lookup, not reading</li> </ul> <p>Title pattern: Use \"X Reference\" suffix</p> Title Content CLI Command Reference All CLI commands and options Configuration Reference All configuration options File Location Reference All file paths and directories <p>Test question: Does this provide technical details for lookup?</p>"},{"location":"contributing/writing-documentation/#choosing-the-right-category","title":"Choosing the Right Category","text":"<p>Use these questions to categorize new content:</p> <ol> <li>Is this teaching a beginner? \u2192 Tutorial</li> <li>Does this explain concepts or theory? \u2192 Topic</li> <li>Does this solve a specific problem? \u2192 How-to</li> <li>Is this a technical specification? \u2192 Reference</li> </ol>"},{"location":"contributing/writing-documentation/#common-mistakes","title":"Common Mistakes","text":"Content Type Wrong Category Right Category \"Introduction to worktrees\" Tutorials Topics \"Worktree CLI Reference\" Topics Reference \"Why we use worktrees\" How-to Topics \"Create a worktree for a plan\" Reference How-to"},{"location":"contributing/writing-documentation/#file-structure","title":"File Structure","text":"<p>Each category directory contains:</p> <ul> <li><code>index.md</code> - Section overview for navigation (MkDocs)</li> <li><code>README.md</code> - Section overview for GitHub viewing</li> <li>Individual topic files</li> </ul>"},{"location":"contributing/writing-documentation/#file-naming","title":"File Naming","text":"<ul> <li>Use lowercase with hyphens: <code>local-workflow.md</code></li> <li>Keep names short but descriptive</li> <li>Avoid abbreviations unless widely known</li> </ul>"},{"location":"contributing/writing-documentation/#cross-references","title":"Cross-References","text":"<p>When linking to other documentation:</p> <ul> <li>Use relative paths: <code>../topics/worktrees.md</code></li> <li>Link to related content in a \"See Also\" section</li> <li>Use the new title conventions when referring to documents</li> </ul>"},{"location":"contributing/writing-documentation/#directory-mappings","title":"Directory Mappings","text":"Old Directory New Directory <code>getting-started/</code> <code>tutorials/</code> <code>concepts/</code> <code>topics/</code> <code>guides/</code> <code>howto/</code> <code>reference/</code> <code>ref/</code> <code>troubleshooting/</code> <code>faq/</code>"},{"location":"contributing/writing-documentation/#see-also","title":"See Also","text":"<ul> <li>Divio Documentation System - Full framework documentation</li> <li>Django Documentation - Example implementation</li> </ul>"},{"location":"faq/","title":"FAQ","text":"<p>Answers to common questions and solutions to frequent problems.</p>"},{"location":"faq/#getting-help","title":"Getting Help","text":"<p>If your issue isn't covered here:</p> <ol> <li>Run <code>erk doctor</code> to check your environment</li> <li>Check the GitHub Issues for known problems</li> <li>File a new issue with output from <code>erk doctor</code></li> </ol>"},{"location":"faq/#see-also","title":"See Also","text":"<ul> <li>Prerequisites - Required tools and versions</li> </ul>"},{"location":"howto/","title":"How-to Guides","text":"<p>Task-focused recipes for accomplishing specific goals with erk.</p> <p>How-to guides are goal-oriented. They provide practical steps to solve real-world problems.</p>"},{"location":"howto/#core-workflows","title":"Core Workflows","text":"<ul> <li>Use the Local Workflow - Plan, implement, and ship code locally</li> <li>Navigate Branches and Worktrees - Switch between branches and stacks</li> <li>Test GitHub Actions Workflows - Test workflow changes before merging</li> </ul>"},{"location":"howto/#pr-operations","title":"PR Operations","text":"<ul> <li>Checkout and Sync PRs - Review and iterate on existing PRs</li> <li>Automatic Merge Conflict Resolution - Handle merge conflicts with AI assistance</li> </ul>"},{"location":"howto/#advanced","title":"Advanced","text":"<ul> <li>Run Remote Execution - Run implementations in GitHub Actions</li> <li>Work Without Plans - Quick changes without formal plans</li> <li>Extract Documentation - Capture patterns for future agents</li> </ul>"},{"location":"howto/#see-also","title":"See Also","text":"<ul> <li>CLI Command Reference - All CLI commands</li> <li>Slash Command Reference - Claude Code commands</li> </ul>"},{"location":"howto/conflict-resolution/","title":"Automatic Merge Conflict Resolution","text":"<p>Handle merge conflicts with AI assistance.</p>"},{"location":"howto/conflict-resolution/#overview","title":"Overview","text":"<p>Merge conflicts occur when two branches modify the same lines of code. In erk workflows, you'll encounter conflicts during:</p> <ul> <li>PR sync (<code>erk pr sync</code>): Syncing your branch with upstream changes</li> <li>Stack rebase (<code>gt restack</code>): Restacking branches after landing a PR</li> <li>Remote rebase: When GitHub Actions rebases your PR</li> </ul> <p>Erk provides two resolution paths: local (resolve in your worktree with Claude) and remote (trigger a GitHub Actions workflow).</p>"},{"location":"howto/conflict-resolution/#local-resolution","title":"Local Resolution","text":"<p>The primary workflow for resolving conflicts locally. Use this when you're in the worktree and want immediate resolution.</p>"},{"location":"howto/conflict-resolution/#when-to-use","title":"When to Use","text":"<ul> <li>You're already checked out in the branch's worktree</li> <li>You want to review the resolution before pushing</li> <li>The conflicts require domain knowledge you can provide interactively</li> </ul>"},{"location":"howto/conflict-resolution/#commands","title":"Commands","text":"<p>CLI command (outside a Claude session):</p> <pre><code>erk pr fix-conflicts --dangerous\n</code></pre> <p>Slash command (inside a Claude Code session):</p> <pre><code>/erk:fix-conflicts\n</code></pre> <p>Both invoke Claude to resolve conflicts. The <code>--dangerous</code> flag acknowledges that Claude will run with elevated permissions.</p>"},{"location":"howto/conflict-resolution/#how-it-works","title":"How It Works","text":"<p>Claude will:</p> <ol> <li>Run <code>git status</code> to identify conflicted files</li> <li>Read each conflicted file and understand the conflict markers</li> <li>Resolve conflicts by choosing the appropriate changes</li> <li>Stage the resolved files with <code>git add</code></li> <li>Continue the rebase with <code>git rebase --continue</code></li> <li>Repeat if the rebase reveals more conflicts</li> </ol>"},{"location":"howto/conflict-resolution/#semantic-conflicts","title":"Semantic Conflicts","text":"<p>Sometimes both sides of a conflict are semantically correct but Claude needs guidance on which behavior to preserve. In these cases, Claude will ask for clarification before proceeding.</p> <p>For example, if both branches renamed the same function differently, Claude will ask which name you prefer.</p>"},{"location":"howto/conflict-resolution/#after-resolution","title":"After Resolution","text":"<p>Once conflicts are resolved and the rebase completes, push your changes:</p> <ul> <li>With Graphite: <code>gt submit</code> or <code>gt ss</code></li> <li>Without Graphite: <code>git push --force-with-lease</code></li> </ul>"},{"location":"howto/conflict-resolution/#handling-branch-updated-remotely-errors","title":"Handling \"Branch Updated Remotely\" Errors","text":"<p>When <code>gt submit</code> fails with \"Branch X has been updated remotely\", this indicates branch divergence - not a merge conflict (yet). Your local branch and the remote branch have both advanced independently.</p> <p>This commonly happens when:</p> <ul> <li>CI/autofix added commits to your branch</li> <li>You amended a commit locally after pushing</li> <li>Another tool or workflow pushed to your branch</li> </ul>"},{"location":"howto/conflict-resolution/#divergence-vs-conflicts","title":"Divergence vs Conflicts","text":"Situation What It Means Command to Use Branch diverged Local and remote both have new commits <code>erk pr sync-divergence</code> Rebase in progress Conflict markers in files during a rebase <code>erk pr fix-conflicts</code>"},{"location":"howto/conflict-resolution/#sync-divergence-command","title":"Sync Divergence Command","text":"<p>CLI command (outside a Claude session):</p> <pre><code>erk pr sync-divergence --dangerous\n</code></pre> <p>Slash command (inside a Claude Code session):</p> <pre><code>/erk:sync-divergence\n</code></pre>"},{"location":"howto/conflict-resolution/#how-it-works_1","title":"How It Works","text":"<p>Claude will:</p> <ol> <li>Fetch remote state with <code>git fetch origin</code></li> <li>Analyze divergence (commits on each side)</li> <li>If remote has commits you don't have: fast-forward merge</li> <li>If both sides have commits: rebase your local commits on top of remote</li> <li>If rebase causes conflicts: resolve them automatically</li> <li>Push the synchronized branch</li> </ol>"},{"location":"howto/conflict-resolution/#after-sync","title":"After Sync","text":"<p>Once synced, retry your original operation:</p> <ul> <li>With Graphite: <code>gt submit</code> or <code>gt ss</code></li> <li>Without Graphite: <code>git push --force-with-lease</code></li> </ul>"},{"location":"howto/conflict-resolution/#remote-resolution","title":"Remote Resolution","text":"<p>Resolve conflicts without checking out the branch locally. A GitHub Actions workflow handles the rebase and conflict resolution.</p>"},{"location":"howto/conflict-resolution/#when-to-use_1","title":"When to Use","text":"<ul> <li>You don't want to switch to the branch's worktree</li> <li>The branch is from a remote execution that you'd prefer to keep separate</li> <li>You want a clean squash before resolving conflicts</li> </ul>"},{"location":"howto/conflict-resolution/#command","title":"Command","text":"<pre><code>erk pr fix-conflicts-remote\n</code></pre> <p>Or for a specific PR without being on the branch:</p> <pre><code>erk pr fix-conflicts-remote 123\n</code></pre>"},{"location":"howto/conflict-resolution/#what-happens","title":"What Happens","text":"<p>The workflow:</p> <ol> <li>Squashes all commits on the branch (unless <code>--no-squash</code>)</li> <li>Rebases onto the PR's base branch</li> <li>Uses Claude to resolve any merge conflicts</li> <li>Force pushes the rebased branch</li> </ol>"},{"location":"howto/conflict-resolution/#options","title":"Options","text":"Option Description <code>--no-squash</code> Skip squashing commits before rebase <code>--model</code> Specify Claude model (default: claude-sonnet-4-5)"},{"location":"howto/conflict-resolution/#examples","title":"Examples","text":"<pre><code># Basic usage - squash and rebase current branch's PR\nerk pr fix-conflicts-remote\n\n# Trigger rebase for a specific PR (without checking out)\nerk pr fix-conflicts-remote 123\n\n# Rebase without squashing\nerk pr fix-conflicts-remote --no-squash\n\n# Use a specific model\nerk pr fix-conflicts-remote --model claude-sonnet-4-5\n</code></pre>"},{"location":"howto/conflict-resolution/#requirements","title":"Requirements","text":"<ul> <li>Either be on a branch with an open PR, or provide a PR number</li> <li>GitHub Actions secrets must be configured (<code>ERK_QUEUE_GH_PAT</code>, Claude credentials)</li> </ul>"},{"location":"howto/conflict-resolution/#understanding-stack-conflicts","title":"Understanding Stack Conflicts","text":"<p>When using Graphite for stacked PRs, conflicts can propagate through the stack.</p>"},{"location":"howto/conflict-resolution/#how-stack-conflicts-occur","title":"How Stack Conflicts Occur","text":"<pre><code>master (updated)\n\u2514\u2500\u2500 feature-base (needs rebase)\n    \u2514\u2500\u2500 feature-part-1 (needs rebase after parent)\n        \u2514\u2500\u2500 feature-part-2 (needs rebase after parent)\n</code></pre> <p>When <code>master</code> advances, each branch in the stack may need rebasing. Conflicts resolved in <code>feature-base</code> may reveal new conflicts in <code>feature-part-1</code>, and so on.</p>"},{"location":"howto/conflict-resolution/#restack-workflow","title":"Restack Workflow","text":"<p>After landing a PR in a stack:</p> <ol> <li><code>gt restack</code> attempts to rebase remaining branches</li> <li>If conflicts occur, resolve them with <code>/erk:fix-conflicts</code></li> <li>After resolution, <code>gt restack</code> continues automatically</li> <li>Repeat until the entire stack is rebased</li> </ol>"},{"location":"howto/conflict-resolution/#navigation-during-conflicts","title":"Navigation During Conflicts","text":"<p>Use stack navigation to move between branches:</p> <pre><code>erk up      # Move toward leaves (away from trunk)\nerk down    # Move toward trunk (toward parent)\n</code></pre> <p>See Navigate Branches and Worktrees for details.</p>"},{"location":"howto/conflict-resolution/#manual-resolution-fallback","title":"Manual Resolution (Fallback)","text":"<p>When AI resolution doesn't produce the desired result, fall back to standard git workflow:</p> <ol> <li>Check status: <code>git status</code> shows conflicted files</li> <li>Edit files: Open each conflicted file and resolve the <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> markers manually</li> <li>Stage: <code>git add &lt;resolved-files&gt;</code></li> <li>Continue: <code>git rebase --continue</code></li> <li>Repeat: If more conflicts appear, repeat the process</li> <li>Push: <code>git push --force-with-lease</code> or <code>gt submit</code></li> </ol>"},{"location":"howto/conflict-resolution/#best-practices","title":"Best Practices","text":"<p>Sync frequently. The longer your branch diverges from trunk, the more likely conflicts become. Run <code>erk pr sync --dangerous</code> regularly to stay up to date.</p> <p>Prefer smaller, focused PRs. Large PRs touching many files are more likely to conflict. Break work into smaller, independent changes when possible.</p> <p>Review resolution before pushing. After AI-powered conflict resolution, review the changes with <code>git diff</code> to ensure the resolution makes sense. The AI might not understand the full context of your changes.</p> <p>Use <code>--force-with-lease</code>. When pushing rebased branches, <code>--force-with-lease</code> is safer than <code>--force</code>. It fails if someone else has pushed to the branch, preventing you from overwriting their work.</p>"},{"location":"howto/conflict-resolution/#see-also","title":"See Also","text":"<ul> <li>Graphite Integration - Understanding stacks</li> <li>Navigate Branches and Worktrees - Moving between branches</li> <li>Use the Local Workflow - Standard development cycle</li> <li>Worktrees - How worktrees enable parallel work</li> </ul>"},{"location":"howto/documentation-extraction/","title":"Extract Documentation","text":"<p>Capture patterns for future agents.</p>"},{"location":"howto/documentation-extraction/#overview","title":"Overview","text":""},{"location":"howto/documentation-extraction/#the-docslearned-directory","title":"The docs/learned/ Directory","text":""},{"location":"howto/documentation-extraction/#when-to-extract-documentation","title":"When to Extract Documentation","text":""},{"location":"howto/documentation-extraction/#creating-a-learn-plan","title":"Creating a Learn Plan","text":""},{"location":"howto/documentation-extraction/#documentation-structure","title":"Documentation Structure","text":""},{"location":"howto/documentation-extraction/#how-agents-use-documentation","title":"How Agents Use Documentation","text":""},{"location":"howto/documentation-extraction/#see-also","title":"See Also","text":"<p>The <code>docs/learned/</code> directory contains agent-generated documentation for AI agents.</p>"},{"location":"howto/local-workflow/","title":"Use the Local Workflow","text":"<p>Plan, implement, and ship code locally.</p>"},{"location":"howto/local-workflow/#overview","title":"Overview","text":"<p>The local workflow is the standard development cycle with erk: plan your changes in Claude Code, save the plan to GitHub, implement in a worktree, and ship via PR. Use this when you're developing on your own machine and want full control over the process.</p>"},{"location":"howto/local-workflow/#step-1-start-a-claude-code-session","title":"Step 1: Start a Claude Code Session","text":"<p>Open your terminal in any erk-initialized repository and run:</p> <pre><code>claude\n</code></pre> <p>This starts an interactive Claude Code session with access to erk's slash commands and skills.</p>"},{"location":"howto/local-workflow/#step-2-enter-plan-mode-and-develop-your-plan","title":"Step 2: Enter Plan Mode and Develop Your Plan","text":"<p>Press Shift+Tab or describe a task that requires planning. Claude enters plan mode and shows \"plan\" in the status line.</p> <p>In plan mode, Claude researches your codebase and designs an implementation approach without making changes. The plan should cover what changes to make, why, and in what order.</p>"},{"location":"howto/local-workflow/#step-3-save-the-plan","title":"Step 3: Save the Plan","text":"<p>When the plan is ready, Claude presents options:</p> Option Action Save to GitHub Creates a GitHub issue with the plan (for later) Implement now Saves to GitHub and immediately starts implementing <p>If you are familiar with Claude Code, you'll note that these options are different when you use <code>erk</code>. This is deliberate.</p> <p>The standard workflow in <code>erk</code> is to save the plan to GitHub. There are cases where it makes sense to implement the plan immediately, but we will not be doing that in this guide.</p> <p>Saving the plan in GitHub makes it easy to access from either a different worktree or a remote worker.</p>"},{"location":"howto/local-workflow/#step-4-implement-the-plan","title":"Step 4: Implement the Plan","text":"<p>Copy and paste the implement command you see, and exit Claude. Then run it:</p> <pre><code>erk implement &lt;issue-number&gt;\n</code></pre> <p>This command:</p> <ol> <li>Assigns or creates a worktree with a feature branch.</li> <li>Switches working directory to that worktree.</li> <li>Launches Claude Code, fetches the plan, begins implementation.</li> </ol>"},{"location":"howto/local-workflow/#step-5-submit-the-pr","title":"Step 5: Submit the PR","text":"<p>Upon successful implementation, <code>/erk:pr-submit</code> will automatically run in the Claude session. This generates a commit message from the diff, pushes the branch, and creates or updates the PR with a summary linking to the plan issue.</p> <p>If you need to run this manually later you can run it from the CLI (<code>erk pr submit</code>) or use <code>/erk:pr-submit</code> within a Claude session.</p>"},{"location":"howto/local-workflow/#step-6-address-review-feedback","title":"Step 6: Address Review Feedback","text":"<p><code>erk</code> is designed to incorporate PR review into the workflow, even if you are working alone. Think of the PR as a continuation of the Claude Code session. You (or agents or your collaborators) leave comments in the context of the relevant code. Then within a claude session in the relevant branch you can run:</p> <pre><code>/erk:pr-address\n</code></pre> <p>This fetches PR comments and unresolved review threads, then makes the requested changes. Run CI and submit again after addressing feedback.</p>"},{"location":"howto/local-workflow/#step-7-land-the-pr","title":"Step 7: Land the PR","text":"<p>Once approved and CI passes, merge the PR:</p> <pre><code>erk land\n</code></pre> <p>This merges via GitHub, closes the plan issue, deletes the branch, and cleans up the worktree. Add <code>--up</code> to navigate to a stacked branch after landing. It also plugs into other workflows, such as objectives and learning, which are covered in other guides.</p>"},{"location":"howto/local-workflow/#see-also","title":"See Also","text":"<ul> <li>Your First Plan - Tutorial walkthrough</li> <li>The Workflow - Conceptual overview</li> </ul>"},{"location":"howto/navigate-branches-worktrees/","title":"Navigate Branches and Worktrees","text":"<p>Switch between branches and navigate stacks seamlessly.</p>"},{"location":"howto/navigate-branches-worktrees/#overview","title":"Overview","text":"<p>Navigation commands let you move between branches and worktrees without manually <code>cd</code>-ing to directories. They automatically allocate worktrees when needed\u2014either creating a new one or using an available slot\u2014so you can focus on the code rather than filesystem management.</p>"},{"location":"howto/navigate-branches-worktrees/#navigate-by-branch-name","title":"Navigate by Branch Name","text":"<p><code>erk br co</code> (alias for <code>erk branch checkout</code>) is the most common navigation command. Give it a branch name and it switches you to that branch's worktree:</p> <pre><code>erk br co P1234-some-feature\n</code></pre> <p>This command handles several scenarios automatically:</p> <ul> <li>Branch is checked out in a worktree: Switches to it</li> <li>Branch exists but is not checked out in a worktree: Allocates one, then switches</li> <li>Branch only exists on remote: Creates a tracking branch and allocates a worktree</li> </ul> <p>Use this when you know the branch name and want to work on it.</p>"},{"location":"howto/navigate-branches-worktrees/#navigate-by-worktree-name","title":"Navigate by Worktree Name","text":"<p><code>erk wt co</code> (alias for <code>erk wt checkout</code>) navigates by worktree name rather than branch name:</p> <pre><code>erk wt co some-worktree\n</code></pre> <p>The special keyword <code>root</code> always takes you to the original clone location.</p>"},{"location":"howto/navigate-branches-worktrees/#checkout-a-pr","title":"Checkout a PR","text":"<p><code>erk pr co</code> checks out a pull request by number or URL:</p> <pre><code>erk pr co 123\nerk pr co https://github.com/owner/repo/pull/123\n</code></pre> <p>This fetches the PR's branch, allocates a worktree if needed, and switches to it. Use this when reviewing or iterating on someone else's PR.</p>"},{"location":"howto/navigate-branches-worktrees/#navigate-stacks","title":"Navigate Stacks","text":"<p>When using Graphite for stacked PRs, <code>erk up</code> and <code>erk down</code> move through the stack:</p> <pre><code>erk up      # Move toward leaves (away from trunk)\nerk down    # Move toward trunk (toward parent)\n</code></pre> <p>Stack terminology:</p> <ul> <li>Up = toward children/leaves (away from main)</li> <li>Down = toward parent (toward main)</li> </ul> <pre><code>main\n \u2514\u2500\u2500 feature-base (erk down from here)\n      \u2514\u2500\u2500 feature-part-1 (current)\n           \u2514\u2500\u2500 feature-part-2 (erk up goes here)\n</code></pre> <p>After landing a PR, use <code>--delete-current</code> to clean up:</p> <pre><code>erk down --delete-current    # Land, then move down and delete current worktree\n</code></pre> <p>Both commands automatically allocate worktrees for stack branches that don't have them yet.</p>"},{"location":"howto/navigate-branches-worktrees/#move-current-branch-to-another-worktree","title":"Move Current Branch to Another Worktree","text":"<p>Sometimes you create a branch in the root worktree (or any worktree you want to keep on a different branch) and decide you'd rather work on it in a dedicated worktree:</p> <pre><code>erk wt create --from-current-branch\n</code></pre> <p>This allocates a new worktree for your current branch and switches to it. The original worktree returns to whatever branch it had before (typically <code>master</code> or <code>main</code>).</p>"},{"location":"howto/navigate-branches-worktrees/#choosing-the-right-command","title":"Choosing the Right Command","text":"Scenario Command Know the branch name <code>erk br co &lt;branch&gt;</code> Know the worktree name <code>erk wt co &lt;worktree&gt;</code> Return to root repository <code>erk wt co root</code> Review a PR <code>erk pr co &lt;number&gt;</code> Move up the stack <code>erk up</code> Move down the stack <code>erk down</code> Land PR and navigate up <code>erk land --up</code> Move current branch to new worktree <code>erk wt create --from-current-branch</code>"},{"location":"howto/navigate-branches-worktrees/#see-also","title":"See Also","text":"<ul> <li>Worktrees - How worktrees work and why erk uses them</li> </ul>"},{"location":"howto/planless-workflow/","title":"Work Without Plans","text":"<p>Quick changes without formal plans. Use this workflow for simple fixes, small features, and rapid iteration when upfront planning would slow you down more than help.</p>"},{"location":"howto/planless-workflow/#when-to-skip-planning","title":"When to Skip Planning","text":"<p>Skip planning for:</p> <ul> <li>Bug fixes - Straightforward fixes with obvious solution</li> <li>Documentation updates - README changes, typo fixes, doc improvements</li> <li>Refactoring - Renaming, code organization, style improvements</li> <li>Small features - Single-file changes, simple additions</li> <li>Experiments - Trying something to see if it works</li> <li>Revisions - Addressing PR feedback, fixing failing CI</li> </ul> <p>Rule of thumb: If you can describe the entire change in 1-2 sentences, skip planning.</p>"},{"location":"howto/planless-workflow/#creating-a-worktree","title":"Creating a Worktree","text":"<p>Create an isolated worktree for your changes:</p> <pre><code>erk wt create my-feature-name\n</code></pre> <p>This creates a new worktree in <code>../&lt;timestamp&gt;-my-feature-name/</code> and:</p> <ul> <li>Creates a new branch</li> <li>Checks out the branch in the worktree</li> <li>Sets up git configuration</li> <li>Opens the worktree in your shell</li> </ul> <p>Tip: Use descriptive branch names. <code>fix-auth-bug</code> is better than <code>fix</code>.</p>"},{"location":"howto/planless-workflow/#making-changes","title":"Making Changes","text":"<p>Work normally in Claude Code:</p> <ol> <li>Describe the change - \"Fix the authentication timeout bug\"</li> <li>Let Claude iterate - Claude uses Read, Edit, Write tools</li> <li>Verify locally - Test your changes work</li> <li>Commit as you go - Use <code>/erk:git-pr-push</code> for atomic commits</li> </ol> <p>No .impl/ folder - Planless workflow doesn't use <code>.impl/</code> or progress tracking.</p>"},{"location":"howto/planless-workflow/#submitting-the-pr","title":"Submitting the PR","text":"<p>Once your changes are ready:</p> <pre><code>erk pr submit\n</code></pre> <p>This:</p> <ul> <li>Stages all changes</li> <li>Generates AI commit message from diff</li> <li>Creates commit with proper attribution</li> <li>Pushes branch to remote</li> <li>Creates PR via <code>gh pr create --fill</code></li> </ul> <p>PR state: Opens as ready for review (not draft).</p>"},{"location":"howto/planless-workflow/#landing","title":"Landing","text":"<p>After PR approval:</p> <pre><code>erk pr land\n</code></pre> <p>Or use the <code>/erk:land</code> slash command in Claude Code.</p> <p>This:</p> <ul> <li>Fetches latest from remote</li> <li>Rebases PR branch on trunk</li> <li>Handles any conflicts (with Claude's help if using slash command)</li> <li>Merges to trunk</li> <li>Pushes to remote</li> <li>Cleans up worktree and branch</li> </ul> <p>Objective integration: If the PR is associated with an objective, <code>/erk:land</code> automatically updates the objective issue after landing.</p>"},{"location":"howto/planless-workflow/#quick-submit","title":"Quick Submit","text":"<p>For rapid iteration during development:</p> <pre><code>/local:quick-submit\n</code></pre> <p>This streamlined command:</p> <ul> <li>Commits all changes with AI-generated message</li> <li>Submits via Graphite (<code>gt submit</code>)</li> <li>Skips confirmation prompts</li> </ul> <p>Use when: Making frequent small updates during active development.</p> <p>Don't use: For final PR submission or when you need careful review of what's being committed.</p>"},{"location":"howto/planless-workflow/#troubleshooting","title":"Troubleshooting","text":""},{"location":"howto/planless-workflow/#merge-conflicts","title":"Merge Conflicts","text":"<p>If rebasing fails during landing:</p> <ol> <li>Use <code>/erk:fix-conflicts</code> - Claude helps resolve conflicts</li> <li>Or manually resolve - Edit conflicting files, then <code>git rebase --continue</code></li> <li>Re-run landing - Continue the <code>erk pr land</code> process</li> </ol>"},{"location":"howto/planless-workflow/#failed-ci-checks","title":"Failed CI Checks","text":"<p>When CI fails on your PR:</p> <ol> <li>Use <code>/local:debug-ci</code> - Analyzes failures and suggests fixes</li> <li>Fix locally - Make corrections in your worktree</li> <li>Submit again - Use <code>erk pr submit</code> to update the PR</li> </ol>"},{"location":"howto/planless-workflow/#stacked-changes","title":"Stacked Changes","text":"<p>If you need to make changes that depend on uncommitted work:</p> <ol> <li>Commit current work - Use <code>/erk:git-pr-push</code></li> <li>Create stacked worktree - <code>erk wt create next-feature</code> (creates branch off current)</li> <li>Make new changes - Work in the stacked worktree</li> <li>Submit independently - Each worktree tracks its own PR</li> </ol>"},{"location":"howto/planless-workflow/#when-to-switch-to-planning","title":"When to Switch to Planning","text":"<p>Switch to planning workflow if you find yourself:</p> <ul> <li>Working for &gt;2 hours - The change is bigger than expected</li> <li>Touching 5+ files - Scope is expanding</li> <li>Uncertain about approach - Multiple valid solutions exist</li> <li>Needing research - Have to understand existing code first</li> <li>Making architectural changes - Affects multiple components</li> </ul> <p>How to switch:</p> <ol> <li>Stop coding - Don't continue down uncertain path</li> <li>Enter plan mode - Let Claude create a plan with research</li> <li>Save plan - Use <code>/erk:plan-save</code></li> <li>Implement from plan - Use <code>/erk:plan-implement</code></li> </ol> <p>See When to Switch to Planning Pattern for detailed decision framework.</p>"},{"location":"howto/planless-workflow/#collaboration","title":"Collaboration","text":""},{"location":"howto/planless-workflow/#working-with-others","title":"Working with Others","text":"<p>Before starting work:</p> <pre><code># Check if someone else is working on similar changes\ngh pr list --search \"label:in-progress\"\n</code></pre> <p>During development:</p> <ul> <li>Mark PR as draft if not ready for review</li> <li>Use descriptive commit messages</li> <li>Keep PR scope focused</li> </ul> <p>After submission:</p> <ul> <li>Respond to review feedback promptly</li> <li>Use <code>erk pr submit</code> to update PR with fixes</li> <li>Don't force-push - rebasing is handled by <code>erk pr land</code></li> </ul>"},{"location":"howto/planless-workflow/#learn-workflow-integration","title":"Learn Workflow Integration","text":"<p>After landing a PR without a plan:</p> <pre><code>erk learn --from-pr &lt;pr-number&gt;\n</code></pre> <p>This extracts learnings from the implementation session for future documentation.</p> <p>When to use: After implementing something novel or discovering patterns worth documenting.</p>"},{"location":"howto/planless-workflow/#see-also","title":"See Also","text":"<ul> <li>Use the Local Workflow - Full planning workflow</li> <li>Worktrees - Understanding worktrees</li> <li>When to Switch to Planning - Decision framework</li> <li>Quick Submit Command - Rapid iteration command details</li> </ul>"},{"location":"howto/pr-checkout-sync/","title":"Checkout and Sync PRs","text":"<p>Review and iterate on existing PRs locally.</p>"},{"location":"howto/pr-checkout-sync/#overview","title":"Overview","text":"<p>Use this workflow when you need to:</p> <ul> <li>Review teammate PRs: Check out code locally to test or explore</li> <li>Debug remote execution: Investigate issues from agent-created PRs</li> <li>Take over PRs: Continue work started by others or remote agents</li> <li>Address review comments: Make changes in response to PR feedback</li> </ul>"},{"location":"howto/pr-checkout-sync/#checking-out-a-pr","title":"Checking Out a PR","text":"<p>Use <code>erk pr checkout</code> (alias: <code>erk pr co</code>) to check out a PR into a new worktree:</p> <pre><code># By PR number\nerk pr co 123\n\n# By GitHub URL\nerk pr co https://github.com/owner/repo/pull/123\n\n# See what would be created (no changes)\nerk pr co 123 --dry-run\n</code></pre> <p>This command:</p> <ol> <li>Creates a new worktree for the PR branch</li> <li>Checks out the branch in that worktree</li> <li>Sets up Graphite tracking if applicable</li> </ol>"},{"location":"howto/pr-checkout-sync/#flags","title":"Flags","text":"Flag Description <code>--dry-run</code> Show what would be done, don't act <code>--restack</code> Run <code>gt restack</code> after checkout"},{"location":"howto/pr-checkout-sync/#syncing-with-remote","title":"Syncing with Remote","text":"<p>When remote changes have been pushed (e.g., by CI, remote agents, or teammates), sync your local branch:</p> <pre><code># Sync using Graphite (recommended for gt-tracked branches)\nerk pr sync --dangerous\n\n# Git-only sync (without Graphite)\ngit fetch origin &amp;&amp; git rebase origin/&lt;branch&gt;\n</code></pre> <p>Warning: The <code>--dangerous</code> flag is required because syncing can rewrite history. Use <code>/erk:sync-divergence</code> if you're unsure about the sync strategy.</p>"},{"location":"howto/pr-checkout-sync/#when-divergence-occurs","title":"When Divergence Occurs","text":"<p>If your local branch has diverged from remote:</p> <pre><code># Use the automated divergence resolver\n/erk:sync-divergence\n</code></pre> <p>This command analyzes the divergence and chooses the appropriate sync strategy.</p>"},{"location":"howto/pr-checkout-sync/#making-changes","title":"Making Changes","text":"<p>Once checked out, iterate on the PR using standard workflows:</p>"},{"location":"howto/pr-checkout-sync/#using-claude-code","title":"Using Claude Code","text":"<pre><code># Address PR review comments\n/erk:pr-address\n\n# General changes with Claude\nclaude \"make the requested changes\"\n</code></pre>"},{"location":"howto/pr-checkout-sync/#manual-changes","title":"Manual Changes","text":"<pre><code># Edit files directly\nvim src/my_file.py\n\n# Commit changes\ngit add -p\ngit commit -m \"Address review feedback\"\n</code></pre>"},{"location":"howto/pr-checkout-sync/#submitting-updates","title":"Submitting Updates","text":"<p>After making changes, push them to the PR:</p> <pre><code># Using Graphite (recommended)\nerk pr submit\n\n# Or with force push if needed\ngt submit --force --no-interactive\n</code></pre> <p>For quick iteration:</p> <pre><code># Commit and submit in one step\n/local:quick-submit\n</code></pre>"},{"location":"howto/pr-checkout-sync/#landing","title":"Landing","text":"<p>When the PR is approved and CI passes:</p> <pre><code># Land the PR (merge and cleanup)\nerk land\n\n# Land and move to the next branch in stack\nerk land --up\n</code></pre> <p>The <code>erk land</code> command:</p> <ol> <li>Merges the PR via GitHub</li> <li>Deletes the feature branch</li> <li>Removes the worktree (if in a linked worktree)</li> <li>Checks out trunk or the next branch</li> </ol>"},{"location":"howto/pr-checkout-sync/#common-scenarios","title":"Common Scenarios","text":"Scenario Command Sequence Review teammate's PR <code>erk pr co 123</code> then explore/test Address my PR's comments <code>erk pr co 123</code> \u2192 <code>/erk:pr-address</code> \u2192 submit Take over remote agent PR <code>erk pr co 123</code> \u2192 make changes \u2192 submit Debug CI failure <code>erk pr co 123</code> \u2192 run tests locally \u2192 fix \u2192 submit Sync after force push <code>/erk:sync-divergence</code> or <code>erk pr sync --dangerous</code>"},{"location":"howto/pr-checkout-sync/#see-also","title":"See Also","text":"<ul> <li>Run Remote Execution - When PRs come from remote agents</li> <li>Resolve Merge Conflicts - If sync causes conflicts</li> <li>pr-sync-divergence - Divergence resolution details</li> </ul>"},{"location":"howto/remote-execution/","title":"Run Remote Execution","text":"<p>Run implementations in GitHub Actions for sandboxed, parallel execution.</p>"},{"location":"howto/remote-execution/#overview","title":"Overview","text":""},{"location":"howto/remote-execution/#prerequisites","title":"Prerequisites","text":""},{"location":"howto/remote-execution/#creating-a-plan","title":"Creating a Plan","text":""},{"location":"howto/remote-execution/#submitting-for-remote-execution","title":"Submitting for Remote Execution","text":""},{"location":"howto/remote-execution/#monitoring-execution","title":"Monitoring Execution","text":""},{"location":"howto/remote-execution/#reviewing-the-result","title":"Reviewing the Result","text":""},{"location":"howto/remote-execution/#debugging-remote-prs","title":"Debugging Remote PRs","text":""},{"location":"howto/remote-execution/#when-to-use-remote-vs-local","title":"When to Use Remote vs Local","text":""},{"location":"howto/remote-execution/#see-also","title":"See Also","text":"<ul> <li>Use the Local Workflow - Alternative local approach</li> <li>Checkout and Sync PRs - Debug remote PRs locally</li> </ul>"},{"location":"howto/test-workflows/","title":"Test GitHub Actions Workflows","text":"<p>Test changes to erk's GitHub Actions workflows before merging.</p>"},{"location":"howto/test-workflows/#overview","title":"Overview","text":"<p>When modifying workflow files like <code>.github/workflows/plan-implement.yml</code>, you need to test the actual workflow execution, not just the YAML syntax. This guide shows how to use <code>erk admin test-erk-impl-gh-workflow</code> to automate this process.</p>"},{"location":"howto/test-workflows/#prerequisites","title":"Prerequisites","text":"<ul> <li>Your workflow changes committed to a branch</li> <li>GitHub CLI (<code>gh</code>) authenticated</li> <li>Push access to the repository</li> </ul>"},{"location":"howto/test-workflows/#quick-start","title":"Quick Start","text":"<pre><code># Test erk-impl workflow from your current branch\nerk admin test-erk-impl-gh-workflow\n\n# Use an existing issue (avoids creating a new one)\nerk admin test-erk-impl-gh-workflow --issue 12345\n\n# Watch the run in real-time\nerk admin test-erk-impl-gh-workflow --watch\n</code></pre>"},{"location":"howto/test-workflows/#what-the-command-does","title":"What the Command Does","text":"<ol> <li>Pushes your branch - Ensures your workflow changes are on remote</li> <li>Creates a test issue - Or uses an existing one with <code>--issue</code></li> <li>Creates a test branch - Pushes <code>master</code> to <code>test-workflow-{timestamp}</code></li> <li>Creates a draft PR - Required by the workflow's <code>pr_number</code> input</li> <li>Triggers the workflow - Uses <code>--ref</code> to run YOUR version of the YAML</li> <li>Returns the run URL - So you can monitor the execution</li> </ol>"},{"location":"howto/test-workflows/#understanding-ref","title":"Understanding --ref","text":"<p>The key insight is that <code>gh workflow run --ref &lt;branch&gt;</code> runs the workflow file from that branch, not just with different inputs. This means:</p> <ul> <li>Changes to workflow steps, jobs, and scripts take effect</li> <li>You're testing the actual modified workflow, not the one on <code>master</code></li> </ul>"},{"location":"howto/test-workflows/#example-output","title":"Example Output","text":"<pre><code>Ensuring branch 'my-workflow-fix' exists on remote...\n\u2713 Branch 'my-workflow-fix' pushed to origin\n\u2713 Created test issue #4358\nCreating test branch 'test-workflow-abc123'...\n\u2713 Test branch 'test-workflow-abc123' created\n\u2713 Draft PR #4359 created\nTriggering erk-impl workflow from 'my-workflow-fix'...\n\nWorkflow triggered successfully!\n\nRun URL: https://github.com/dagster-io/erk/actions/runs/123456789\nTest branch: test-workflow-abc123\nDraft PR: https://github.com/dagster-io/erk/pull/4359\n</code></pre>"},{"location":"howto/test-workflows/#cleanup-after-testing","title":"Cleanup After Testing","text":"<p>The command creates test artifacts that you should clean up:</p> <pre><code># Delete the test branch\ngit push origin --delete test-workflow-abc123\n\n# Close the draft PR (use the PR number from output)\ngh pr close 4359\n\n# Optionally close the test issue if you created one\ngh issue close 4358\n</code></pre>"},{"location":"howto/test-workflows/#when-to-use-this","title":"When to Use This","text":"<ul> <li>Modifying plan-implement.yml - Test before merging changes</li> <li>Debugging workflow failures - Reproduce issues with your fixes</li> <li>Testing new workflow inputs - Verify parameter handling</li> <li>Developing new workflows - Iterate on workflow logic</li> </ul>"},{"location":"howto/test-workflows/#manual-alternative","title":"Manual Alternative","text":"<p>For more control, you can trigger workflows manually:</p> <pre><code># 1. Push your branch\ngit push origin HEAD\n\n# 2. Create test infrastructure\ngit push origin master:test-branch\ngh pr create --head test-branch --base master --draft --title \"Test\"\n\n# 3. Trigger with --ref pointing to YOUR branch\ngh workflow run plan-implement.yml \\\n  --ref your-branch-with-workflow-changes \\\n  -f issue_number=12345 \\\n  -f submitted_by=your-username \\\n  -f distinct_id=test123 \\\n  -f issue_title=\"Test\" \\\n  -f branch_name=test-branch \\\n  -f pr_number=PR_NUMBER \\\n  -f base_branch=master\n</code></pre>"},{"location":"howto/test-workflows/#see-also","title":"See Also","text":"<ul> <li>Remote Execution - How remote implementation works</li> <li>The Workflow - Overview of erk's workflow</li> </ul>"},{"location":"ref/","title":"Reference","text":"<p>Complete technical reference for erk commands, configuration, and file locations.</p> <p>Reference documentation is information-oriented. It provides accurate, complete descriptions of erk's interfaces.</p>"},{"location":"ref/#contents","title":"Contents","text":""},{"location":"ref/#commands","title":"Commands","text":"<ul> <li>CLI Command Reference - All CLI commands and their options</li> <li>Slash Command Reference - Claude Code slash commands for in-session use</li> </ul>"},{"location":"ref/#configuration","title":"Configuration","text":"<ul> <li>Configuration Reference - Config files and options</li> <li>File Location Reference - Where erk stores data and configuration</li> </ul>"},{"location":"ref/commands/","title":"CLI Command Reference","text":"<p>All erk CLI commands and their options.</p>"},{"location":"ref/commands/#overview","title":"Overview","text":""},{"location":"ref/commands/#plan-commands","title":"Plan Commands","text":""},{"location":"ref/commands/#worktree-commands","title":"Worktree Commands","text":""},{"location":"ref/commands/#branch-commands","title":"Branch Commands","text":""},{"location":"ref/commands/#pr-commands","title":"PR Commands","text":""},{"location":"ref/commands/#stack-commands","title":"Stack Commands","text":""},{"location":"ref/commands/#configuration-commands","title":"Configuration Commands","text":""},{"location":"ref/commands/#see-also","title":"See Also","text":"<ul> <li>Slash Command Reference - Claude Code commands</li> <li>Configuration Reference - Config options</li> </ul>"},{"location":"ref/configuration/","title":"Configuration Reference","text":"<p>Erk uses a layered configuration system with global, repository, and local configuration files.</p>"},{"location":"ref/configuration/#configuration-files","title":"Configuration Files","text":"File Scope Versioned Purpose <code>~/.erk/config.toml</code> All repositories No User-wide settings <code>.erk/config.toml</code> Single repo Yes Team-shared repository settings <code>.erk/config.local.toml</code> Single repo No Personal overrides (gitignored)"},{"location":"ref/configuration/#global-configuration","title":"Global Configuration","text":"<p>Settings in <code>~/.erk/config.toml</code> apply to all repositories.</p> Option Type Description <code>erks_root</code> string Directory where worktrees are stored <code>use_graphite</code> boolean Enable Graphite integration for stacked PRs <code>github_planning</code> boolean Enable GitHub issue-based planning <code>shell_integration</code> boolean Enable auto-navigation when switching worktrees <p>Example:</p> <pre><code>erks_root = \"/Users/you/erks\"\nuse_graphite = true\ngithub_planning = true\nshell_integration = true\n</code></pre>"},{"location":"ref/configuration/#repository-configuration","title":"Repository Configuration","text":"<p>Settings in <code>.erk/config.toml</code> are shared across the team and checked into git.</p>"},{"location":"ref/configuration/#env-environment-variables","title":"<code>[env]</code> - Environment Variables","text":"<p>Define environment variables that are templated into each worktree's <code>.env</code> file.</p> <pre><code>[env]\nDAGSTER_GIT_REPO_DIR = \"{worktree_path}\"\nDATABASE_URL = \"postgresql://localhost/{name}\"\nMY_API_KEY = \"shared-dev-key\"\n</code></pre> <p>See Environment Variables below for template syntax and loading behavior.</p>"},{"location":"ref/configuration/#post_create-post-creation-commands","title":"<code>[post_create]</code> - Post-Creation Commands","text":"<p>Commands run after worktree creation.</p> <pre><code>[post_create]\nshell = \"bash\"\ncommands = [\n    \"uv sync\",\n    \"npm install\"\n]\n</code></pre>"},{"location":"ref/configuration/#pool-worktree-pool-settings","title":"<code>[pool]</code> - Worktree Pool Settings","text":"<p>Configure the worktree pool for efficient worktree reuse.</p> <pre><code>[pool]\nmax_slots = 8\n\n[pool.checkout]\nshell = \"bash\"\ncommands = [\"uv sync\"]\n</code></pre>"},{"location":"ref/configuration/#environment-variables","title":"Environment Variables","text":"<p>Erk automatically manages environment variables per worktree, making it easy to configure tools that need worktree-specific paths.</p>"},{"location":"ref/configuration/#template-variables","title":"Template Variables","text":"<p>Use these placeholders in <code>[env]</code> values:</p> Variable Description Example Value <code>{worktree_path}</code> Absolute path to worktree directory <code>/Users/you/erks/repo/my-feature</code> <code>{repo_root}</code> Absolute path to git repository root <code>/Users/you/code/repo</code> <code>{name}</code> Worktree name (branch slug) <code>my-feature</code>"},{"location":"ref/configuration/#auto-generated-variables","title":"Auto-Generated Variables","text":"<p>These variables are always added to <code>.env</code>, regardless of your configuration:</p> Variable Source Description <code>WORKTREE_PATH</code> <code>{worktree_path}</code> Current worktree path <code>REPO_ROOT</code> <code>{repo_root}</code> Repository root path <code>WORKTREE_NAME</code> <code>{name}</code> Worktree name (branch slug)"},{"location":"ref/configuration/#when-variables-are-loaded","title":"When Variables Are Loaded","text":"<ol> <li>Worktree creation: Erk generates <code>.env</code> with substituted template values</li> <li>Worktree activation: The activation script sources <code>.env</code> using <code>set -a</code> (allexport mode)</li> </ol> <p>The activation script loads environment variables like this:</p> <pre><code># Load .env into the environment (allexport)\nset -a\nif [ -f ./.env ]; then\n  . ./.env\nfi\nset +a\n</code></pre>"},{"location":"ref/configuration/#example","title":"Example","text":"<p>Configuration (<code>.erk/config.toml</code>):</p> <pre><code>[env]\nDAGSTER_GIT_REPO_DIR = \"{worktree_path}\"\nDATABASE_URL = \"postgresql://localhost/{name}\"\n</code></pre> <p>Generated <code>.env</code> (for worktree <code>my-feature</code>):</p> <pre><code>DAGSTER_GIT_REPO_DIR=\"/Users/you/erks/repo/my-feature\"\nDATABASE_URL=\"postgresql://localhost/my-feature\"\nWORKTREE_PATH=\"/Users/you/erks/repo/my-feature\"\nREPO_ROOT=\"/Users/you/code/repo\"\nWORKTREE_NAME=\"my-feature\"\n</code></pre>"},{"location":"ref/configuration/#common-use-cases","title":"Common Use Cases","text":"Variable Purpose Example Config <code>DAGSTER_GIT_REPO_DIR</code> Point Dagster to worktree <code>\"{worktree_path}\"</code> <code>DATABASE_URL</code> Per-worktree database <code>\"postgresql://localhost/{name}\"</code> <code>LOG_FILE</code> Separate log files per worktree <code>\"{worktree_path}/logs/app.log\"</code> <code>CONFIG_PATH</code> Worktree-specific config <code>\"{worktree_path}/.local-config.json\"</code>"},{"location":"ref/configuration/#see-also","title":"See Also","text":"<ul> <li>Installation - Initial configuration</li> <li>File Location Reference - Where config files live</li> </ul>"},{"location":"ref/file-locations/","title":"File Location Reference","text":"<p>Where erk stores data and configuration.</p>"},{"location":"ref/file-locations/#overview","title":"Overview","text":""},{"location":"ref/file-locations/#global-locations","title":"Global Locations","text":""},{"location":"ref/file-locations/#repository-locations","title":"Repository Locations","text":""},{"location":"ref/file-locations/#worktree-locations","title":"Worktree Locations","text":""},{"location":"ref/file-locations/#scratch-storage","title":"Scratch Storage","text":""},{"location":"ref/file-locations/#claude-code-integration","title":"Claude Code Integration","text":""},{"location":"ref/file-locations/#gitignore-patterns","title":"Gitignore Patterns","text":""},{"location":"ref/file-locations/#see-also","title":"See Also","text":"<ul> <li>Configuration Reference - Config file options</li> <li>Installation - Initial setup</li> </ul>"},{"location":"ref/slash-commands/","title":"Slash Command Reference","text":"<p>Claude Code slash commands for in-session use.</p>"},{"location":"ref/slash-commands/#overview","title":"Overview","text":""},{"location":"ref/slash-commands/#implementation-commands","title":"Implementation Commands","text":""},{"location":"ref/slash-commands/#pr-commands","title":"PR Commands","text":""},{"location":"ref/slash-commands/#iteration-commands","title":"Iteration Commands","text":""},{"location":"ref/slash-commands/#navigation-commands","title":"Navigation Commands","text":""},{"location":"ref/slash-commands/#erkland","title":"/erk:land","text":"<p>Merge a PR and clean up worktree. Optionally updates linked objectives.</p>"},{"location":"ref/slash-commands/#erkobjective-inspect","title":"/erk:objective-inspect","text":"<p>View an objective's dependency graph, progress, and associated plans/PRs. Read-only command that works in plan mode.</p> <pre><code>/erk:objective-inspect 3679\n/erk:objective-inspect  # auto-detects from current branch\n</code></pre>"},{"location":"ref/slash-commands/#erkobjective-plan","title":"/erk:objective-plan","text":"<p>Create an implementation plan from a specific objective roadmap step.</p>"},{"location":"ref/slash-commands/#documentation-commands","title":"Documentation Commands","text":""},{"location":"ref/slash-commands/#local-commands","title":"Local Commands","text":""},{"location":"ref/slash-commands/#see-also","title":"See Also","text":"<ul> <li>CLI Command Reference - CLI commands</li> <li>The Workflow - When to use each command</li> </ul>"},{"location":"topics/","title":"Topics","text":"<p>Core concepts that explain how erk works.</p> <p>Topics are understanding-oriented. They provide background knowledge and conceptual explanations to deepen your understanding of erk.</p>"},{"location":"topics/#contents","title":"Contents","text":"<ul> <li>Worktrees - Git worktrees enable parallel development without branch switching</li> <li>Graphite Integration - Stacked PR workflows with Graphite</li> <li>Plan Mode - Claude Code's planning workflow and how erk extends it</li> <li>The Workflow - The complete journey from idea to merged PR</li> <li>Plan-Oriented Engineering - Why planning first leads to better outcomes</li> <li>Why GitHub Issues for Plans - Why plans are stored as GitHub issues</li> </ul>"},{"location":"topics/#why-these-concepts-matter","title":"Why These Concepts Matter","text":"<p>Understanding these concepts will help you:</p> <ul> <li>Make informed decisions about when to use different workflows</li> <li>Debug issues by understanding what's happening under the hood</li> <li>Extend erk's capabilities for your specific needs</li> </ul>"},{"location":"topics/plan-mode/","title":"Plan Mode","text":"<p>Claude Code's planning workflow and how erk extends it.</p>"},{"location":"topics/plan-mode/#what-is-plan-mode","title":"What Is Plan Mode?","text":""},{"location":"topics/plan-mode/#entering-plan-mode","title":"Entering Plan Mode","text":""},{"location":"topics/plan-mode/#writing-plans","title":"Writing Plans","text":""},{"location":"topics/plan-mode/#erks-plan-mode-extension","title":"<code>erk</code>'s Plan Mode Extension","text":""},{"location":"topics/plan-mode/#saving-plans-to-github","title":"Saving Plans to GitHub","text":""},{"location":"topics/plan-mode/#plan-structure","title":"Plan Structure","text":""},{"location":"topics/plan-mode/#see-also","title":"See Also","text":"<ul> <li>Your First Plan - Hands-on tutorial</li> <li>Use the Local Workflow - Using plans in practice</li> </ul>"},{"location":"topics/plan-oriented-engineering/","title":"Plan-Oriented Engineering","text":"<p>The philosophy behind erk's approach to AI-assisted development.</p>"},{"location":"topics/plan-oriented-engineering/#the-core-idea","title":"The Core Idea","text":""},{"location":"topics/plan-oriented-engineering/#why-plan-first","title":"Why Plan First?","text":""},{"location":"topics/plan-oriented-engineering/#ai-as-planner-and-executor","title":"AI as Planner and Executor","text":""},{"location":"topics/plan-oriented-engineering/#plans-as-artifacts","title":"Plans as Artifacts","text":""},{"location":"topics/plan-oriented-engineering/#isolation-through-worktrees","title":"Isolation Through Worktrees","text":""},{"location":"topics/plan-oriented-engineering/#the-feedback-loop","title":"The Feedback Loop","text":""},{"location":"topics/plan-oriented-engineering/#see-also","title":"See Also","text":"<ul> <li>The TAO of erk - Design principles</li> <li>The Workflow - Putting philosophy into practice</li> </ul>"},{"location":"topics/the-workflow/","title":"The Workflow","text":"<p>The complete journey from idea to merged PR.</p>"},{"location":"topics/the-workflow/#overview","title":"Overview","text":""},{"location":"topics/the-workflow/#phase-1-planning","title":"Phase 1: Planning","text":""},{"location":"topics/the-workflow/#phase-2-saving","title":"Phase 2: Saving","text":""},{"location":"topics/the-workflow/#phase-3-implementation","title":"Phase 3: Implementation","text":""},{"location":"topics/the-workflow/#phase-4-review","title":"Phase 4: Review","text":""},{"location":"topics/the-workflow/#phase-5-iteration","title":"Phase 5: Iteration","text":""},{"location":"topics/the-workflow/#phase-6-landing","title":"Phase 6: Landing","text":""},{"location":"topics/the-workflow/#the-ide-free-promise","title":"The IDE-Free Promise","text":""},{"location":"topics/the-workflow/#see-also","title":"See Also","text":"<ul> <li>Your First Plan - Try the workflow yourself</li> <li>Use the Local Workflow - Detailed guide</li> </ul>"},{"location":"topics/why-github-issues/","title":"Why GitHub Issues for Plans","text":"<p>Why erk stores plans as GitHub issues rather than markdown files in the repository.</p>"},{"location":"topics/why-github-issues/#the-origin-story-markdown-files-didnt-work","title":"The Origin Story: Markdown Files Didn't Work","text":"<p><code>erk</code> originated as a worktree management tool. Users were heavily using plans as well, but managing and coordinating them became burdensome. They were manually saving markdown files on disk, checking them in, copying them between worktrees, and so forth.</p> <p>GitHub Issues were a simple, available, and convenient way to store these markdown documents and have them available across worktrees. But nearly all their features turned out to be applicable to plans\u2014linkage to PRs, comments for context, labels for classification.</p>"},{"location":"topics/why-github-issues/#the-data-model-fit","title":"The Data Model Fit","text":"<p>GitHub Issues have a number of features applicable to plan management: document storage, labeling, attribution, comments as an update stream, and integration with developer-centric workflows. By utilizing these features, <code>erk</code> uses GitHub Issues as a database of plans and other related entities.</p>"},{"location":"topics/why-github-issues/#issue-as-entity","title":"Issue as Entity","text":"<p>Each plan is discrete and addressable. It has a stable identity (issue number, URL) that persists regardless of which worktree or branch is active. You can reference plan #123 from anywhere, and it has well-known APIs and tools (such as <code>gh</code>) for querying its content.</p>"},{"location":"topics/why-github-issues/#labels-for-classification","title":"Labels for Classification","text":"<p>Structured metadata without schema rigidity. <code>erk</code> uses labels like <code>erk-plan</code> to categorize without a rigid database schema. Adding new plan types and concepts means adding new labels.</p>"},{"location":"topics/why-github-issues/#comment-stream-as-immutable-log","title":"Comment Stream as Immutable Log","text":"<p><code>erk</code> treats comments as an append-only log of updates where one can record the prompts that led to a plan, track progress, add context, and so forth. When an agent starts implementation, it adds a comment. When it completes, another comment. When a human provides feedback, another comment. This creates an audit trail that can't be rewritten\u2014you can see exactly how a plan evolved from ideation to completion.</p>"},{"location":"topics/why-github-issues/#workflow-integration","title":"Workflow Integration","text":"<p>GitHub Issues integrate with workflows that already exist:</p> <p>PR-to-issue linking: A PR body containing <code>Closes #123</code> automatically closes the plan issue when the PR merges. No manual bookkeeping.</p> <p>GitHub Actions: Workflows can trigger on issue state transitions. Open a plan \u2192 start implementation. Close an issue \u2192 clean up worktrees.</p> <p>Existing ecosystem: Notifications, permissions, search, mobile apps\u2014all work out of the box. No custom infrastructure to maintain.</p>"},{"location":"topics/why-github-issues/#lifecycle-mapping","title":"Lifecycle Mapping","text":"<p>Issue states map naturally to plan lifecycle:</p> Issue State Plan Meaning Open Active or queued for implementation Assigned Claimed by an agent or person Closed Completed or cancelled <p>This isn't a forced mapping\u2014it's how people already think about work items. A plan progresses from open to implemented to merged, just like any ticket.</p>"},{"location":"topics/why-github-issues/#the-hierarchy-pattern","title":"The Hierarchy Pattern","text":"<p>Plans often belong to larger efforts. <code>erk</code> supports this through objectives\u2014parent issues that track multiple related plans:</p> <pre><code>Objective #100: \"Improve authentication\"\n\u251c\u2500\u2500 Plan #101: \"Add OAuth support\"\n\u251c\u2500\u2500 Plan #102: \"Implement rate limiting\"\n\u2514\u2500\u2500 Plan #103: \"Add session management\"\n</code></pre> <p>Each plan's metadata includes an <code>objective_id</code> field linking to its parent. Most ticketing systems support this pattern (epics, sub-tasks, parent issues) and it is applicable to objectives, plans and other future use cases.</p>"},{"location":"topics/why-github-issues/#plans-as-context-graphs","title":"Plans as Context Graphs","text":"<p>The most powerful aspect of issue-based plans is what they accumulate over time.</p>"},{"location":"topics/why-github-issues/#rules-vs-decision-traces","title":"Rules vs. Decision Traces","text":"<p>The plan schema defines what should happen\u2014the implementation steps, success criteria, constraints. The comment stream records what actually happened\u2014the decisions made, blockers hit, workarounds discovered.</p> <p>Foundation Capital's \"context graphs\" concept captures this distinction. AI systems need both rules (what to do) and decision traces (what was done and why). A plan issue provides both in one artifact.</p>"},{"location":"topics/why-github-issues/#system-of-record-for-agentic-engineering","title":"System of Record for Agentic Engineering","text":"<p>Past plans become queryable precedent. When an agent encounters an edge case\u2014\"how do I handle rate limiting in this codebase?\"\u2014it can search previous plans for patterns. The comment streams show not just what was done, but what problems arose and how they were resolved. We can query historical plans and the outcomes they generated to improve future outcomes in the codebase.</p>"},{"location":"topics/why-github-issues/#looking-forward-beyond-github","title":"Looking Forward: Beyond GitHub","text":"<p>GitHub Issues is one implementation of this pattern. The underlying abstraction is:</p> <ul> <li>Entity: Discrete, addressable, with stable identity</li> <li>Metadata: Structured fields for fast queries</li> <li>Log: Append-only history of activities</li> <li>Lifecycle: States that map to workflow stages</li> <li>Hierarchy: Parent-child relationships between entities</li> </ul> <p>Other systems implement this pattern differently. Linear's agent-first primitives (AgentSession, activities) show the pattern generalizing beyond traditional ticketing. The concept is portable even if specific implementations aren't yet.</p>"},{"location":"topics/why-github-issues/#conclusion","title":"Conclusion","text":"<p>GitHub Issues weren't designed for AI agent workflows. But they implement the context graph pattern that agent workflows need: entities with identity, metadata for queries, append-only logs for decision traces, and lifecycle states for coordination.</p> <p>The \"accidental architecture\" turned out to be right. Rather than building custom plan infrastructure, erk leverages infrastructure that already exists, already scales, and already integrates with developer workflows.</p>"},{"location":"topics/why-github-issues/#see-also","title":"See Also","text":"<ul> <li>The Workflow - How plans fit into the complete workflow</li> <li>Plan-Oriented Engineering - The philosophy behind planning first</li> <li>Plan Mode - How Claude Code creates plans</li> </ul>"},{"location":"topics/worktrees/","title":"Worktrees","text":"<p>Git worktrees enable parallel agent execution without filesystem conflicts.</p>"},{"location":"topics/worktrees/#the-problem-parallel-agents-need-separate-filesystems","title":"The Problem: Parallel Agents Need Separate Filesystems","text":"<p>As you become proficient with agentic engineering and model capabilities increase, you can work on tasks of increasing complexity and size. Larger tasks mean higher latency\u2014agents take longer to complete their work. At that point, you want multiple agents working in parallel.</p> <p>But here's the problem: if two agents work in parallel on the same branch, they're writing to the same location in the filesystem. That doesn't work. They'll overwrite each other's changes, create conflicts mid-execution, and generally make a mess.</p> <p>Worktrees are the solution. Git can manage multiple working copies of the same repository, each checked out to a different branch in a different directory. This lets you run many agents in parallel, each in its own worktree, without interference.</p>"},{"location":"topics/worktrees/#what-are-worktrees","title":"What Are Worktrees?","text":"<p>Git worktrees let you check out multiple branches simultaneously, each in its own directory. Think of it like browser tabs: instead of one tab loading different pages, you have multiple tabs open at once.</p> <pre><code>Traditional:                    With Worktrees:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    repo/     \u2502               \u2502  feature-a/  \u2502  \u2502  feature-b/  \u2502\n\u2502 (one branch) \u2502               \u2502  (branch A)  \u2502  \u2502  (branch B)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Each worktree is a full working directory with its own checked-out files, but they share the same <code>.git</code> data. Changes in one worktree don't affect another until you merge.</p>"},{"location":"topics/worktrees/#why-erk-uses-worktrees","title":"Why Erk Uses Worktrees","text":"<p>Worktrees are essential to the plan-oriented workflow for several reasons:</p> <p>Parallel agent execution: The primary use case. Launch multiple agents implementing different plans simultaneously. Each agent has its own worktree, its own branch, its own filesystem. No conflicts, no coordination overhead.</p> <p>Plan isolation: Each plan gets its own worktree. One agent implements authentication while another works on logging. They can't interfere with each other until you're ready to merge.</p> <p>Organized structure: Worktrees live in a predictable hierarchy (<code>~/.erk/repos/&lt;repo&gt;/worktrees/&lt;worktree&gt;/</code>), making them easy to find and manage. Each is tied to a specific plan via naming convention.</p> <p>Context preservation: For human work, switching between worktrees preserves your state\u2014open files, terminal history, test results. No stashing required.</p>"},{"location":"topics/worktrees/#worktree-structure","title":"Worktree Structure","text":"<p>Erk organizes worktrees in a consistent hierarchy:</p> <pre><code>~/.erk/repos/                              # Erk repos root\n\u2514\u2500\u2500 my-project/                            # Repo directory\n    \u2514\u2500\u2500 worktrees/                         # Worktrees container\n        \u251c\u2500\u2500 P123-auth-feature-0115/        # Worktree for plan #123\n        \u251c\u2500\u2500 P124-fix-tests-0115/           # Worktree for plan #124\n        \u2514\u2500\u2500 P125-add-logging-0116/         # Worktree for plan #125\n</code></pre> <p>Erk Root (<code>~/.erk/</code>): Erk's configuration and data directory.</p> <p>Repos Dir (<code>~/.erk/repos/&lt;repo&gt;/</code>): Per-repository directory containing worktrees and other repo-specific data.</p> <p>Worktrees Dir (<code>~/.erk/repos/&lt;repo&gt;/worktrees/</code>): Container for all worktrees for this repository.</p> <p>Naming Convention: <code>P{issue}-{slug}-{timestamp}</code> links each worktree to its GitHub issue. The timestamp ensures uniqueness if you create multiple worktrees for the same plan.</p>"},{"location":"topics/worktrees/#root-worktree","title":"Root Worktree","text":"<p>The original clone location (wherever you ran <code>git clone</code>) is the root worktree. It's special\u2014it exists outside the erks directory structure and can't be deleted via <code>erk wt delete</code>.</p> <p>Most daily work happens in non-root worktrees. The root worktree often serves as a \"home base\" for starting new plans or checking overall repository state.</p>"},{"location":"topics/worktrees/#erk-worktrees-vs-git-worktrees","title":"Erk Worktrees vs Git Worktrees","text":"<p>Git's built-in <code>git worktree</code> command is barebones\u2014it creates a directory and checks out a branch. Everything else is manual. Erk provides substantially more:</p> Aspect Git Worktree Erk Worktree Directory Any path (you choose) Organized under <code>~/.erk/repos/</code> Navigation Manual <code>cd</code> Automatic directory switching Environment None Runs scripts on switch (e.g., uv sync) Plan association None Linked to GitHub issue via <code>.impl/</code> <p>With vanilla git worktrees, you manually <code>cd</code> between directories and devise your own storage scheme. With erk, <code>erk wt checkout</code> changes your shell's working directory automatically. You can also configure scripts to run on each switch\u2014for example, syncing a Python virtual environment with <code>uv sync</code> whenever you navigate to a worktree.</p> <p>Note that <code>erk implement</code> automatically navigates to a new worktree when starting implementation.</p>"},{"location":"topics/worktrees/#common-operations","title":"Common Operations","text":"<p>Erk provides commands for worktree lifecycle management:</p> <ul> <li>Create: <code>erk wt create</code> - Creates a new worktree with branch and optional virtual environment</li> <li>List: <code>erk wt list</code> - Shows all worktrees with status (branch, plan, etc.)</li> <li>Switch: <code>erk wt checkout</code> or <code>erk br co</code> - Navigate to a worktree. Since erk manages the mapping between branches and worktrees, checking out a branch automatically switches to its associated worktree.</li> <li>Delete: <code>erk wt delete</code> - Removes worktree and cleans up branch</li> <li>Status: <code>erk wt status</code> - Shows current worktree details</li> </ul> <p>Navigation commands like <code>erk wt checkout</code> and <code>erk br co</code> automatically change your shell's working directory to the target worktree.</p>"},{"location":"topics/worktrees/#slots-reusing-worktrees-in-large-codebases","title":"Slots: Reusing Worktrees in Large Codebases","text":"<p>In large codebases or monorepos, creating a new worktree can take substantial time\u2014git must copy the entire working directory. For repositories with many files, this overhead becomes painful.</p> <p>Erk solves this with the slots system. Instead of creating and destroying worktrees, you allocate a fixed number of worktree \"slots\" upfront. Erk then manages bookkeeping to assign and unassign branches from these slots.</p> <p>Conceptually, each plan still gets its own worktree. Physically, the worktrees are reused. When you start implementing a new plan, erk finds an available slot, checks out your branch there, and you're ready to go\u2014without waiting for a fresh copy of the entire repository.</p> <p>Slots are enabled by default and used automatically by <code>erk implement</code>. You can still create standalone worktrees with <code>erk wt create</code> for advanced use cases, but most users never need to.</p> <p>Slot commands:</p> <ul> <li><code>erk slot init-pool</code> - Initialize pool with a fixed number of worktree slots</li> <li><code>erk slot list</code> - List all slots with their current assignment status</li> <li><code>erk slot assign</code> - Assign an existing branch to an available slot</li> <li><code>erk slot unassign</code> - Remove a branch assignment, freeing the slot</li> <li><code>erk slot repair</code> - Clean up stale assignments from pool state</li> </ul>"},{"location":"topics/worktrees/#why-worktrees-instead-of-multiple-clones","title":"Why Worktrees Instead of Multiple Clones?","text":"<p>You might wonder: why not just clone the repository multiple times? Worktrees are fundamentally better for several reasons.</p> <p>Unified git state. All worktrees share the same <code>.git</code> directory\u2014branches, tags, reflog, remote configuration, everything. Create a branch in one worktree and it's immediately visible in all others. Make a commit and it's in the shared database, accessible everywhere. Run <code>git fetch</code> once and all worktrees see the updated refs. With separate clones, each has its own isolated git state. You'd need to fetch in each one, set them up as remotes of each other, or constantly push/pull between them.</p> <p>Shared object store. The <code>.git/objects</code> directory contains your entire repository history\u2014all commits, all file contents. Worktrees share this; clones duplicate it. For a repository with substantial history, this difference is massive. One user reported their repo takes 1GB as a clone but only 150MB as a worktree, because only the working directory files are duplicated, not the history.</p> <p>Local creation. Creating a worktree doesn't require network transfer. The objects already exist locally; git just checks out the working directory files. Creating another clone means downloading everything again.</p> <p>The bottom line: worktrees give you isolated working directories with shared git infrastructure. Clones give you completely isolated repositories. For parallel development in the same codebase, worktrees are the right abstraction.</p>"},{"location":"topics/worktrees/#see-also","title":"See Also","text":"<ul> <li>The Workflow - How worktrees fit into plan-oriented development</li> <li>Why GitHub Issues - How plans connect to worktrees</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Step-by-step lessons to get you started with erk.</p> <p>Tutorials are learning-oriented. They guide you through a series of steps to complete a project, helping you learn by doing.</p>"},{"location":"tutorials/#core-tutorial","title":"Core Tutorial","text":"<p>Complete these in order:</p> <ol> <li>Prerequisites - Tools you need before installing erk</li> <li>Installation - Install erk and run initial configuration</li> <li>Your First Plan - Complete tutorial from idea to merged PR</li> </ol>"},{"location":"tutorials/#optional-enhancements","title":"Optional Enhancements","text":"<p>After completing your first plan, you may want to:</p> <ul> <li>Advanced Configuration - Capabilities, init flags, and troubleshooting</li> <li>Graphite Integration - Stacked PR workflows with Graphite</li> </ul>"},{"location":"tutorials/#what-youll-learn","title":"What You'll Learn","text":"<p>After completing the core tutorial, you will:</p> <ul> <li>Have erk installed and configured</li> <li>Understand the plan-implement-ship workflow</li> <li>Be able to create and execute plans using Claude Code</li> </ul>"},{"location":"tutorials/#next-steps","title":"Next Steps","text":"<p>After completing the tutorials, explore:</p> <ul> <li>The Workflow - Understand the full plan-implement-ship cycle</li> <li>Use the Local Workflow - Detailed guide to daily usage</li> </ul>"},{"location":"tutorials/advanced-configuration/","title":"Advanced Configuration","text":"<p>Optional capabilities, init flags, and troubleshooting for erk initialization.</p> <p>Prerequisites: Complete Installation first.</p>"},{"location":"tutorials/advanced-configuration/#capabilities","title":"Capabilities","text":"<p>Capabilities are optional features you can enable. View all available capabilities:</p> <pre><code>erk init capability list\n</code></pre> <p>Project capabilities (committed to repo, shared by team):</p> Capability Description <code>devrun-agent</code> Safe execution agent for pytest/ty/ruff/make/gt <code>devrun-reminder</code> Remind agent to use devrun for CI tool commands <code>dignified-python</code> Python coding standards (LBYL, modern types, ABCs) <code>dignified-python-reminder</code> Remind agent to follow dignified-python standards <code>dignified-review</code> Python code review (via convention-based system) <code>erk-bash-permissions</code> Allow <code>Bash(erk:*)</code> commands in Claude Code <code>erk-hooks</code> Configure Claude Code hooks for session management <code>erk-impl-workflow</code> GitHub Action for automated implementation <code>fake-driven-testing</code> 5-layer test architecture with fakes <code>learn-workflow</code> GitHub Action for automated documentation learning <code>learned-docs</code> Autolearning documentation system <code>ruff-format</code> Auto-format Python files with ruff after Write/Edit <code>tripwires-reminder</code> Remind agent to check tripwires.md <code>tripwires-review</code> Tripwire code review (via convention-based system) <p>User capabilities (local to each developer):</p> Capability Description <code>shell-integration</code> Shell wrapper for seamless worktree switching <code>statusline</code> Claude Code status line configuration <p>Install a capability with:</p> <pre><code>erk init capability add &lt;capability-name&gt;\n</code></pre>"},{"location":"tutorials/advanced-configuration/#init-flags","title":"Init Flags","text":"Flag Purpose <code>--no-interactive</code> Skip all prompts (use defaults) <code>-f, --force</code> Overwrite existing repo config <code>--shell</code> Show shell integration setup only <code>--statusline</code> Configure erk-statusline in Claude Code only"},{"location":"tutorials/advanced-configuration/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Permission errors on <code>.claude/settings.json</code> \u2014 Check file permissions, or edit manually</li> <li>Artifact sync failures \u2014 Non-fatal; run <code>erk artifact sync</code> to retry</li> <li>Global config issues \u2014 Check <code>~/.erk/</code> directory exists and is writable</li> </ul>"},{"location":"tutorials/advanced-configuration/#see-also","title":"See Also","text":"<ul> <li>Installation \u2014 Basic erk setup</li> <li>Shell Integration \u2014 Seamless worktree switching</li> </ul>"},{"location":"tutorials/first-plan/","title":"Your First Plan","text":"<p>This tutorial walks you through erk's complete workflow: creating a plan, saving it to GitHub, implementing it, and landing the PR. You'll build a simple CLI chatbot and add features to it.</p> <p>Prerequisites: Complete Installation and verify with <code>erk doctor</code>.</p>"},{"location":"tutorials/first-plan/#step-1-clone-the-starter-project","title":"Step 1: Clone the Starter Project","text":"<p>Clone the tutorial starter repo using the GitHub CLI. This front-loads authentication\u2014if there are any issues, you'll discover them now:</p> <pre><code>gh repo create say --template dagster-io/erk-tutorial --public --clone\ncd say\n</code></pre> <p>If prompted to authenticate, follow the instructions.</p> <p>The starter is a Python project using modern tools: uv, ruff, ty, pytest, and, of course, erk.</p> <p>Verify the setup:</p> <pre><code>uv run say\n</code></pre> <p>You should see a <code>&gt;</code> prompt. Type something and press Enter\u2014it echoes back. Press Ctrl+C to exit.</p>"},{"location":"tutorials/first-plan/#step-2-plan-your-first-feature","title":"Step 2: Plan Your First Feature","text":"<p><code>erk</code> is built around a plan \u2192 implement cycle. We believe explicit planning is critical for agentic engineering: you get better outcomes, more precise control, and can perform larger units of work more confidently and autonomously.</p> <p>We'll demonstrate this using Plan Mode in Claude Code to add a simple feature.</p> <p>Start a new session:</p> <pre><code>claude\n</code></pre> <p>Ask Claude to plan adding a <code>/quit</code> command:</p> <pre><code>I want to add a /quit command that exits the loop gracefully with a \"bye\" message. Let's plan this.\n</code></pre> <p>Claude enters plan mode. You can also enter plan mode anytime by pressing Shift+Tab to cycle through modes (Auto \u2192 Plan \u2192 Auto).</p> <p>You'll see Claude exploring the codebase\u2014reading files, understanding the CLI structure, finding where the input loop lives, and identifying patterns to follow. When it finishes exploring, it presents a plan for your review.</p>"},{"location":"tutorials/first-plan/#step-3-develop-the-plan","title":"Step 3: Develop the Plan","text":"<p>This is a simple feature, so the plan should be straightforward: modify the input loop to check for <code>/quit</code>, print \"bye\", and exit. Review what Claude proposes and continue when you're satisfied.</p>"},{"location":"tutorials/first-plan/#step-4-save-the-plan-to-github","title":"Step 4: Save the Plan to GitHub","text":"<p>When the plan is ready, Claude prompts you for next steps.</p>"},{"location":"tutorials/first-plan/#erk-extends-plan-mode","title":"<code>erk</code> Extends Plan Mode","text":"<p>Standard Claude Code plan mode shows this menu when you approve:</p> <pre><code>\u25cb Start implementation\n\u25cb Edit the plan\n</code></pre> <p><code>erk</code> extends this with additional options:</p> <pre><code>\u25cb Save the plan          # Save as GitHub issue, stop here\n\u25cb Implement              # Save to GitHub, then implement\n\u25cb Incremental            # Implement directly (for quick iterations)\n\u25cb View/Edit the plan\n</code></pre> <p>Choose Save the plan. Claude runs <code>/erk:plan-save</code>, which:</p> <ol> <li>Creates a GitHub issue with your plan</li> <li>Adds the <code>erk-plan</code> label</li> <li>Returns the issue number</li> </ol> <p>You'll see output like:</p> <pre><code>Plan saved as issue #1\n</code></pre>"},{"location":"tutorials/first-plan/#why-save-to-github","title":"Why Save to GitHub?","text":"<p>When you develop a plan in Claude Code, it normally lives only in the conversation\u2014easy to lose when you close the session. By saving as a GitHub issue:</p> <ul> <li>The plan persists beyond your session</li> <li>Anyone can implement it\u2014you, a teammate, or a CI agent</li> <li>Progress is tracked effortlessly through GitHub's issue system</li> </ul>"},{"location":"tutorials/first-plan/#step-5-implement-the-plan","title":"Step 5: Implement the Plan","text":"<p>The standard erk workflow implements each plan in its own worktree.</p>"},{"location":"tutorials/first-plan/#whats-a-worktree","title":"What's a Worktree?","text":"<p>Git worktrees let you have multiple branches checked out simultaneously in separate directories. Instead of switching branches in your main directory, erk creates a new directory with the feature branch\u2014completely isolated.</p>"},{"location":"tutorials/first-plan/#prepare-the-worktree","title":"Prepare the Worktree","text":"<p>First, exit Claude Code:</p> <pre><code>/exit\n</code></pre> <p>Now prepare a worktree for your plan:</p> <pre><code>erk br co --for-plan 1\n</code></pre> <p>This creates a worktree with the plan's content. You'll see output like:</p> <pre><code>Created branch: P1-quit-command\n\u2713 Assigned P1-quit-command to slot-1\nCreated .impl/ folder from issue #1\n\nTo activate and start implementation:\n  source /Users/you/.erk/repos/say/worktrees/slot-1/.erk/bin/activate.sh &amp;&amp; erk implement  (copied to clipboard)\n</code></pre>"},{"location":"tutorials/first-plan/#activate-and-implement","title":"Activate and Implement","text":"<p>The activation command is automatically copied to your clipboard. Just paste and run it:</p> <pre><code>source /path/to/slot-1/.erk/bin/activate.sh &amp;&amp; erk implement\n</code></pre> <p>This does two things:</p> <ol> <li>Activates the worktree environment (changes directory, sets up venv, loads .env)</li> <li>Starts Claude Code with the plan loaded</li> </ol> <p>Your plan is now implementing.</p>"},{"location":"tutorials/first-plan/#work-in-parallel","title":"Work in Parallel","text":"<p>Open a new terminal and return to your main directory:</p> <pre><code>cd ~/say\n</code></pre> <p>From here, you can monitor progress with the erk dashboard:</p> <pre><code>erk dash\n</code></pre> <p>This launches an interactive TUI showing all your plans and their implementation status.</p>"},{"location":"tutorials/first-plan/#step-6-submit-the-pr","title":"Step 6: Submit the PR","text":"<p>When the implementation finishes, you're already in the worktree. Submit the PR:</p> <pre><code>erk pr submit\n</code></pre> <p>This creates a pull request linked to the original issue.</p>"},{"location":"tutorials/first-plan/#step-7-land-the-pr","title":"Step 7: Land the PR","text":"<p>For this tutorial, merge your own PR:</p> <pre><code>erk land\n</code></pre> <p>This:</p> <ol> <li>Merges the PR</li> <li>Closes the linked issue</li> <li>Deletes the feature branch</li> <li>Frees the worktree for reuse</li> </ol> <p>After landing, return to your main repo:</p> <pre><code>cd ~/say\n</code></pre>"},{"location":"tutorials/first-plan/#what-youve-learned","title":"What You've Learned","text":"<p>You've completed the full erk workflow:</p> Phase What Happened Plan Created a detailed implementation plan with Claude Save Stored the plan as a GitHub issue for tracking Implement Executed the plan in an isolated worktree Submit Created a PR linked to the original issue Land Merged and cleaned up automatically"},{"location":"tutorials/first-plan/#quick-reference","title":"Quick Reference","text":"Task Command Start Claude <code>claude</code> Save plan <code>/erk:plan-save</code> Exit Claude <code>/exit</code> Prepare worktree <code>erk br co --for-plan &lt;issue&gt;</code> Activate + implement <code>source .erk/bin/activate.sh &amp;&amp; erk implement</code> Monitor plans <code>erk dash</code> Submit PR <code>erk pr submit</code> Land PR <code>erk land</code>"},{"location":"tutorials/first-plan/#next-steps","title":"Next Steps","text":"<ul> <li>The Workflow - Conceptual understanding of plan-oriented development</li> <li>CLI Command Reference - All available commands</li> </ul>"},{"location":"tutorials/graphite-integration/","title":"Graphite Integration","text":"<p>An optional enhancement that enables stacked PR workflows when using erk.</p>"},{"location":"tutorials/graphite-integration/#do-you-need-this","title":"Do You Need This?","text":"<p>Only if you already use Graphite. This tutorial assumes you're familiar with Graphite and understand stacking concepts (<code>gt create</code>, <code>gt submit</code>, upstack/downstack).</p> <p>If you're new to stacked PRs, visit graphite.dev first.</p> <p>Value prop: When Graphite is detected, erk uses <code>gt</code> under the hood for branch creation and PR submission. Your existing Graphite workflow gets enhanced with plan-driven implementation.</p>"},{"location":"tutorials/graphite-integration/#setup","title":"Setup","text":""},{"location":"tutorials/graphite-integration/#verify-graphite-is-installed","title":"Verify Graphite is Installed","text":"<pre><code>gt --version\n</code></pre> <p>If not installed, see graphite.dev/docs/getting-started.</p>"},{"location":"tutorials/graphite-integration/#no-additional-configuration-needed","title":"No Additional Configuration Needed","text":"<p><code>erk</code> auto-detects Graphite. If <code>gt</code> is on your PATH, erk uses it automatically.</p> <p>To verify Graphite is installed and detected:</p> <pre><code>erk doctor\n</code></pre> <p>Look for \"Graphite CLI installed\" in the output.</p>"},{"location":"tutorials/graphite-integration/#how-erk-uses-graphite","title":"How <code>erk</code> Uses Graphite","text":"<p>When Graphite is enabled, erk's core workflow commands use <code>gt</code> under the hood.</p>"},{"location":"tutorials/graphite-integration/#branch-creation","title":"Branch Creation","text":"<pre><code>erk implement 123\n</code></pre> <p>Under the hood, this runs <code>gt create</code> to create a stacked branch. The parent branch is tracked automatically based on your current location.</p> Without Graphite With Graphite <code>git checkout -b feature-branch</code> <code>gt create feature-branch</code> Parent: trunk only Parent: current branch (stacking)"},{"location":"tutorials/graphite-integration/#pr-submission","title":"PR Submission","text":"<pre><code>erk pr submit\n</code></pre> <p>Under the hood, this runs:</p> <ol> <li><code>gt squash</code> - Consolidate commits into a clean history</li> <li><code>gt restack</code> - Rebase the stack if needed</li> <li><code>gt submit</code> - Push and create/update PRs for the stack</li> </ol> <p>This ensures your entire stack stays synchronized.</p>"},{"location":"tutorials/graphite-integration/#landing-prs","title":"Landing PRs","text":"<pre><code>erk land\n</code></pre> <p>When landing a stacked PR:</p> <ol> <li>Merges the PR on GitHub</li> <li>Cleans up the local branch and worktree</li> <li>Restacks child branches automatically</li> </ol> <p>Child branches in the stack are rebased onto the new trunk state.</p>"},{"location":"tutorials/graphite-integration/#navigating-after-landing","title":"Navigating After Landing","text":"<p>By default, <code>erk land</code> returns you to the root worktree. When working in a stack, use <code>--up</code> to navigate to the next child branch instead:</p> <pre><code>erk land --up\n</code></pre> <p>This lands the current PR and moves you to the child worktree, allowing you to continue working up the stack.</p>"},{"location":"tutorials/graphite-integration/#stacking-plans","title":"Stacking Plans","text":"<p><code>erk</code>'s plan-driven workflow naturally supports stacking. When you implement a second plan while in a feature worktree, it stacks on top.</p> <p>Example workflow:</p> <pre><code># In root worktree, implement first plan\nerk implement 100\n# Creates worktree-100 stacked on master\n\n# While in worktree-100, implement a dependent plan\nerk implement 101\n# Creates worktree-101 stacked on the branch from plan 100\n</code></pre> <p>The stack structure:</p> <pre><code>master\n\u2514\u2500\u2500 feature-from-plan-100\n    \u2514\u2500\u2500 feature-from-plan-101\n</code></pre> <p>Submit the entire stack with <code>erk pr submit</code> from any branch in the stack.</p>"},{"location":"tutorials/graphite-integration/#stack-navigation","title":"Stack Navigation","text":"<p>Navigate between branches in your stack just like regular git branching\u2014erk handles the worktree switching automatically as you move up and down.</p>"},{"location":"tutorials/graphite-integration/#move-up-the-stack","title":"Move Up the Stack","text":"<pre><code>erk up\n</code></pre> <p>Moves to the child branch (away from trunk). <code>erk</code> switches you to the corresponding worktree.</p>"},{"location":"tutorials/graphite-integration/#move-down-the-stack","title":"Move Down the Stack","text":"<pre><code>erk down\n</code></pre> <p>Moves to the parent branch (toward trunk). <code>erk</code> switches you to the corresponding worktree.</p>"},{"location":"tutorials/graphite-integration/#view-the-stack","title":"View the Stack","text":"<pre><code>erk stack list\n</code></pre> <p>Shows your stack structure with current position:</p> <pre><code>master\n\u2514\u2500\u2500 feature-auth \u2190 you are here\n    \u2514\u2500\u2500 feature-api\n</code></pre>"},{"location":"tutorials/graphite-integration/#next-steps","title":"Next Steps","text":"<ul> <li>The Workflow - Full plan-implement-ship cycle</li> </ul>"},{"location":"tutorials/installation/","title":"Installation","text":"<p>Install erk and verify your setup.</p> <p>Prerequisites: Complete Prerequisites first\u2014you need Python 3.11+, Claude Code, uv, and GitHub CLI.</p>"},{"location":"tutorials/installation/#install-erk","title":"Install erk","text":"<p>Install erk as a project dependency:</p> <pre><code>cd your-project\nuv add erk\nuv sync\n</code></pre> <p>Verify the installation:</p> <pre><code># In your project directory (with venv activated)\nerk --version\n</code></pre> <p>You should see output like <code>erk 0.7.x</code>.</p> <p>Troubleshooting:</p> <ul> <li><code>uv: command not found</code> \u2014 Install uv first. See Prerequisites.</li> <li>Python version error \u2014 erk requires Python 3.11 or higher. Check with <code>python --version</code>.</li> <li><code>erk: command not found</code> \u2014 Make sure your venv is activated (<code>. .venv/bin/activate</code>) or use <code>.venv/bin/erk</code> directly.</li> </ul>"},{"location":"tutorials/installation/#verify-installation","title":"Verify Installation","text":"<p>Run the doctor command to check your setup:</p> <pre><code>erk doctor\n</code></pre> <p>Doctor checks two categories:</p> <ul> <li>Repository Setup: Checks specific to the current repo (git, config, hooks)</li> <li>User Setup: Global prerequisites (CLI tools, authentication)</li> </ul> <p>Condensed output (default):</p> <pre><code>\ud83d\udd0d Checking erk setup...\n\nRepository Setup\n\u2705 Git repository (2 checks)\n\u2705 Claude settings (4 checks)\n\u2705 Erk configuration (6 checks)\n\u2705 GitHub (3 checks)\n\u2705 Hooks (1 checks)\n\nUser Setup\n\u2705 erk CLI installed: v0.4.7\n\u2705 Claude CLI installed\n\u2705 GitHub CLI installed\n\u2705 uv installed\n\u2705 User checks (4 checks)\n\n\u2728 All checks passed!\n</code></pre> <p>Verbose output (<code>erk doctor --verbose</code>):</p> <p>Add <code>--verbose</code> to see individual checks within each category\u2014useful for debugging failures.</p> <p>Status indicators:</p> Icon Meaning Action \u2705 Passed None needed \u2139\ufe0f Info Optional enhancement available \u274c Failed Fix required before continuing <p>If checks fail:</p> <ul> <li>Repository Setup failures \u2014 Run <code>erk init</code> to configure the repo</li> <li>User Setup failures \u2014 See Prerequisites to install missing tools</li> </ul>"},{"location":"tutorials/installation/#initialize-a-repository","title":"Initialize a Repository","text":"<p>Erk initialization has two phases:</p> <ol> <li> <p>Project setup (one-time per repository) \u2014 Creates configuration files and Claude Code artifacts that are committed to the repo. Once done, other team members get erk support automatically.</p> </li> <li> <p>User setup (one-time per developer) \u2014 Creates local configuration on each developer's machine. This includes the global config file.</p> </li> </ol> <p>Run init from your project's root directory:</p> <pre><code>erk init\n</code></pre>"},{"location":"tutorials/installation/#what-happens-during-project-setup","title":"What happens during project setup","text":"<p>When you run <code>erk init</code> in a repository for the first time, it creates:</p> <ul> <li><code>.erk/config.toml</code> \u2014 Repository configuration (commit this)</li> <li><code>.erk/required-erk-uv-tool-version</code> \u2014 Minimum erk version for the project</li> <li><code>.claude/commands/erk/</code> \u2014 Claude Code slash commands like <code>/erk:plan-save</code></li> <li><code>.claude/skills/</code> \u2014 Coding standards and documentation patterns</li> <li><code>.claude/agents/</code> \u2014 Agent definitions (e.g., devrun for test execution)</li> </ul> <p>Once committed, any developer who clones the repo gets these artifacts automatically.</p>"},{"location":"tutorials/installation/#what-happens-during-user-setup","title":"What happens during user setup","text":"<p>Each developer needs local state that isn't committed:</p> <ul> <li><code>~/.erk/config.json</code> \u2014 Global config with:</li> <li><code>erk_root</code>: Where worktrees are created (default: <code>~/.erk/repos/&lt;repo&gt;/worktrees/</code>)</li> <li><code>use_graphite</code>: Auto-detected based on whether <code>gt</code> is installed</li> </ul> <p>The first time you run <code>erk init</code> (in any repo), it creates your global config. Subsequent runs in other repos skip this step.</p> <p>For optional capabilities (devrun, dignified-python, etc.), init flags, and troubleshooting, see Advanced Configuration.</p>"},{"location":"tutorials/installation/#quick-reference","title":"Quick Reference","text":"Task Command Install erk <code>uv add erk &amp;&amp; uv sync</code> Check version <code>erk --version</code> Verify setup <code>erk doctor</code> Verbose diagnostics <code>erk doctor --verbose</code> Initialize repo <code>erk init</code> Update erk <code>uv upgrade erk</code>"},{"location":"tutorials/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Your First Plan \u2014 Create your first plan and land a PR</li> </ul>"},{"location":"tutorials/prerequisites/","title":"Prerequisites","text":"<p>Tools you need before installing erk.</p> <p>Erk orchestrates several tools to enable plan-oriented agentic engineering. This guide helps you install and verify each one.</p>"},{"location":"tutorials/prerequisites/#required-tools","title":"Required Tools","text":""},{"location":"tutorials/prerequisites/#python-311","title":"Python 3.11+","text":"<p>Erk is a Python CLI tool. You need Python 3.11 or higher.</p> <p>Check your version:</p> <pre><code>python --version\n</code></pre> <p>You should see <code>Python 3.11.x</code> or higher (3.12, 3.13 also work).</p> <p>If you need to install Python, see Install Python.</p>"},{"location":"tutorials/prerequisites/#claude-code-cli","title":"Claude Code CLI","text":"<p>Claude Code is the AI agent that powers erk's planning and implementation. You need an active Anthropic account with API access.</p> <p>Install:</p> <pre><code>curl -fsSL https://claude.ai/install.sh | bash\n</code></pre> <p>Verify:</p> <pre><code>claude --version\n</code></pre> <p>You should see output like <code>claude-code 1.x.x</code>.</p> <p>First-time setup:</p> <p>When you first run <code>claude</code>, you'll be prompted to authenticate with your Anthropic account. Follow the browser prompts to complete setup.</p> <p>Troubleshooting:</p> <ul> <li>If you see authentication errors, run <code>claude</code> and follow the login prompts</li> </ul>"},{"location":"tutorials/prerequisites/#uv-python-package-manager","title":"uv (Python Package Manager)","text":"<p>Erk uses uv for fast, reproducible Python package management. It's significantly faster than pip and ensures consistent environments.</p> <p>Install:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Verify:</p> <pre><code>uv --version\n</code></pre> <p>You should see output like <code>uv 0.x.x</code>.</p> <p>Why uv instead of pip?</p> <ul> <li>Speed: 10-100x faster than pip</li> <li>Reproducibility: Lockfiles ensure consistent installs</li> <li>Simplicity: Handles Python version management too</li> </ul>"},{"location":"tutorials/prerequisites/#github-cli","title":"GitHub CLI","text":"<p>The GitHub CLI (<code>gh</code>) enables erk to create issues, PRs, and interact with your repositories programmatically.</p> <p>macOS (Homebrew):</p> <pre><code>brew install gh\n</code></pre> <p>Linux (Ubuntu/Debian):</p> <pre><code>sudo apt install gh\n</code></pre> <p>Verify installation:</p> <pre><code>gh --version\n</code></pre> <p>You should see output like <code>gh version 2.x.x</code>.</p> <p>Authenticate with GitHub:</p> <pre><code>gh auth login\n</code></pre> <p>Follow the prompts to authenticate via browser or token.</p> <p>Verify authentication:</p> <pre><code>gh auth status\n</code></pre> <p>You should see output confirming you're logged into github.com.</p> <p>Troubleshooting:</p> <ul> <li>If <code>gh auth status</code> shows \"not logged in\", run <code>gh auth login</code> again</li> <li>For GitHub Enterprise, use <code>gh auth login --hostname your-enterprise.com</code></li> </ul>"},{"location":"tutorials/prerequisites/#optional-enhancements","title":"Optional Enhancements","text":"<p>These tools unlock additional features but are not required to start:</p>"},{"location":"tutorials/prerequisites/#graphite-gt","title":"Graphite (gt)","text":"<p>Graphite enables stacked PRs\u2014a workflow where you build features as a stack of dependent branches. This is powerful for large features that benefit from incremental review.</p> <p>What it enables:</p> <ul> <li>Stack multiple PRs that depend on each other</li> <li>Rebase entire stacks with a single command</li> <li>Track stack status in erk dashboard</li> </ul> <p>See Graphite Integration for setup instructions.</p>"},{"location":"tutorials/prerequisites/#quick-reference","title":"Quick Reference","text":"Tool Install Command Verify Command Python python.org/downloads <code>python --version</code> Claude CLI <code>curl -fsSL https://claude.ai/install.sh \\| bash</code> <code>claude --version</code> uv <code>curl -LsSf https://astral.sh/uv/install.sh \\| sh</code> <code>uv --version</code> GitHub CLI <code>brew install gh</code> <code>gh --version</code>"},{"location":"tutorials/prerequisites/#next-steps","title":"Next Steps","text":"<p>Once all required tools are installed and verified:</p> <ul> <li>Installation - Install erk itself</li> </ul>"}]}