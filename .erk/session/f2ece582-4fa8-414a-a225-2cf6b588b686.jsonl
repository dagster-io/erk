{"type":"queue-operation","operation":"dequeue","timestamp":"2026-02-22T14:39:38.224Z","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686"}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","type":"user","message":{"role":"user","content":"<command-message>erk:plan-implement is running…</command-message>\n<command-name>/erk:plan-implement</command-name>\n<command-args>7854</command-args>"},"uuid":"8e005628-23ab-49c9-a328-6b04fd8391a8","timestamp":"2026-02-22T14:39:38.280Z"}
{"parentUuid":"8e005628-23ab-49c9-a328-6b04fd8391a8","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","type":"user","message":{"role":"user","content":[{"type":"text","text":"# /erk:plan-implement\n\nImplement a plan - either from a GitHub issue, a markdown file, an existing `.impl/` folder, or by saving the current plan first.\n\nThis is the primary implementation workflow - it orchestrates:\n\n1. Setting up the `.impl/` folder (from issue, file, existing folder, or fresh plan)\n2. Executing the implementation\n3. Running CI and submitting the PR\n\n## Prerequisites\n\n- Must be in a git repository managed by erk\n- GitHub CLI (`gh`) must be authenticated\n- One of:\n  - An issue number, URL, or file path argument\n  - An existing `.impl/` folder\n  - A plan in `~/.claude/plans/` (from plan mode)\n\n## Usage\n\n```bash\n/erk:plan-implement                    # Use .impl/ or save current plan\n/erk:plan-implement 2521               # Fetch and implement issue #2521\n/erk:plan-implement https://github.com/owner/repo/issues/2521  # URL form\n/erk:plan-implement ./my-plan.md       # Implement from local markdown file\n```\n\n---\n\n## Agent Instructions\n\n### Step 0: Parse Arguments\n\nExtract optional argument from `7854`:\n\n- **If numeric** (e.g., `2521`): Store as `ISSUE_ARG`\n- **If GitHub URL** (e.g., `https://github.com/owner/repo/issues/2521`): Extract number from path, store as `ISSUE_ARG`\n- **If path to file** (anything else non-empty): Store as `FILE_ARG`\n- **If empty**: Proceed to check `.impl/` folder\n\nStore either `ISSUE_ARG` (issue number) or `FILE_ARG` (file path), or neither if empty.\n\n### Step 1: Determine Implementation Source\n\nFollow this priority order:\n\n#### 1a. If ISSUE_ARG is provided\n\nFirst, check if `.impl/` already exists and is valid:\n\n```bash\nerk exec impl-init --json\n```\n\nIf this succeeds with `\"valid\": true`:\n\n- If `has_issue_tracking: false`: **Skip directly to Step 2d** (file-based plan, no remote to sync with).\n- If `has_issue_tracking: true`: **Still call `setup-impl-from-issue`** to ensure the local branch is synced with remote (see below). The command is idempotent — if already on the plan branch it just pulls the latest.\n\nOtherwise, set up from the specified issue:\n\n```bash\nerk exec setup-impl-from-issue <ISSUE_ARG>\n```\n\nThis command:\n\n- For draft-PR plans: checks out the plan branch and syncs with remote via pull-rebase\n- For issue-based plans: creates a feature branch from current branch (stacked) or trunk\n- Checks out the branch in the current worktree\n- Creates `.impl/` folder with the plan content\n- Saves issue reference for PR linking\n\nIf this fails, display the error and stop.\n\nThen run impl-init:\n\n```bash\nerk exec impl-init --json\n```\n\n#### 1a-file. If FILE_ARG is provided\n\nSet up from the specified markdown file:\n\n1. **Verify the file exists** using the Read tool\n2. **Extract the title** from the first `# ` heading in the file\n3. **Generate branch name** from the title (slugify: lowercase, replace spaces with hyphens, remove special chars)\n4. **Create a feature branch** (use devrun agent for gt commands):\n   ```bash\n   gt create <branch-name>\n   ```\n5. **Create `.impl/` folder** and copy the plan:\n   ```bash\n   mkdir -p .impl && cp <FILE_ARG> .impl/plan.md\n   ```\n\nThis is a local-only plan (no GitHub issue tracking).\n\nThen run impl-init:\n\n```bash\nerk exec impl-init --json\n```\n\nNote: `has_issue_tracking` will be `false` for file-based plans.\n\n#### 1b. If .impl/ already exists\n\nCheck if implementation is already set up:\n\n```bash\nerk exec impl-init --json\n```\n\nIf this succeeds with `\"valid\": true`:\n\n- If `has_issue_tracking: false`: **Skip directly to Step 2d** (file-based plan, no remote to sync with).\n- If `has_issue_tracking: true`: **Call `setup-impl-from-issue <issue_number>`** to sync the local branch with remote, then proceed to Step 2d. The `issue_number` is available in `.impl/issue.json`.\n\nIf it fails or returns `\"valid\": false`, continue to Step 2.\n\n#### 1c. Fall back to saving current plan\n\nIf neither argument nor valid `.impl/` exists, save the current plan from plan mode (Step 2).\n\n### Step 2: Save Plan to GitHub\n\nSave the current plan to GitHub and capture the issue number:\n\n```bash\nerk exec plan-save --format json --session-id=\"${CLAUDE_SESSION_ID}\"\n```\n\nParse the JSON output to get:\n\n- `issue_number`: The created issue number\n- `title`: The issue title (for branch naming)\n\nIf this fails, display the error and stop.\n\n### Step 2b: Create Branch and Setup .impl/\n\nNow set up the implementation environment using the saved issue:\n\n```bash\nerk exec setup-impl-from-issue <issue-number>\n```\n\nThis command:\n\n- Creates a feature branch from current branch (stacked) or trunk\n- Checks out the new branch in the current worktree\n- Creates `.impl/` folder with the plan content\n- Saves issue reference for PR linking\n\nIf this fails, display the error and stop.\n\n### Step 2c: Re-run Implementation Initialization\n\nRun impl-init again now that .impl/ is set up:\n\n```bash\nerk exec impl-init --json\n```\n\nUse the returned `phases` for TodoWrite entries. If validation fails, display error and stop.\n\n### Step 2d: Clean Up Plan Staging Directory (All Paths)\n\n**All setup paths converge here before Step 3.** If `.erk/impl-context/` exists in git tracking (from draft-PR plan save), remove it:\n\n```bash\nif [ -d .erk/impl-context/ ]; then\n  git rm -rf .erk/impl-context/\n  git commit -m \"Remove .erk/impl-context/ before implementation\"\n  git push origin \"$(git branch --show-current)\"\nfi\n```\n\nThis directory contains plan content committed during plan-save. It is idempotent — safe to run even when the directory doesn't exist.\n\n### Step 3: Read Plan and Load Context\n\nRead `.impl/plan.md` to understand:\n\n- Overall goal and context\n- Context & Understanding sections (API quirks, architectural insights, pitfalls)\n- Implementation phases and dependencies\n- Success criteria\n\n**Context Consumption**: Plans contain expensive discoveries. Ignoring `[CRITICAL:]` tags, \"Related Context:\" subsections, or \"DO NOT\" items causes repeated mistakes.\n\n### Step 4: Load Related Documentation\n\nIf plan contains \"Related Documentation\" section, load listed skills via Skill tool and read listed docs.\n\n### Step 5: Create TodoWrite Entries\n\nCreate todo entries for each phase from impl-init output.\n\n### Step 6: Signal GitHub Started\n\n```bash\nerk exec impl-signal started --session-id=\"${CLAUDE_SESSION_ID}\" 2>/dev/null || true\n```\n\nThis also deletes the Claude plan file (from `~/.claude/plans/`) since:\n\n- The content has been saved to GitHub issue\n- The content has been snapshotted to `.erk/scratch/`\n- Keeping it could cause confusion if the user tries to re-save\n\n### Step 7: Execute Each Phase Sequentially\n\nFor each phase:\n\n1. **Mark phase as in_progress** (in TodoWrite)\n2. **Read task requirements** carefully\n3. **Implement code AND tests together**:\n   - Load `dignified-python-313` skill for coding standards\n   - Load `fake-driven-testing` skill for test patterns\n   - Follow project AGENTS.md standards\n4. **Mark phase as completed** (in TodoWrite)\n5. **Report progress**: changes made, what's next\n\n**Important:** `.impl/plan.md` is immutable - NEVER edit during implementation\n\n### Step 8: Report Progress\n\nAfter each phase: report changes made and what's next.\n\n### Step 9: Final Verification\n\nConfirm all tasks executed, success criteria met, note deviations, summarize changes.\n\n### Step 10: Signal GitHub Ended\n\n```bash\nerk exec impl-signal ended --session-id=\"${CLAUDE_SESSION_ID}\" 2>/dev/null || true\n```\n\n### Step 10b: Upload Session for Async Learn\n\nUpload the current session to enable async learn:\n\n```bash\n# Capture session info\neval \"$(erk exec capture-session-info)\"\n\n# Get issue number from .impl/issue.json (jq extracts issue_number field)\nISSUE_NUMBER=$(jq -r '.issue_number // empty' .impl/issue.json 2>/dev/null || echo \"\")\n\n# Upload if we have both session and issue tracking\nif [ -n \"$SESSION_ID\" ] && [ -n \"$SESSION_FILE\" ] && [ -n \"$ISSUE_NUMBER\" ]; then\n  erk exec upload-session \\\n    --session-file \"$SESSION_FILE\" \\\n    --session-id \"$SESSION_ID\" \\\n    --source local \\\n    --issue-number \"$ISSUE_NUMBER\" || true\nfi\n```\n\nThis enables `erk learn --async` to work for locally-implemented PRs by uploading the session to a gist.\n\n### Step 11: Verify .impl/ Preserved\n\n**CRITICAL GUARDRAIL**: Verify the .impl/ folder was NOT deleted.\n\n```bash\nerk exec impl-verify\n```\n\nIf this fails, you have violated instructions. The .impl/ folder must be preserved for user review.\n\n### Step 12: Run CI Iteratively\n\n1. If `.erk/prompt-hooks/post-plan-implement-ci.md` exists: follow its instructions\n2. Otherwise: check CLAUDE.md/AGENTS.md for CI commands\n\n**Note:** `.worker-impl/` and `.erk/impl-context/` cleanup is handled by the workflow before implementation begins. For local execution, Step 2d handles `.erk/impl-context/` cleanup.\n\n**CRITICAL**: Never delete `.impl/` - leave for user review (no auto-commit).\n\n### Step 13: Submit PR\n\nPush the branch and create or update the PR using the Graphite-aware submit pipeline:\n\n```bash\nerk pr submit\n```\n\nThis handles pushing commits, creating/updating the PR, generating the PR description, and enhancing with Graphite stack metadata when available.\n\nAfter successful submission, signal lifecycle transition:\n\n```bash\nerk exec impl-signal submitted 2>/dev/null || true\n```\n\nThen validate PR rules:\n\n```bash\nerk pr check\n```\n\nIf checks fail, display output and warn user.\n\n### Step 14: Output Format\n\n- **Start**: \"Setting up implementation...\" or \"Fetching plan from issue #X...\"\n- **After setup**: \"Implementation environment ready, reading plan...\"\n- **Each phase**: \"Phase X: [brief description]\" with code changes\n- **End**: \"Plan execution complete. [Summary]\"\n\n---\n\n## Related Commands\n\n- `/erk:plan-save` - Save plan only, don't implement (for defer-to-later workflow)\n- `/erk:replan` - Re-plan an existing issue with current codebase state\n"}]},"isMeta":true,"uuid":"217cabd6-4a33-4818-85f6-7beb6a3c006c","timestamp":"2026-02-22T14:39:38.280Z"}
{"parentUuid":"217cabd6-4a33-4818-85f6-7beb6a3c006c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","message":{"model":"claude-opus-4-6","id":"msg_013NzyEcUSKHTzBB9mSFDoBE","type":"message","role":"assistant","content":[{"type":"text","text":"\n\nI'll implement plan #7854. Let me start by setting up the implementation environment."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":11843,"cache_read_input_tokens":16522,"cache_creation":{"ephemeral_5m_input_tokens":11843,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHCMFF9y7FMcEpfAdRp","type":"assistant","uuid":"359738b9-32ae-4274-b8ec-ef9722dbf86c","timestamp":"2026-02-22T14:39:41.859Z"}
{"parentUuid":"359738b9-32ae-4274-b8ec-ef9722dbf86c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","message":{"model":"claude-opus-4-6","id":"msg_013NzyEcUSKHTzBB9mSFDoBE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DBnYdXYJvF9H6TFPm4v7Mo","name":"Bash","input":{"command":"erk exec impl-init --json 2>&1","description":"Check if .impl/ already exists"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":11843,"cache_read_input_tokens":16522,"cache_creation":{"ephemeral_5m_input_tokens":11843,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHCMFF9y7FMcEpfAdRp","type":"assistant","uuid":"33ee8f1a-1fdf-480a-a1d2-b8ebdf1cdf9a","timestamp":"2026-02-22T14:39:42.671Z"}
{"parentUuid":"33ee8f1a-1fdf-480a-a1d2-b8ebdf1cdf9a","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DBnYdXYJvF9H6TFPm4v7Mo","type":"tool_result","content":"{\"valid\": true, \"impl_type\": \"impl\", \"has_issue_tracking\": true, \"related_docs\": {\"skills\": [], \"docs\": []}, \"issue_number\": 7854}","is_error":false}]},"uuid":"5a232ae2-394c-462d-98d4-730557e0b525","timestamp":"2026-02-22T14:39:43.770Z","toolUseResult":{"stdout":"{\"valid\": true, \"impl_type\": \"impl\", \"has_issue_tracking\": true, \"related_docs\": {\"skills\": [], \"docs\": []}, \"issue_number\": 7854}","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"5a232ae2-394c-462d-98d4-730557e0b525","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","message":{"model":"claude-opus-4-6","id":"msg_01YAJ4HiYwdQ4CHSTY5EEodf","type":"message","role":"assistant","content":[{"type":"text","text":"The `.impl/` is valid with issue tracking. Let me sync with remote and read the plan."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":164,"cache_read_input_tokens":28365,"cache_creation":{"ephemeral_5m_input_tokens":164,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHCgm1BqFZu41DfEarx","type":"assistant","uuid":"9191cd2b-59a6-4a6b-bdb4-045373d52023","timestamp":"2026-02-22T14:39:46.092Z"}
{"parentUuid":"9191cd2b-59a6-4a6b-bdb4-045373d52023","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","message":{"model":"claude-opus-4-6","id":"msg_01YAJ4HiYwdQ4CHSTY5EEodf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GGaJViqXmhxRoPmmWGNYsP","name":"Bash","input":{"command":"erk exec setup-impl-from-issue 7854 2>&1","description":"Sync local branch with remote"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":164,"cache_read_input_tokens":28365,"cache_creation":{"ephemeral_5m_input_tokens":164,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHCgm1BqFZu41DfEarx","type":"assistant","uuid":"fe7262d3-65b4-4ec9-9560-9bff7b807d0e","timestamp":"2026-02-22T14:39:46.758Z"}
{"parentUuid":"fe7262d3-65b4-4ec9-9560-9bff7b807d0e","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","message":{"model":"claude-opus-4-6","id":"msg_01YAJ4HiYwdQ4CHSTY5EEodf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CCn2FDwo1t2soR2fpotyEg","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/.impl/plan.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":164,"cache_read_input_tokens":28365,"cache_creation":{"ephemeral_5m_input_tokens":164,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHCgm1BqFZu41DfEarx","type":"assistant","uuid":"4de8ce0d-11a3-4fa0-a544-fda655a15125","timestamp":"2026-02-22T14:39:47.284Z"}
{"parentUuid":"4de8ce0d-11a3-4fa0-a544-fda655a15125","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GGaJViqXmhxRoPmmWGNYsP","type":"tool_result","content":"Found existing .impl/ for plan #7854, skipping branch setup\n{\"success\": true, \"impl_path\": \"/home/runner/work/erk/erk/.impl\", \"issue_number\": 7854, \"issue_url\": \"https://github.com/dagster-io/erk/pull/7854\", \"branch\": \"planned/shorted-planned-prefix-02-22-0934\", \"plan_title\": \"\", \"no_impl\": false}","is_error":false}]},"uuid":"1335a7f2-dac9-425b-8ecb-1675d63fd1ea","timestamp":"2026-02-22T14:39:48.290Z","toolUseResult":{"stdout":"Found existing .impl/ for plan #7854, skipping branch setup\n{\"success\": true, \"impl_path\": \"/home/runner/work/erk/erk/.impl\", \"issue_number\": 7854, \"issue_url\": \"https://github.com/dagster-io/erk/pull/7854\", \"branch\": \"planned/shorted-planned-prefix-02-22-0934\", \"plan_title\": \"\", \"no_impl\": false}","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"1335a7f2-dac9-425b-8ecb-1675d63fd1ea","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CCn2FDwo1t2soR2fpotyEg","type":"tool_result","content":"     1→_One-shot: plan content will be populated by one-shot workflow._\n     2→\n     3→**Prompt:** shorted planned/ prefix on branches to plnd/\n     4→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"0a68f952-adee-4b5f-9f9a-ffbab53e4aef","timestamp":"2026-02-22T14:39:48.298Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/.impl/plan.md","content":"_One-shot: plan content will be populated by one-shot workflow._\n\n**Prompt:** shorted planned/ prefix on branches to plnd/\n","numLines":4,"startLine":1,"totalLines":4}}}
{"parentUuid":"0a68f952-adee-4b5f-9f9a-ffbab53e4aef","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_013wzxsjiZir95BPFAuHTErT","type":"message","role":"assistant","content":[{"type":"text","text":"The plan is a one-shot with a brief prompt. Let me check the actual issue for more details, and also clean up staging dirs."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":458,"cache_read_input_tokens":28529,"cache_creation":{"ephemeral_5m_input_tokens":458,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHD2AK5WdL4oA8vVptK","type":"assistant","uuid":"cf52cf54-edcd-4fa0-9561-a9572e747586","timestamp":"2026-02-22T14:39:51.073Z"}
{"parentUuid":"cf52cf54-edcd-4fa0-9561-a9572e747586","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_013wzxsjiZir95BPFAuHTErT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SDcQy5YasQtFYKRni25KQN","name":"Bash","input":{"command":"gh issue view 7854 --json title,body 2>&1 | head -100","description":"View issue details for plan 7854"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":458,"cache_read_input_tokens":28529,"cache_creation":{"ephemeral_5m_input_tokens":458,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHD2AK5WdL4oA8vVptK","type":"assistant","uuid":"0ed405ce-61c0-49a4-8025-d3232d1c2fd1","timestamp":"2026-02-22T14:39:52.081Z"}
{"parentUuid":"0ed405ce-61c0-49a4-8025-d3232d1c2fd1","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_013wzxsjiZir95BPFAuHTErT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Nuj8vaYMhdrhydYbxk1CY4","name":"Bash","input":{"command":"if [ -d .erk/impl-context/ ]; then git rm -rf .erk/impl-context/ && git commit -m \"Remove .erk/impl-context/ before implementation\" && git push origin \"$(git branch --show-current)\"; else echo \"No impl-context dir to clean\"; fi","description":"Clean up plan staging directory"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":458,"cache_read_input_tokens":28529,"cache_creation":{"ephemeral_5m_input_tokens":458,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHD2AK5WdL4oA8vVptK","type":"assistant","uuid":"c0982a06-d9f3-4992-8ff1-f75ccb31d63b","timestamp":"2026-02-22T14:39:53.206Z"}
{"parentUuid":"c0982a06-d9f3-4992-8ff1-f75ccb31d63b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SDcQy5YasQtFYKRni25KQN","type":"tool_result","content":"{\"body\":\"<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\\n<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\\n<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\\n<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\\n<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\\n<!-- erk:metadata-block:plan-header -->\\n<details>\\n<summary>plan-header</summary>\\n\\n```yaml\\n\\nschema_version: '2'\\ncreated_at: '2026-02-22T09:34:49.528424+00:00'\\ncreated_by: schrockn\\nplan_comment_id: null\\nlast_dispatched_run_id: '22279106651'\\nlast_dispatched_node_id: WFR_kwLOPxC3hc8AAAAFL_AwWw\\nlast_dispatched_at: '2026-02-22T14:38:53Z'\\nlast_local_impl_at: null\\nlast_local_impl_event: null\\nlast_local_impl_session: null\\nlast_local_impl_user: null\\nlast_remote_impl_at: null\\nlast_remote_impl_run_id: null\\nlast_remote_impl_session_id: null\\nbranch_name: planned/shorted-planned-prefix-02-22-0934\\nlifecycle_stage: planned\\n\\n```\\n\\n</details>\\n<!-- /erk:metadata-block:plan-header -->\\n\\n\\n---\\n\\n<details>\\n<summary>original-plan</summary>\\n\\n_One-shot: plan content will be populated by one-shot workflow._\\n\\n**Prompt:** shorted planned/ prefix on branches to plnd/\\n\\n\\n</details>\\n---\\n\\n\\nTo checkout this PR in a fresh worktree and environment locally, run:\\n\\n```\\nsource \\\"$(erk pr checkout 7854 --script)\\\" && erk pr sync --dangerous\\n```\\n\\n**Remotely executed:** [Run #22279106651](https://github.com/dagster-io/erk/actions/runs/22279106651)\",\"title\":\"[erk-plan] Shorten planned/ prefix to plnd/ on branches and PR titles\"}","is_error":false}]},"uuid":"354d2127-e633-4d61-ac27-8442e7fddc17","timestamp":"2026-02-22T14:39:55.165Z","toolUseResult":{"stdout":"{\"body\":\"<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\\n<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\\n<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\\n<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\\n<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\\n<!-- erk:metadata-block:plan-header -->\\n<details>\\n<summary>plan-header</summary>\\n\\n```yaml\\n\\nschema_version: '2'\\ncreated_at: '2026-02-22T09:34:49.528424+00:00'\\ncreated_by: schrockn\\nplan_comment_id: null\\nlast_dispatched_run_id: '22279106651'\\nlast_dispatched_node_id: WFR_kwLOPxC3hc8AAAAFL_AwWw\\nlast_dispatched_at: '2026-02-22T14:38:53Z'\\nlast_local_impl_at: null\\nlast_local_impl_event: null\\nlast_local_impl_session: null\\nlast_local_impl_user: null\\nlast_remote_impl_at: null\\nlast_remote_impl_run_id: null\\nlast_remote_impl_session_id: null\\nbranch_name: planned/shorted-planned-prefix-02-22-0934\\nlifecycle_stage: planned\\n\\n```\\n\\n</details>\\n<!-- /erk:metadata-block:plan-header -->\\n\\n\\n---\\n\\n<details>\\n<summary>original-plan</summary>\\n\\n_One-shot: plan content will be populated by one-shot workflow._\\n\\n**Prompt:** shorted planned/ prefix on branches to plnd/\\n\\n\\n</details>\\n---\\n\\n\\nTo checkout this PR in a fresh worktree and environment locally, run:\\n\\n```\\nsource \\\"$(erk pr checkout 7854 --script)\\\" && erk pr sync --dangerous\\n```\\n\\n**Remotely executed:** [Run #22279106651](https://github.com/dagster-io/erk/actions/runs/22279106651)\",\"title\":\"[erk-plan] Shorten planned/ prefix to plnd/ on branches and PR titles\"}","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"354d2127-e633-4d61-ac27-8442e7fddc17","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Nuj8vaYMhdrhydYbxk1CY4","type":"tool_result","content":"No impl-context dir to clean","is_error":false}]},"uuid":"fa7ddeaf-5a3a-45b4-982b-6cdab4bb3deb","timestamp":"2026-02-22T14:39:56.700Z","toolUseResult":{"stdout":"No impl-context dir to clean","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"fa7ddeaf-5a3a-45b4-982b-6cdab4bb3deb","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Wun4U81e4vD7LMaZFUvAxq","type":"message","role":"assistant","content":[{"type":"text","text":"Now I understand the task: shorten the `planned/` prefix on branches to `plnd/`. Let me look at the existing commit on this branch to see what was already done, and find all the places where `planned/` is used as a branch prefix."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1019,"cache_read_input_tokens":28987,"cache_creation":{"ephemeral_5m_input_tokens":1019,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHDe3ZwEjsQf29iDEgu","type":"assistant","uuid":"2b22fddc-f6f2-404c-ae26-18c3df83545e","timestamp":"2026-02-22T14:40:00.616Z"}
{"parentUuid":"2b22fddc-f6f2-404c-ae26-18c3df83545e","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Wun4U81e4vD7LMaZFUvAxq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JCzNfLF4xfXRuT3PLqeq1t","name":"Bash","input":{"command":"git log --oneline master..HEAD 2>&1","description":"See commits on this branch"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1019,"cache_read_input_tokens":28987,"cache_creation":{"ephemeral_5m_input_tokens":1019,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHDe3ZwEjsQf29iDEgu","type":"assistant","uuid":"36a3c86b-9ff1-48c1-9911-eaff44209fe1","timestamp":"2026-02-22T14:40:00.784Z"}
{"parentUuid":"36a3c86b-9ff1-48c1-9911-eaff44209fe1","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Wun4U81e4vD7LMaZFUvAxq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Bcg6mrfuvE8enaoAqL9h6p","name":"Bash","input":{"command":"git diff master..HEAD --stat 2>&1","description":"See what files changed"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1019,"cache_read_input_tokens":28987,"cache_creation":{"ephemeral_5m_input_tokens":1019,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHDe3ZwEjsQf29iDEgu","type":"assistant","uuid":"fc33e3f4-6b5e-48db-8082-7d3f77b4c4b7","timestamp":"2026-02-22T14:40:01.343Z"}
{"parentUuid":"fc33e3f4-6b5e-48db-8082-7d3f77b4c4b7","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Bcg6mrfuvE8enaoAqL9h6p","type":"tool_result","content":"","is_error":false}]},"uuid":"fe24a7fc-e151-49a5-9a80-7929ef02398a","timestamp":"2026-02-22T14:40:01.754Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"fe24a7fc-e151-49a5-9a80-7929ef02398a","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JCzNfLF4xfXRuT3PLqeq1t","type":"tool_result","content":"149f22141 Remove plan staging dirs before implementation\n393240b29 Update plan for plan #7854 (rerun)\n61c42877e One-shot: shorted planned/ prefix on branches to plnd/","is_error":false}]},"uuid":"140bbcd5-a2b9-4727-ad5e-45236b56c8d6","timestamp":"2026-02-22T14:40:01.759Z","toolUseResult":{"stdout":"149f22141 Remove plan staging dirs before implementation\n393240b29 Update plan for plan #7854 (rerun)\n61c42877e One-shot: shorted planned/ prefix on branches to plnd/","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"140bbcd5-a2b9-4727-ad5e-45236b56c8d6","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01GTLRAZsozwpTh4Cag2nhno","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01349SRCpUtonZ5fHKbxJCfb","name":"Bash","input":{"command":"git diff master..HEAD 2>&1","description":"See full diff on this branch"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":37,"cache_creation_input_tokens":390,"cache_read_input_tokens":30006,"cache_creation":{"ephemeral_5m_input_tokens":390,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHE1hZRHjALNQVNNvwQ","type":"assistant","uuid":"39ead8d2-9ec5-4f08-89e9-aac078b72817","timestamp":"2026-02-22T14:40:04.106Z"}
{"parentUuid":"39ead8d2-9ec5-4f08-89e9-aac078b72817","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01349SRCpUtonZ5fHKbxJCfb","type":"tool_result","content":"","is_error":false}]},"uuid":"892e9561-490e-4ad9-87f9-ae8059361f82","timestamp":"2026-02-22T14:40:04.456Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"892e9561-490e-4ad9-87f9-ae8059361f82","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01CHWL5tcuwgSkvGm7Cjw2aZ","type":"message","role":"assistant","content":[{"type":"text","text":"No actual code changes on this branch yet - the commits are just plan setup. Let me explore the codebase to find all references to the `planned/` branch prefix."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":144,"cache_read_input_tokens":30396,"cache_creation":{"ephemeral_5m_input_tokens":144,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHEDCcKwd5E5ZKZxJzp","type":"assistant","uuid":"2df5a3c2-0737-4d68-a551-d036775ac9fb","timestamp":"2026-02-22T14:40:07.182Z"}
{"parentUuid":"2df5a3c2-0737-4d68-a551-d036775ac9fb","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01CHWL5tcuwgSkvGm7Cjw2aZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015XZWWnoehJs24P9Q7Nmon3","name":"Task","input":{"subagent_type":"Explore","prompt":"FIRST check docs/learned/index.md for existing documentation on this topic.\nRead relevant docs before exploring raw files. Then explore codebase as necessary.\n\nFind ALL places in the codebase where \"planned/\" is used as a branch prefix. This includes:\n1. Python source code in src/erk/ that generates or references branch names with \"planned/\" prefix\n2. Tests that reference \"planned/\" prefix\n3. Commands, hooks, skills, or configuration files that reference \"planned/\"\n4. Documentation that references \"planned/\"\n5. Any constants or configuration that define the prefix\n\nBe very thorough - search for:\n- The string literal \"planned/\"\n- Any variable or constant that holds \"planned/\" or \"planned\"\n- Pattern matching or regex that matches planned/ branches\n- Branch naming logic that prepends \"planned/\"\n\nFor each finding, report the exact file path, line number, and the relevant code snippet.","description":"Find all planned/ prefix refs"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":144,"cache_read_input_tokens":30396,"cache_creation":{"ephemeral_5m_input_tokens":144,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHEDCcKwd5E5ZKZxJzp","type":"assistant","uuid":"193a59e6-fdaa-4f58-bfef-8af9c408ea4a","timestamp":"2026-02-22T14:40:13.391Z"}
{"parentUuid":"193a59e6-fdaa-4f58-bfef-8af9c408ea4a","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015XZWWnoehJs24P9Q7Nmon3","type":"tool_result","content":[{"type":"text","text":"Perfect! Now I have comprehensive coverage. Let me compile my final report with all findings.\n\n## Final Report: All \"planned/\" References in Erk Codebase\n\nI've conducted a thorough search of the erk codebase and found ALL places where \"planned/\" is used as a branch prefix. Here are the complete findings:\n\n### 1. **Configuration/Constants**\n\n**File:** `/home/runner/work/erk/erk/src/erk/cli/constants.py` (Line 13)\n```python\nPLANNED_PR_TITLE_PREFIX = \"planned/\"\n```\nThis is the canonical constant defining the PR title prefix for plan-originated PRs.\n\n---\n\n### 2. **Branch Name Generation (Core Logic)**\n\n**File:** `/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/naming.py`\n\n**Function:** `generate_draft_pr_branch_name()` (Lines 792-832)\n```python\ndef generate_draft_pr_branch_name(\n    title: str,\n    timestamp: datetime,\n    *,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate branch name for draft-PR-backed plans.\n\n    Format: planned/{sanitized_title}-{timestamp}\n    Or with objective: planned/O{objective_id}-{sanitized_title}-{timestamp}\n    Example: planned/fix-auth-bug-01-15-1430\n    Example with objective: planned/O456-fix-auth-bug-01-15-1430\n    \"\"\"\n    prefix = \"planned/\"\n    if objective_id is not None:\n        prefix += f\"O{objective_id}-\"\n    sanitized_title = sanitize_worktree_name(title)\n    base_branch_name = (prefix + sanitized_title)[:31].rstrip(\"-\")\n    timestamp_suffix = format_branch_timestamp_suffix(timestamp)\n    return base_branch_name + timestamp_suffix\n```\nThis is the canonical function for generating draft-PR branch names with `planned/` prefix.\n\n**Function:** `extract_objective_number()` (Lines 580-614)\n```python\ndef extract_objective_number(branch_name: str) -> int | None:\n    \"\"\"Extract objective number from branch name.\n\n    Supports branch naming patterns:\n    - Issue-based: ``P{plan}-O{objective}-{slug}-{timestamp}``\n    - Draft-PR (current): ``planned/O{objective}-{slug}-{timestamp}``\n    - Draft-PR (legacy): ``plan/O{objective}-{slug}-{timestamp}``\n    \"\"\"\n    match = re.match(r\"^(?:[Pp]?\\d+-|plan(?:ned)?/)[Oo](\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n```\nThis regex pattern recognizes `planned/` (with both forward slash) as a branch prefix.\n\n**Function:** `extract_plan_review_issue_number()` (Lines 617-642)\n```python\ndef extract_plan_review_issue_number(branch_name: str) -> int | None:\n    \"\"\"Extract issue number from a plan review branch name.\n\n    Plan review branches follow the pattern: planned/review-{issue_number}-{timestamp}\n    Examples: \"planned/review-6214-01-15-1430\"\n    \"\"\"\n    match = re.match(r\"^planned/review-(\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n```\nSpecifically recognizes `planned/review-` pattern for plan review branches.\n\n---\n\n### 3. **PR Title Prefix Addition (Two Independent Paths)**\n\n**File:** `/home/runner/work/erk/erk/src/erk/cli/commands/submit.py` (Lines 279-290)\n```python\ndef _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'planned/' prefix, skipping if already prefixed\n    \"\"\"\n    if title.startswith(PLANNED_PR_TITLE_PREFIX):\n        return title\n    return f\"{PLANNED_PR_TITLE_PREFIX}{title}\"\n```\nUsed in `_create_branch_and_pr()` (Line 767) and `_submit_single_issue()` (Line 901):\n```python\npr_title = _add_planned_prefix(_strip_plan_markers(issue.title))\n```\n\n**File:** `/home/runner/work/erk/erk/src/erk/cli/commands/pr/submit_pipeline.py` (Lines 54-65)\n```python\ndef _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'planned/' prefix, skipping if already prefixed\n    \"\"\"\n    if title.startswith(PLANNED_PR_TITLE_PREFIX):\n        return title\n    return f\"{PLANNED_PR_TITLE_PREFIX}{title}\"\n```\nUsed in `finalize_pr()` (Line 697):\n```python\nif issue_number is not None:\n    pr_title = _add_planned_prefix(pr_title)\n```\n\nBoth implementations are intentionally duplicated (not shared) to avoid coupling between different submission flows.\n\n---\n\n### 4. **Slash Command / Non-Graphite PR Creation**\n\n**File:** `/home/runner/work/erk/erk/.claude/commands/erk/git-pr-push.md` (Lines 89-109)\n```markdown\n### Step 3.5: Add Planned Prefix (if from plan)\n\nIf this worktree was created from a plan (`.impl/` directory exists), prepend `planned/` to the PR title:\n\nWhen generating the commit message in Step 4, if `has_impl_dir` is true, prepend `planned/` to the title:\n\n```bash\nif [ \"$has_impl_dir\" = true ]; then\n    pr_title=\"planned/${pr_title}\"\nfi\n```\n```\nThis is a shell-level check for non-Graphite PR creation workflows.\n\n---\n\n### 5. **Plan Review Branch Creation**\n\n**File:** `/home/runner/work/erk/erk/src/erk/cli/commands/exec/scripts/plan_create_review_branch.py` (Lines 161-163)\n```python\n# Define branch and file names with timestamp (format: planned/review-{issue}-{MM-DD-HHMM})\ntimestamp_suffix = format_branch_timestamp_suffix(time.now())\nbranch_name = f\"planned/review-{issue_number}{timestamp_suffix}\"\n```\nCreates plan review branches with `planned/review-` pattern.\n\n**Documentation at Line 207:**\n```python\ndef plan_create_review_branch(\n    ctx: click.Context,\n    issue_number: int,\n) -> None:\n    \"\"\"Create a plan review branch and push to remote.\n\n    Creates a branch planned/review-{issue}-{timestamp} from origin/master, writes plan\n    to PLAN-REVIEW-{issue}.md, commits, and pushes to origin.\n    \"\"\"\n```\n\n---\n\n### 6. **One-Shot Dispatch (Draft-PR Backend)**\n\n**File:** `/home/runner/work/erk/erk/src/erk/cli/commands/one_shot_dispatch.py` (Lines 168, 193-198)\n\n**Line 168 (comment):**\n```python\n# draft_pr backend: skip skeleton issue, use planned/ branch naming, PR is the plan\n```\n\n**Lines 193-198 (actual code):**\n```python\nif is_draft_pr:\n    # draft_pr: planned/ prefix (no issue number needed)\n    branch_name = generate_draft_pr_branch_name(\n        params.prompt,\n        ctx.time.now(),\n        objective_id=objective_id,\n    )\n```\n\n---\n\n### 7. **Plan Data Provider (Worktree Resolution)**\n\n**File:** `/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py` (Lines 484-506)\n\n**Lines 484-486 (docstring):**\n```python\nFor draft-PR plan branches (planned/{slug}-{timestamp}), falls back to\nreading .impl/plan-ref.json from the worktree to get the plan ID,\nsince the PR number is not encoded in the branch name.\n```\n\n**Lines 500-503 (actual code):**\n```python\n# Fallback for draft-PR branches: read .impl/plan-ref.json\nif issue_number is None and worktree.branch and worktree.branch.startswith(\"planned/\"):\n    impl_dir = worktree.path / \".impl\"\n    plan_ref = read_plan_ref(impl_dir)\n    if plan_ref is not None and plan_ref.plan_id.isdigit():\n```\n\n---\n\n### 8. **Documentation Files**\n\n**File:** `/home/runner/work/erk/erk/docs/learned/planning/plan-title-prefix-system.md` (Lines 11-62)\n- Comprehensive documentation of the `planned/` PR title prefix system\n- Constant definition reference\n- Three code paths applying the prefix\n- Idempotency pattern explanation\n\n**File:** `/home/runner/work/erk/erk/docs/learned/erk/branch-naming.md` (Lines 45-72)\n- Branch format documentation with `planned/` examples\n- `extract_objective_number()` documentation\n- Draft-PR branch patterns\n- Constraints and sanitization rules\n\n**File:** `/home/runner/work/erk/erk/docs/learned/planning/branch-name-inference.md` (Lines 61-71)\n- Draft-PR branches documentation\n- `generate_draft_pr_branch_name()` reference\n- `DraftPRPlanBackend.resolve_plan_id_for_branch()` reference\n- `extract_objective_number()` handling of both patterns\n\n---\n\n### 9. **Tests (Comprehensive Coverage)**\n\n**Test Files Referencing `planned/`:**\n\n1. **`tests/commands/one_shot/test_one_shot_dispatch.py`**\n   - Tests full draft_pr dispatch with `planned/` branch naming\n   - Verifies `result.branch_name.startswith(\"planned/\")`\n\n2. **`tests/commands/land/test_get_objective_for_branch.py`**\n   - Tests branch with `planned/` prefix for objective extraction\n   - Example: `\"planned/O456-fix-auth-01-15-1430\"`\n\n3. **`tests/commands/submit/test_basic_submission.py`**\n   - Verifies PR title becomes `\"planned/Implement feature X\"`\n\n4. **`tests/commands/submit/test_pr_creation.py`**\n   - Comprehensive tests for `_add_planned_prefix()` function\n   - Tests idempotency: `assert twice.count(\"planned/\") == 1`\n   - Edge case testing with empty title: `assert _add_planned_prefix(\"\") == \"planned/\"`\n   - Already-prefixed titles: `assert _add_planned_prefix(\"planned/Already prefixed\") == \"planned/Already prefixed\"`\n\n5. **`tests/tui/data/test_provider.py`**\n   - Draft PR branch resolution tests\n   - Tests with `\"planned/fix-missing-data-02-19-1416\"`\n   - Tests differentiation: `planned/` (forward slash) vs `planned-` (hyphen)\n\n6. **`tests/core/utils/test_naming.py`**\n   - Tests `extract_objective_number()` with draft-PR pattern\n   - Example: `(\"planned/O456-fix-auth-bug-01-15-1430\", 456)`\n\n---\n\n## Summary of References\n\n| Category | File | Type | Line(s) |\n|----------|------|------|---------|\n| **Constant** | `src/erk/cli/constants.py` | Definition | 13 |\n| **Branch Generation** | `packages/erk-shared/src/erk_shared/naming.py` | Function | 792-832 (generate_draft_pr_branch_name) |\n| **Branch Extraction** | `packages/erk-shared/src/erk_shared/naming.py` | Regex Pattern | 611 (extract_objective_number) |\n| **Plan Review** | `packages/erk-shared/src/erk_shared/naming.py` | Regex Pattern | 639 (extract_plan_review_issue_number) |\n| **PR Title Prefix** | `src/erk/cli/commands/submit.py` | Function | 279-290 (_add_planned_prefix) |\n| **PR Title Prefix** | `src/erk/cli/commands/pr/submit_pipeline.py` | Function | 54-65 (_add_planned_prefix) |\n| **Shell Command** | `.claude/commands/erk/git-pr-push.md` | Template | 107 |\n| **Plan Review Branch** | `src/erk/cli/commands/exec/scripts/plan_create_review_branch.py` | Code | 163 |\n| **One-Shot Dispatch** | `src/erk/cli/commands/one_shot_dispatch.py` | Code & Comment | 168, 193-198 |\n| **Worktree Resolution** | `packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py` | Code & Docstring | 484-506 |\n| **Documentation** | `docs/learned/planning/plan-title-prefix-system.md` | Docs | Multiple |\n| **Documentation** | `docs/learned/erk/branch-naming.md` | Docs | Multiple |\n| **Documentation** | `docs/learned/planning/branch-name-inference.md` | Docs | Multiple |\n| **Tests** | Multiple test files | Test Code | See section 9 |\n\nAll references to \"planned/\" are intentional and part of the draft-PR plan backend system for branch naming and PR title prefixing."},{"type":"text","text":"agentId: aa5d024 (for resuming to continue this agent's work if needed)"}]}]},"uuid":"dc5b2ec4-6fb9-460f-9a86-165ab6360b75","timestamp":"2026-02-22T14:41:01.284Z","toolUseResult":{"status":"completed","prompt":"FIRST check docs/learned/index.md for existing documentation on this topic.\nRead relevant docs before exploring raw files. Then explore codebase as necessary.\n\nFind ALL places in the codebase where \"planned/\" is used as a branch prefix. This includes:\n1. Python source code in src/erk/ that generates or references branch names with \"planned/\" prefix\n2. Tests that reference \"planned/\" prefix\n3. Commands, hooks, skills, or configuration files that reference \"planned/\"\n4. Documentation that references \"planned/\"\n5. Any constants or configuration that define the prefix\n\nBe very thorough - search for:\n- The string literal \"planned/\"\n- Any variable or constant that holds \"planned/\" or \"planned\"\n- Pattern matching or regex that matches planned/ branches\n- Branch naming logic that prepends \"planned/\"\n\nFor each finding, report the exact file path, line number, and the relevant code snippet.","agentId":"aa5d024","content":[{"type":"text","text":"Perfect! Now I have comprehensive coverage. Let me compile my final report with all findings.\n\n## Final Report: All \"planned/\" References in Erk Codebase\n\nI've conducted a thorough search of the erk codebase and found ALL places where \"planned/\" is used as a branch prefix. Here are the complete findings:\n\n### 1. **Configuration/Constants**\n\n**File:** `/home/runner/work/erk/erk/src/erk/cli/constants.py` (Line 13)\n```python\nPLANNED_PR_TITLE_PREFIX = \"planned/\"\n```\nThis is the canonical constant defining the PR title prefix for plan-originated PRs.\n\n---\n\n### 2. **Branch Name Generation (Core Logic)**\n\n**File:** `/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/naming.py`\n\n**Function:** `generate_draft_pr_branch_name()` (Lines 792-832)\n```python\ndef generate_draft_pr_branch_name(\n    title: str,\n    timestamp: datetime,\n    *,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate branch name for draft-PR-backed plans.\n\n    Format: planned/{sanitized_title}-{timestamp}\n    Or with objective: planned/O{objective_id}-{sanitized_title}-{timestamp}\n    Example: planned/fix-auth-bug-01-15-1430\n    Example with objective: planned/O456-fix-auth-bug-01-15-1430\n    \"\"\"\n    prefix = \"planned/\"\n    if objective_id is not None:\n        prefix += f\"O{objective_id}-\"\n    sanitized_title = sanitize_worktree_name(title)\n    base_branch_name = (prefix + sanitized_title)[:31].rstrip(\"-\")\n    timestamp_suffix = format_branch_timestamp_suffix(timestamp)\n    return base_branch_name + timestamp_suffix\n```\nThis is the canonical function for generating draft-PR branch names with `planned/` prefix.\n\n**Function:** `extract_objective_number()` (Lines 580-614)\n```python\ndef extract_objective_number(branch_name: str) -> int | None:\n    \"\"\"Extract objective number from branch name.\n\n    Supports branch naming patterns:\n    - Issue-based: ``P{plan}-O{objective}-{slug}-{timestamp}``\n    - Draft-PR (current): ``planned/O{objective}-{slug}-{timestamp}``\n    - Draft-PR (legacy): ``plan/O{objective}-{slug}-{timestamp}``\n    \"\"\"\n    match = re.match(r\"^(?:[Pp]?\\d+-|plan(?:ned)?/)[Oo](\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n```\nThis regex pattern recognizes `planned/` (with both forward slash) as a branch prefix.\n\n**Function:** `extract_plan_review_issue_number()` (Lines 617-642)\n```python\ndef extract_plan_review_issue_number(branch_name: str) -> int | None:\n    \"\"\"Extract issue number from a plan review branch name.\n\n    Plan review branches follow the pattern: planned/review-{issue_number}-{timestamp}\n    Examples: \"planned/review-6214-01-15-1430\"\n    \"\"\"\n    match = re.match(r\"^planned/review-(\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n```\nSpecifically recognizes `planned/review-` pattern for plan review branches.\n\n---\n\n### 3. **PR Title Prefix Addition (Two Independent Paths)**\n\n**File:** `/home/runner/work/erk/erk/src/erk/cli/commands/submit.py` (Lines 279-290)\n```python\ndef _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'planned/' prefix, skipping if already prefixed\n    \"\"\"\n    if title.startswith(PLANNED_PR_TITLE_PREFIX):\n        return title\n    return f\"{PLANNED_PR_TITLE_PREFIX}{title}\"\n```\nUsed in `_create_branch_and_pr()` (Line 767) and `_submit_single_issue()` (Line 901):\n```python\npr_title = _add_planned_prefix(_strip_plan_markers(issue.title))\n```\n\n**File:** `/home/runner/work/erk/erk/src/erk/cli/commands/pr/submit_pipeline.py` (Lines 54-65)\n```python\ndef _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'planned/' prefix, skipping if already prefixed\n    \"\"\"\n    if title.startswith(PLANNED_PR_TITLE_PREFIX):\n        return title\n    return f\"{PLANNED_PR_TITLE_PREFIX}{title}\"\n```\nUsed in `finalize_pr()` (Line 697):\n```python\nif issue_number is not None:\n    pr_title = _add_planned_prefix(pr_title)\n```\n\nBoth implementations are intentionally duplicated (not shared) to avoid coupling between different submission flows.\n\n---\n\n### 4. **Slash Command / Non-Graphite PR Creation**\n\n**File:** `/home/runner/work/erk/erk/.claude/commands/erk/git-pr-push.md` (Lines 89-109)\n```markdown\n### Step 3.5: Add Planned Prefix (if from plan)\n\nIf this worktree was created from a plan (`.impl/` directory exists), prepend `planned/` to the PR title:\n\nWhen generating the commit message in Step 4, if `has_impl_dir` is true, prepend `planned/` to the title:\n\n```bash\nif [ \"$has_impl_dir\" = true ]; then\n    pr_title=\"planned/${pr_title}\"\nfi\n```\n```\nThis is a shell-level check for non-Graphite PR creation workflows.\n\n---\n\n### 5. **Plan Review Branch Creation**\n\n**File:** `/home/runner/work/erk/erk/src/erk/cli/commands/exec/scripts/plan_create_review_branch.py` (Lines 161-163)\n```python\n# Define branch and file names with timestamp (format: planned/review-{issue}-{MM-DD-HHMM})\ntimestamp_suffix = format_branch_timestamp_suffix(time.now())\nbranch_name = f\"planned/review-{issue_number}{timestamp_suffix}\"\n```\nCreates plan review branches with `planned/review-` pattern.\n\n**Documentation at Line 207:**\n```python\ndef plan_create_review_branch(\n    ctx: click.Context,\n    issue_number: int,\n) -> None:\n    \"\"\"Create a plan review branch and push to remote.\n\n    Creates a branch planned/review-{issue}-{timestamp} from origin/master, writes plan\n    to PLAN-REVIEW-{issue}.md, commits, and pushes to origin.\n    \"\"\"\n```\n\n---\n\n### 6. **One-Shot Dispatch (Draft-PR Backend)**\n\n**File:** `/home/runner/work/erk/erk/src/erk/cli/commands/one_shot_dispatch.py` (Lines 168, 193-198)\n\n**Line 168 (comment):**\n```python\n# draft_pr backend: skip skeleton issue, use planned/ branch naming, PR is the plan\n```\n\n**Lines 193-198 (actual code):**\n```python\nif is_draft_pr:\n    # draft_pr: planned/ prefix (no issue number needed)\n    branch_name = generate_draft_pr_branch_name(\n        params.prompt,\n        ctx.time.now(),\n        objective_id=objective_id,\n    )\n```\n\n---\n\n### 7. **Plan Data Provider (Worktree Resolution)**\n\n**File:** `/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py` (Lines 484-506)\n\n**Lines 484-486 (docstring):**\n```python\nFor draft-PR plan branches (planned/{slug}-{timestamp}), falls back to\nreading .impl/plan-ref.json from the worktree to get the plan ID,\nsince the PR number is not encoded in the branch name.\n```\n\n**Lines 500-503 (actual code):**\n```python\n# Fallback for draft-PR branches: read .impl/plan-ref.json\nif issue_number is None and worktree.branch and worktree.branch.startswith(\"planned/\"):\n    impl_dir = worktree.path / \".impl\"\n    plan_ref = read_plan_ref(impl_dir)\n    if plan_ref is not None and plan_ref.plan_id.isdigit():\n```\n\n---\n\n### 8. **Documentation Files**\n\n**File:** `/home/runner/work/erk/erk/docs/learned/planning/plan-title-prefix-system.md` (Lines 11-62)\n- Comprehensive documentation of the `planned/` PR title prefix system\n- Constant definition reference\n- Three code paths applying the prefix\n- Idempotency pattern explanation\n\n**File:** `/home/runner/work/erk/erk/docs/learned/erk/branch-naming.md` (Lines 45-72)\n- Branch format documentation with `planned/` examples\n- `extract_objective_number()` documentation\n- Draft-PR branch patterns\n- Constraints and sanitization rules\n\n**File:** `/home/runner/work/erk/erk/docs/learned/planning/branch-name-inference.md` (Lines 61-71)\n- Draft-PR branches documentation\n- `generate_draft_pr_branch_name()` reference\n- `DraftPRPlanBackend.resolve_plan_id_for_branch()` reference\n- `extract_objective_number()` handling of both patterns\n\n---\n\n### 9. **Tests (Comprehensive Coverage)**\n\n**Test Files Referencing `planned/`:**\n\n1. **`tests/commands/one_shot/test_one_shot_dispatch.py`**\n   - Tests full draft_pr dispatch with `planned/` branch naming\n   - Verifies `result.branch_name.startswith(\"planned/\")`\n\n2. **`tests/commands/land/test_get_objective_for_branch.py`**\n   - Tests branch with `planned/` prefix for objective extraction\n   - Example: `\"planned/O456-fix-auth-01-15-1430\"`\n\n3. **`tests/commands/submit/test_basic_submission.py`**\n   - Verifies PR title becomes `\"planned/Implement feature X\"`\n\n4. **`tests/commands/submit/test_pr_creation.py`**\n   - Comprehensive tests for `_add_planned_prefix()` function\n   - Tests idempotency: `assert twice.count(\"planned/\") == 1`\n   - Edge case testing with empty title: `assert _add_planned_prefix(\"\") == \"planned/\"`\n   - Already-prefixed titles: `assert _add_planned_prefix(\"planned/Already prefixed\") == \"planned/Already prefixed\"`\n\n5. **`tests/tui/data/test_provider.py`**\n   - Draft PR branch resolution tests\n   - Tests with `\"planned/fix-missing-data-02-19-1416\"`\n   - Tests differentiation: `planned/` (forward slash) vs `planned-` (hyphen)\n\n6. **`tests/core/utils/test_naming.py`**\n   - Tests `extract_objective_number()` with draft-PR pattern\n   - Example: `(\"planned/O456-fix-auth-bug-01-15-1430\", 456)`\n\n---\n\n## Summary of References\n\n| Category | File | Type | Line(s) |\n|----------|------|------|---------|\n| **Constant** | `src/erk/cli/constants.py` | Definition | 13 |\n| **Branch Generation** | `packages/erk-shared/src/erk_shared/naming.py` | Function | 792-832 (generate_draft_pr_branch_name) |\n| **Branch Extraction** | `packages/erk-shared/src/erk_shared/naming.py` | Regex Pattern | 611 (extract_objective_number) |\n| **Plan Review** | `packages/erk-shared/src/erk_shared/naming.py` | Regex Pattern | 639 (extract_plan_review_issue_number) |\n| **PR Title Prefix** | `src/erk/cli/commands/submit.py` | Function | 279-290 (_add_planned_prefix) |\n| **PR Title Prefix** | `src/erk/cli/commands/pr/submit_pipeline.py` | Function | 54-65 (_add_planned_prefix) |\n| **Shell Command** | `.claude/commands/erk/git-pr-push.md` | Template | 107 |\n| **Plan Review Branch** | `src/erk/cli/commands/exec/scripts/plan_create_review_branch.py` | Code | 163 |\n| **One-Shot Dispatch** | `src/erk/cli/commands/one_shot_dispatch.py` | Code & Comment | 168, 193-198 |\n| **Worktree Resolution** | `packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py` | Code & Docstring | 484-506 |\n| **Documentation** | `docs/learned/planning/plan-title-prefix-system.md` | Docs | Multiple |\n| **Documentation** | `docs/learned/erk/branch-naming.md` | Docs | Multiple |\n| **Documentation** | `docs/learned/planning/branch-name-inference.md` | Docs | Multiple |\n| **Tests** | Multiple test files | Test Code | See section 9 |\n\nAll references to \"planned/\" are intentional and part of the draft-PR plan backend system for branch naming and PR title prefixing."}],"totalDurationMs":47881,"totalTokens":89444,"totalToolUseCount":16,"usage":{"input_tokens":6,"cache_creation_input_tokens":9489,"cache_read_input_tokens":76472,"cache_creation":{"ephemeral_5m_input_tokens":9489,"ephemeral_1h_input_tokens":0},"output_tokens":3477,"service_tier":"standard","inference_geo":"not_available"}}}
{"parentUuid":"dc5b2ec4-6fb9-460f-9a86-165ab6360b75","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01EuerBGTck1zdykFcsXNrkP","type":"message","role":"assistant","content":[{"type":"text","text":"\n\nExcellent, comprehensive findings. Now let me read the key files and set up the implementation plan."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3944,"cache_read_input_tokens":30540,"cache_creation":{"ephemeral_5m_input_tokens":3944,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHJQCm72paj2v9FmGje","type":"assistant","uuid":"81e6191a-5b73-4df5-aa31-aa04fdb535d6","timestamp":"2026-02-22T14:41:04.125Z"}
{"parentUuid":"81e6191a-5b73-4df5-aa31-aa04fdb535d6","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01EuerBGTck1zdykFcsXNrkP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011z15zZVoP1oH6qpymkhMTz","name":"TodoWrite","input":{"todos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"pending","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"pending","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"pending","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"pending","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"pending","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":3944,"cache_read_input_tokens":30540,"cache_creation":{"ephemeral_5m_input_tokens":3944,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHJQCm72paj2v9FmGje","type":"assistant","uuid":"20532c7c-dae1-45bd-b446-fb3541e10c72","timestamp":"2026-02-22T14:41:09.345Z"}
{"parentUuid":"20532c7c-dae1-45bd-b446-fb3541e10c72","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011z15zZVoP1oH6qpymkhMTz","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"49e6f8fc-c821-4b10-999b-b2eb391c8531","timestamp":"2026-02-22T14:41:09.361Z","toolUseResult":{"oldTodos":[],"newTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"pending","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"pending","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"pending","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"pending","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"pending","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]}}
{"parentUuid":"49e6f8fc-c821-4b10-999b-b2eb391c8531","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01ReYmRtVLUnD6Y77L9ZAHqB","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read all the source files I need to modify in parallel."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":598,"cache_read_input_tokens":34484,"cache_creation":{"ephemeral_5m_input_tokens":598,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHJzgRqfypVVBCAWG2x","type":"assistant","uuid":"fa4d033c-2f14-4ade-ab6f-6dd373309991","timestamp":"2026-02-22T14:41:11.956Z"}
{"parentUuid":"fa4d033c-2f14-4ade-ab6f-6dd373309991","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01ReYmRtVLUnD6Y77L9ZAHqB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TiSFq5G1EZuWT2eAbsYnvd","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/constants.py"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":598,"cache_read_input_tokens":34484,"cache_creation":{"ephemeral_5m_input_tokens":598,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHJzgRqfypVVBCAWG2x","type":"assistant","uuid":"dc845de3-bba0-43a7-beb8-e133ce650699","timestamp":"2026-02-22T14:41:12.585Z"}
{"parentUuid":"dc845de3-bba0-43a7-beb8-e133ce650699","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01ReYmRtVLUnD6Y77L9ZAHqB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014KcEkUZo2CFLQcH1yqGhQV","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/naming.py","offset":575,"limit":270},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":598,"cache_read_input_tokens":34484,"cache_creation":{"ephemeral_5m_input_tokens":598,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHJzgRqfypVVBCAWG2x","type":"assistant","uuid":"b00275ae-2bea-4509-9557-478e685c0aae","timestamp":"2026-02-22T14:41:13.192Z"}
{"parentUuid":"b00275ae-2bea-4509-9557-478e685c0aae","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01ReYmRtVLUnD6Y77L9ZAHqB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Fc2QE7s1NK8Jvw7JxGXKHj","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/commands/submit.py","offset":270,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":598,"cache_read_input_tokens":34484,"cache_creation":{"ephemeral_5m_input_tokens":598,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHJzgRqfypVVBCAWG2x","type":"assistant","uuid":"de51b5f0-c94f-4643-a213-08c5526e1327","timestamp":"2026-02-22T14:41:13.956Z"}
{"parentUuid":"de51b5f0-c94f-4643-a213-08c5526e1327","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01ReYmRtVLUnD6Y77L9ZAHqB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ByG4NpCRfCoDffyjHzqThx","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/commands/pr/submit_pipeline.py","offset":45,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":598,"cache_read_input_tokens":34484,"cache_creation":{"ephemeral_5m_input_tokens":598,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHJzgRqfypVVBCAWG2x","type":"assistant","uuid":"b4e6aef8-985a-44c5-9f09-618aae9491bb","timestamp":"2026-02-22T14:41:14.826Z"}
{"parentUuid":"b4e6aef8-985a-44c5-9f09-618aae9491bb","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01ReYmRtVLUnD6Y77L9ZAHqB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GNsSFcLFQHiNn5dW81N9RQ","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/commands/exec/scripts/plan_create_review_branch.py","offset":155,"limit":20},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":598,"cache_read_input_tokens":34484,"cache_creation":{"ephemeral_5m_input_tokens":598,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHJzgRqfypVVBCAWG2x","type":"assistant","uuid":"0594022f-a44c-40b8-ad01-1c3184c0d29e","timestamp":"2026-02-22T14:41:16.158Z"}
{"parentUuid":"0594022f-a44c-40b8-ad01-1c3184c0d29e","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01ReYmRtVLUnD6Y77L9ZAHqB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01R1aAPtLXxif9koEZ993RY2","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/commands/one_shot_dispatch.py","offset":160,"limit":45},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":598,"cache_read_input_tokens":34484,"cache_creation":{"ephemeral_5m_input_tokens":598,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHJzgRqfypVVBCAWG2x","type":"assistant","uuid":"1faa19fa-892b-490f-b8eb-991e0ed7fe8f","timestamp":"2026-02-22T14:41:16.536Z"}
{"parentUuid":"1faa19fa-892b-490f-b8eb-991e0ed7fe8f","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01ReYmRtVLUnD6Y77L9ZAHqB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YB5bWoX32EHMY1Ufs6UwDy","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py","offset":478,"limit":35},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":598,"cache_read_input_tokens":34484,"cache_creation":{"ephemeral_5m_input_tokens":598,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHJzgRqfypVVBCAWG2x","type":"assistant","uuid":"3f16d23e-dd85-47b3-834f-f5fff23d6420","timestamp":"2026-02-22T14:41:17.126Z"}
{"parentUuid":"3f16d23e-dd85-47b3-834f-f5fff23d6420","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TiSFq5G1EZuWT2eAbsYnvd","type":"tool_result","content":"     1→\"\"\"Shared constants for erk CLI commands.\"\"\"\n     2→\n     3→# GitHub issue label for erk plans\n     4→ERK_PLAN_LABEL = \"erk-plan\"\n     5→\n     6→# Title prefix for erk-plan issues (with trailing space for easy stripping)\n     7→ERK_PLAN_TITLE_PREFIX = \"[erk-plan] \"\n     8→\n     9→# Plan markdown heading prefix (with trailing space for easy stripping)\n    10→PLAN_HEADING_PREFIX = \"Plan: \"\n    11→\n    12→# PR title prefix for plan-originated PRs\n    13→PLANNED_PR_TITLE_PREFIX = \"planned/\"\n    14→\n    15→# GitHub Actions workflow for remote implementation dispatch\n    16→DISPATCH_WORKFLOW_NAME = \"plan-implement.yml\"\n    17→DISPATCH_WORKFLOW_METADATA_NAME = \"plan-implement\"\n    18→\n    19→# GitHub Actions workflow for remote rebase with conflict resolution\n    20→REBASE_WORKFLOW_NAME = \"pr-fix-conflicts.yml\"\n    21→\n    22→# GitHub Actions workflow for remote PR comment addressing\n    23→PR_ADDRESS_WORKFLOW_NAME = \"pr-address.yml\"\n    24→\n    25→# GitHub Actions workflow for one-shot autonomous execution\n    26→ONE_SHOT_WORKFLOW_NAME = \"one-shot.yml\"\n    27→\n    28→# Workflow command name to actual workflow filename mapping\n    29→# This provides a unified interface via `erk launch <name>`\n    30→WORKFLOW_COMMAND_MAP: dict[str, str] = {\n    31→    \"plan-implement\": DISPATCH_WORKFLOW_NAME,  # plan-implement.yml\n    32→    \"pr-fix-conflicts\": REBASE_WORKFLOW_NAME,  # pr-fix-conflicts.yml\n    33→    \"pr-address\": PR_ADDRESS_WORKFLOW_NAME,  # pr-address.yml\n    34→    \"learn\": \"learn.yml\",\n    35→    \"one-shot\": ONE_SHOT_WORKFLOW_NAME,  # one-shot.yml\n    36→}\n    37→\n    38→# Workflow names that trigger the autofix workflow\n    39→# Must match the `name:` field in each .yml file (which should match filename without .yml)\n    40→AUTOFIX_TRIGGER_WORKFLOWS = frozenset(\n    41→    {\n    42→        \"python-format\",\n    43→        \"lint\",\n    44→        \"docs-check\",\n    45→        \"markdown-format\",\n    46→    }\n    47→)\n    48→\n    49→# Documentation extraction tracking label\n    50→DOCS_EXTRACTED_LABEL = \"docs-extracted\"\n    51→DOCS_EXTRACTED_LABEL_DESCRIPTION = \"Session logs analyzed for documentation improvements\"\n    52→DOCS_EXTRACTED_LABEL_COLOR = \"5319E7\"  # Purple\n    53→\n    54→# Learn plan label (for plans that learn from sessions)\n    55→ERK_LEARN_LABEL = \"erk-learn\"\n    56→\n    57→# Plan review PR label and title prefix\n    58→PLAN_REVIEW_LABEL = \"erk-plan-review\"\n    59→ERK_PLAN_REVIEW_TITLE_PREFIX = \"[erk-plan-review] \"\n    60→ERK_LEARN_LABEL_DESCRIPTION = \"Documentation learning plan\"\n    61→ERK_LEARN_LABEL_COLOR = \"D93F0B\"  # Orange-red\n    62→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"0db4ce44-2d45-46eb-8c98-1f1445f95f6e","timestamp":"2026-02-22T14:41:17.164Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/constants.py","content":"\"\"\"Shared constants for erk CLI commands.\"\"\"\n\n# GitHub issue label for erk plans\nERK_PLAN_LABEL = \"erk-plan\"\n\n# Title prefix for erk-plan issues (with trailing space for easy stripping)\nERK_PLAN_TITLE_PREFIX = \"[erk-plan] \"\n\n# Plan markdown heading prefix (with trailing space for easy stripping)\nPLAN_HEADING_PREFIX = \"Plan: \"\n\n# PR title prefix for plan-originated PRs\nPLANNED_PR_TITLE_PREFIX = \"planned/\"\n\n# GitHub Actions workflow for remote implementation dispatch\nDISPATCH_WORKFLOW_NAME = \"plan-implement.yml\"\nDISPATCH_WORKFLOW_METADATA_NAME = \"plan-implement\"\n\n# GitHub Actions workflow for remote rebase with conflict resolution\nREBASE_WORKFLOW_NAME = \"pr-fix-conflicts.yml\"\n\n# GitHub Actions workflow for remote PR comment addressing\nPR_ADDRESS_WORKFLOW_NAME = \"pr-address.yml\"\n\n# GitHub Actions workflow for one-shot autonomous execution\nONE_SHOT_WORKFLOW_NAME = \"one-shot.yml\"\n\n# Workflow command name to actual workflow filename mapping\n# This provides a unified interface via `erk launch <name>`\nWORKFLOW_COMMAND_MAP: dict[str, str] = {\n    \"plan-implement\": DISPATCH_WORKFLOW_NAME,  # plan-implement.yml\n    \"pr-fix-conflicts\": REBASE_WORKFLOW_NAME,  # pr-fix-conflicts.yml\n    \"pr-address\": PR_ADDRESS_WORKFLOW_NAME,  # pr-address.yml\n    \"learn\": \"learn.yml\",\n    \"one-shot\": ONE_SHOT_WORKFLOW_NAME,  # one-shot.yml\n}\n\n# Workflow names that trigger the autofix workflow\n# Must match the `name:` field in each .yml file (which should match filename without .yml)\nAUTOFIX_TRIGGER_WORKFLOWS = frozenset(\n    {\n        \"python-format\",\n        \"lint\",\n        \"docs-check\",\n        \"markdown-format\",\n    }\n)\n\n# Documentation extraction tracking label\nDOCS_EXTRACTED_LABEL = \"docs-extracted\"\nDOCS_EXTRACTED_LABEL_DESCRIPTION = \"Session logs analyzed for documentation improvements\"\nDOCS_EXTRACTED_LABEL_COLOR = \"5319E7\"  # Purple\n\n# Learn plan label (for plans that learn from sessions)\nERK_LEARN_LABEL = \"erk-learn\"\n\n# Plan review PR label and title prefix\nPLAN_REVIEW_LABEL = \"erk-plan-review\"\nERK_PLAN_REVIEW_TITLE_PREFIX = \"[erk-plan-review] \"\nERK_LEARN_LABEL_DESCRIPTION = \"Documentation learning plan\"\nERK_LEARN_LABEL_COLOR = \"D93F0B\"  # Orange-red\n","numLines":62,"startLine":1,"totalLines":62}}}
{"parentUuid":"0db4ce44-2d45-46eb-8c98-1f1445f95f6e","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014KcEkUZo2CFLQcH1yqGhQV","type":"tool_result","content":"   575→    if match:\n   576→        return int(match.group(1))\n   577→    return None\n   578→\n   579→\n   580→def extract_objective_number(branch_name: str) -> int | None:\n   581→    \"\"\"Extract objective number from branch name.\n   582→\n   583→    Supports branch naming patterns:\n   584→\n   585→    - Issue-based: ``P{plan}-O{objective}-{slug}-{timestamp}``\n   586→    - Draft-PR (current): ``planned/O{objective}-{slug}-{timestamp}``\n   587→    - Draft-PR (legacy): ``plan/O{objective}-{slug}-{timestamp}``\n   588→\n   589→    Also supports lowercase \"o\" prefix for case-insensitive matching.\n   590→\n   591→    Args:\n   592→        branch_name: Branch name to parse\n   593→\n   594→    Returns:\n   595→        Objective number if branch contains O{number} after the prefix, else None\n   596→\n   597→    Examples:\n   598→        >>> extract_objective_number(\"P123-O456-fix-auth-bug-01-15-1430\")\n   599→        456\n   600→        >>> extract_objective_number(\"P123-o456-fix-bug\")\n   601→        456\n   602→        >>> extract_objective_number(\"planned/O456-fix-auth-01-15-1430\")\n   603→        456\n   604→        >>> extract_objective_number(\"plan/O456-fix-auth-01-15-1430\")\n   605→        456\n   606→        >>> extract_objective_number(\"P123-fix-auth-bug-01-15-1430\")\n   607→        None\n   608→        >>> extract_objective_number(\"feature-branch\")\n   609→        None\n   610→    \"\"\"\n   611→    match = re.match(r\"^(?:[Pp]?\\d+-|plan(?:ned)?/)[Oo](\\d+)-\", branch_name)\n   612→    if match:\n   613→        return int(match.group(1))\n   614→    return None\n   615→\n   616→\n   617→def extract_plan_review_issue_number(branch_name: str) -> int | None:\n   618→    \"\"\"Extract issue number from a plan review branch name.\n   619→\n   620→    Plan review branches follow the pattern: planned/review-{issue_number}-{timestamp}\n   621→    Examples: \"planned/review-6214-01-15-1430\"\n   622→\n   623→    Args:\n   624→        branch_name: Branch name to parse\n   625→\n   626→    Returns:\n   627→        Issue number if branch matches planned/review-{number}- pattern, else None\n   628→\n   629→    Examples:\n   630→        >>> extract_plan_review_issue_number(\"planned/review-6214-01-15-1430\")\n   631→        6214\n   632→        >>> extract_plan_review_issue_number(\"planned/review-42-01-28-0930\")\n   633→        42\n   634→        >>> extract_plan_review_issue_number(\"P2382-convert-erk-create-raw-ext\")\n   635→        None\n   636→        >>> extract_plan_review_issue_number(\"feature-branch\")\n   637→        None\n   638→    \"\"\"\n   639→    match = re.match(r\"^planned/review-(\\d+)-\", branch_name)\n   640→    if match:\n   641→        return int(match.group(1))\n   642→    return None\n   643→\n   644→\n   645→def ensure_unique_worktree_name_with_date(base_name: str, worktrees_dir: Path, git_ops) -> str:\n   646→    \"\"\"Ensure unique worktree name with datetime suffix and smart versioning.\n   647→\n   648→    Adds datetime suffix in format -YY-MM-DD-HHMM to the base name.\n   649→    If a worktree with that name exists, increments numeric suffix starting at 2 AFTER the datetime.\n   650→    Uses LBYL pattern: checks via git_ops.worktree.path_exists() before operations.\n   651→\n   652→    This function is used for plan-derived worktrees where multiple worktrees may be\n   653→    created from the same plan, requiring datetime-based disambiguation.\n   654→\n   655→    Args:\n   656→        base_name: Sanitized worktree base name (without datetime suffix)\n   657→        worktrees_dir: Directory containing worktrees\n   658→        git_ops: Git operations interface for checking path existence\n   659→\n   660→    Returns:\n   661→        Guaranteed unique worktree name with datetime suffix\n   662→\n   663→    Examples:\n   664→        First time: \"my-feature\" → \"my-feature-25-11-08-1430\"\n   665→        Duplicate: \"my-feature\" → \"my-feature-25-11-08-1430-2\"\n   666→        Next minute: \"my-feature\" → \"my-feature-25-11-08-1431\"\n   667→    \"\"\"\n   668→    date_suffix = datetime.now().strftime(WORKTREE_DATE_SUFFIX_FORMAT)\n   669→    candidate_name = f\"{base_name}-{date_suffix}\"\n   670→\n   671→    # Check if the base candidate exists\n   672→    if not git_ops.worktree.path_exists(worktrees_dir / candidate_name):\n   673→        return candidate_name\n   674→\n   675→    # Name exists, find next available number (append after date)\n   676→    counter = 2\n   677→    while True:\n   678→        versioned_name = f\"{base_name}-{date_suffix}-{counter}\"\n   679→        if not git_ops.worktree.path_exists(worktrees_dir / versioned_name):\n   680→            return versioned_name\n   681→        counter += 1\n   682→\n   683→\n   684→def ensure_simple_worktree_name(base_name: str, worktrees_dir: Path, git_ops) -> str:\n   685→    \"\"\"Ensure simple worktree name without date suffix for manual checkouts.\n   686→\n   687→    Returns the simple name if no worktree exists at that path.\n   688→    If a worktree already exists, returns the simple name (caller validates branch match).\n   689→    Uses LBYL pattern: checks via git_ops.worktree.path_exists() before operations.\n   690→\n   691→    This function is used for manual checkout operations where predictable names are\n   692→    desired (e.g., `erk co feature` → `feature` not `feature-25-11-08`).\n   693→\n   694→    Args:\n   695→        base_name: Sanitized worktree base name\n   696→        worktrees_dir: Directory containing worktrees\n   697→        git_ops: Git operations interface for checking path existence\n   698→\n   699→    Returns:\n   700→        Simple worktree name without date suffix\n   701→\n   702→    Examples:\n   703→        First time: \"my-feature\" → \"my-feature\"\n   704→        Exists: \"my-feature\" → \"my-feature\" (caller handles validation)\n   705→    \"\"\"\n   706→    candidate_name = base_name\n   707→    # Always return simple name - collision handling happens in caller\n   708→    return candidate_name\n   709→\n   710→\n   711→def ensure_unique_worktree_name(base_name: str, worktrees_dir: Path, git_ops) -> str:\n   712→    \"\"\"Deprecated: Use ensure_unique_worktree_name_with_date for plan-derived worktrees.\n   713→\n   714→    This function is kept for backward compatibility but will be removed in the future.\n   715→    New code should use:\n   716→    - ensure_unique_worktree_name_with_date() for plan-derived worktrees\n   717→    - ensure_simple_worktree_name() for manual checkout operations\n   718→    \"\"\"\n   719→    return ensure_unique_worktree_name_with_date(base_name, worktrees_dir, git_ops)\n   720→\n   721→\n   722→def default_branch_for_worktree(name: str) -> str:\n   723→    \"\"\"Default branch name for a worktree with the given `name`.\n   724→\n   725→    Returns the sanitized name directly (without any prefix).\n   726→\n   727→    Args:\n   728→        name: Worktree name\n   729→\n   730→    Returns:\n   731→        Default branch name (sanitized)\n   732→\n   733→    Examples:\n   734→        >>> default_branch_for_worktree(\"my-feature\")\n   735→        \"my-feature\"\n   736→        >>> default_branch_for_worktree(\"Fix Bug!\")\n   737→        \"fix-bug\"\n   738→    \"\"\"\n   739→    return sanitize_branch_component(name)\n   740→\n   741→\n   742→def generate_issue_branch_name(\n   743→    issue_number: int | str,\n   744→    title: str,\n   745→    timestamp: datetime,\n   746→    *,\n   747→    objective_id: int | None,\n   748→) -> str:\n   749→    \"\"\"Generate branch name for issue-based worktree.\n   750→\n   751→    Format: P{issue_number}-{sanitized_title}-{timestamp}\n   752→    Or with objective: P{issue_number}-O{objective_id}-{sanitized_title}-{timestamp}\n   753→    Example: P123-fix-auth-bug-01-15-1430\n   754→    Example with objective: P123-O456-fix-auth-bug-01-15-1430\n   755→\n   756→    The branch name is constructed as:\n   757→    1. P prefix + issue number + hyphen\n   758→    2. If objective_id provided: O prefix + objective_id + hyphen\n   759→    3. Sanitized title (lowercased, special chars replaced)\n   760→    4. Truncated to 31 chars total (before timestamp)\n   761→    5. Timestamp suffix appended (format: -MM-DD-HHMM)\n   762→\n   763→    Args:\n   764→        issue_number: GitHub issue number\n   765→        title: Issue title to sanitize\n   766→        timestamp: Timestamp for the suffix\n   767→        objective_id: Optional objective ID to encode in branch name\n   768→\n   769→    Returns:\n   770→        Branch name in format P{num}-{slug}-{timestamp} or P{num}-O{obj}-{slug}-{timestamp}\n   771→\n   772→    Examples:\n   773→        >>> from datetime import datetime\n   774→        >>> generate_issue_branch_name(\n   775→        ...     123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n   776→        ... )\n   777→        \"P123-fix-auth-bug-01-15-1430\"\n   778→        >>> generate_issue_branch_name(\n   779→        ...     123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456\n   780→        ... )\n   781→        \"P123-O456-fix-auth-bug-01-15-1430\"\n   782→    \"\"\"\n   783→    prefix = f\"P{issue_number}-\"\n   784→    if objective_id is not None:\n   785→        prefix += f\"O{objective_id}-\"\n   786→    sanitized_title = sanitize_worktree_name(title)\n   787→    base_branch_name = (prefix + sanitized_title)[:31].rstrip(\"-\")\n   788→    timestamp_suffix = format_branch_timestamp_suffix(timestamp)\n   789→    return base_branch_name + timestamp_suffix\n   790→\n   791→\n   792→def generate_draft_pr_branch_name(\n   793→    title: str,\n   794→    timestamp: datetime,\n   795→    *,\n   796→    objective_id: int | None,\n   797→) -> str:\n   798→    \"\"\"Generate branch name for draft-PR-backed plans.\n   799→\n   800→    Format: planned/{sanitized_title}-{timestamp}\n   801→    Or with objective: planned/O{objective_id}-{sanitized_title}-{timestamp}\n   802→    Example: planned/fix-auth-bug-01-15-1430\n   803→    Example with objective: planned/O456-fix-auth-bug-01-15-1430\n   804→\n   805→    No P{issue} prefix since the PR number isn't known until after creation.\n   806→\n   807→    Args:\n   808→        title: Plan title to sanitize\n   809→        timestamp: Timestamp for the suffix\n   810→        objective_id: Optional objective ID to encode in branch name\n   811→\n   812→    Returns:\n   813→        Branch name in format planned/{slug}-{timestamp}\n   814→\n   815→    Examples:\n   816→        >>> from datetime import datetime\n   817→        >>> generate_draft_pr_branch_name(\n   818→        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n   819→        ... )\n   820→        \"planned/fix-auth-bug-01-15-1430\"\n   821→        >>> generate_draft_pr_branch_name(\n   822→        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456\n   823→        ... )\n   824→        \"planned/O456-fix-auth-bug-01-15-1430\"\n   825→    \"\"\"\n   826→    prefix = \"planned/\"\n   827→    if objective_id is not None:\n   828→        prefix += f\"O{objective_id}-\"\n   829→    sanitized_title = sanitize_worktree_name(title)\n   830→    base_branch_name = (prefix + sanitized_title)[:31].rstrip(\"-\")\n   831→    timestamp_suffix = format_branch_timestamp_suffix(timestamp)\n   832→    return base_branch_name + timestamp_suffix\n   833→\n   834→\n   835→def derive_branch_name_from_title(title: str) -> str:\n   836→    \"\"\"Derive branch name from issue/plan title.\n   837→\n   838→    This function matches the logic used by the erk-impl workflow\n   839→    to ensure CLI and workflow produce identical branch names.\n   840→\n   841→    Transforms:\n   842→    - Lowercase\n   843→    - Replace non-alphanumeric (except hyphen) with hyphen\n   844→    - Collapse consecutive hyphens\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"35df1c32-6010-4d64-8dc6-895ecd692d51","timestamp":"2026-02-22T14:41:17.164Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/naming.py","content":"    if match:\n        return int(match.group(1))\n    return None\n\n\ndef extract_objective_number(branch_name: str) -> int | None:\n    \"\"\"Extract objective number from branch name.\n\n    Supports branch naming patterns:\n\n    - Issue-based: ``P{plan}-O{objective}-{slug}-{timestamp}``\n    - Draft-PR (current): ``planned/O{objective}-{slug}-{timestamp}``\n    - Draft-PR (legacy): ``plan/O{objective}-{slug}-{timestamp}``\n\n    Also supports lowercase \"o\" prefix for case-insensitive matching.\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Objective number if branch contains O{number} after the prefix, else None\n\n    Examples:\n        >>> extract_objective_number(\"P123-O456-fix-auth-bug-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-o456-fix-bug\")\n        456\n        >>> extract_objective_number(\"planned/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"plan/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-fix-auth-bug-01-15-1430\")\n        None\n        >>> extract_objective_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^(?:[Pp]?\\d+-|plan(?:ned)?/)[Oo](\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n\n\ndef extract_plan_review_issue_number(branch_name: str) -> int | None:\n    \"\"\"Extract issue number from a plan review branch name.\n\n    Plan review branches follow the pattern: planned/review-{issue_number}-{timestamp}\n    Examples: \"planned/review-6214-01-15-1430\"\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Issue number if branch matches planned/review-{number}- pattern, else None\n\n    Examples:\n        >>> extract_plan_review_issue_number(\"planned/review-6214-01-15-1430\")\n        6214\n        >>> extract_plan_review_issue_number(\"planned/review-42-01-28-0930\")\n        42\n        >>> extract_plan_review_issue_number(\"P2382-convert-erk-create-raw-ext\")\n        None\n        >>> extract_plan_review_issue_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^planned/review-(\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n\n\ndef ensure_unique_worktree_name_with_date(base_name: str, worktrees_dir: Path, git_ops) -> str:\n    \"\"\"Ensure unique worktree name with datetime suffix and smart versioning.\n\n    Adds datetime suffix in format -YY-MM-DD-HHMM to the base name.\n    If a worktree with that name exists, increments numeric suffix starting at 2 AFTER the datetime.\n    Uses LBYL pattern: checks via git_ops.worktree.path_exists() before operations.\n\n    This function is used for plan-derived worktrees where multiple worktrees may be\n    created from the same plan, requiring datetime-based disambiguation.\n\n    Args:\n        base_name: Sanitized worktree base name (without datetime suffix)\n        worktrees_dir: Directory containing worktrees\n        git_ops: Git operations interface for checking path existence\n\n    Returns:\n        Guaranteed unique worktree name with datetime suffix\n\n    Examples:\n        First time: \"my-feature\" → \"my-feature-25-11-08-1430\"\n        Duplicate: \"my-feature\" → \"my-feature-25-11-08-1430-2\"\n        Next minute: \"my-feature\" → \"my-feature-25-11-08-1431\"\n    \"\"\"\n    date_suffix = datetime.now().strftime(WORKTREE_DATE_SUFFIX_FORMAT)\n    candidate_name = f\"{base_name}-{date_suffix}\"\n\n    # Check if the base candidate exists\n    if not git_ops.worktree.path_exists(worktrees_dir / candidate_name):\n        return candidate_name\n\n    # Name exists, find next available number (append after date)\n    counter = 2\n    while True:\n        versioned_name = f\"{base_name}-{date_suffix}-{counter}\"\n        if not git_ops.worktree.path_exists(worktrees_dir / versioned_name):\n            return versioned_name\n        counter += 1\n\n\ndef ensure_simple_worktree_name(base_name: str, worktrees_dir: Path, git_ops) -> str:\n    \"\"\"Ensure simple worktree name without date suffix for manual checkouts.\n\n    Returns the simple name if no worktree exists at that path.\n    If a worktree already exists, returns the simple name (caller validates branch match).\n    Uses LBYL pattern: checks via git_ops.worktree.path_exists() before operations.\n\n    This function is used for manual checkout operations where predictable names are\n    desired (e.g., `erk co feature` → `feature` not `feature-25-11-08`).\n\n    Args:\n        base_name: Sanitized worktree base name\n        worktrees_dir: Directory containing worktrees\n        git_ops: Git operations interface for checking path existence\n\n    Returns:\n        Simple worktree name without date suffix\n\n    Examples:\n        First time: \"my-feature\" → \"my-feature\"\n        Exists: \"my-feature\" → \"my-feature\" (caller handles validation)\n    \"\"\"\n    candidate_name = base_name\n    # Always return simple name - collision handling happens in caller\n    return candidate_name\n\n\ndef ensure_unique_worktree_name(base_name: str, worktrees_dir: Path, git_ops) -> str:\n    \"\"\"Deprecated: Use ensure_unique_worktree_name_with_date for plan-derived worktrees.\n\n    This function is kept for backward compatibility but will be removed in the future.\n    New code should use:\n    - ensure_unique_worktree_name_with_date() for plan-derived worktrees\n    - ensure_simple_worktree_name() for manual checkout operations\n    \"\"\"\n    return ensure_unique_worktree_name_with_date(base_name, worktrees_dir, git_ops)\n\n\ndef default_branch_for_worktree(name: str) -> str:\n    \"\"\"Default branch name for a worktree with the given `name`.\n\n    Returns the sanitized name directly (without any prefix).\n\n    Args:\n        name: Worktree name\n\n    Returns:\n        Default branch name (sanitized)\n\n    Examples:\n        >>> default_branch_for_worktree(\"my-feature\")\n        \"my-feature\"\n        >>> default_branch_for_worktree(\"Fix Bug!\")\n        \"fix-bug\"\n    \"\"\"\n    return sanitize_branch_component(name)\n\n\ndef generate_issue_branch_name(\n    issue_number: int | str,\n    title: str,\n    timestamp: datetime,\n    *,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate branch name for issue-based worktree.\n\n    Format: P{issue_number}-{sanitized_title}-{timestamp}\n    Or with objective: P{issue_number}-O{objective_id}-{sanitized_title}-{timestamp}\n    Example: P123-fix-auth-bug-01-15-1430\n    Example with objective: P123-O456-fix-auth-bug-01-15-1430\n\n    The branch name is constructed as:\n    1. P prefix + issue number + hyphen\n    2. If objective_id provided: O prefix + objective_id + hyphen\n    3. Sanitized title (lowercased, special chars replaced)\n    4. Truncated to 31 chars total (before timestamp)\n    5. Timestamp suffix appended (format: -MM-DD-HHMM)\n\n    Args:\n        issue_number: GitHub issue number\n        title: Issue title to sanitize\n        timestamp: Timestamp for the suffix\n        objective_id: Optional objective ID to encode in branch name\n\n    Returns:\n        Branch name in format P{num}-{slug}-{timestamp} or P{num}-O{obj}-{slug}-{timestamp}\n\n    Examples:\n        >>> from datetime import datetime\n        >>> generate_issue_branch_name(\n        ...     123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n        ... )\n        \"P123-fix-auth-bug-01-15-1430\"\n        >>> generate_issue_branch_name(\n        ...     123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456\n        ... )\n        \"P123-O456-fix-auth-bug-01-15-1430\"\n    \"\"\"\n    prefix = f\"P{issue_number}-\"\n    if objective_id is not None:\n        prefix += f\"O{objective_id}-\"\n    sanitized_title = sanitize_worktree_name(title)\n    base_branch_name = (prefix + sanitized_title)[:31].rstrip(\"-\")\n    timestamp_suffix = format_branch_timestamp_suffix(timestamp)\n    return base_branch_name + timestamp_suffix\n\n\ndef generate_draft_pr_branch_name(\n    title: str,\n    timestamp: datetime,\n    *,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate branch name for draft-PR-backed plans.\n\n    Format: planned/{sanitized_title}-{timestamp}\n    Or with objective: planned/O{objective_id}-{sanitized_title}-{timestamp}\n    Example: planned/fix-auth-bug-01-15-1430\n    Example with objective: planned/O456-fix-auth-bug-01-15-1430\n\n    No P{issue} prefix since the PR number isn't known until after creation.\n\n    Args:\n        title: Plan title to sanitize\n        timestamp: Timestamp for the suffix\n        objective_id: Optional objective ID to encode in branch name\n\n    Returns:\n        Branch name in format planned/{slug}-{timestamp}\n\n    Examples:\n        >>> from datetime import datetime\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n        ... )\n        \"planned/fix-auth-bug-01-15-1430\"\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456\n        ... )\n        \"planned/O456-fix-auth-bug-01-15-1430\"\n    \"\"\"\n    prefix = \"planned/\"\n    if objective_id is not None:\n        prefix += f\"O{objective_id}-\"\n    sanitized_title = sanitize_worktree_name(title)\n    base_branch_name = (prefix + sanitized_title)[:31].rstrip(\"-\")\n    timestamp_suffix = format_branch_timestamp_suffix(timestamp)\n    return base_branch_name + timestamp_suffix\n\n\ndef derive_branch_name_from_title(title: str) -> str:\n    \"\"\"Derive branch name from issue/plan title.\n\n    This function matches the logic used by the erk-impl workflow\n    to ensure CLI and workflow produce identical branch names.\n\n    Transforms:\n    - Lowercase\n    - Replace non-alphanumeric (except hyphen) with hyphen\n    - Collapse consecutive hyphens","numLines":270,"startLine":575,"totalLines":879}}}
{"parentUuid":"35df1c32-6010-4d64-8dc6-895ecd692d51","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Fc2QE7s1NK8Jvw7JxGXKHj","type":"tool_result","content":"   270→    # Strip \"[erk-plan] \" prefix if present\n   271→    if result.startswith(ERK_PLAN_TITLE_PREFIX):\n   272→        result = result[len(ERK_PLAN_TITLE_PREFIX) :]\n   273→    # Strip \"Plan: \" prefix if present\n   274→    if result.startswith(PLAN_HEADING_PREFIX):\n   275→        result = result[len(PLAN_HEADING_PREFIX) :]\n   276→    return result\n   277→\n   278→\n   279→def _add_planned_prefix(title: str) -> str:\n   280→    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).\n   281→\n   282→    Args:\n   283→        title: The PR title to prefix\n   284→\n   285→    Returns:\n   286→        The title with 'planned/' prefix, skipping if already prefixed\n   287→    \"\"\"\n   288→    if title.startswith(PLANNED_PR_TITLE_PREFIX):\n   289→        return title\n   290→    return f\"{PLANNED_PR_TITLE_PREFIX}{title}\"\n   291→\n   292→\n   293→def _build_pr_url(issue_url: str, pr_number: int) -> str:\n   294→    \"\"\"Construct GitHub PR URL from issue URL and PR number.\n   295→\n   296→    Args:\n   297→        issue_url: GitHub issue URL (e.g., https://github.com/owner/repo/issues/123)\n   298→        pr_number: PR number\n   299→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"1bc29a28-4b5b-456b-b62a-53267d95d634","timestamp":"2026-02-22T14:41:17.164Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/commands/submit.py","content":"    # Strip \"[erk-plan] \" prefix if present\n    if result.startswith(ERK_PLAN_TITLE_PREFIX):\n        result = result[len(ERK_PLAN_TITLE_PREFIX) :]\n    # Strip \"Plan: \" prefix if present\n    if result.startswith(PLAN_HEADING_PREFIX):\n        result = result[len(PLAN_HEADING_PREFIX) :]\n    return result\n\n\ndef _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'planned/' prefix, skipping if already prefixed\n    \"\"\"\n    if title.startswith(PLANNED_PR_TITLE_PREFIX):\n        return title\n    return f\"{PLANNED_PR_TITLE_PREFIX}{title}\"\n\n\ndef _build_pr_url(issue_url: str, pr_number: int) -> str:\n    \"\"\"Construct GitHub PR URL from issue URL and PR number.\n\n    Args:\n        issue_url: GitHub issue URL (e.g., https://github.com/owner/repo/issues/123)\n        pr_number: PR number\n","numLines":30,"startLine":270,"totalLines":1339}}}
{"parentUuid":"1bc29a28-4b5b-456b-b62a-53267d95d634","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ByG4NpCRfCoDffyjHzqThx","type":"tool_result","content":"    45→)\n    46→from erk_shared.plan_store.draft_pr_lifecycle import extract_metadata_prefix\n    47→from erk_shared.scratch.scratch import write_scratch_file\n    48→\n    49→# ---------------------------------------------------------------------------\n    50→# Utilities\n    51→# ---------------------------------------------------------------------------\n    52→\n    53→\n    54→def _add_planned_prefix(title: str) -> str:\n    55→    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).\n    56→\n    57→    Args:\n    58→        title: The PR title to prefix\n    59→\n    60→    Returns:\n    61→        The title with 'planned/' prefix, skipping if already prefixed\n    62→    \"\"\"\n    63→    if title.startswith(PLANNED_PR_TITLE_PREFIX):\n    64→        return title\n    65→    return f\"{PLANNED_PR_TITLE_PREFIX}{title}\"\n    66→\n    67→\n    68→# ---------------------------------------------------------------------------\n    69→# Data Types\n    70→# ---------------------------------------------------------------------------\n    71→\n    72→\n    73→@dataclass(frozen=True)\n    74→class SubmitState:\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"afaac0e2-7974-4953-be03-ff0efa4e9594","timestamp":"2026-02-22T14:41:17.164Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/commands/pr/submit_pipeline.py","content":")\nfrom erk_shared.plan_store.draft_pr_lifecycle import extract_metadata_prefix\nfrom erk_shared.scratch.scratch import write_scratch_file\n\n# ---------------------------------------------------------------------------\n# Utilities\n# ---------------------------------------------------------------------------\n\n\ndef _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'planned/' prefix, skipping if already prefixed\n    \"\"\"\n    if title.startswith(PLANNED_PR_TITLE_PREFIX):\n        return title\n    return f\"{PLANNED_PR_TITLE_PREFIX}{title}\"\n\n\n# ---------------------------------------------------------------------------\n# Data Types\n# ---------------------------------------------------------------------------\n\n\n@dataclass(frozen=True)\nclass SubmitState:","numLines":30,"startLine":45,"totalLines":870}}}
{"parentUuid":"afaac0e2-7974-4953-be03-ff0efa4e9594","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GNsSFcLFQHiNn5dW81N9RQ","type":"tool_result","content":"   155→    Raises:\n   156→        PlanReviewBranchException: If plan content cannot be fetched or validated\n   157→    \"\"\"\n   158→    # Fetch plan content (raises PlanReviewBranchException on failure)\n   159→    plan_title, plan_content = _fetch_plan_content(github_issues, repo_root, issue_number)\n   160→\n   161→    # Define branch and file names with timestamp (format: planned/review-{issue}-{MM-DD-HHMM})\n   162→    timestamp_suffix = format_branch_timestamp_suffix(time.now())\n   163→    branch_name = f\"planned/review-{issue_number}{timestamp_suffix}\"\n   164→    file_name = f\"PLAN-REVIEW-{issue_number}.md\"\n   165→\n   166→    # Fetch origin/master, create branch, commit, and push\n   167→    # These operations let exceptions escape as they represent invariant violations\n   168→    # if they fail (network/disk/auth issues are exceptional, not expected states)\n   169→    git.remote.fetch_branch(repo_root, \"origin\", \"master\")\n   170→    create_result = git.branch.create_branch(repo_root, branch_name, \"origin/master\", force=False)\n   171→    if isinstance(create_result, BranchAlreadyExists):\n   172→        raise UserFacingCliError(create_result.message)\n   173→    git.branch.checkout_branch(repo_root, branch_name)\n   174→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c5cd0c4d-21b3-452a-8e70-c3d29949b9d1","timestamp":"2026-02-22T14:41:17.164Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/commands/exec/scripts/plan_create_review_branch.py","content":"    Raises:\n        PlanReviewBranchException: If plan content cannot be fetched or validated\n    \"\"\"\n    # Fetch plan content (raises PlanReviewBranchException on failure)\n    plan_title, plan_content = _fetch_plan_content(github_issues, repo_root, issue_number)\n\n    # Define branch and file names with timestamp (format: planned/review-{issue}-{MM-DD-HHMM})\n    timestamp_suffix = format_branch_timestamp_suffix(time.now())\n    branch_name = f\"planned/review-{issue_number}{timestamp_suffix}\"\n    file_name = f\"PLAN-REVIEW-{issue_number}.md\"\n\n    # Fetch origin/master, create branch, commit, and push\n    # These operations let exceptions escape as they represent invariant violations\n    # if they fail (network/disk/auth issues are exceptional, not expected states)\n    git.remote.fetch_branch(repo_root, \"origin\", \"master\")\n    create_result = git.branch.create_branch(repo_root, branch_name, \"origin/master\", force=False)\n    if isinstance(create_result, BranchAlreadyExists):\n        raise UserFacingCliError(create_result.message)\n    git.branch.checkout_branch(repo_root, branch_name)\n","numLines":20,"startLine":155,"totalLines":232}}}
{"parentUuid":"c5cd0c4d-21b3-452a-8e70-c3d29949b9d1","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01R1aAPtLXxif9koEZ993RY2","type":"tool_result","content":"   160→\n   161→    objective_issue_str = params.extra_workflow_inputs.get(\"objective_issue\")\n   162→    objective_id = int(objective_issue_str) if objective_issue_str else None\n   163→\n   164→    is_draft_pr = ctx.plan_backend.get_provider_name() == \"github-draft-pr\"\n   165→\n   166→    # --- Backend-conditional entity creation ---\n   167→    # github backend: create skeleton issue first for P<N>- branch naming\n   168→    # draft_pr backend: skip skeleton issue, use planned/ branch naming, PR is the plan\n   169→    plan_issue_number: int | None = None\n   170→    if not is_draft_pr:\n   171→        skeleton_plan_content = (\n   172→            f\"_One-shot: plan content will be populated by one-shot workflow._\\n\\n\"\n   173→            f\"**Prompt:** {params.prompt}\"\n   174→        )\n   175→        skeleton_result = create_plan_issue(\n   176→            github_issues=ctx.github.issues,\n   177→            repo_root=repo.root,\n   178→            plan_content=skeleton_plan_content,\n   179→            title=f\"One-shot: {params.prompt[:max_title_len]}{suffix}\",\n   180→            extra_labels=None,\n   181→            title_tag=None,\n   182→            source_repo=None,\n   183→            objective_id=objective_id,\n   184→            created_from_session=None,\n   185→            created_from_workflow_run_url=None,\n   186→            learned_from_issue=None,\n   187→            lifecycle_stage=\"prompted\",\n   188→        )\n   189→        plan_issue_number = skeleton_result.issue_number\n   190→\n   191→    # Generate branch name\n   192→    if is_draft_pr:\n   193→        # draft_pr: planned/ prefix (no issue number needed)\n   194→        branch_name = generate_draft_pr_branch_name(\n   195→            params.prompt,\n   196→            ctx.time.now(),\n   197→            objective_id=objective_id,\n   198→        )\n   199→    else:\n   200→        # github: P<N>- prefix using skeleton issue number\n   201→        branch_name = generate_branch_name(\n   202→            params.prompt,\n   203→            time=ctx.time,\n   204→            plan_issue_number=plan_issue_number,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3fd23976-baae-418e-975c-40cb7f9ce96e","timestamp":"2026-02-22T14:41:17.164Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/commands/one_shot_dispatch.py","content":"\n    objective_issue_str = params.extra_workflow_inputs.get(\"objective_issue\")\n    objective_id = int(objective_issue_str) if objective_issue_str else None\n\n    is_draft_pr = ctx.plan_backend.get_provider_name() == \"github-draft-pr\"\n\n    # --- Backend-conditional entity creation ---\n    # github backend: create skeleton issue first for P<N>- branch naming\n    # draft_pr backend: skip skeleton issue, use planned/ branch naming, PR is the plan\n    plan_issue_number: int | None = None\n    if not is_draft_pr:\n        skeleton_plan_content = (\n            f\"_One-shot: plan content will be populated by one-shot workflow._\\n\\n\"\n            f\"**Prompt:** {params.prompt}\"\n        )\n        skeleton_result = create_plan_issue(\n            github_issues=ctx.github.issues,\n            repo_root=repo.root,\n            plan_content=skeleton_plan_content,\n            title=f\"One-shot: {params.prompt[:max_title_len]}{suffix}\",\n            extra_labels=None,\n            title_tag=None,\n            source_repo=None,\n            objective_id=objective_id,\n            created_from_session=None,\n            created_from_workflow_run_url=None,\n            learned_from_issue=None,\n            lifecycle_stage=\"prompted\",\n        )\n        plan_issue_number = skeleton_result.issue_number\n\n    # Generate branch name\n    if is_draft_pr:\n        # draft_pr: planned/ prefix (no issue number needed)\n        branch_name = generate_draft_pr_branch_name(\n            params.prompt,\n            ctx.time.now(),\n            objective_id=objective_id,\n        )\n    else:\n        # github: P<N>- prefix using skeleton issue number\n        branch_name = generate_branch_name(\n            params.prompt,\n            time=ctx.time,\n            plan_issue_number=plan_issue_number,","numLines":45,"startLine":160,"totalLines":432}}}
{"parentUuid":"3fd23976-baae-418e-975c-40cb7f9ce96e","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YB5bWoX32EHMY1Ufs6UwDy","type":"tool_result","content":"   478→    def _build_worktree_mapping(self) -> dict[int, tuple[str, str | None]]:\n   479→        \"\"\"Build mapping of plan ID to (worktree name, branch).\n   480→\n   481→        Uses PXXXX prefix matching on branch names to associate worktrees\n   482→        with issues. Branch names follow pattern: P{plan_id}-{slug}-{timestamp}\n   483→\n   484→        For draft-PR plan branches (planned/{slug}-{timestamp}), falls back to\n   485→        reading .impl/plan-ref.json from the worktree to get the plan ID,\n   486→        since the PR number is not encoded in the branch name.\n   487→\n   488→        Returns:\n   489→            Mapping of plan ID to tuple of (worktree_name, branch_name)\n   490→        \"\"\"\n   491→        _ensure_erk_metadata_dir_from_context(self._ctx.repo)\n   492→        worktree_by_plan_id: dict[int, tuple[str, str | None]] = {}\n   493→        worktrees = self._ctx.git.worktree.list_worktrees(self._location.root)\n   494→        for worktree in worktrees:\n   495→            issue_number = (\n   496→                extract_leading_issue_number(worktree.branch) if worktree.branch else None\n   497→            )\n   498→\n   499→            # Fallback for draft-PR branches: read .impl/plan-ref.json\n   500→            if issue_number is None and worktree.branch and worktree.branch.startswith(\"planned/\"):\n   501→                impl_dir = worktree.path / \".impl\"\n   502→                plan_ref = read_plan_ref(impl_dir)\n   503→                if plan_ref is not None and plan_ref.plan_id.isdigit():\n   504→                    issue_number = int(plan_ref.plan_id)\n   505→\n   506→            if issue_number is not None:\n   507→                if issue_number not in worktree_by_plan_id:\n   508→                    worktree_by_plan_id[issue_number] = (\n   509→                        worktree.path.name,\n   510→                        worktree.branch,\n   511→                    )\n   512→        return worktree_by_plan_id\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a99dfc2d-26b3-4b49-ab72-fcb6ac63db36","timestamp":"2026-02-22T14:41:17.164Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py","content":"    def _build_worktree_mapping(self) -> dict[int, tuple[str, str | None]]:\n        \"\"\"Build mapping of plan ID to (worktree name, branch).\n\n        Uses PXXXX prefix matching on branch names to associate worktrees\n        with issues. Branch names follow pattern: P{plan_id}-{slug}-{timestamp}\n\n        For draft-PR plan branches (planned/{slug}-{timestamp}), falls back to\n        reading .impl/plan-ref.json from the worktree to get the plan ID,\n        since the PR number is not encoded in the branch name.\n\n        Returns:\n            Mapping of plan ID to tuple of (worktree_name, branch_name)\n        \"\"\"\n        _ensure_erk_metadata_dir_from_context(self._ctx.repo)\n        worktree_by_plan_id: dict[int, tuple[str, str | None]] = {}\n        worktrees = self._ctx.git.worktree.list_worktrees(self._location.root)\n        for worktree in worktrees:\n            issue_number = (\n                extract_leading_issue_number(worktree.branch) if worktree.branch else None\n            )\n\n            # Fallback for draft-PR branches: read .impl/plan-ref.json\n            if issue_number is None and worktree.branch and worktree.branch.startswith(\"planned/\"):\n                impl_dir = worktree.path / \".impl\"\n                plan_ref = read_plan_ref(impl_dir)\n                if plan_ref is not None and plan_ref.plan_id.isdigit():\n                    issue_number = int(plan_ref.plan_id)\n\n            if issue_number is not None:\n                if issue_number not in worktree_by_plan_id:\n                    worktree_by_plan_id[issue_number] = (\n                        worktree.path.name,\n                        worktree.branch,\n                    )\n        return worktree_by_plan_id","numLines":35,"startLine":478,"totalLines":895}}}
{"parentUuid":"a99dfc2d-26b3-4b49-ab72-fcb6ac63db36","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01KNrTb266Svnytn9BQVbj7w","type":"message","role":"assistant","content":[{"type":"text","text":"Good, I have all the source code. Now let me also read the git-pr-push command and check what the `planned/` length limitation is - the branch name gets truncated to 31 chars. Let me think about this carefully.\n\nThe task is to change `planned/` (8 chars) to `plnd/` (5 chars) as a branch prefix. This saves 3 characters in branch names. I also need to update the PR title prefix. Let me also read the command file."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":8673,"cache_read_input_tokens":35082,"cache_creation":{"ephemeral_5m_input_tokens":8673,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHKaAaCFasVXjHaDvnu","type":"assistant","uuid":"befe1c59-9ae5-4aca-8cb7-b1c3af581632","timestamp":"2026-02-22T14:41:21.943Z"}
{"parentUuid":"befe1c59-9ae5-4aca-8cb7-b1c3af581632","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01KNrTb266Svnytn9BQVbj7w","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SLpXhU75H4gYHqBrVGXSsn","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/.claude/commands/erk/git-pr-push.md","offset":85,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":8673,"cache_read_input_tokens":35082,"cache_creation":{"ephemeral_5m_input_tokens":8673,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHKaAaCFasVXjHaDvnu","type":"assistant","uuid":"4073740b-1f55-4945-8d2a-3ee3afa769c7","timestamp":"2026-02-22T14:41:23.145Z"}
{"parentUuid":"4073740b-1f55-4945-8d2a-3ee3afa769c7","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SLpXhU75H4gYHqBrVGXSsn","type":"tool_result","content":"    85→```\n    86→\n    87→Load the `erk-diff-analysis` skill for commit message generation guidance.\n    88→\n    89→### Step 3.5: Add Planned Prefix (if from plan)\n    90→\n    91→If this worktree was created from a plan (`.impl/` directory exists), prepend `planned/` to the PR title:\n    92→\n    93→```bash\n    94→if [ -d \".impl\" ]; then\n    95→    # Extract the title before creating the commit\n    96→    # (we'll apply the prefix when creating the commit message below)\n    97→    has_impl_dir=true\n    98→else\n    99→    has_impl_dir=false\n   100→fi\n   101→```\n   102→\n   103→When generating the commit message in Step 4, if `has_impl_dir` is true, prepend `planned/` to the title:\n   104→\n   105→```bash\n   106→if [ \"$has_impl_dir\" = true ]; then\n   107→    pr_title=\"planned/${pr_title}\"\n   108→fi\n   109→```\n   110→\n   111→### Step 4: Create Commit\n   112→\n   113→Create the commit with your AI-generated message using heredoc:\n   114→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"bea1a2ed-d98b-477d-a784-0acc50c5a321","timestamp":"2026-02-22T14:41:23.286Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/.claude/commands/erk/git-pr-push.md","content":"```\n\nLoad the `erk-diff-analysis` skill for commit message generation guidance.\n\n### Step 3.5: Add Planned Prefix (if from plan)\n\nIf this worktree was created from a plan (`.impl/` directory exists), prepend `planned/` to the PR title:\n\n```bash\nif [ -d \".impl\" ]; then\n    # Extract the title before creating the commit\n    # (we'll apply the prefix when creating the commit message below)\n    has_impl_dir=true\nelse\n    has_impl_dir=false\nfi\n```\n\nWhen generating the commit message in Step 4, if `has_impl_dir` is true, prepend `planned/` to the title:\n\n```bash\nif [ \"$has_impl_dir\" = true ]; then\n    pr_title=\"planned/${pr_title}\"\nfi\n```\n\n### Step 4: Create Commit\n\nCreate the commit with your AI-generated message using heredoc:\n","numLines":30,"startLine":85,"totalLines":401}}}
{"parentUuid":"bea1a2ed-d98b-477d-a784-0acc50c5a321","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_019U7asfLGXZjUGaFCGmYfrR","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me signal started and begin implementing. I need to also make sure the regex patterns handle both old `planned/` and new `plnd/` for backwards compatibility with existing branches."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":636,"cache_read_input_tokens":43755,"cache_creation":{"ephemeral_5m_input_tokens":636,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHL2EE1eP4TzvV6LEnx","type":"assistant","uuid":"88f19f47-3b12-4d4f-ba81-ea39a58407ad","timestamp":"2026-02-22T14:41:26.458Z"}
{"parentUuid":"88f19f47-3b12-4d4f-ba81-ea39a58407ad","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_019U7asfLGXZjUGaFCGmYfrR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QGxQeaX2wasc6cpXXe5c9G","name":"Bash","input":{"command":"erk exec impl-signal started --session-id \"${CLAUDE_SESSION_ID}\" 2>/dev/null || true","description":"Signal implementation started"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":636,"cache_read_input_tokens":43755,"cache_creation":{"ephemeral_5m_input_tokens":636,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHL2EE1eP4TzvV6LEnx","type":"assistant","uuid":"751d7319-b885-49e4-9b74-f21d475a2810","timestamp":"2026-02-22T14:41:27.641Z"}
{"parentUuid":"751d7319-b885-49e4-9b74-f21d475a2810","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QGxQeaX2wasc6cpXXe5c9G","type":"tool_result","content":"{\n  \"success\": false,\n  \"event\": \"started\",\n  \"error_type\": \"session-id-required\",\n  \"message\": \"Session ID required for impl-signal started. Ensure ${CLAUDE_SESSION_ID} is available in the command context.\"\n}","is_error":false}]},"uuid":"6a704f0f-5cec-4ca2-bbdd-583fa3115be6","timestamp":"2026-02-22T14:41:28.652Z","toolUseResult":{"stdout":"{\n  \"success\": false,\n  \"event\": \"started\",\n  \"error_type\": \"session-id-required\",\n  \"message\": \"Session ID required for impl-signal started. Ensure ${CLAUDE_SESSION_ID} is available in the command context.\"\n}","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"6a704f0f-5cec-4ca2-bbdd-583fa3115be6","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_0114syRrDTLwAE2apZmoJBRo","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me start implementing. I'll work through each file systematically."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":547,"cache_read_input_tokens":44391,"cache_creation":{"ephemeral_5m_input_tokens":547,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHLRBbsEXrsD9BYPnQ7","type":"assistant","uuid":"bc9c4ac0-7193-45a6-bb26-f77fe371bbe3","timestamp":"2026-02-22T14:41:30.884Z"}
{"parentUuid":"bc9c4ac0-7193-45a6-bb26-f77fe371bbe3","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_0114syRrDTLwAE2apZmoJBRo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VLqpErYFmMGENMtv9oozzv","name":"TodoWrite","input":{"todos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"in_progress","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"pending","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"pending","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"pending","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"pending","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":547,"cache_read_input_tokens":44391,"cache_creation":{"ephemeral_5m_input_tokens":547,"ephemeral_1h_input_tokens":0},"output_tokens":549,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHLRBbsEXrsD9BYPnQ7","type":"assistant","uuid":"584c67bd-6c30-4ff0-8497-03f7e41bc9bb","timestamp":"2026-02-22T14:41:35.208Z"}
{"parentUuid":"584c67bd-6c30-4ff0-8497-03f7e41bc9bb","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VLqpErYFmMGENMtv9oozzv","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"5e947082-3fdd-4d68-ae6d-e7c844a65bb0","timestamp":"2026-02-22T14:41:35.217Z","toolUseResult":{"oldTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"pending","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"pending","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"pending","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"pending","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"pending","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}],"newTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"in_progress","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"pending","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"pending","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"pending","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"pending","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]}}
{"parentUuid":"5e947082-3fdd-4d68-ae6d-e7c844a65bb0","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01SLqok78m7qBtFMjG8zUakk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DeDY1SC7mDz7BoTHkUqobe","name":"Skill","input":{"skill":"dignified-python"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":591,"cache_read_input_tokens":44938,"cache_creation":{"ephemeral_5m_input_tokens":591,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHLuFohgYVEpdjc4a5a","type":"assistant","uuid":"67687c88-2271-4082-90c1-08f625ca1294","timestamp":"2026-02-22T14:41:37.565Z"}
{"parentUuid":"67687c88-2271-4082-90c1-08f625ca1294","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"type":"tool_result","tool_use_id":"toolu_01DeDY1SC7mDz7BoTHkUqobe","content":"Launching skill: dignified-python"}]},"uuid":"ea53308d-be86-40a0-a93e-3ffa794cb6cf","timestamp":"2026-02-22T14:41:37.592Z","toolUseResult":{"success":true,"commandName":"dignified-python"}}
{"parentUuid":"ea53308d-be86-40a0-a93e-3ffa794cb6cf","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"type":"text","text":"Base directory for this skill: /home/runner/work/erk/erk/.claude/skills/dignified-python\n\n# Dignified Python Coding Standards\n\n## Core Knowledge (ALWAYS Loaded)\n\n@dignified-python-core.md\n\n## Version Detection\n\n**Identify the project's minimum Python version** by checking (in order):\n\n1. `pyproject.toml` - Look for `requires-python` field (e.g., `requires-python = \">=3.12\"`)\n2. `setup.py` or `setup.cfg` - Look for `python_requires`\n3. `.python-version` file - Contains version like `3.12` or `3.12.0`\n4. Default to Python 3.12 if no version specifier found\n\n**Once identified, load the appropriate version-specific file:**\n\n- Python 3.10: Load `versions/python-3.10.md`\n- Python 3.11: Load `versions/python-3.11.md`\n- Python 3.12: Load `versions/python-3.12.md`\n- Python 3.13: Load `versions/python-3.13.md`\n\n## Conditional Loading (Load Based on Task Patterns)\n\nCore files above cover 80%+ of Python code patterns. Only load these additional files when you detect specific patterns:\n\nPattern detection examples:\n\n- If task mentions \"click\" or \"CLI\" -> Load `cli-patterns.md`\n- If task mentions \"subprocess\" -> Load `subprocess.md`\n\n## When to Read Each Reference Document\n\nThe `references/` directory contains detailed guidance for specialized topics. Load these on-demand when you encounter relevant patterns:\n\n### `references/exception-handling.md`\n\n**Read when**:\n\n- Writing try/except blocks\n- Wrapping third-party APIs that may raise\n- Seeing or writing `from e` or `from None`\n- Unsure if LBYL alternative exists\n\n### `references/interfaces.md`\n\n**Read when**:\n\n- Creating ABC or Protocol classes\n- Writing @abstractmethod decorators\n- Designing gateway layer interfaces\n- Choosing between ABC and Protocol\n\n### `references/typing-advanced.md`\n\n**Read when**:\n\n- Using typing.cast()\n- Creating Literal type aliases\n- Narrowing types in conditional blocks\n\n### `references/module-design.md`\n\n**Read when**:\n\n- Creating new Python modules\n- Adding module-level code (beyond simple constants)\n- Using @cache decorator at module level\n- Seeing Path() or computation at module level\n- Considering inline imports\n\n### `references/api-design.md`\n\n**Read when**:\n\n- Adding default parameter values to functions\n- Defining functions with 5 or more parameters\n- Using ThreadPoolExecutor.submit()\n- Reviewing function signatures\n\n### `references/checklists.md`\n\n**Read when**:\n\n- Final review before committing Python code\n- Unsure if you've followed all rules\n- Need a quick lookup of requirements\n\n## How to Use This Skill\n\n1. **Core knowledge** is loaded automatically (LBYL, pathlib, basic imports, anti-patterns)\n2. **Version detection** happens once - identify the minimum Python version and load the appropriate version file\n3. **Reference documents** are loaded on-demand based on the triggers above\n4. **Additional patterns** may require extra loading (CLI patterns, subprocess)\n5. **Each file is self-contained** with complete guidance for its domain\n"}]},"isMeta":true,"uuid":"bd13ed7e-c8e6-4642-8965-ce6b8afd4122","timestamp":"2026-02-22T14:41:37.592Z","sourceToolUseID":"toolu_01DeDY1SC7mDz7BoTHkUqobe"}
{"parentUuid":"bd13ed7e-c8e6-4642-8965-ce6b8afd4122","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_012eMzDdV1qTk621aPcEYUFD","type":"message","role":"assistant","content":[{"type":"text","text":"\n\nNow let me load the core rules and detect the Python version."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":875,"cache_read_input_tokens":45529,"cache_creation":{"ephemeral_5m_input_tokens":875,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHM5QznLpzgCVr6x58G","type":"assistant","uuid":"92b9e23b-938d-4528-b820-c185207f4d39","timestamp":"2026-02-22T14:41:40.030Z"}
{"parentUuid":"92b9e23b-938d-4528-b820-c185207f4d39","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_012eMzDdV1qTk621aPcEYUFD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012aByLLm5VNEUuzmUB452ai","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/.claude/skills/dignified-python/dignified-python-core.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":875,"cache_read_input_tokens":45529,"cache_creation":{"ephemeral_5m_input_tokens":875,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHM5QznLpzgCVr6x58G","type":"assistant","uuid":"c61651ac-6d74-4944-adec-3e3a06b9c157","timestamp":"2026-02-22T14:41:40.606Z"}
{"parentUuid":"c61651ac-6d74-4944-adec-3e3a06b9c157","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_012eMzDdV1qTk621aPcEYUFD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TcgeEpsGcfzrStbn3cGeWr","name":"Bash","input":{"command":"grep -m1 'requires-python' /home/runner/work/erk/erk/pyproject.toml 2>/dev/null || cat /home/runner/work/erk/erk/.python-version 2>/dev/null || echo \"no version found\"","description":"Detect Python version"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":875,"cache_read_input_tokens":45529,"cache_creation":{"ephemeral_5m_input_tokens":875,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHM5QznLpzgCVr6x58G","type":"assistant","uuid":"865a96a7-2a03-4914-a00d-de2da6fb7304","timestamp":"2026-02-22T14:41:42.043Z"}
{"parentUuid":"865a96a7-2a03-4914-a00d-de2da6fb7304","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012aByLLm5VNEUuzmUB452ai","type":"tool_result","content":"     1→---\n     2→---\n     3→\n     4→# Dignified Python - Core Standards\n     5→\n     6→This document contains the core Python coding standards that apply to 80%+ of Python code. These principles are loaded with every skill invocation.\n     7→\n     8→For conditional loading of specialized patterns:\n     9→\n    10→- CLI development -> Load `cli-patterns.md`\n    11→- Subprocess operations -> Load `subprocess.md`\n    12→\n    13→For detailed reference material, see the \"When to Read Each Reference\" section in SKILL.md.\n    14→\n    15→---\n    16→\n    17→## The Cornerstone: LBYL Over EAFP\n    18→\n    19→**Look Before You Leap: Check conditions proactively, NEVER use exceptions for control flow.**\n    20→\n    21→This is the single most important rule in dignified Python. Every pattern below flows from this principle.\n    22→\n    23→```python\n    24→# CORRECT: Check first\n    25→if key in mapping:\n    26→    value = mapping[key]\n    27→    process(value)\n    28→\n    29→# WRONG: Exception as control flow\n    30→try:\n    31→    value = mapping[key]\n    32→    process(value)\n    33→except KeyError:\n    34→    pass\n    35→```\n    36→\n    37→---\n    38→\n    39→## Exception Handling Basics\n    40→\n    41→### Core Principle\n    42→\n    43→**ALWAYS use LBYL, NEVER EAFP for control flow**\n    44→\n    45→LBYL means checking conditions before acting. EAFP (Easier to Ask for Forgiveness than Permission) means trying operations and catching exceptions. In dignified Python, we strongly prefer LBYL.\n    46→\n    47→### Dictionary Access Patterns\n    48→\n    49→```python\n    50→# CORRECT: Membership testing\n    51→if key in mapping:\n    52→    value = mapping[key]\n    53→    process(value)\n    54→else:\n    55→    handle_missing()\n    56→\n    57→# ALSO CORRECT: .get() with default\n    58→value = mapping.get(key, default_value)\n    59→process(value)\n    60→\n    61→# CORRECT: Check before nested access\n    62→if \"config\" in data and \"timeout\" in data[\"config\"]:\n    63→    timeout = data[\"config\"][\"timeout\"]\n    64→\n    65→# WRONG: KeyError as control flow\n    66→try:\n    67→    value = mapping[key]\n    68→except KeyError:\n    69→    handle_missing()\n    70→```\n    71→\n    72→### When Exceptions ARE Acceptable\n    73→\n    74→Exceptions are ONLY acceptable at:\n    75→\n    76→1. **Error boundaries** (CLI/API level)\n    77→2. **Third-party API compatibility** (when no alternative exists)\n    78→3. **Adding context before re-raising**\n    79→\n    80→**Default: Let exceptions bubble up**\n    81→\n    82→For detailed exception handling patterns including B904 chaining, third-party API examples, and anti-patterns, see `references/exception-handling.md`.\n    83→\n    84→### Assert for Type Narrowing\n    85→\n    86→`assert` is acceptable when used **solely to narrow types** after a guard check has already established the invariant:\n    87→\n    88→```python\n    89→# CORRECT: assert for type narrowing after guard check\n    90→if not result.is_valid:\n    91→    return None\n    92→# is_valid guarantees metadata is not None, assert narrows the type\n    93→assert result.metadata is not None\n    94→process(result.metadata)\n    95→\n    96→# WRONG: assert as control flow (no prior guard)\n    97→assert result.metadata is not None  # This IS control flow\n    98→process(result.metadata)\n    99→```\n   100→\n   101→The key distinction: if removing the assert would cause a runtime error, it's control flow (WRONG). If removing it would only lose type information, it's type narrowing (ACCEPTABLE).\n   102→\n   103→---\n   104→\n   105→## Path Operations\n   106→\n   107→### The Golden Rule\n   108→\n   109→**ALWAYS check `.exists()` BEFORE `.resolve()` or `.is_relative_to()`**\n   110→\n   111→### Why This Matters\n   112→\n   113→- `.resolve()` raises `OSError` for non-existent paths\n   114→- `.is_relative_to()` raises `ValueError` for invalid comparisons\n   115→- Checking `.exists()` first avoids exceptions entirely (LBYL!)\n   116→\n   117→### Correct Patterns\n   118→\n   119→```python\n   120→from pathlib import Path\n   121→\n   122→# CORRECT: Check exists first\n   123→for wt_path in worktree_paths:\n   124→    if wt_path.exists():\n   125→        wt_path_resolved = wt_path.resolve()\n   126→        if current_dir.is_relative_to(wt_path_resolved):\n   127→            current_worktree = wt_path_resolved\n   128→            break\n   129→\n   130→# WRONG: Using exceptions for path validation\n   131→try:\n   132→    wt_path_resolved = wt_path.resolve()\n   133→    if current_dir.is_relative_to(wt_path_resolved):\n   134→        current_worktree = wt_path_resolved\n   135→except (OSError, ValueError):\n   136→    continue\n   137→```\n   138→\n   139→### Pathlib Best Practices\n   140→\n   141→**Always Use Pathlib (Never os.path)**\n   142→\n   143→```python\n   144→# CORRECT: Use pathlib.Path\n   145→from pathlib import Path\n   146→\n   147→config_file = Path.home() / \".config\" / \"app.yml\"\n   148→if config_file.exists():\n   149→    content = config_file.read_text(encoding=\"utf-8\")\n   150→\n   151→# WRONG: Use os.path\n   152→import os.path\n   153→config_file = os.path.join(os.path.expanduser(\"~\"), \".config\", \"app.yml\")\n   154→```\n   155→\n   156→**Always Specify Encoding**\n   157→\n   158→```python\n   159→# CORRECT: Always specify encoding\n   160→content = path.read_text(encoding=\"utf-8\")\n   161→path.write_text(data, encoding=\"utf-8\")\n   162→\n   163→# WRONG: Default encoding\n   164→content = path.read_text()  # Platform-dependent!\n   165→```\n   166→\n   167→---\n   168→\n   169→## Import Organization\n   170→\n   171→### Core Rules\n   172→\n   173→1. **Default: ALWAYS place imports at module level**\n   174→2. **Use absolute imports only** (no relative imports)\n   175→3. **Inline imports only for specific exceptions** (circular deps, TYPE_CHECKING, conditional features)\n   176→\n   177→```python\n   178→# CORRECT: Module-level imports\n   179→import json\n   180→import click\n   181→from pathlib import Path\n   182→from erk.config import load_config\n   183→\n   184→def my_function() -> None:\n   185→    data = json.loads(content)\n   186→\n   187→# CORRECT: Absolute import\n   188→from erk.config import load_config\n   189→\n   190→# WRONG: Relative import\n   191→from .config import load_config\n   192→\n   193→# WRONG: Inline imports without justification\n   194→def my_function() -> None:\n   195→    import json  # NEVER do this\n   196→```\n   197→\n   198→For detailed inline import patterns and when they're legitimate, see `references/module-design.md`.\n   199→\n   200→### No Import Aliases\n   201→\n   202→**Rule:** Imports must use canonical names. The `as` keyword for aliasing is prohibited by default.\n   203→\n   204→**Rationale:** Import aliases obscure the canonical name, make grep-based discovery harder, and invite cargo-culting. When reading code, aliases force you to scroll up to find the real import, breaking flow. When searching for usage of a symbol, aliases fragment results across different names.\n   205→\n   206→**The only acceptable exception:** Resolving genuine name collisions between two different modules that export identically-named symbols.\n   207→\n   208→```python\n   209→# WRONG: Gratuitous aliasing\n   210→from erk.helpers import require_issues as require_github_issues\n   211→\n   212→# CORRECT: Use canonical name\n   213→from erk.helpers import require_issues\n   214→\n   215→# CORRECT (rare exception): Resolving genuine collision\n   216→from datetime import datetime as dt\n   217→from pandas import datetime as pd_datetime\n   218→```\n   219→\n   220→**Note:** This rule is complementary to the \"No Re-Exports\" rule. Re-exports use `import X as X` for explicit re-export syntax at package boundaries. This rule targets gratuitous renaming aliases.\n   221→\n   222→---\n   223→\n   224→## Performance Guidelines\n   225→\n   226→### Properties Must Be O(1)\n   227→\n   228→```python\n   229→# WRONG: Property doing I/O\n   230→@property\n   231→def size(self) -> int:\n   232→    return self._fetch_from_db()\n   233→\n   234→# CORRECT: Explicit method name\n   235→def fetch_size_from_db(self) -> int:\n   236→    return self._fetch_from_db()\n   237→\n   238→# CORRECT: O(1) property\n   239→@property\n   240→def size(self) -> int:\n   241→    return self._cached_size\n   242→```\n   243→\n   244→### Magic Methods Must Be O(1)\n   245→\n   246→```python\n   247→# WRONG: __len__ doing iteration\n   248→def __len__(self) -> int:\n   249→    return sum(1 for _ in self._items)\n   250→\n   251→# CORRECT: O(1) __len__\n   252→def __len__(self) -> int:\n   253→    return self._count\n   254→```\n   255→\n   256→---\n   257→\n   258→## Anti-Patterns\n   259→\n   260→### No Backwards Compatibility Preservation (Default)\n   261→\n   262→```python\n   263→# WRONG: Keeping old API unnecessarily\n   264→def process_data(data: dict, legacy_format: bool = False) -> Result:\n   265→    if legacy_format:\n   266→        return legacy_process(data)\n   267→    return new_process(data)\n   268→\n   269→# CORRECT: Break and migrate immediately\n   270→def process_data(data: dict) -> Result:\n   271→    return new_process(data)\n   272→```\n   273→\n   274→### No Re-Exports: One Canonical Import Path\n   275→\n   276→**Core Principle:** Every symbol has exactly one import path. Never re-export.\n   277→\n   278→```python\n   279→# WRONG: __all__ exports create duplicate import paths\n   280→# myapp/__init__.py\n   281→from myapp.core import Process\n   282→__all__ = [\"Process\"]\n   283→\n   284→# CORRECT: Empty __init__.py, import from canonical location\n   285→# from myapp.core import Process\n   286→```\n   287→\n   288→**When re-exports ARE required** (plugin entry points): Use explicit `import X as X` syntax:\n   289→\n   290→```python\n   291→# CORRECT: Explicit re-export syntax for required entry points\n   292→from myapp.core.feature import my_function as my_function\n   293→```\n   294→\n   295→### Declare Variables Close to Use\n   296→\n   297→```python\n   298→# WRONG: Variable declared far from use\n   299→def process_data(ctx, items):\n   300→    result_path = compute_result_path(ctx)  # Declared here...\n   301→    # 20+ lines of other logic...\n   302→    save_to_path(transformed, result_path)  # ...used here\n   303→\n   304→# CORRECT: Inline at use site\n   305→def process_data(ctx, items):\n   306→    validate_items(items)\n   307→    transformed = transform_items(items)\n   308→    save_to_path(transformed, compute_result_path(ctx))\n   309→```\n   310→\n   311→### Don't Destructure Objects Into Single-Use Locals\n   312→\n   313→```python\n   314→# WRONG: Unnecessary field extraction\n   315→result = fetch_user(user_id)\n   316→name = result.name      # only used once below\n   317→email = result.email    # only used once below\n   318→send_notification(name, email, role)\n   319→\n   320→# CORRECT: Access fields directly\n   321→user = fetch_user(user_id)\n   322→send_notification(user.name, user.email, user.role)\n   323→```\n   324→\n   325→### Indentation Depth Limit\n   326→\n   327→**Maximum indentation: 4 levels**\n   328→\n   329→```python\n   330→# WRONG: Too deeply nested (5 levels)\n   331→def process_items(items):\n   332→    for item in items:\n   333→        if item.valid:\n   334→            for child in item.children:\n   335→                if child.enabled:\n   336→                    for grandchild in child.descendants:\n   337→                        pass  # 5 levels deep!\n   338→\n   339→# CORRECT: Extract helper functions\n   340→def process_items(items):\n   341→    for item in items:\n   342→        if item.valid:\n   343→            process_children(item.children)\n   344→\n   345→def process_children(children):\n   346→    for child in children:\n   347→        if child.enabled:\n   348→            process_descendants(child.descendants)\n   349→```\n   350→\n   351→---\n   352→\n   353→## Lightweight `__init__` Pattern\n   354→\n   355→Class `__init__` methods should be lightweight and cheap - just data assignment. Heavy I/O operations belong in static factory methods.\n   356→\n   357→### Why\n   358→\n   359→- **Testability**: Tests can construct objects directly without I/O setup\n   360→- **Predictability**: Instantiation has no side effects\n   361→- **Explicit dependencies**: Heavy operations are visible at call sites\n   362→- **Flexibility**: Multiple construction paths (from file, from dict, for testing)\n   363→\n   364→### Correct Pattern\n   365→\n   366→```python\n   367→class Registry:\n   368→    def __init__(self, items: list[Item], default: str | None) -> None:\n   369→        \"\"\"Lightweight - just assigns data.\"\"\"\n   370→        self._items = {item.name: item for item in items}\n   371→        self._default = default\n   372→\n   373→    @classmethod\n   374→    def from_config_path(cls, path: Path) -> \"Registry\":\n   375→        \"\"\"Heavy I/O happens here, not in __init__.\"\"\"\n   376→        data = tomllib.loads(path.read_text())\n   377→        items = [Item.from_dict(d) for d in data.get(\"items\", [])]\n   378→        return cls(items=items, default=data.get(\"default\"))\n   379→```\n   380→\n   381→### Anti-pattern\n   382→\n   383→```python\n   384→# WRONG: __init__ does heavy I/O\n   385→class Registry:\n   386→    def __init__(self, config_path: Path) -> None:\n   387→        data = tomllib.loads(config_path.read_text())  # Heavy I/O\n   388→        self._items = ...\n   389→```\n   390→\n   391→### When This Applies\n   392→\n   393→- Any class backed by file storage (TOML, JSON, etc.)\n   394→- Any class that calls subprocess on construction\n   395→- Any class that makes network requests on construction\n   396→- Any class where tests need to verify behavior without I/O\n   397→\n   398→---\n   399→\n   400→## No Invalid Object Construction\n   401→\n   402→**Never construct objects with invalid states.** Validate at the construction boundary — factory methods, reader functions, parse functions — so that if an object exists, all its fields are valid. Don't allow invalid objects to exist and then guard at every callsite.\n   403→\n   404→### Why\n   405→\n   406→- **Eliminates defensive guards**: Every callsite can trust the object's fields without conversion or None checks\n   407→- **Single validation point**: Validation logic lives in one place, not scattered across N callsites\n   408→- **Type system works for you**: Once constructed, the type tells the full story — `int` means it's numeric, not \"might be numeric\"\n   409→- **Bugs are caught early**: Invalid data is rejected at parse/read time, not at use time\n   410→\n   411→### Correct Pattern\n   412→\n   413→```python\n   414→@dataclass(frozen=True)\n   415→class PlanRef:\n   416→    plan_id: int          # Always valid — numeric guaranteed\n   417→    url: str\n   418→    provider: str\n   419→\n   420→def read_plan_ref(folder: Path) -> PlanRef | None:\n   421→    \"\"\"Validate at the boundary. Return None if invalid.\"\"\"\n   422→    data = json.loads(path.read_text())\n   423→    raw_id = data.get(\"plan_id\")\n   424→    if not isinstance(raw_id, int):\n   425→        return None  # Don't construct with invalid state\n   426→    return PlanRef(plan_id=raw_id, url=data[\"url\"], provider=data[\"provider\"])\n   427→```\n   428→\n   429→### Anti-pattern\n   430→\n   431→```python\n   432→@dataclass(frozen=True)\n   433→class PlanRef:\n   434→    plan_id: str          # Could be \"42\" or \"PROJ-123\" — caller must check\n   435→\n   436→    @property\n   437→    def numeric_plan_id(self) -> int | None:\n   438→        \"\"\"Every callsite must use this instead of plan_id.\"\"\"\n   439→        if self.plan_id.isdigit():\n   440→            return int(self.plan_id)\n   441→        return None\n   442→\n   443→# Result: N callsites with defensive guards\n   444→issue = plan_ref.numeric_plan_id\n   445→if issue is None:\n   446→    log.warning(\"Non-numeric plan_id\")\n   447→    return\n   448→```\n   449→\n   450→### When This Applies\n   451→\n   452→- Dataclasses read from JSON/TOML/YAML (validate during parsing)\n   453→- Objects constructed from user input (validate before construction)\n   454→- Any case where a field's type is broader than the valid domain (e.g., `str` when only digits are valid → use `int`)\n   455→- Factory methods that transform external data into domain objects\n   456→\n   457→### Decision: Return None vs Raise\n   458→\n   459→- **Return `None`**: When invalid data is expected/normal (e.g., missing optional file, legacy format)\n   460→- **Raise exception**: When invalid data indicates a programming error or corrupt state\n   461→\n   462→---\n   463→\n   464→## Backwards Compatibility Philosophy\n   465→\n   466→**Default stance: NO backwards compatibility preservation**\n   467→\n   468→Only preserve backwards compatibility when:\n   469→\n   470→- Code is clearly part of public API\n   471→- User explicitly requests it\n   472→- Migration cost is prohibitively high (rare)\n   473→\n   474→Benefits:\n   475→\n   476→- Cleaner, maintainable codebase\n   477→- Faster iteration\n   478→- No legacy code accumulation\n   479→- Simpler mental models\n   480→\n   481→---\n   482→\n   483→## See Also\n   484→\n   485→For detailed guidance on specialized topics:\n   486→\n   487→- **Exception chaining (B904)**: `references/exception-handling.md`\n   488→- **ABC vs Protocol**: `references/interfaces.md`\n   489→- **typing.cast() assertions**: `references/typing-advanced.md`\n   490→- **Import-time side effects, @cache**: `references/module-design.md`\n   491→- **Default parameters, keyword-only args**: `references/api-design.md`\n   492→- **All decision checklists**: `references/checklists.md`\n   493→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"8a4c2591-4dd6-4e01-9b94-5e4b66405402","timestamp":"2026-02-22T14:41:42.061Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/.claude/skills/dignified-python/dignified-python-core.md","content":"---\n---\n\n# Dignified Python - Core Standards\n\nThis document contains the core Python coding standards that apply to 80%+ of Python code. These principles are loaded with every skill invocation.\n\nFor conditional loading of specialized patterns:\n\n- CLI development -> Load `cli-patterns.md`\n- Subprocess operations -> Load `subprocess.md`\n\nFor detailed reference material, see the \"When to Read Each Reference\" section in SKILL.md.\n\n---\n\n## The Cornerstone: LBYL Over EAFP\n\n**Look Before You Leap: Check conditions proactively, NEVER use exceptions for control flow.**\n\nThis is the single most important rule in dignified Python. Every pattern below flows from this principle.\n\n```python\n# CORRECT: Check first\nif key in mapping:\n    value = mapping[key]\n    process(value)\n\n# WRONG: Exception as control flow\ntry:\n    value = mapping[key]\n    process(value)\nexcept KeyError:\n    pass\n```\n\n---\n\n## Exception Handling Basics\n\n### Core Principle\n\n**ALWAYS use LBYL, NEVER EAFP for control flow**\n\nLBYL means checking conditions before acting. EAFP (Easier to Ask for Forgiveness than Permission) means trying operations and catching exceptions. In dignified Python, we strongly prefer LBYL.\n\n### Dictionary Access Patterns\n\n```python\n# CORRECT: Membership testing\nif key in mapping:\n    value = mapping[key]\n    process(value)\nelse:\n    handle_missing()\n\n# ALSO CORRECT: .get() with default\nvalue = mapping.get(key, default_value)\nprocess(value)\n\n# CORRECT: Check before nested access\nif \"config\" in data and \"timeout\" in data[\"config\"]:\n    timeout = data[\"config\"][\"timeout\"]\n\n# WRONG: KeyError as control flow\ntry:\n    value = mapping[key]\nexcept KeyError:\n    handle_missing()\n```\n\n### When Exceptions ARE Acceptable\n\nExceptions are ONLY acceptable at:\n\n1. **Error boundaries** (CLI/API level)\n2. **Third-party API compatibility** (when no alternative exists)\n3. **Adding context before re-raising**\n\n**Default: Let exceptions bubble up**\n\nFor detailed exception handling patterns including B904 chaining, third-party API examples, and anti-patterns, see `references/exception-handling.md`.\n\n### Assert for Type Narrowing\n\n`assert` is acceptable when used **solely to narrow types** after a guard check has already established the invariant:\n\n```python\n# CORRECT: assert for type narrowing after guard check\nif not result.is_valid:\n    return None\n# is_valid guarantees metadata is not None, assert narrows the type\nassert result.metadata is not None\nprocess(result.metadata)\n\n# WRONG: assert as control flow (no prior guard)\nassert result.metadata is not None  # This IS control flow\nprocess(result.metadata)\n```\n\nThe key distinction: if removing the assert would cause a runtime error, it's control flow (WRONG). If removing it would only lose type information, it's type narrowing (ACCEPTABLE).\n\n---\n\n## Path Operations\n\n### The Golden Rule\n\n**ALWAYS check `.exists()` BEFORE `.resolve()` or `.is_relative_to()`**\n\n### Why This Matters\n\n- `.resolve()` raises `OSError` for non-existent paths\n- `.is_relative_to()` raises `ValueError` for invalid comparisons\n- Checking `.exists()` first avoids exceptions entirely (LBYL!)\n\n### Correct Patterns\n\n```python\nfrom pathlib import Path\n\n# CORRECT: Check exists first\nfor wt_path in worktree_paths:\n    if wt_path.exists():\n        wt_path_resolved = wt_path.resolve()\n        if current_dir.is_relative_to(wt_path_resolved):\n            current_worktree = wt_path_resolved\n            break\n\n# WRONG: Using exceptions for path validation\ntry:\n    wt_path_resolved = wt_path.resolve()\n    if current_dir.is_relative_to(wt_path_resolved):\n        current_worktree = wt_path_resolved\nexcept (OSError, ValueError):\n    continue\n```\n\n### Pathlib Best Practices\n\n**Always Use Pathlib (Never os.path)**\n\n```python\n# CORRECT: Use pathlib.Path\nfrom pathlib import Path\n\nconfig_file = Path.home() / \".config\" / \"app.yml\"\nif config_file.exists():\n    content = config_file.read_text(encoding=\"utf-8\")\n\n# WRONG: Use os.path\nimport os.path\nconfig_file = os.path.join(os.path.expanduser(\"~\"), \".config\", \"app.yml\")\n```\n\n**Always Specify Encoding**\n\n```python\n# CORRECT: Always specify encoding\ncontent = path.read_text(encoding=\"utf-8\")\npath.write_text(data, encoding=\"utf-8\")\n\n# WRONG: Default encoding\ncontent = path.read_text()  # Platform-dependent!\n```\n\n---\n\n## Import Organization\n\n### Core Rules\n\n1. **Default: ALWAYS place imports at module level**\n2. **Use absolute imports only** (no relative imports)\n3. **Inline imports only for specific exceptions** (circular deps, TYPE_CHECKING, conditional features)\n\n```python\n# CORRECT: Module-level imports\nimport json\nimport click\nfrom pathlib import Path\nfrom erk.config import load_config\n\ndef my_function() -> None:\n    data = json.loads(content)\n\n# CORRECT: Absolute import\nfrom erk.config import load_config\n\n# WRONG: Relative import\nfrom .config import load_config\n\n# WRONG: Inline imports without justification\ndef my_function() -> None:\n    import json  # NEVER do this\n```\n\nFor detailed inline import patterns and when they're legitimate, see `references/module-design.md`.\n\n### No Import Aliases\n\n**Rule:** Imports must use canonical names. The `as` keyword for aliasing is prohibited by default.\n\n**Rationale:** Import aliases obscure the canonical name, make grep-based discovery harder, and invite cargo-culting. When reading code, aliases force you to scroll up to find the real import, breaking flow. When searching for usage of a symbol, aliases fragment results across different names.\n\n**The only acceptable exception:** Resolving genuine name collisions between two different modules that export identically-named symbols.\n\n```python\n# WRONG: Gratuitous aliasing\nfrom erk.helpers import require_issues as require_github_issues\n\n# CORRECT: Use canonical name\nfrom erk.helpers import require_issues\n\n# CORRECT (rare exception): Resolving genuine collision\nfrom datetime import datetime as dt\nfrom pandas import datetime as pd_datetime\n```\n\n**Note:** This rule is complementary to the \"No Re-Exports\" rule. Re-exports use `import X as X` for explicit re-export syntax at package boundaries. This rule targets gratuitous renaming aliases.\n\n---\n\n## Performance Guidelines\n\n### Properties Must Be O(1)\n\n```python\n# WRONG: Property doing I/O\n@property\ndef size(self) -> int:\n    return self._fetch_from_db()\n\n# CORRECT: Explicit method name\ndef fetch_size_from_db(self) -> int:\n    return self._fetch_from_db()\n\n# CORRECT: O(1) property\n@property\ndef size(self) -> int:\n    return self._cached_size\n```\n\n### Magic Methods Must Be O(1)\n\n```python\n# WRONG: __len__ doing iteration\ndef __len__(self) -> int:\n    return sum(1 for _ in self._items)\n\n# CORRECT: O(1) __len__\ndef __len__(self) -> int:\n    return self._count\n```\n\n---\n\n## Anti-Patterns\n\n### No Backwards Compatibility Preservation (Default)\n\n```python\n# WRONG: Keeping old API unnecessarily\ndef process_data(data: dict, legacy_format: bool = False) -> Result:\n    if legacy_format:\n        return legacy_process(data)\n    return new_process(data)\n\n# CORRECT: Break and migrate immediately\ndef process_data(data: dict) -> Result:\n    return new_process(data)\n```\n\n### No Re-Exports: One Canonical Import Path\n\n**Core Principle:** Every symbol has exactly one import path. Never re-export.\n\n```python\n# WRONG: __all__ exports create duplicate import paths\n# myapp/__init__.py\nfrom myapp.core import Process\n__all__ = [\"Process\"]\n\n# CORRECT: Empty __init__.py, import from canonical location\n# from myapp.core import Process\n```\n\n**When re-exports ARE required** (plugin entry points): Use explicit `import X as X` syntax:\n\n```python\n# CORRECT: Explicit re-export syntax for required entry points\nfrom myapp.core.feature import my_function as my_function\n```\n\n### Declare Variables Close to Use\n\n```python\n# WRONG: Variable declared far from use\ndef process_data(ctx, items):\n    result_path = compute_result_path(ctx)  # Declared here...\n    # 20+ lines of other logic...\n    save_to_path(transformed, result_path)  # ...used here\n\n# CORRECT: Inline at use site\ndef process_data(ctx, items):\n    validate_items(items)\n    transformed = transform_items(items)\n    save_to_path(transformed, compute_result_path(ctx))\n```\n\n### Don't Destructure Objects Into Single-Use Locals\n\n```python\n# WRONG: Unnecessary field extraction\nresult = fetch_user(user_id)\nname = result.name      # only used once below\nemail = result.email    # only used once below\nsend_notification(name, email, role)\n\n# CORRECT: Access fields directly\nuser = fetch_user(user_id)\nsend_notification(user.name, user.email, user.role)\n```\n\n### Indentation Depth Limit\n\n**Maximum indentation: 4 levels**\n\n```python\n# WRONG: Too deeply nested (5 levels)\ndef process_items(items):\n    for item in items:\n        if item.valid:\n            for child in item.children:\n                if child.enabled:\n                    for grandchild in child.descendants:\n                        pass  # 5 levels deep!\n\n# CORRECT: Extract helper functions\ndef process_items(items):\n    for item in items:\n        if item.valid:\n            process_children(item.children)\n\ndef process_children(children):\n    for child in children:\n        if child.enabled:\n            process_descendants(child.descendants)\n```\n\n---\n\n## Lightweight `__init__` Pattern\n\nClass `__init__` methods should be lightweight and cheap - just data assignment. Heavy I/O operations belong in static factory methods.\n\n### Why\n\n- **Testability**: Tests can construct objects directly without I/O setup\n- **Predictability**: Instantiation has no side effects\n- **Explicit dependencies**: Heavy operations are visible at call sites\n- **Flexibility**: Multiple construction paths (from file, from dict, for testing)\n\n### Correct Pattern\n\n```python\nclass Registry:\n    def __init__(self, items: list[Item], default: str | None) -> None:\n        \"\"\"Lightweight - just assigns data.\"\"\"\n        self._items = {item.name: item for item in items}\n        self._default = default\n\n    @classmethod\n    def from_config_path(cls, path: Path) -> \"Registry\":\n        \"\"\"Heavy I/O happens here, not in __init__.\"\"\"\n        data = tomllib.loads(path.read_text())\n        items = [Item.from_dict(d) for d in data.get(\"items\", [])]\n        return cls(items=items, default=data.get(\"default\"))\n```\n\n### Anti-pattern\n\n```python\n# WRONG: __init__ does heavy I/O\nclass Registry:\n    def __init__(self, config_path: Path) -> None:\n        data = tomllib.loads(config_path.read_text())  # Heavy I/O\n        self._items = ...\n```\n\n### When This Applies\n\n- Any class backed by file storage (TOML, JSON, etc.)\n- Any class that calls subprocess on construction\n- Any class that makes network requests on construction\n- Any class where tests need to verify behavior without I/O\n\n---\n\n## No Invalid Object Construction\n\n**Never construct objects with invalid states.** Validate at the construction boundary — factory methods, reader functions, parse functions — so that if an object exists, all its fields are valid. Don't allow invalid objects to exist and then guard at every callsite.\n\n### Why\n\n- **Eliminates defensive guards**: Every callsite can trust the object's fields without conversion or None checks\n- **Single validation point**: Validation logic lives in one place, not scattered across N callsites\n- **Type system works for you**: Once constructed, the type tells the full story — `int` means it's numeric, not \"might be numeric\"\n- **Bugs are caught early**: Invalid data is rejected at parse/read time, not at use time\n\n### Correct Pattern\n\n```python\n@dataclass(frozen=True)\nclass PlanRef:\n    plan_id: int          # Always valid — numeric guaranteed\n    url: str\n    provider: str\n\ndef read_plan_ref(folder: Path) -> PlanRef | None:\n    \"\"\"Validate at the boundary. Return None if invalid.\"\"\"\n    data = json.loads(path.read_text())\n    raw_id = data.get(\"plan_id\")\n    if not isinstance(raw_id, int):\n        return None  # Don't construct with invalid state\n    return PlanRef(plan_id=raw_id, url=data[\"url\"], provider=data[\"provider\"])\n```\n\n### Anti-pattern\n\n```python\n@dataclass(frozen=True)\nclass PlanRef:\n    plan_id: str          # Could be \"42\" or \"PROJ-123\" — caller must check\n\n    @property\n    def numeric_plan_id(self) -> int | None:\n        \"\"\"Every callsite must use this instead of plan_id.\"\"\"\n        if self.plan_id.isdigit():\n            return int(self.plan_id)\n        return None\n\n# Result: N callsites with defensive guards\nissue = plan_ref.numeric_plan_id\nif issue is None:\n    log.warning(\"Non-numeric plan_id\")\n    return\n```\n\n### When This Applies\n\n- Dataclasses read from JSON/TOML/YAML (validate during parsing)\n- Objects constructed from user input (validate before construction)\n- Any case where a field's type is broader than the valid domain (e.g., `str` when only digits are valid → use `int`)\n- Factory methods that transform external data into domain objects\n\n### Decision: Return None vs Raise\n\n- **Return `None`**: When invalid data is expected/normal (e.g., missing optional file, legacy format)\n- **Raise exception**: When invalid data indicates a programming error or corrupt state\n\n---\n\n## Backwards Compatibility Philosophy\n\n**Default stance: NO backwards compatibility preservation**\n\nOnly preserve backwards compatibility when:\n\n- Code is clearly part of public API\n- User explicitly requests it\n- Migration cost is prohibitively high (rare)\n\nBenefits:\n\n- Cleaner, maintainable codebase\n- Faster iteration\n- No legacy code accumulation\n- Simpler mental models\n\n---\n\n## See Also\n\nFor detailed guidance on specialized topics:\n\n- **Exception chaining (B904)**: `references/exception-handling.md`\n- **ABC vs Protocol**: `references/interfaces.md`\n- **typing.cast() assertions**: `references/typing-advanced.md`\n- **Import-time side effects, @cache**: `references/module-design.md`\n- **Default parameters, keyword-only args**: `references/api-design.md`\n- **All decision checklists**: `references/checklists.md`\n","numLines":493,"startLine":1,"totalLines":493}}}
{"parentUuid":"8a4c2591-4dd6-4e01-9b94-5e4b66405402","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TcgeEpsGcfzrStbn3cGeWr","type":"tool_result","content":"requires-python = \">=3.11\"","is_error":false}]},"uuid":"10b667e9-6c32-4435-8351-965c0bc9fabb","timestamp":"2026-02-22T14:41:44.205Z","toolUseResult":{"stdout":"requires-python = \">=3.11\"","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"10b667e9-6c32-4435-8351-965c0bc9fabb","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01BpyevbXL5z3ns4FL6z4x7D","type":"message","role":"assistant","content":[{"type":"text","text":"Python 3.11. Now let me start making the changes. The key decision: `planned/` → `plnd/` for both branch names and PR title prefixes. Regexes need to handle both old `planned/` and new `plnd/` patterns for backwards compatibility with existing branches.\n\nLet me make all the source code changes now:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":5756,"cache_read_input_tokens":46404,"cache_creation":{"ephemeral_5m_input_tokens":5756,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHMZh6qnsKxJjB3ktux","type":"assistant","uuid":"92996f5e-9f36-454a-a86a-f6d93cd02eac","timestamp":"2026-02-22T14:41:49.290Z"}
{"parentUuid":"92996f5e-9f36-454a-a86a-f6d93cd02eac","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01BpyevbXL5z3ns4FL6z4x7D","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015Zw5JiLxVtA88YWTnPVMjz","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/constants.py","old_string":"# PR title prefix for plan-originated PRs\nPLANNED_PR_TITLE_PREFIX = \"planned/\"","new_string":"# PR title prefix for plan-originated PRs\nPLANNED_PR_TITLE_PREFIX = \"plnd/\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":5756,"cache_read_input_tokens":46404,"cache_creation":{"ephemeral_5m_input_tokens":5756,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHMZh6qnsKxJjB3ktux","type":"assistant","uuid":"91064406-ee65-430e-adc9-429a0968fa3e","timestamp":"2026-02-22T14:41:51.968Z"}
{"parentUuid":"91064406-ee65-430e-adc9-429a0968fa3e","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015Zw5JiLxVtA88YWTnPVMjz","type":"tool_result","content":"The file /home/runner/work/erk/erk/src/erk/cli/constants.py has been updated successfully."}]},"uuid":"0cb97eea-2bcf-4d0a-9514-2049ebf72a9b","timestamp":"2026-02-22T14:41:52.719Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/constants.py","oldString":"# PR title prefix for plan-originated PRs\nPLANNED_PR_TITLE_PREFIX = \"planned/\"","newString":"# PR title prefix for plan-originated PRs\nPLANNED_PR_TITLE_PREFIX = \"plnd/\"","originalFile":"\"\"\"Shared constants for erk CLI commands.\"\"\"\n\n# GitHub issue label for erk plans\nERK_PLAN_LABEL = \"erk-plan\"\n\n# Title prefix for erk-plan issues (with trailing space for easy stripping)\nERK_PLAN_TITLE_PREFIX = \"[erk-plan] \"\n\n# Plan markdown heading prefix (with trailing space for easy stripping)\nPLAN_HEADING_PREFIX = \"Plan: \"\n\n# PR title prefix for plan-originated PRs\nPLANNED_PR_TITLE_PREFIX = \"planned/\"\n\n# GitHub Actions workflow for remote implementation dispatch\nDISPATCH_WORKFLOW_NAME = \"plan-implement.yml\"\nDISPATCH_WORKFLOW_METADATA_NAME = \"plan-implement\"\n\n# GitHub Actions workflow for remote rebase with conflict resolution\nREBASE_WORKFLOW_NAME = \"pr-fix-conflicts.yml\"\n\n# GitHub Actions workflow for remote PR comment addressing\nPR_ADDRESS_WORKFLOW_NAME = \"pr-address.yml\"\n\n# GitHub Actions workflow for one-shot autonomous execution\nONE_SHOT_WORKFLOW_NAME = \"one-shot.yml\"\n\n# Workflow command name to actual workflow filename mapping\n# This provides a unified interface via `erk launch <name>`\nWORKFLOW_COMMAND_MAP: dict[str, str] = {\n    \"plan-implement\": DISPATCH_WORKFLOW_NAME,  # plan-implement.yml\n    \"pr-fix-conflicts\": REBASE_WORKFLOW_NAME,  # pr-fix-conflicts.yml\n    \"pr-address\": PR_ADDRESS_WORKFLOW_NAME,  # pr-address.yml\n    \"learn\": \"learn.yml\",\n    \"one-shot\": ONE_SHOT_WORKFLOW_NAME,  # one-shot.yml\n}\n\n# Workflow names that trigger the autofix workflow\n# Must match the `name:` field in each .yml file (which should match filename without .yml)\nAUTOFIX_TRIGGER_WORKFLOWS = frozenset(\n    {\n        \"python-format\",\n        \"lint\",\n        \"docs-check\",\n        \"markdown-format\",\n    }\n)\n\n# Documentation extraction tracking label\nDOCS_EXTRACTED_LABEL = \"docs-extracted\"\nDOCS_EXTRACTED_LABEL_DESCRIPTION = \"Session logs analyzed for documentation improvements\"\nDOCS_EXTRACTED_LABEL_COLOR = \"5319E7\"  # Purple\n\n# Learn plan label (for plans that learn from sessions)\nERK_LEARN_LABEL = \"erk-learn\"\n\n# Plan review PR label and title prefix\nPLAN_REVIEW_LABEL = \"erk-plan-review\"\nERK_PLAN_REVIEW_TITLE_PREFIX = \"[erk-plan-review] \"\nERK_LEARN_LABEL_DESCRIPTION = \"Documentation learning plan\"\nERK_LEARN_LABEL_COLOR = \"D93F0B\"  # Orange-red\n","structuredPatch":[{"oldStart":10,"oldLines":7,"newStart":10,"newLines":7,"lines":[" PLAN_HEADING_PREFIX = \"Plan: \""," "," # PR title prefix for plan-originated PRs","-PLANNED_PR_TITLE_PREFIX = \"planned/\"","+PLANNED_PR_TITLE_PREFIX = \"plnd/\""," "," # GitHub Actions workflow for remote implementation dispatch"," DISPATCH_WORKFLOW_NAME = \"plan-implement.yml\""]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"0cb97eea-2bcf-4d0a-9514-2049ebf72a9b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_016UB9kF9hEJjtMieDuqpBia","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SmMzoCBcF8S66AvX9Xb65S","name":"TodoWrite","input":{"todos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"in_progress","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"pending","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"pending","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"pending","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":617,"cache_read_input_tokens":52160,"cache_creation":{"ephemeral_5m_input_tokens":617,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHNC67Y6TksE1aoUcoc","type":"assistant","uuid":"f6706329-b936-428c-af24-c73b4deb6a73","timestamp":"2026-02-22T14:41:59.359Z"}
{"parentUuid":"f6706329-b936-428c-af24-c73b4deb6a73","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SmMzoCBcF8S66AvX9Xb65S","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"f7484423-0fd3-45d2-bdbe-016f64af7b6b","timestamp":"2026-02-22T14:41:59.375Z","toolUseResult":{"oldTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"in_progress","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"pending","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"pending","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"pending","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"pending","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}],"newTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"in_progress","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"pending","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"pending","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"pending","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]}}
{"parentUuid":"f7484423-0fd3-45d2-bdbe-016f64af7b6b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Cx9yRqiAafEhAivHhdMMQK","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `generate_draft_pr_branch_name()` in naming.py:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":52777,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHNgb7YFRrP9o66hXRq","type":"assistant","uuid":"c3489c89-9940-4b4e-bebf-da27168c2d51","timestamp":"2026-02-22T14:42:02.057Z"}
{"parentUuid":"c3489c89-9940-4b4e-bebf-da27168c2d51","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Cx9yRqiAafEhAivHhdMMQK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Qms1zWWwbcKbo5osgz7AFL","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/naming.py","old_string":"def generate_draft_pr_branch_name(\n    title: str,\n    timestamp: datetime,\n    *,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate branch name for draft-PR-backed plans.\n\n    Format: planned/{sanitized_title}-{timestamp}\n    Or with objective: planned/O{objective_id}-{sanitized_title}-{timestamp}\n    Example: planned/fix-auth-bug-01-15-1430\n    Example with objective: planned/O456-fix-auth-bug-01-15-1430\n\n    No P{issue} prefix since the PR number isn't known until after creation.\n\n    Args:\n        title: Plan title to sanitize\n        timestamp: Timestamp for the suffix\n        objective_id: Optional objective ID to encode in branch name\n\n    Returns:\n        Branch name in format planned/{slug}-{timestamp}\n\n    Examples:\n        >>> from datetime import datetime\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n        ... )\n        \"planned/fix-auth-bug-01-15-1430\"\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456\n        ... )\n        \"planned/O456-fix-auth-bug-01-15-1430\"\n    \"\"\"\n    prefix = \"planned/\"","new_string":"def generate_draft_pr_branch_name(\n    title: str,\n    timestamp: datetime,\n    *,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate branch name for draft-PR-backed plans.\n\n    Format: plnd/{sanitized_title}-{timestamp}\n    Or with objective: plnd/O{objective_id}-{sanitized_title}-{timestamp}\n    Example: plnd/fix-auth-bug-01-15-1430\n    Example with objective: plnd/O456-fix-auth-bug-01-15-1430\n\n    No P{issue} prefix since the PR number isn't known until after creation.\n\n    Args:\n        title: Plan title to sanitize\n        timestamp: Timestamp for the suffix\n        objective_id: Optional objective ID to encode in branch name\n\n    Returns:\n        Branch name in format plnd/{slug}-{timestamp}\n\n    Examples:\n        >>> from datetime import datetime\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n        ... )\n        \"plnd/fix-auth-bug-01-15-1430\"\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456\n        ... )\n        \"plnd/O456-fix-auth-bug-01-15-1430\"\n    \"\"\"\n    prefix = \"plnd/\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":52777,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHNgb7YFRrP9o66hXRq","type":"assistant","uuid":"8823a2d7-d834-452b-b57a-bab9d5abe268","timestamp":"2026-02-22T14:42:11.397Z"}
{"parentUuid":"8823a2d7-d834-452b-b57a-bab9d5abe268","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Qms1zWWwbcKbo5osgz7AFL","type":"tool_result","content":"The file /home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/naming.py has been updated successfully."}]},"uuid":"35a39cb1-3892-402f-b7a0-ca11f2ba1aea","timestamp":"2026-02-22T14:42:12.094Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/naming.py","oldString":"def generate_draft_pr_branch_name(\n    title: str,\n    timestamp: datetime,\n    *,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate branch name for draft-PR-backed plans.\n\n    Format: planned/{sanitized_title}-{timestamp}\n    Or with objective: planned/O{objective_id}-{sanitized_title}-{timestamp}\n    Example: planned/fix-auth-bug-01-15-1430\n    Example with objective: planned/O456-fix-auth-bug-01-15-1430\n\n    No P{issue} prefix since the PR number isn't known until after creation.\n\n    Args:\n        title: Plan title to sanitize\n        timestamp: Timestamp for the suffix\n        objective_id: Optional objective ID to encode in branch name\n\n    Returns:\n        Branch name in format planned/{slug}-{timestamp}\n\n    Examples:\n        >>> from datetime import datetime\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n        ... )\n        \"planned/fix-auth-bug-01-15-1430\"\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456\n        ... )\n        \"planned/O456-fix-auth-bug-01-15-1430\"\n    \"\"\"\n    prefix = \"planned/\"","newString":"def generate_draft_pr_branch_name(\n    title: str,\n    timestamp: datetime,\n    *,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate branch name for draft-PR-backed plans.\n\n    Format: plnd/{sanitized_title}-{timestamp}\n    Or with objective: plnd/O{objective_id}-{sanitized_title}-{timestamp}\n    Example: plnd/fix-auth-bug-01-15-1430\n    Example with objective: plnd/O456-fix-auth-bug-01-15-1430\n\n    No P{issue} prefix since the PR number isn't known until after creation.\n\n    Args:\n        title: Plan title to sanitize\n        timestamp: Timestamp for the suffix\n        objective_id: Optional objective ID to encode in branch name\n\n    Returns:\n        Branch name in format plnd/{slug}-{timestamp}\n\n    Examples:\n        >>> from datetime import datetime\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n        ... )\n        \"plnd/fix-auth-bug-01-15-1430\"\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456\n        ... )\n        \"plnd/O456-fix-auth-bug-01-15-1430\"\n    \"\"\"\n    prefix = \"plnd/\"","originalFile":"\"\"\"Naming utilities for filenames and worktree names.\n\nThis module provides pure utility functions for transforming titles and names\ninto sanitized, filesystem-safe identifiers. All functions are pure (no I/O)\nand follow LBYL patterns.\n\nFunctions that require git operations accept a git_ops parameter via dependency\ninjection to maintain separation from I/O concerns.\n\"\"\"\n\nimport re\nimport unicodedata\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom pathlib import Path\n\n_SAFE_COMPONENT_RE = re.compile(r\"[^A-Za-z0-9_/-]+\")\n\n# Date suffix format for plan-derived worktree names: -YY-MM-DD-HHMM\nWORKTREE_DATE_SUFFIX_FORMAT = \"%y-%m-%d-%H%M\"\n\n# Branch timestamp suffix format: -MM-DD-HHMM (appended after truncation)\nBRANCH_TIMESTAMP_SUFFIX_FORMAT = \"%m-%d-%H%M\"\n\n# Regex pattern to detect existing timestamp suffix (MM-DD-HHMM)\n_TIMESTAMP_SUFFIX_PATTERN = re.compile(r\"-\\d{2}-\\d{2}-\\d{4}$\")\n\n\ndef has_timestamp_suffix(name: str) -> bool:\n    \"\"\"Check if a name already ends with a timestamp suffix (-MM-DD-HHMM).\n\n    Args:\n        name: Branch or worktree name to check\n\n    Returns:\n        True if name ends with timestamp suffix pattern, False otherwise\n\n    Examples:\n        >>> has_timestamp_suffix(\"42-feature-01-15-1430\")\n        True\n        >>> has_timestamp_suffix(\"42-feature\")\n        False\n        >>> has_timestamp_suffix(\"42-feature-branch\")\n        False\n    \"\"\"\n    return _TIMESTAMP_SUFFIX_PATTERN.search(name) is not None\n\n\ndef format_branch_timestamp_suffix(dt: datetime) -> str:\n    \"\"\"Format a datetime as a branch timestamp suffix.\n\n    Returns a suffix in the format -MM-DD-HHMM to be appended to branch names.\n\n    Args:\n        dt: Datetime to format\n\n    Returns:\n        Formatted suffix string (e.g., \"-01-15-1430\")\n\n    Examples:\n        >>> from datetime import datetime\n        >>> format_branch_timestamp_suffix(datetime(2024, 1, 15, 14, 30))\n        \"-01-15-1430\"\n        >>> format_branch_timestamp_suffix(datetime(2024, 12, 31, 23, 59))\n        \"-12-31-2359\"\n    \"\"\"\n    return f\"-{dt.strftime(BRANCH_TIMESTAMP_SUFFIX_FORMAT)}\"\n\n\n_OBJECTIVE_SLUG_PATTERN = re.compile(r\"^[a-z][a-z0-9]*(-[a-z0-9]+)*$\")\n\n# Plan title constraints\n_PLAN_TITLE_MIN_LENGTH = 5\n_PLAN_TITLE_MAX_LENGTH = 100\n\n\n@dataclass(frozen=True)\nclass ValidPlanTitle:\n    \"\"\"Validation success for a plan title.\n\n    Attributes:\n        title: The validated title value.\n    \"\"\"\n\n    title: str\n\n\n@dataclass(frozen=True)\nclass InvalidPlanTitle:\n    \"\"\"Validation failure for a plan title.\n\n    Attributes:\n        raw_title: The original title value that failed validation.\n        reason: A short description of why validation failed.\n    \"\"\"\n\n    raw_title: str\n    reason: str\n\n    @property\n    def error_type(self) -> str:\n        return \"invalid-plan-title\"\n\n    @property\n    def message(self) -> str:\n        \"\"\"Full error message with rules, actual value, and examples.\n\n        Designed so an agent receiving this message can self-correct.\n        \"\"\"\n        return (\n            f\"Invalid plan title: {self.reason}\\n\"\n            f\"  Actual value: {self.raw_title!r}\\n\"\n            f\"  Rules:\\n\"\n            f\"    - {_PLAN_TITLE_MIN_LENGTH}-{_PLAN_TITLE_MAX_LENGTH} characters\\n\"\n            f\"    - Must contain at least one alphabetic character\\n\"\n            f\"    - Must retain meaningful content after sanitization\\n\"\n            f\"      (emojis, special characters, and accents are stripped)\\n\"\n            f\"  Valid examples: Add User Authentication,\"\n            f\" Refactor Gateway Layer\\n\"\n            f\"  Invalid examples: \\U0001f680\\U0001f389, 123, #!@, Plan\"\n        )\n\n\ndef validate_plan_title(title: str) -> ValidPlanTitle | InvalidPlanTitle:\n    \"\"\"Validate a plan title against minimum content requirements.\n\n    This is an agent-facing validation gate. It ensures plan titles have enough\n    meaningful content before they are used to generate filenames, branch names,\n    or issue titles. Human-facing paths (like generate_filename_from_title) can\n    still transform arbitrary input silently.\n\n    Returns ValidPlanTitle on success, or InvalidPlanTitle describing the failure.\n\n    Args:\n        title: The plan title string to validate.\n\n    Returns:\n        ValidPlanTitle if valid, InvalidPlanTitle if invalid.\n\n    Examples:\n        >>> validate_plan_title(\"Add User Authentication\")\n        ValidPlanTitle(title='Add User Authentication')\n        >>> validate_plan_title(\"\")\n        InvalidPlanTitle(raw_title='', reason='...')\n        >>> validate_plan_title(\"🚀🎉\")\n        InvalidPlanTitle(raw_title='🚀🎉', reason='...')\n    \"\"\"\n    stripped = title.strip()\n\n    if not stripped:\n        return InvalidPlanTitle(raw_title=title, reason=\"Title is empty or whitespace-only\")\n\n    if len(stripped) < _PLAN_TITLE_MIN_LENGTH:\n        return InvalidPlanTitle(\n            raw_title=title,\n            reason=f\"Too short ({len(stripped)} characters, minimum {_PLAN_TITLE_MIN_LENGTH})\",\n        )\n\n    if len(stripped) > _PLAN_TITLE_MAX_LENGTH:\n        return InvalidPlanTitle(\n            raw_title=title,\n            reason=f\"Too long ({len(stripped)} characters, maximum {_PLAN_TITLE_MAX_LENGTH})\",\n        )\n\n    if not any(c.isalpha() for c in stripped):\n        return InvalidPlanTitle(\n            raw_title=title,\n            reason=\"Must contain at least one alphabetic character\",\n        )\n\n    # Check that sanitization retains meaningful content.\n    # generate_filename_from_title strips emojis, accents, and special chars.\n    # If the result is \"plan.md\" (the fallback), the title has no usable content.\n    filename = generate_filename_from_title(stripped)\n    if filename == \"plan.md\":\n        return InvalidPlanTitle(\n            raw_title=title,\n            reason=\"No usable content after sanitization (only emojis or special characters)\",\n        )\n\n    return ValidPlanTitle(title=stripped)\n\n\n@dataclass(frozen=True)\nclass ValidObjectiveSlug:\n    \"\"\"Validation success for an objective slug.\n\n    Attributes:\n        slug: The validated slug value.\n    \"\"\"\n\n    slug: str\n\n\n@dataclass(frozen=True)\nclass InvalidObjectiveSlug:\n    \"\"\"Validation failure for an objective slug.\n\n    Attributes:\n        raw_slug: The original slug value that failed validation.\n        reason: A short description of why validation failed.\n    \"\"\"\n\n    raw_slug: str\n    reason: str\n\n    @property\n    def message(self) -> str:\n        \"\"\"Full error message with pattern, rules, actual value, and examples.\n\n        Designed so an agent receiving this message can self-correct.\n        \"\"\"\n        return (\n            f\"Invalid objective slug: {self.reason}\\n\"\n            f\"  Actual value: {self.raw_slug!r}\\n\"\n            f\"  Pattern: ^[a-z][a-z0-9]*(-[a-z0-9]+)*$\\n\"\n            f\"  Rules:\\n\"\n            f\"    - 3-40 characters\\n\"\n            f\"    - Lowercase letters and digits only\\n\"\n            f\"    - Must start with a letter\\n\"\n            f\"    - Hyphens allowed between words (no consecutive hyphens)\\n\"\n            f\"  Valid examples: build-auth-system, refactor-gateway, add-dark-mode\\n\"\n            f\"  Invalid examples: Build-Auth, 123-start, my--slug, ab\"\n        )\n\n\ndef validate_objective_slug(slug: str) -> ValidObjectiveSlug | InvalidObjectiveSlug:\n    \"\"\"Validate an objective slug against the required format.\n\n    Returns ValidObjectiveSlug on success, or InvalidObjectiveSlug describing the failure.\n\n    Args:\n        slug: The slug string to validate.\n\n    Returns:\n        ValidObjectiveSlug if valid, InvalidObjectiveSlug if invalid.\n\n    Examples:\n        >>> validate_objective_slug(\"build-auth-system\")  # valid\n        ValidObjectiveSlug(slug='build-auth-system')\n        >>> validate_objective_slug(\"AB\")  # invalid\n        InvalidObjectiveSlug(raw_slug='AB', reason='...')\n    \"\"\"\n    if len(slug) < 3:\n        return InvalidObjectiveSlug(raw_slug=slug, reason=\"Too short (minimum 3 characters)\")\n    if len(slug) > 40:\n        return InvalidObjectiveSlug(raw_slug=slug, reason=\"Too long (maximum 40 characters)\")\n    if _OBJECTIVE_SLUG_PATTERN.match(slug) is None:\n        return InvalidObjectiveSlug(raw_slug=slug, reason=\"Does not match required pattern\")\n    return ValidObjectiveSlug(slug=slug)\n\n\ndef sanitize_worktree_name(name: str) -> str:\n    \"\"\"Sanitize a worktree name for use as a directory name.\n\n    - If name already has timestamp suffix (-MM-DD-HHMM), returns as-is (idempotent)\n    - Lowercases input\n    - Replaces underscores with hyphens\n    - Replaces characters outside `[A-Za-z0-9-]` with `-`\n    - Collapses consecutive `-`\n    - Strips leading/trailing `-`\n    - Truncates to 31 characters maximum (matches branch component sanitization)\n    Returns `\"work\"` if the result is empty.\n\n    The 31-character limit ensures worktree names match their corresponding branch\n    names, maintaining consistency across the worktree/branch model.\n\n    Args:\n        name: Arbitrary string to sanitize\n\n    Returns:\n        Sanitized worktree name (max 31 chars, unless timestamp already present)\n\n    Examples:\n        >>> sanitize_worktree_name(\"My_Feature\")\n        \"my-feature\"\n        >>> sanitize_worktree_name(\"a\" * 40)\n        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"  # 31 chars\n        >>> sanitize_worktree_name(\"42-feature-01-15-1430\")\n        \"42-feature-01-15-1430\"  # timestamp preserved (idempotent)\n    \"\"\"\n    # If name already has a timestamp suffix, return as-is (idempotent)\n    if has_timestamp_suffix(name):\n        return name\n\n    lowered = name.strip().lower()\n    # Replace underscores with hyphens\n    replaced_underscores = lowered.replace(\"_\", \"-\")\n    # Replace unsafe characters with hyphens\n    replaced = re.sub(r\"[^a-z0-9-]+\", \"-\", replaced_underscores)\n    # Collapse consecutive hyphens\n    collapsed = re.sub(r\"-+\", \"-\", replaced)\n    # Strip leading/trailing hyphens\n    trimmed = collapsed.strip(\"-\")\n    result = trimmed or \"work\"\n\n    # Truncate to 31 characters and strip trailing hyphens\n    if len(result) > 31:\n        result = result[:31].rstrip(\"-\")\n\n    return result\n\n\ndef sanitize_branch_component(name: str) -> str:\n    \"\"\"Return a sanitized, predictable branch component from an arbitrary name.\n\n    - Lowercases input\n    - Replaces characters outside `[A-Za-z0-9_/-]` with `-`\n    - Collapses consecutive `-`\n    - Strips leading/trailing `-` and `/`\n    - Truncates to 31 characters maximum (matches worktree behavior)\n    Returns `\"work\"` if the result is empty.\n\n    Args:\n        name: Arbitrary string to sanitize\n\n    Returns:\n        Sanitized branch component name (max 31 chars)\n\n    Examples:\n        >>> sanitize_branch_component(\"My Feature!\")\n        \"my-feature\"\n        >>> sanitize_branch_component(\"fix/bug-123\")\n        \"fix/bug-123\"\n        >>> sanitize_branch_component(\"\")\n        \"work\"\n        >>> sanitize_branch_component(\"a\" * 40)\n        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"  # 31 chars\n    \"\"\"\n    lowered = name.strip().lower()\n    replaced = _SAFE_COMPONENT_RE.sub(\"-\", lowered)\n    collapsed = re.sub(r\"-+\", \"-\", replaced)\n    trimmed = collapsed.strip(\"-/\")\n    result = trimmed or \"work\"\n\n    # Truncate to 31 characters and strip trailing hyphens (matching worktree behavior)\n    if len(result) > 31:\n        result = result[:31].rstrip(\"-\")\n\n    return result\n\n\ndef generate_filename_from_title(title: str) -> str:\n    \"\"\"Convert title to kebab-case filename with -plan.md suffix.\n\n    Comprehensive transformation:\n    1. Lowercase\n    2. Replace spaces with hyphens\n    3. Unicode normalization (NFD)\n    4. Remove emojis and non-alphanumeric characters (except hyphens)\n    5. Collapse consecutive hyphens\n    6. Strip leading/trailing hyphens\n    7. Validate at least one alphanumeric character remains\n    8. Append \"-plan.md\"\n\n    Returns \"plan.md\" if title is empty after cleanup.\n\n    Args:\n        title: Plan title to convert\n\n    Returns:\n        Sanitized filename ending with -plan.md\n\n    Example:\n        >>> generate_filename_from_title(\"User Auth Feature\")\n        'user-auth-feature-plan.md'\n\n        >>> generate_filename_from_title(\"Fix: Bug #123\")\n        'fix-bug-123-plan.md'\n\n        >>> generate_filename_from_title(\"🚀 Feature Launch 🎉\")\n        'feature-launch-plan.md'\n\n        >>> generate_filename_from_title(\"café\")\n        'cafe-plan.md'\n    \"\"\"\n    # Step 1: Lowercase and strip whitespace\n    lowered = title.strip().lower()\n\n    # Step 2: Unicode normalization (NFD form for decomposition)\n    # Decompose combined characters (é → e + ´)\n    normalized = unicodedata.normalize(\"NFD\", lowered)\n\n    # Step 3: Remove emojis and non-ASCII characters, convert to ASCII\n    # Keep only ASCII alphanumeric, spaces, and hyphens\n    cleaned = \"\"\n    for char in normalized:\n        # Keep ASCII alphanumeric, spaces, and hyphens\n        if ord(char) < 128 and (char.isalnum() or char in (\" \", \"-\")):\n            cleaned += char\n        # Skip combining marks (accents) and emoji\n        # Skip non-ASCII characters (CJK, emoji, special symbols)\n\n    # Step 4: Replace spaces with hyphens\n    replaced = cleaned.replace(\" \", \"-\")\n\n    # Step 5: Collapse consecutive hyphens\n    collapsed = re.sub(r\"-+\", \"-\", replaced)\n\n    # Step 6: Strip leading/trailing hyphens\n    trimmed = collapsed.strip(\"-\")\n\n    # Step 7: Validate at least one alphanumeric character\n    if not trimmed or not any(c.isalnum() for c in trimmed):\n        return \"plan.md\"\n\n    return f\"{trimmed}-plan.md\"\n\n\ndef strip_plan_from_filename(filename: str) -> str:\n    \"\"\"Remove 'plan' or 'implementation plan' from a filename stem intelligently.\n\n    Handles case-insensitive matching and common separators (-, _, space).\n    If removal would leave empty string, returns original unchanged.\n\n    Args:\n        filename: Filename stem (without extension) to process\n\n    Returns:\n        Filename with plan-related words removed, or original if would be empty\n\n    Examples:\n        >>> strip_plan_from_filename(\"devclikit-extraction-plan\")\n        \"devclikit-extraction\"\n        >>> strip_plan_from_filename(\"my-feature-plan\")\n        \"my-feature\"\n        >>> strip_plan_from_filename(\"implementation-plan-for-auth\")\n        \"for-auth\"\n        >>> strip_plan_from_filename(\"feature_implementation_plan\")\n        \"feature\"\n        >>> strip_plan_from_filename(\"plan\")\n        \"plan\"  # preserved - would be empty\n    \"\"\"\n    original_trimmed = filename.strip(\"-_ \\t\\n\\r\")\n    original_is_plan = original_trimmed.casefold() == \"plan\" if original_trimmed else False\n\n    # First, handle \"implementation plan\" with various separators\n    # Pattern matches \"implementation\" + separator + \"plan\" as complete words\n    impl_pattern = r\"(^|[-_\\s])(implementation)([-_\\s])(plan)([-_\\s]|$)\"\n\n    def replace_impl_plan(match: re.Match[str]) -> str:\n        prefix = match.group(1)\n        implementation_word = match.group(2)  # Preserves original case\n        suffix = match.group(5)\n\n        if suffix == \"\" and prefix:\n            prefix_start = match.start(1)\n            preceding_segment = filename[:prefix_start]\n            trimmed_segment = preceding_segment.strip(\"-_ \\t\\n\\r\")\n            if trimmed_segment:\n                preceding_tokens = re.split(r\"[-_\\s]+\", trimmed_segment)\n                if preceding_tokens:\n                    preceding_token = preceding_tokens[-1]\n                    if preceding_token.casefold() == \"plan\":\n                        return f\"{prefix}{implementation_word}\"\n\n        # If entire string is \"implementation-plan\", keep just \"implementation\"\n        if not prefix and not suffix:\n            return implementation_word\n\n        # If in the middle, preserve one separator\n        if prefix and suffix:\n            return prefix if prefix.strip() else suffix\n\n        # At start or end: remove it and the adjacent separator\n        return \"\"\n\n    cleaned = re.sub(impl_pattern, replace_impl_plan, filename, flags=re.IGNORECASE)\n\n    # Then handle standalone \"plan\" as a complete word\n    plan_pattern = r\"(^|[-_\\s])(plan)([-_\\s]|$)\"\n\n    def replace_plan(match: re.Match[str]) -> str:\n        prefix = match.group(1)\n        suffix = match.group(3)\n\n        # If both prefix and suffix are empty (entire string is \"plan\"), keep it\n        if not prefix and not suffix:\n            return \"plan\"\n\n        # If plan is in the middle, preserve one separator\n        if prefix and suffix:\n            # Use the prefix separator if available, otherwise use suffix\n            return prefix if prefix.strip() else suffix\n\n        # Plan at start or end: remove it and the adjacent separator\n        return \"\"\n\n    cleaned = re.sub(plan_pattern, replace_plan, cleaned, flags=re.IGNORECASE)\n\n    def clean_separators(text: str) -> str:\n        stripped = text.strip(\"-_ \\t\\n\\r\")\n        stripped = re.sub(r\"--+\", \"-\", stripped)\n        stripped = re.sub(r\"__+\", \"_\", stripped)\n        stripped = re.sub(r\"\\s+\", \" \", stripped)\n        return stripped\n\n    cleaned = clean_separators(cleaned)\n\n    plan_only_cleaned = clean_separators(\n        re.sub(plan_pattern, replace_plan, filename, flags=re.IGNORECASE)\n    )\n\n    if (\n        cleaned.casefold() == \"plan\"\n        and plan_only_cleaned\n        and plan_only_cleaned.casefold() != \"plan\"\n    ):\n        cleaned = plan_only_cleaned\n\n    # If stripping left us with nothing or just \"plan\", preserve original\n    if not cleaned or (cleaned.casefold() == \"plan\" and original_is_plan):\n        return filename\n\n    return cleaned\n\n\ndef extract_trailing_number(name: str) -> tuple[str, int | None]:\n    r\"\"\"Extract trailing number from a name.\n\n    Detects trailing numbers in names using regex pattern `^(.+?)-(\\d+)$`.\n    Returns tuple of (base_name, number) or (name, None).\n\n    Args:\n        name: Name to parse\n\n    Returns:\n        Tuple of (base_name, number) if trailing number found, else (name, None)\n\n    Examples:\n        >>> extract_trailing_number(\"my-feature\")\n        (\"my-feature\", None)\n        >>> extract_trailing_number(\"my-feature-2\")\n        (\"my-feature\", 2)\n        >>> extract_trailing_number(\"fix-42\")\n        (\"fix\", 42)\n    \"\"\"\n    match = re.match(r\"^(.+?)-(\\d+)$\", name)\n    if match:\n        base_name = match.group(1)\n        number = int(match.group(2))\n        return (base_name, number)\n    return (name, None)\n\n\ndef extract_leading_issue_number(branch_name: str) -> int | None:\n    \"\"\"Extract leading issue number from a branch name.\n\n    Branch names follow the pattern: P{issue_number}-{slug}-{timestamp}\n    Examples: \"P2382-convert-erk-create-raw-ext-12-05-2359\"\n\n    Also supports legacy format without \"P\" prefix for backwards compatibility.\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Issue number if branch starts with optional \"P\" followed by digits and hyphen, else None\n\n    Examples:\n        >>> extract_leading_issue_number(\"P2382-convert-erk-create-raw-ext-12-05-2359\")\n        2382\n        >>> extract_leading_issue_number(\"P42-fix-bug\")\n        42\n        >>> extract_leading_issue_number(\"2382-convert-erk-create-raw-ext-12-05-2359\")\n        2382\n        >>> extract_leading_issue_number(\"42-fix-bug\")\n        42\n        >>> extract_leading_issue_number(\"feature-branch\")\n        None\n        >>> extract_leading_issue_number(\"master\")\n        None\n    \"\"\"\n    match = re.match(r\"^[Pp]?(\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n\n\ndef extract_objective_number(branch_name: str) -> int | None:\n    \"\"\"Extract objective number from branch name.\n\n    Supports branch naming patterns:\n\n    - Issue-based: ``P{plan}-O{objective}-{slug}-{timestamp}``\n    - Draft-PR (current): ``planned/O{objective}-{slug}-{timestamp}``\n    - Draft-PR (legacy): ``plan/O{objective}-{slug}-{timestamp}``\n\n    Also supports lowercase \"o\" prefix for case-insensitive matching.\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Objective number if branch contains O{number} after the prefix, else None\n\n    Examples:\n        >>> extract_objective_number(\"P123-O456-fix-auth-bug-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-o456-fix-bug\")\n        456\n        >>> extract_objective_number(\"planned/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"plan/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-fix-auth-bug-01-15-1430\")\n        None\n        >>> extract_objective_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^(?:[Pp]?\\d+-|plan(?:ned)?/)[Oo](\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n\n\ndef extract_plan_review_issue_number(branch_name: str) -> int | None:\n    \"\"\"Extract issue number from a plan review branch name.\n\n    Plan review branches follow the pattern: planned/review-{issue_number}-{timestamp}\n    Examples: \"planned/review-6214-01-15-1430\"\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Issue number if branch matches planned/review-{number}- pattern, else None\n\n    Examples:\n        >>> extract_plan_review_issue_number(\"planned/review-6214-01-15-1430\")\n        6214\n        >>> extract_plan_review_issue_number(\"planned/review-42-01-28-0930\")\n        42\n        >>> extract_plan_review_issue_number(\"P2382-convert-erk-create-raw-ext\")\n        None\n        >>> extract_plan_review_issue_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^planned/review-(\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n\n\ndef ensure_unique_worktree_name_with_date(base_name: str, worktrees_dir: Path, git_ops) -> str:\n    \"\"\"Ensure unique worktree name with datetime suffix and smart versioning.\n\n    Adds datetime suffix in format -YY-MM-DD-HHMM to the base name.\n    If a worktree with that name exists, increments numeric suffix starting at 2 AFTER the datetime.\n    Uses LBYL pattern: checks via git_ops.worktree.path_exists() before operations.\n\n    This function is used for plan-derived worktrees where multiple worktrees may be\n    created from the same plan, requiring datetime-based disambiguation.\n\n    Args:\n        base_name: Sanitized worktree base name (without datetime suffix)\n        worktrees_dir: Directory containing worktrees\n        git_ops: Git operations interface for checking path existence\n\n    Returns:\n        Guaranteed unique worktree name with datetime suffix\n\n    Examples:\n        First time: \"my-feature\" → \"my-feature-25-11-08-1430\"\n        Duplicate: \"my-feature\" → \"my-feature-25-11-08-1430-2\"\n        Next minute: \"my-feature\" → \"my-feature-25-11-08-1431\"\n    \"\"\"\n    date_suffix = datetime.now().strftime(WORKTREE_DATE_SUFFIX_FORMAT)\n    candidate_name = f\"{base_name}-{date_suffix}\"\n\n    # Check if the base candidate exists\n    if not git_ops.worktree.path_exists(worktrees_dir / candidate_name):\n        return candidate_name\n\n    # Name exists, find next available number (append after date)\n    counter = 2\n    while True:\n        versioned_name = f\"{base_name}-{date_suffix}-{counter}\"\n        if not git_ops.worktree.path_exists(worktrees_dir / versioned_name):\n            return versioned_name\n        counter += 1\n\n\ndef ensure_simple_worktree_name(base_name: str, worktrees_dir: Path, git_ops) -> str:\n    \"\"\"Ensure simple worktree name without date suffix for manual checkouts.\n\n    Returns the simple name if no worktree exists at that path.\n    If a worktree already exists, returns the simple name (caller validates branch match).\n    Uses LBYL pattern: checks via git_ops.worktree.path_exists() before operations.\n\n    This function is used for manual checkout operations where predictable names are\n    desired (e.g., `erk co feature` → `feature` not `feature-25-11-08`).\n\n    Args:\n        base_name: Sanitized worktree base name\n        worktrees_dir: Directory containing worktrees\n        git_ops: Git operations interface for checking path existence\n\n    Returns:\n        Simple worktree name without date suffix\n\n    Examples:\n        First time: \"my-feature\" → \"my-feature\"\n        Exists: \"my-feature\" → \"my-feature\" (caller handles validation)\n    \"\"\"\n    candidate_name = base_name\n    # Always return simple name - collision handling happens in caller\n    return candidate_name\n\n\ndef ensure_unique_worktree_name(base_name: str, worktrees_dir: Path, git_ops) -> str:\n    \"\"\"Deprecated: Use ensure_unique_worktree_name_with_date for plan-derived worktrees.\n\n    This function is kept for backward compatibility but will be removed in the future.\n    New code should use:\n    - ensure_unique_worktree_name_with_date() for plan-derived worktrees\n    - ensure_simple_worktree_name() for manual checkout operations\n    \"\"\"\n    return ensure_unique_worktree_name_with_date(base_name, worktrees_dir, git_ops)\n\n\ndef default_branch_for_worktree(name: str) -> str:\n    \"\"\"Default branch name for a worktree with the given `name`.\n\n    Returns the sanitized name directly (without any prefix).\n\n    Args:\n        name: Worktree name\n\n    Returns:\n        Default branch name (sanitized)\n\n    Examples:\n        >>> default_branch_for_worktree(\"my-feature\")\n        \"my-feature\"\n        >>> default_branch_for_worktree(\"Fix Bug!\")\n        \"fix-bug\"\n    \"\"\"\n    return sanitize_branch_component(name)\n\n\ndef generate_issue_branch_name(\n    issue_number: int | str,\n    title: str,\n    timestamp: datetime,\n    *,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate branch name for issue-based worktree.\n\n    Format: P{issue_number}-{sanitized_title}-{timestamp}\n    Or with objective: P{issue_number}-O{objective_id}-{sanitized_title}-{timestamp}\n    Example: P123-fix-auth-bug-01-15-1430\n    Example with objective: P123-O456-fix-auth-bug-01-15-1430\n\n    The branch name is constructed as:\n    1. P prefix + issue number + hyphen\n    2. If objective_id provided: O prefix + objective_id + hyphen\n    3. Sanitized title (lowercased, special chars replaced)\n    4. Truncated to 31 chars total (before timestamp)\n    5. Timestamp suffix appended (format: -MM-DD-HHMM)\n\n    Args:\n        issue_number: GitHub issue number\n        title: Issue title to sanitize\n        timestamp: Timestamp for the suffix\n        objective_id: Optional objective ID to encode in branch name\n\n    Returns:\n        Branch name in format P{num}-{slug}-{timestamp} or P{num}-O{obj}-{slug}-{timestamp}\n\n    Examples:\n        >>> from datetime import datetime\n        >>> generate_issue_branch_name(\n        ...     123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n        ... )\n        \"P123-fix-auth-bug-01-15-1430\"\n        >>> generate_issue_branch_name(\n        ...     123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456\n        ... )\n        \"P123-O456-fix-auth-bug-01-15-1430\"\n    \"\"\"\n    prefix = f\"P{issue_number}-\"\n    if objective_id is not None:\n        prefix += f\"O{objective_id}-\"\n    sanitized_title = sanitize_worktree_name(title)\n    base_branch_name = (prefix + sanitized_title)[:31].rstrip(\"-\")\n    timestamp_suffix = format_branch_timestamp_suffix(timestamp)\n    return base_branch_name + timestamp_suffix\n\n\ndef generate_draft_pr_branch_name(\n    title: str,\n    timestamp: datetime,\n    *,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate branch name for draft-PR-backed plans.\n\n    Format: planned/{sanitized_title}-{timestamp}\n    Or with objective: planned/O{objective_id}-{sanitized_title}-{timestamp}\n    Example: planned/fix-auth-bug-01-15-1430\n    Example with objective: planned/O456-fix-auth-bug-01-15-1430\n\n    No P{issue} prefix since the PR number isn't known until after creation.\n\n    Args:\n        title: Plan title to sanitize\n        timestamp: Timestamp for the suffix\n        objective_id: Optional objective ID to encode in branch name\n\n    Returns:\n        Branch name in format planned/{slug}-{timestamp}\n\n    Examples:\n        >>> from datetime import datetime\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n        ... )\n        \"planned/fix-auth-bug-01-15-1430\"\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456\n        ... )\n        \"planned/O456-fix-auth-bug-01-15-1430\"\n    \"\"\"\n    prefix = \"planned/\"\n    if objective_id is not None:\n        prefix += f\"O{objective_id}-\"\n    sanitized_title = sanitize_worktree_name(title)\n    base_branch_name = (prefix + sanitized_title)[:31].rstrip(\"-\")\n    timestamp_suffix = format_branch_timestamp_suffix(timestamp)\n    return base_branch_name + timestamp_suffix\n\n\ndef derive_branch_name_from_title(title: str) -> str:\n    \"\"\"Derive branch name from issue/plan title.\n\n    This function matches the logic used by the erk-impl workflow\n    to ensure CLI and workflow produce identical branch names.\n\n    Transforms:\n    - Lowercase\n    - Replace non-alphanumeric (except hyphen) with hyphen\n    - Collapse consecutive hyphens\n    - Strip leading/trailing hyphens\n    - Truncate to 30 chars\n    - Strip trailing hyphen after truncation\n\n    Args:\n        title: Issue or plan title\n\n    Returns:\n        Branch name (max 30 chars, kebab-case)\n\n    Examples:\n        >>> derive_branch_name_from_title(\"My Feature\")\n        \"my-feature\"\n        >>> derive_branch_name_from_title(\"Fix Bug #123!\")\n        \"fix-bug-123\"\n        >>> derive_branch_name_from_title(\"A\" * 40)\n        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"  # 30 chars (one less than sanitize_branch_component)\n    \"\"\"\n    # Convert to lowercase\n    branch_name = title.lower()\n    # Replace non-alphanumeric (except hyphen) with hyphen\n    branch_name = re.sub(r\"[^a-z0-9-]\", \"-\", branch_name)\n    # Collapse consecutive hyphens\n    branch_name = re.sub(r\"-+\", \"-\", branch_name)\n    # Strip leading/trailing hyphens\n    branch_name = branch_name.strip(\"-\")\n\n    # Truncate to 30 chars (matches workflow logic)\n    branch_name = branch_name[:30]\n\n    # Strip trailing hyphen after truncation\n    branch_name = branch_name.rstrip(\"-\")\n\n    return branch_name\n","structuredPatch":[{"oldStart":797,"oldLines":10,"newStart":797,"newLines":10,"lines":[" ) -> str:","     \"\"\"Generate branch name for draft-PR-backed plans."," ","-    Format: planned/{sanitized_title}-{timestamp}","-    Or with objective: planned/O{objective_id}-{sanitized_title}-{timestamp}","-    Example: planned/fix-auth-bug-01-15-1430","-    Example with objective: planned/O456-fix-auth-bug-01-15-1430","+    Format: plnd/{sanitized_title}-{timestamp}","+    Or with objective: plnd/O{objective_id}-{sanitized_title}-{timestamp}","+    Example: plnd/fix-auth-bug-01-15-1430","+    Example with objective: plnd/O456-fix-auth-bug-01-15-1430"," ","     No P{issue} prefix since the PR number isn't known until after creation."," "]},{"oldStart":810,"oldLines":20,"newStart":810,"newLines":20,"lines":["         objective_id: Optional objective ID to encode in branch name"," ","     Returns:","-        Branch name in format planned/{slug}-{timestamp}","+        Branch name in format plnd/{slug}-{timestamp}"," ","     Examples:","         >>> from datetime import datetime","         >>> generate_draft_pr_branch_name(","         ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None","         ... )","-        \"planned/fix-auth-bug-01-15-1430\"","+        \"plnd/fix-auth-bug-01-15-1430\"","         >>> generate_draft_pr_branch_name(","         ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456","         ... )","-        \"planned/O456-fix-auth-bug-01-15-1430\"","+        \"plnd/O456-fix-auth-bug-01-15-1430\"","     \"\"\"","-    prefix = \"planned/\"","+    prefix = \"plnd/\"","     if objective_id is not None:","         prefix += f\"O{objective_id}-\"","     sanitized_title = sanitize_worktree_name(title)"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"35a39cb1-3892-402f-b7a0-ca11f2ba1aea","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Bxsm3uJjB5ZE4E4v3FLnZL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TpPSEb1WGZ5pzY4hqZ1t4A","name":"TodoWrite","input":{"todos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"in_progress","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"pending","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"pending","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":918,"cache_read_input_tokens":53352,"cache_creation":{"ephemeral_5m_input_tokens":918,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHPd25e5ThCEvN9Hj4W","type":"assistant","uuid":"cc4b0019-bae3-4611-a28a-6bedaf85e668","timestamp":"2026-02-22T14:42:17.737Z"}
{"parentUuid":"cc4b0019-bae3-4611-a28a-6bedaf85e668","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TpPSEb1WGZ5pzY4hqZ1t4A","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"2d117d91-f637-49fa-bed4-808d68c3025f","timestamp":"2026-02-22T14:42:17.757Z","toolUseResult":{"oldTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"in_progress","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"pending","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"pending","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"pending","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}],"newTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"in_progress","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"pending","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"pending","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]}}
{"parentUuid":"2d117d91-f637-49fa-bed4-808d68c3025f","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01UB9nANjpUaAJ5cR31DEHmP","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `extract_objective_number()` - the regex needs to match both `planned/` (legacy) and `plnd/` (new):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":54270,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHQ38QiUV554ZsTfzMQ","type":"assistant","uuid":"531147e6-4566-4df0-97f8-c8efe16f9c5f","timestamp":"2026-02-22T14:42:20.225Z"}
{"parentUuid":"531147e6-4566-4df0-97f8-c8efe16f9c5f","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01UB9nANjpUaAJ5cR31DEHmP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GvHRnzya9BBh9YuxusG7dA","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/naming.py","old_string":"def extract_objective_number(branch_name: str) -> int | None:\n    \"\"\"Extract objective number from branch name.\n\n    Supports branch naming patterns:\n\n    - Issue-based: ``P{plan}-O{objective}-{slug}-{timestamp}``\n    - Draft-PR (current): ``planned/O{objective}-{slug}-{timestamp}``\n    - Draft-PR (legacy): ``plan/O{objective}-{slug}-{timestamp}``\n\n    Also supports lowercase \"o\" prefix for case-insensitive matching.\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Objective number if branch contains O{number} after the prefix, else None\n\n    Examples:\n        >>> extract_objective_number(\"P123-O456-fix-auth-bug-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-o456-fix-bug\")\n        456\n        >>> extract_objective_number(\"planned/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"plan/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-fix-auth-bug-01-15-1430\")\n        None\n        >>> extract_objective_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^(?:[Pp]?\\d+-|plan(?:ned)?/)[Oo](\\d+)-\", branch_name)","new_string":"def extract_objective_number(branch_name: str) -> int | None:\n    \"\"\"Extract objective number from branch name.\n\n    Supports branch naming patterns:\n\n    - Issue-based: ``P{plan}-O{objective}-{slug}-{timestamp}``\n    - Draft-PR (current): ``plnd/O{objective}-{slug}-{timestamp}``\n    - Draft-PR (legacy): ``planned/O{objective}-{slug}-{timestamp}``\n    - Draft-PR (legacy): ``plan/O{objective}-{slug}-{timestamp}``\n\n    Also supports lowercase \"o\" prefix for case-insensitive matching.\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Objective number if branch contains O{number} after the prefix, else None\n\n    Examples:\n        >>> extract_objective_number(\"P123-O456-fix-auth-bug-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-o456-fix-bug\")\n        456\n        >>> extract_objective_number(\"plnd/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"planned/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"plan/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-fix-auth-bug-01-15-1430\")\n        None\n        >>> extract_objective_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^(?:[Pp]?\\d+-|pl(?:an(?:ned)?|nd)/)[Oo](\\d+)-\", branch_name)"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":54270,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHQ38QiUV554ZsTfzMQ","type":"assistant","uuid":"8c8ebf88-9b76-44e2-ad14-4ae0eaf6f3e5","timestamp":"2026-02-22T14:42:29.125Z"}
{"parentUuid":"8c8ebf88-9b76-44e2-ad14-4ae0eaf6f3e5","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GvHRnzya9BBh9YuxusG7dA","type":"tool_result","content":"The file /home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/naming.py has been updated successfully."}]},"uuid":"ef6077fc-e561-4766-802f-993910eef93b","timestamp":"2026-02-22T14:42:29.807Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/naming.py","oldString":"def extract_objective_number(branch_name: str) -> int | None:\n    \"\"\"Extract objective number from branch name.\n\n    Supports branch naming patterns:\n\n    - Issue-based: ``P{plan}-O{objective}-{slug}-{timestamp}``\n    - Draft-PR (current): ``planned/O{objective}-{slug}-{timestamp}``\n    - Draft-PR (legacy): ``plan/O{objective}-{slug}-{timestamp}``\n\n    Also supports lowercase \"o\" prefix for case-insensitive matching.\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Objective number if branch contains O{number} after the prefix, else None\n\n    Examples:\n        >>> extract_objective_number(\"P123-O456-fix-auth-bug-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-o456-fix-bug\")\n        456\n        >>> extract_objective_number(\"planned/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"plan/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-fix-auth-bug-01-15-1430\")\n        None\n        >>> extract_objective_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^(?:[Pp]?\\d+-|plan(?:ned)?/)[Oo](\\d+)-\", branch_name)","newString":"def extract_objective_number(branch_name: str) -> int | None:\n    \"\"\"Extract objective number from branch name.\n\n    Supports branch naming patterns:\n\n    - Issue-based: ``P{plan}-O{objective}-{slug}-{timestamp}``\n    - Draft-PR (current): ``plnd/O{objective}-{slug}-{timestamp}``\n    - Draft-PR (legacy): ``planned/O{objective}-{slug}-{timestamp}``\n    - Draft-PR (legacy): ``plan/O{objective}-{slug}-{timestamp}``\n\n    Also supports lowercase \"o\" prefix for case-insensitive matching.\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Objective number if branch contains O{number} after the prefix, else None\n\n    Examples:\n        >>> extract_objective_number(\"P123-O456-fix-auth-bug-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-o456-fix-bug\")\n        456\n        >>> extract_objective_number(\"plnd/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"planned/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"plan/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-fix-auth-bug-01-15-1430\")\n        None\n        >>> extract_objective_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^(?:[Pp]?\\d+-|pl(?:an(?:ned)?|nd)/)[Oo](\\d+)-\", branch_name)","originalFile":"\"\"\"Naming utilities for filenames and worktree names.\n\nThis module provides pure utility functions for transforming titles and names\ninto sanitized, filesystem-safe identifiers. All functions are pure (no I/O)\nand follow LBYL patterns.\n\nFunctions that require git operations accept a git_ops parameter via dependency\ninjection to maintain separation from I/O concerns.\n\"\"\"\n\nimport re\nimport unicodedata\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom pathlib import Path\n\n_SAFE_COMPONENT_RE = re.compile(r\"[^A-Za-z0-9_/-]+\")\n\n# Date suffix format for plan-derived worktree names: -YY-MM-DD-HHMM\nWORKTREE_DATE_SUFFIX_FORMAT = \"%y-%m-%d-%H%M\"\n\n# Branch timestamp suffix format: -MM-DD-HHMM (appended after truncation)\nBRANCH_TIMESTAMP_SUFFIX_FORMAT = \"%m-%d-%H%M\"\n\n# Regex pattern to detect existing timestamp suffix (MM-DD-HHMM)\n_TIMESTAMP_SUFFIX_PATTERN = re.compile(r\"-\\d{2}-\\d{2}-\\d{4}$\")\n\n\ndef has_timestamp_suffix(name: str) -> bool:\n    \"\"\"Check if a name already ends with a timestamp suffix (-MM-DD-HHMM).\n\n    Args:\n        name: Branch or worktree name to check\n\n    Returns:\n        True if name ends with timestamp suffix pattern, False otherwise\n\n    Examples:\n        >>> has_timestamp_suffix(\"42-feature-01-15-1430\")\n        True\n        >>> has_timestamp_suffix(\"42-feature\")\n        False\n        >>> has_timestamp_suffix(\"42-feature-branch\")\n        False\n    \"\"\"\n    return _TIMESTAMP_SUFFIX_PATTERN.search(name) is not None\n\n\ndef format_branch_timestamp_suffix(dt: datetime) -> str:\n    \"\"\"Format a datetime as a branch timestamp suffix.\n\n    Returns a suffix in the format -MM-DD-HHMM to be appended to branch names.\n\n    Args:\n        dt: Datetime to format\n\n    Returns:\n        Formatted suffix string (e.g., \"-01-15-1430\")\n\n    Examples:\n        >>> from datetime import datetime\n        >>> format_branch_timestamp_suffix(datetime(2024, 1, 15, 14, 30))\n        \"-01-15-1430\"\n        >>> format_branch_timestamp_suffix(datetime(2024, 12, 31, 23, 59))\n        \"-12-31-2359\"\n    \"\"\"\n    return f\"-{dt.strftime(BRANCH_TIMESTAMP_SUFFIX_FORMAT)}\"\n\n\n_OBJECTIVE_SLUG_PATTERN = re.compile(r\"^[a-z][a-z0-9]*(-[a-z0-9]+)*$\")\n\n# Plan title constraints\n_PLAN_TITLE_MIN_LENGTH = 5\n_PLAN_TITLE_MAX_LENGTH = 100\n\n\n@dataclass(frozen=True)\nclass ValidPlanTitle:\n    \"\"\"Validation success for a plan title.\n\n    Attributes:\n        title: The validated title value.\n    \"\"\"\n\n    title: str\n\n\n@dataclass(frozen=True)\nclass InvalidPlanTitle:\n    \"\"\"Validation failure for a plan title.\n\n    Attributes:\n        raw_title: The original title value that failed validation.\n        reason: A short description of why validation failed.\n    \"\"\"\n\n    raw_title: str\n    reason: str\n\n    @property\n    def error_type(self) -> str:\n        return \"invalid-plan-title\"\n\n    @property\n    def message(self) -> str:\n        \"\"\"Full error message with rules, actual value, and examples.\n\n        Designed so an agent receiving this message can self-correct.\n        \"\"\"\n        return (\n            f\"Invalid plan title: {self.reason}\\n\"\n            f\"  Actual value: {self.raw_title!r}\\n\"\n            f\"  Rules:\\n\"\n            f\"    - {_PLAN_TITLE_MIN_LENGTH}-{_PLAN_TITLE_MAX_LENGTH} characters\\n\"\n            f\"    - Must contain at least one alphabetic character\\n\"\n            f\"    - Must retain meaningful content after sanitization\\n\"\n            f\"      (emojis, special characters, and accents are stripped)\\n\"\n            f\"  Valid examples: Add User Authentication,\"\n            f\" Refactor Gateway Layer\\n\"\n            f\"  Invalid examples: \\U0001f680\\U0001f389, 123, #!@, Plan\"\n        )\n\n\ndef validate_plan_title(title: str) -> ValidPlanTitle | InvalidPlanTitle:\n    \"\"\"Validate a plan title against minimum content requirements.\n\n    This is an agent-facing validation gate. It ensures plan titles have enough\n    meaningful content before they are used to generate filenames, branch names,\n    or issue titles. Human-facing paths (like generate_filename_from_title) can\n    still transform arbitrary input silently.\n\n    Returns ValidPlanTitle on success, or InvalidPlanTitle describing the failure.\n\n    Args:\n        title: The plan title string to validate.\n\n    Returns:\n        ValidPlanTitle if valid, InvalidPlanTitle if invalid.\n\n    Examples:\n        >>> validate_plan_title(\"Add User Authentication\")\n        ValidPlanTitle(title='Add User Authentication')\n        >>> validate_plan_title(\"\")\n        InvalidPlanTitle(raw_title='', reason='...')\n        >>> validate_plan_title(\"🚀🎉\")\n        InvalidPlanTitle(raw_title='🚀🎉', reason='...')\n    \"\"\"\n    stripped = title.strip()\n\n    if not stripped:\n        return InvalidPlanTitle(raw_title=title, reason=\"Title is empty or whitespace-only\")\n\n    if len(stripped) < _PLAN_TITLE_MIN_LENGTH:\n        return InvalidPlanTitle(\n            raw_title=title,\n            reason=f\"Too short ({len(stripped)} characters, minimum {_PLAN_TITLE_MIN_LENGTH})\",\n        )\n\n    if len(stripped) > _PLAN_TITLE_MAX_LENGTH:\n        return InvalidPlanTitle(\n            raw_title=title,\n            reason=f\"Too long ({len(stripped)} characters, maximum {_PLAN_TITLE_MAX_LENGTH})\",\n        )\n\n    if not any(c.isalpha() for c in stripped):\n        return InvalidPlanTitle(\n            raw_title=title,\n            reason=\"Must contain at least one alphabetic character\",\n        )\n\n    # Check that sanitization retains meaningful content.\n    # generate_filename_from_title strips emojis, accents, and special chars.\n    # If the result is \"plan.md\" (the fallback), the title has no usable content.\n    filename = generate_filename_from_title(stripped)\n    if filename == \"plan.md\":\n        return InvalidPlanTitle(\n            raw_title=title,\n            reason=\"No usable content after sanitization (only emojis or special characters)\",\n        )\n\n    return ValidPlanTitle(title=stripped)\n\n\n@dataclass(frozen=True)\nclass ValidObjectiveSlug:\n    \"\"\"Validation success for an objective slug.\n\n    Attributes:\n        slug: The validated slug value.\n    \"\"\"\n\n    slug: str\n\n\n@dataclass(frozen=True)\nclass InvalidObjectiveSlug:\n    \"\"\"Validation failure for an objective slug.\n\n    Attributes:\n        raw_slug: The original slug value that failed validation.\n        reason: A short description of why validation failed.\n    \"\"\"\n\n    raw_slug: str\n    reason: str\n\n    @property\n    def message(self) -> str:\n        \"\"\"Full error message with pattern, rules, actual value, and examples.\n\n        Designed so an agent receiving this message can self-correct.\n        \"\"\"\n        return (\n            f\"Invalid objective slug: {self.reason}\\n\"\n            f\"  Actual value: {self.raw_slug!r}\\n\"\n            f\"  Pattern: ^[a-z][a-z0-9]*(-[a-z0-9]+)*$\\n\"\n            f\"  Rules:\\n\"\n            f\"    - 3-40 characters\\n\"\n            f\"    - Lowercase letters and digits only\\n\"\n            f\"    - Must start with a letter\\n\"\n            f\"    - Hyphens allowed between words (no consecutive hyphens)\\n\"\n            f\"  Valid examples: build-auth-system, refactor-gateway, add-dark-mode\\n\"\n            f\"  Invalid examples: Build-Auth, 123-start, my--slug, ab\"\n        )\n\n\ndef validate_objective_slug(slug: str) -> ValidObjectiveSlug | InvalidObjectiveSlug:\n    \"\"\"Validate an objective slug against the required format.\n\n    Returns ValidObjectiveSlug on success, or InvalidObjectiveSlug describing the failure.\n\n    Args:\n        slug: The slug string to validate.\n\n    Returns:\n        ValidObjectiveSlug if valid, InvalidObjectiveSlug if invalid.\n\n    Examples:\n        >>> validate_objective_slug(\"build-auth-system\")  # valid\n        ValidObjectiveSlug(slug='build-auth-system')\n        >>> validate_objective_slug(\"AB\")  # invalid\n        InvalidObjectiveSlug(raw_slug='AB', reason='...')\n    \"\"\"\n    if len(slug) < 3:\n        return InvalidObjectiveSlug(raw_slug=slug, reason=\"Too short (minimum 3 characters)\")\n    if len(slug) > 40:\n        return InvalidObjectiveSlug(raw_slug=slug, reason=\"Too long (maximum 40 characters)\")\n    if _OBJECTIVE_SLUG_PATTERN.match(slug) is None:\n        return InvalidObjectiveSlug(raw_slug=slug, reason=\"Does not match required pattern\")\n    return ValidObjectiveSlug(slug=slug)\n\n\ndef sanitize_worktree_name(name: str) -> str:\n    \"\"\"Sanitize a worktree name for use as a directory name.\n\n    - If name already has timestamp suffix (-MM-DD-HHMM), returns as-is (idempotent)\n    - Lowercases input\n    - Replaces underscores with hyphens\n    - Replaces characters outside `[A-Za-z0-9-]` with `-`\n    - Collapses consecutive `-`\n    - Strips leading/trailing `-`\n    - Truncates to 31 characters maximum (matches branch component sanitization)\n    Returns `\"work\"` if the result is empty.\n\n    The 31-character limit ensures worktree names match their corresponding branch\n    names, maintaining consistency across the worktree/branch model.\n\n    Args:\n        name: Arbitrary string to sanitize\n\n    Returns:\n        Sanitized worktree name (max 31 chars, unless timestamp already present)\n\n    Examples:\n        >>> sanitize_worktree_name(\"My_Feature\")\n        \"my-feature\"\n        >>> sanitize_worktree_name(\"a\" * 40)\n        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"  # 31 chars\n        >>> sanitize_worktree_name(\"42-feature-01-15-1430\")\n        \"42-feature-01-15-1430\"  # timestamp preserved (idempotent)\n    \"\"\"\n    # If name already has a timestamp suffix, return as-is (idempotent)\n    if has_timestamp_suffix(name):\n        return name\n\n    lowered = name.strip().lower()\n    # Replace underscores with hyphens\n    replaced_underscores = lowered.replace(\"_\", \"-\")\n    # Replace unsafe characters with hyphens\n    replaced = re.sub(r\"[^a-z0-9-]+\", \"-\", replaced_underscores)\n    # Collapse consecutive hyphens\n    collapsed = re.sub(r\"-+\", \"-\", replaced)\n    # Strip leading/trailing hyphens\n    trimmed = collapsed.strip(\"-\")\n    result = trimmed or \"work\"\n\n    # Truncate to 31 characters and strip trailing hyphens\n    if len(result) > 31:\n        result = result[:31].rstrip(\"-\")\n\n    return result\n\n\ndef sanitize_branch_component(name: str) -> str:\n    \"\"\"Return a sanitized, predictable branch component from an arbitrary name.\n\n    - Lowercases input\n    - Replaces characters outside `[A-Za-z0-9_/-]` with `-`\n    - Collapses consecutive `-`\n    - Strips leading/trailing `-` and `/`\n    - Truncates to 31 characters maximum (matches worktree behavior)\n    Returns `\"work\"` if the result is empty.\n\n    Args:\n        name: Arbitrary string to sanitize\n\n    Returns:\n        Sanitized branch component name (max 31 chars)\n\n    Examples:\n        >>> sanitize_branch_component(\"My Feature!\")\n        \"my-feature\"\n        >>> sanitize_branch_component(\"fix/bug-123\")\n        \"fix/bug-123\"\n        >>> sanitize_branch_component(\"\")\n        \"work\"\n        >>> sanitize_branch_component(\"a\" * 40)\n        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"  # 31 chars\n    \"\"\"\n    lowered = name.strip().lower()\n    replaced = _SAFE_COMPONENT_RE.sub(\"-\", lowered)\n    collapsed = re.sub(r\"-+\", \"-\", replaced)\n    trimmed = collapsed.strip(\"-/\")\n    result = trimmed or \"work\"\n\n    # Truncate to 31 characters and strip trailing hyphens (matching worktree behavior)\n    if len(result) > 31:\n        result = result[:31].rstrip(\"-\")\n\n    return result\n\n\ndef generate_filename_from_title(title: str) -> str:\n    \"\"\"Convert title to kebab-case filename with -plan.md suffix.\n\n    Comprehensive transformation:\n    1. Lowercase\n    2. Replace spaces with hyphens\n    3. Unicode normalization (NFD)\n    4. Remove emojis and non-alphanumeric characters (except hyphens)\n    5. Collapse consecutive hyphens\n    6. Strip leading/trailing hyphens\n    7. Validate at least one alphanumeric character remains\n    8. Append \"-plan.md\"\n\n    Returns \"plan.md\" if title is empty after cleanup.\n\n    Args:\n        title: Plan title to convert\n\n    Returns:\n        Sanitized filename ending with -plan.md\n\n    Example:\n        >>> generate_filename_from_title(\"User Auth Feature\")\n        'user-auth-feature-plan.md'\n\n        >>> generate_filename_from_title(\"Fix: Bug #123\")\n        'fix-bug-123-plan.md'\n\n        >>> generate_filename_from_title(\"🚀 Feature Launch 🎉\")\n        'feature-launch-plan.md'\n\n        >>> generate_filename_from_title(\"café\")\n        'cafe-plan.md'\n    \"\"\"\n    # Step 1: Lowercase and strip whitespace\n    lowered = title.strip().lower()\n\n    # Step 2: Unicode normalization (NFD form for decomposition)\n    # Decompose combined characters (é → e + ´)\n    normalized = unicodedata.normalize(\"NFD\", lowered)\n\n    # Step 3: Remove emojis and non-ASCII characters, convert to ASCII\n    # Keep only ASCII alphanumeric, spaces, and hyphens\n    cleaned = \"\"\n    for char in normalized:\n        # Keep ASCII alphanumeric, spaces, and hyphens\n        if ord(char) < 128 and (char.isalnum() or char in (\" \", \"-\")):\n            cleaned += char\n        # Skip combining marks (accents) and emoji\n        # Skip non-ASCII characters (CJK, emoji, special symbols)\n\n    # Step 4: Replace spaces with hyphens\n    replaced = cleaned.replace(\" \", \"-\")\n\n    # Step 5: Collapse consecutive hyphens\n    collapsed = re.sub(r\"-+\", \"-\", replaced)\n\n    # Step 6: Strip leading/trailing hyphens\n    trimmed = collapsed.strip(\"-\")\n\n    # Step 7: Validate at least one alphanumeric character\n    if not trimmed or not any(c.isalnum() for c in trimmed):\n        return \"plan.md\"\n\n    return f\"{trimmed}-plan.md\"\n\n\ndef strip_plan_from_filename(filename: str) -> str:\n    \"\"\"Remove 'plan' or 'implementation plan' from a filename stem intelligently.\n\n    Handles case-insensitive matching and common separators (-, _, space).\n    If removal would leave empty string, returns original unchanged.\n\n    Args:\n        filename: Filename stem (without extension) to process\n\n    Returns:\n        Filename with plan-related words removed, or original if would be empty\n\n    Examples:\n        >>> strip_plan_from_filename(\"devclikit-extraction-plan\")\n        \"devclikit-extraction\"\n        >>> strip_plan_from_filename(\"my-feature-plan\")\n        \"my-feature\"\n        >>> strip_plan_from_filename(\"implementation-plan-for-auth\")\n        \"for-auth\"\n        >>> strip_plan_from_filename(\"feature_implementation_plan\")\n        \"feature\"\n        >>> strip_plan_from_filename(\"plan\")\n        \"plan\"  # preserved - would be empty\n    \"\"\"\n    original_trimmed = filename.strip(\"-_ \\t\\n\\r\")\n    original_is_plan = original_trimmed.casefold() == \"plan\" if original_trimmed else False\n\n    # First, handle \"implementation plan\" with various separators\n    # Pattern matches \"implementation\" + separator + \"plan\" as complete words\n    impl_pattern = r\"(^|[-_\\s])(implementation)([-_\\s])(plan)([-_\\s]|$)\"\n\n    def replace_impl_plan(match: re.Match[str]) -> str:\n        prefix = match.group(1)\n        implementation_word = match.group(2)  # Preserves original case\n        suffix = match.group(5)\n\n        if suffix == \"\" and prefix:\n            prefix_start = match.start(1)\n            preceding_segment = filename[:prefix_start]\n            trimmed_segment = preceding_segment.strip(\"-_ \\t\\n\\r\")\n            if trimmed_segment:\n                preceding_tokens = re.split(r\"[-_\\s]+\", trimmed_segment)\n                if preceding_tokens:\n                    preceding_token = preceding_tokens[-1]\n                    if preceding_token.casefold() == \"plan\":\n                        return f\"{prefix}{implementation_word}\"\n\n        # If entire string is \"implementation-plan\", keep just \"implementation\"\n        if not prefix and not suffix:\n            return implementation_word\n\n        # If in the middle, preserve one separator\n        if prefix and suffix:\n            return prefix if prefix.strip() else suffix\n\n        # At start or end: remove it and the adjacent separator\n        return \"\"\n\n    cleaned = re.sub(impl_pattern, replace_impl_plan, filename, flags=re.IGNORECASE)\n\n    # Then handle standalone \"plan\" as a complete word\n    plan_pattern = r\"(^|[-_\\s])(plan)([-_\\s]|$)\"\n\n    def replace_plan(match: re.Match[str]) -> str:\n        prefix = match.group(1)\n        suffix = match.group(3)\n\n        # If both prefix and suffix are empty (entire string is \"plan\"), keep it\n        if not prefix and not suffix:\n            return \"plan\"\n\n        # If plan is in the middle, preserve one separator\n        if prefix and suffix:\n            # Use the prefix separator if available, otherwise use suffix\n            return prefix if prefix.strip() else suffix\n\n        # Plan at start or end: remove it and the adjacent separator\n        return \"\"\n\n    cleaned = re.sub(plan_pattern, replace_plan, cleaned, flags=re.IGNORECASE)\n\n    def clean_separators(text: str) -> str:\n        stripped = text.strip(\"-_ \\t\\n\\r\")\n        stripped = re.sub(r\"--+\", \"-\", stripped)\n        stripped = re.sub(r\"__+\", \"_\", stripped)\n        stripped = re.sub(r\"\\s+\", \" \", stripped)\n        return stripped\n\n    cleaned = clean_separators(cleaned)\n\n    plan_only_cleaned = clean_separators(\n        re.sub(plan_pattern, replace_plan, filename, flags=re.IGNORECASE)\n    )\n\n    if (\n        cleaned.casefold() == \"plan\"\n        and plan_only_cleaned\n        and plan_only_cleaned.casefold() != \"plan\"\n    ):\n        cleaned = plan_only_cleaned\n\n    # If stripping left us with nothing or just \"plan\", preserve original\n    if not cleaned or (cleaned.casefold() == \"plan\" and original_is_plan):\n        return filename\n\n    return cleaned\n\n\ndef extract_trailing_number(name: str) -> tuple[str, int | None]:\n    r\"\"\"Extract trailing number from a name.\n\n    Detects trailing numbers in names using regex pattern `^(.+?)-(\\d+)$`.\n    Returns tuple of (base_name, number) or (name, None).\n\n    Args:\n        name: Name to parse\n\n    Returns:\n        Tuple of (base_name, number) if trailing number found, else (name, None)\n\n    Examples:\n        >>> extract_trailing_number(\"my-feature\")\n        (\"my-feature\", None)\n        >>> extract_trailing_number(\"my-feature-2\")\n        (\"my-feature\", 2)\n        >>> extract_trailing_number(\"fix-42\")\n        (\"fix\", 42)\n    \"\"\"\n    match = re.match(r\"^(.+?)-(\\d+)$\", name)\n    if match:\n        base_name = match.group(1)\n        number = int(match.group(2))\n        return (base_name, number)\n    return (name, None)\n\n\ndef extract_leading_issue_number(branch_name: str) -> int | None:\n    \"\"\"Extract leading issue number from a branch name.\n\n    Branch names follow the pattern: P{issue_number}-{slug}-{timestamp}\n    Examples: \"P2382-convert-erk-create-raw-ext-12-05-2359\"\n\n    Also supports legacy format without \"P\" prefix for backwards compatibility.\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Issue number if branch starts with optional \"P\" followed by digits and hyphen, else None\n\n    Examples:\n        >>> extract_leading_issue_number(\"P2382-convert-erk-create-raw-ext-12-05-2359\")\n        2382\n        >>> extract_leading_issue_number(\"P42-fix-bug\")\n        42\n        >>> extract_leading_issue_number(\"2382-convert-erk-create-raw-ext-12-05-2359\")\n        2382\n        >>> extract_leading_issue_number(\"42-fix-bug\")\n        42\n        >>> extract_leading_issue_number(\"feature-branch\")\n        None\n        >>> extract_leading_issue_number(\"master\")\n        None\n    \"\"\"\n    match = re.match(r\"^[Pp]?(\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n\n\ndef extract_objective_number(branch_name: str) -> int | None:\n    \"\"\"Extract objective number from branch name.\n\n    Supports branch naming patterns:\n\n    - Issue-based: ``P{plan}-O{objective}-{slug}-{timestamp}``\n    - Draft-PR (current): ``planned/O{objective}-{slug}-{timestamp}``\n    - Draft-PR (legacy): ``plan/O{objective}-{slug}-{timestamp}``\n\n    Also supports lowercase \"o\" prefix for case-insensitive matching.\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Objective number if branch contains O{number} after the prefix, else None\n\n    Examples:\n        >>> extract_objective_number(\"P123-O456-fix-auth-bug-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-o456-fix-bug\")\n        456\n        >>> extract_objective_number(\"planned/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"plan/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-fix-auth-bug-01-15-1430\")\n        None\n        >>> extract_objective_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^(?:[Pp]?\\d+-|plan(?:ned)?/)[Oo](\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n\n\ndef extract_plan_review_issue_number(branch_name: str) -> int | None:\n    \"\"\"Extract issue number from a plan review branch name.\n\n    Plan review branches follow the pattern: planned/review-{issue_number}-{timestamp}\n    Examples: \"planned/review-6214-01-15-1430\"\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Issue number if branch matches planned/review-{number}- pattern, else None\n\n    Examples:\n        >>> extract_plan_review_issue_number(\"planned/review-6214-01-15-1430\")\n        6214\n        >>> extract_plan_review_issue_number(\"planned/review-42-01-28-0930\")\n        42\n        >>> extract_plan_review_issue_number(\"P2382-convert-erk-create-raw-ext\")\n        None\n        >>> extract_plan_review_issue_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^planned/review-(\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n\n\ndef ensure_unique_worktree_name_with_date(base_name: str, worktrees_dir: Path, git_ops) -> str:\n    \"\"\"Ensure unique worktree name with datetime suffix and smart versioning.\n\n    Adds datetime suffix in format -YY-MM-DD-HHMM to the base name.\n    If a worktree with that name exists, increments numeric suffix starting at 2 AFTER the datetime.\n    Uses LBYL pattern: checks via git_ops.worktree.path_exists() before operations.\n\n    This function is used for plan-derived worktrees where multiple worktrees may be\n    created from the same plan, requiring datetime-based disambiguation.\n\n    Args:\n        base_name: Sanitized worktree base name (without datetime suffix)\n        worktrees_dir: Directory containing worktrees\n        git_ops: Git operations interface for checking path existence\n\n    Returns:\n        Guaranteed unique worktree name with datetime suffix\n\n    Examples:\n        First time: \"my-feature\" → \"my-feature-25-11-08-1430\"\n        Duplicate: \"my-feature\" → \"my-feature-25-11-08-1430-2\"\n        Next minute: \"my-feature\" → \"my-feature-25-11-08-1431\"\n    \"\"\"\n    date_suffix = datetime.now().strftime(WORKTREE_DATE_SUFFIX_FORMAT)\n    candidate_name = f\"{base_name}-{date_suffix}\"\n\n    # Check if the base candidate exists\n    if not git_ops.worktree.path_exists(worktrees_dir / candidate_name):\n        return candidate_name\n\n    # Name exists, find next available number (append after date)\n    counter = 2\n    while True:\n        versioned_name = f\"{base_name}-{date_suffix}-{counter}\"\n        if not git_ops.worktree.path_exists(worktrees_dir / versioned_name):\n            return versioned_name\n        counter += 1\n\n\ndef ensure_simple_worktree_name(base_name: str, worktrees_dir: Path, git_ops) -> str:\n    \"\"\"Ensure simple worktree name without date suffix for manual checkouts.\n\n    Returns the simple name if no worktree exists at that path.\n    If a worktree already exists, returns the simple name (caller validates branch match).\n    Uses LBYL pattern: checks via git_ops.worktree.path_exists() before operations.\n\n    This function is used for manual checkout operations where predictable names are\n    desired (e.g., `erk co feature` → `feature` not `feature-25-11-08`).\n\n    Args:\n        base_name: Sanitized worktree base name\n        worktrees_dir: Directory containing worktrees\n        git_ops: Git operations interface for checking path existence\n\n    Returns:\n        Simple worktree name without date suffix\n\n    Examples:\n        First time: \"my-feature\" → \"my-feature\"\n        Exists: \"my-feature\" → \"my-feature\" (caller handles validation)\n    \"\"\"\n    candidate_name = base_name\n    # Always return simple name - collision handling happens in caller\n    return candidate_name\n\n\ndef ensure_unique_worktree_name(base_name: str, worktrees_dir: Path, git_ops) -> str:\n    \"\"\"Deprecated: Use ensure_unique_worktree_name_with_date for plan-derived worktrees.\n\n    This function is kept for backward compatibility but will be removed in the future.\n    New code should use:\n    - ensure_unique_worktree_name_with_date() for plan-derived worktrees\n    - ensure_simple_worktree_name() for manual checkout operations\n    \"\"\"\n    return ensure_unique_worktree_name_with_date(base_name, worktrees_dir, git_ops)\n\n\ndef default_branch_for_worktree(name: str) -> str:\n    \"\"\"Default branch name for a worktree with the given `name`.\n\n    Returns the sanitized name directly (without any prefix).\n\n    Args:\n        name: Worktree name\n\n    Returns:\n        Default branch name (sanitized)\n\n    Examples:\n        >>> default_branch_for_worktree(\"my-feature\")\n        \"my-feature\"\n        >>> default_branch_for_worktree(\"Fix Bug!\")\n        \"fix-bug\"\n    \"\"\"\n    return sanitize_branch_component(name)\n\n\ndef generate_issue_branch_name(\n    issue_number: int | str,\n    title: str,\n    timestamp: datetime,\n    *,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate branch name for issue-based worktree.\n\n    Format: P{issue_number}-{sanitized_title}-{timestamp}\n    Or with objective: P{issue_number}-O{objective_id}-{sanitized_title}-{timestamp}\n    Example: P123-fix-auth-bug-01-15-1430\n    Example with objective: P123-O456-fix-auth-bug-01-15-1430\n\n    The branch name is constructed as:\n    1. P prefix + issue number + hyphen\n    2. If objective_id provided: O prefix + objective_id + hyphen\n    3. Sanitized title (lowercased, special chars replaced)\n    4. Truncated to 31 chars total (before timestamp)\n    5. Timestamp suffix appended (format: -MM-DD-HHMM)\n\n    Args:\n        issue_number: GitHub issue number\n        title: Issue title to sanitize\n        timestamp: Timestamp for the suffix\n        objective_id: Optional objective ID to encode in branch name\n\n    Returns:\n        Branch name in format P{num}-{slug}-{timestamp} or P{num}-O{obj}-{slug}-{timestamp}\n\n    Examples:\n        >>> from datetime import datetime\n        >>> generate_issue_branch_name(\n        ...     123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n        ... )\n        \"P123-fix-auth-bug-01-15-1430\"\n        >>> generate_issue_branch_name(\n        ...     123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456\n        ... )\n        \"P123-O456-fix-auth-bug-01-15-1430\"\n    \"\"\"\n    prefix = f\"P{issue_number}-\"\n    if objective_id is not None:\n        prefix += f\"O{objective_id}-\"\n    sanitized_title = sanitize_worktree_name(title)\n    base_branch_name = (prefix + sanitized_title)[:31].rstrip(\"-\")\n    timestamp_suffix = format_branch_timestamp_suffix(timestamp)\n    return base_branch_name + timestamp_suffix\n\n\ndef generate_draft_pr_branch_name(\n    title: str,\n    timestamp: datetime,\n    *,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate branch name for draft-PR-backed plans.\n\n    Format: plnd/{sanitized_title}-{timestamp}\n    Or with objective: plnd/O{objective_id}-{sanitized_title}-{timestamp}\n    Example: plnd/fix-auth-bug-01-15-1430\n    Example with objective: plnd/O456-fix-auth-bug-01-15-1430\n\n    No P{issue} prefix since the PR number isn't known until after creation.\n\n    Args:\n        title: Plan title to sanitize\n        timestamp: Timestamp for the suffix\n        objective_id: Optional objective ID to encode in branch name\n\n    Returns:\n        Branch name in format plnd/{slug}-{timestamp}\n\n    Examples:\n        >>> from datetime import datetime\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n        ... )\n        \"plnd/fix-auth-bug-01-15-1430\"\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456\n        ... )\n        \"plnd/O456-fix-auth-bug-01-15-1430\"\n    \"\"\"\n    prefix = \"plnd/\"\n    if objective_id is not None:\n        prefix += f\"O{objective_id}-\"\n    sanitized_title = sanitize_worktree_name(title)\n    base_branch_name = (prefix + sanitized_title)[:31].rstrip(\"-\")\n    timestamp_suffix = format_branch_timestamp_suffix(timestamp)\n    return base_branch_name + timestamp_suffix\n\n\ndef derive_branch_name_from_title(title: str) -> str:\n    \"\"\"Derive branch name from issue/plan title.\n\n    This function matches the logic used by the erk-impl workflow\n    to ensure CLI and workflow produce identical branch names.\n\n    Transforms:\n    - Lowercase\n    - Replace non-alphanumeric (except hyphen) with hyphen\n    - Collapse consecutive hyphens\n    - Strip leading/trailing hyphens\n    - Truncate to 30 chars\n    - Strip trailing hyphen after truncation\n\n    Args:\n        title: Issue or plan title\n\n    Returns:\n        Branch name (max 30 chars, kebab-case)\n\n    Examples:\n        >>> derive_branch_name_from_title(\"My Feature\")\n        \"my-feature\"\n        >>> derive_branch_name_from_title(\"Fix Bug #123!\")\n        \"fix-bug-123\"\n        >>> derive_branch_name_from_title(\"A\" * 40)\n        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"  # 30 chars (one less than sanitize_branch_component)\n    \"\"\"\n    # Convert to lowercase\n    branch_name = title.lower()\n    # Replace non-alphanumeric (except hyphen) with hyphen\n    branch_name = re.sub(r\"[^a-z0-9-]\", \"-\", branch_name)\n    # Collapse consecutive hyphens\n    branch_name = re.sub(r\"-+\", \"-\", branch_name)\n    # Strip leading/trailing hyphens\n    branch_name = branch_name.strip(\"-\")\n\n    # Truncate to 30 chars (matches workflow logic)\n    branch_name = branch_name[:30]\n\n    # Strip trailing hyphen after truncation\n    branch_name = branch_name.rstrip(\"-\")\n\n    return branch_name\n","structuredPatch":[{"oldStart":583,"oldLines":7,"newStart":583,"newLines":8,"lines":["     Supports branch naming patterns:"," ","     - Issue-based: ``P{plan}-O{objective}-{slug}-{timestamp}``","-    - Draft-PR (current): ``planned/O{objective}-{slug}-{timestamp}``","+    - Draft-PR (current): ``plnd/O{objective}-{slug}-{timestamp}``","+    - Draft-PR (legacy): ``planned/O{objective}-{slug}-{timestamp}``","     - Draft-PR (legacy): ``plan/O{objective}-{slug}-{timestamp}``"," ","     Also supports lowercase \"o\" prefix for case-insensitive matching."]},{"oldStart":599,"oldLines":6,"newStart":600,"newLines":8,"lines":["         456","         >>> extract_objective_number(\"P123-o456-fix-bug\")","         456","+        >>> extract_objective_number(\"plnd/O456-fix-auth-01-15-1430\")","+        456","         >>> extract_objective_number(\"planned/O456-fix-auth-01-15-1430\")","         456","         >>> extract_objective_number(\"plan/O456-fix-auth-01-15-1430\")"]},{"oldStart":608,"oldLines":7,"newStart":611,"newLines":7,"lines":["         >>> extract_objective_number(\"feature-branch\")","         None","     \"\"\"","-    match = re.match(r\"^(?:[Pp]?\\d+-|plan(?:ned)?/)[Oo](\\d+)-\", branch_name)","+    match = re.match(r\"^(?:[Pp]?\\d+-|pl(?:an(?:ned)?|nd)/)[Oo](\\d+)-\", branch_name)","     if match:","         return int(match.group(1))","     return None"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"ef6077fc-e561-4766-802f-993910eef93b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01UmY5TLhFEJAtDfU5ZZX8mm","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `extract_plan_review_issue_number()` - also needs to handle both `planned/` and `plnd/`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":972,"cache_read_input_tokens":54845,"cache_creation":{"ephemeral_5m_input_tokens":972,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHQvfzahmZYEdUR7MRg","type":"assistant","uuid":"cba435c0-0481-414a-84fa-40f44c1b49ac","timestamp":"2026-02-22T14:42:31.896Z"}
{"parentUuid":"cba435c0-0481-414a-84fa-40f44c1b49ac","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01UmY5TLhFEJAtDfU5ZZX8mm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WEoEzyXqFBKxQPDmxYT2H9","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/naming.py","old_string":"def extract_plan_review_issue_number(branch_name: str) -> int | None:\n    \"\"\"Extract issue number from a plan review branch name.\n\n    Plan review branches follow the pattern: planned/review-{issue_number}-{timestamp}\n    Examples: \"planned/review-6214-01-15-1430\"\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Issue number if branch matches planned/review-{number}- pattern, else None\n\n    Examples:\n        >>> extract_plan_review_issue_number(\"planned/review-6214-01-15-1430\")\n        6214\n        >>> extract_plan_review_issue_number(\"planned/review-42-01-28-0930\")\n        42\n        >>> extract_plan_review_issue_number(\"P2382-convert-erk-create-raw-ext\")\n        None\n        >>> extract_plan_review_issue_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^planned/review-(\\d+)-\", branch_name)","new_string":"def extract_plan_review_issue_number(branch_name: str) -> int | None:\n    \"\"\"Extract issue number from a plan review branch name.\n\n    Plan review branches follow the pattern: plnd/review-{issue_number}-{timestamp}\n    Legacy pattern: planned/review-{issue_number}-{timestamp}\n    Examples: \"plnd/review-6214-01-15-1430\"\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Issue number if branch matches plnd/review-{number}- pattern, else None\n\n    Examples:\n        >>> extract_plan_review_issue_number(\"plnd/review-6214-01-15-1430\")\n        6214\n        >>> extract_plan_review_issue_number(\"plnd/review-42-01-28-0930\")\n        42\n        >>> extract_plan_review_issue_number(\"planned/review-6214-01-15-1430\")\n        6214\n        >>> extract_plan_review_issue_number(\"P2382-convert-erk-create-raw-ext\")\n        None\n        >>> extract_plan_review_issue_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^pl(?:an(?:ned)?|nd)/review-(\\d+)-\", branch_name)"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":972,"cache_read_input_tokens":54845,"cache_creation":{"ephemeral_5m_input_tokens":972,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHQvfzahmZYEdUR7MRg","type":"assistant","uuid":"e497a49f-c8a5-425f-8b3e-ffcf4ff8cfc8","timestamp":"2026-02-22T14:42:38.038Z"}
{"parentUuid":"e497a49f-c8a5-425f-8b3e-ffcf4ff8cfc8","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WEoEzyXqFBKxQPDmxYT2H9","type":"tool_result","content":"The file /home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/naming.py has been updated successfully."}]},"uuid":"8c45b1c1-d9c7-4dad-a5cf-f421fa4efbd2","timestamp":"2026-02-22T14:42:38.714Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/naming.py","oldString":"def extract_plan_review_issue_number(branch_name: str) -> int | None:\n    \"\"\"Extract issue number from a plan review branch name.\n\n    Plan review branches follow the pattern: planned/review-{issue_number}-{timestamp}\n    Examples: \"planned/review-6214-01-15-1430\"\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Issue number if branch matches planned/review-{number}- pattern, else None\n\n    Examples:\n        >>> extract_plan_review_issue_number(\"planned/review-6214-01-15-1430\")\n        6214\n        >>> extract_plan_review_issue_number(\"planned/review-42-01-28-0930\")\n        42\n        >>> extract_plan_review_issue_number(\"P2382-convert-erk-create-raw-ext\")\n        None\n        >>> extract_plan_review_issue_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^planned/review-(\\d+)-\", branch_name)","newString":"def extract_plan_review_issue_number(branch_name: str) -> int | None:\n    \"\"\"Extract issue number from a plan review branch name.\n\n    Plan review branches follow the pattern: plnd/review-{issue_number}-{timestamp}\n    Legacy pattern: planned/review-{issue_number}-{timestamp}\n    Examples: \"plnd/review-6214-01-15-1430\"\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Issue number if branch matches plnd/review-{number}- pattern, else None\n\n    Examples:\n        >>> extract_plan_review_issue_number(\"plnd/review-6214-01-15-1430\")\n        6214\n        >>> extract_plan_review_issue_number(\"plnd/review-42-01-28-0930\")\n        42\n        >>> extract_plan_review_issue_number(\"planned/review-6214-01-15-1430\")\n        6214\n        >>> extract_plan_review_issue_number(\"P2382-convert-erk-create-raw-ext\")\n        None\n        >>> extract_plan_review_issue_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^pl(?:an(?:ned)?|nd)/review-(\\d+)-\", branch_name)","originalFile":"\"\"\"Naming utilities for filenames and worktree names.\n\nThis module provides pure utility functions for transforming titles and names\ninto sanitized, filesystem-safe identifiers. All functions are pure (no I/O)\nand follow LBYL patterns.\n\nFunctions that require git operations accept a git_ops parameter via dependency\ninjection to maintain separation from I/O concerns.\n\"\"\"\n\nimport re\nimport unicodedata\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom pathlib import Path\n\n_SAFE_COMPONENT_RE = re.compile(r\"[^A-Za-z0-9_/-]+\")\n\n# Date suffix format for plan-derived worktree names: -YY-MM-DD-HHMM\nWORKTREE_DATE_SUFFIX_FORMAT = \"%y-%m-%d-%H%M\"\n\n# Branch timestamp suffix format: -MM-DD-HHMM (appended after truncation)\nBRANCH_TIMESTAMP_SUFFIX_FORMAT = \"%m-%d-%H%M\"\n\n# Regex pattern to detect existing timestamp suffix (MM-DD-HHMM)\n_TIMESTAMP_SUFFIX_PATTERN = re.compile(r\"-\\d{2}-\\d{2}-\\d{4}$\")\n\n\ndef has_timestamp_suffix(name: str) -> bool:\n    \"\"\"Check if a name already ends with a timestamp suffix (-MM-DD-HHMM).\n\n    Args:\n        name: Branch or worktree name to check\n\n    Returns:\n        True if name ends with timestamp suffix pattern, False otherwise\n\n    Examples:\n        >>> has_timestamp_suffix(\"42-feature-01-15-1430\")\n        True\n        >>> has_timestamp_suffix(\"42-feature\")\n        False\n        >>> has_timestamp_suffix(\"42-feature-branch\")\n        False\n    \"\"\"\n    return _TIMESTAMP_SUFFIX_PATTERN.search(name) is not None\n\n\ndef format_branch_timestamp_suffix(dt: datetime) -> str:\n    \"\"\"Format a datetime as a branch timestamp suffix.\n\n    Returns a suffix in the format -MM-DD-HHMM to be appended to branch names.\n\n    Args:\n        dt: Datetime to format\n\n    Returns:\n        Formatted suffix string (e.g., \"-01-15-1430\")\n\n    Examples:\n        >>> from datetime import datetime\n        >>> format_branch_timestamp_suffix(datetime(2024, 1, 15, 14, 30))\n        \"-01-15-1430\"\n        >>> format_branch_timestamp_suffix(datetime(2024, 12, 31, 23, 59))\n        \"-12-31-2359\"\n    \"\"\"\n    return f\"-{dt.strftime(BRANCH_TIMESTAMP_SUFFIX_FORMAT)}\"\n\n\n_OBJECTIVE_SLUG_PATTERN = re.compile(r\"^[a-z][a-z0-9]*(-[a-z0-9]+)*$\")\n\n# Plan title constraints\n_PLAN_TITLE_MIN_LENGTH = 5\n_PLAN_TITLE_MAX_LENGTH = 100\n\n\n@dataclass(frozen=True)\nclass ValidPlanTitle:\n    \"\"\"Validation success for a plan title.\n\n    Attributes:\n        title: The validated title value.\n    \"\"\"\n\n    title: str\n\n\n@dataclass(frozen=True)\nclass InvalidPlanTitle:\n    \"\"\"Validation failure for a plan title.\n\n    Attributes:\n        raw_title: The original title value that failed validation.\n        reason: A short description of why validation failed.\n    \"\"\"\n\n    raw_title: str\n    reason: str\n\n    @property\n    def error_type(self) -> str:\n        return \"invalid-plan-title\"\n\n    @property\n    def message(self) -> str:\n        \"\"\"Full error message with rules, actual value, and examples.\n\n        Designed so an agent receiving this message can self-correct.\n        \"\"\"\n        return (\n            f\"Invalid plan title: {self.reason}\\n\"\n            f\"  Actual value: {self.raw_title!r}\\n\"\n            f\"  Rules:\\n\"\n            f\"    - {_PLAN_TITLE_MIN_LENGTH}-{_PLAN_TITLE_MAX_LENGTH} characters\\n\"\n            f\"    - Must contain at least one alphabetic character\\n\"\n            f\"    - Must retain meaningful content after sanitization\\n\"\n            f\"      (emojis, special characters, and accents are stripped)\\n\"\n            f\"  Valid examples: Add User Authentication,\"\n            f\" Refactor Gateway Layer\\n\"\n            f\"  Invalid examples: \\U0001f680\\U0001f389, 123, #!@, Plan\"\n        )\n\n\ndef validate_plan_title(title: str) -> ValidPlanTitle | InvalidPlanTitle:\n    \"\"\"Validate a plan title against minimum content requirements.\n\n    This is an agent-facing validation gate. It ensures plan titles have enough\n    meaningful content before they are used to generate filenames, branch names,\n    or issue titles. Human-facing paths (like generate_filename_from_title) can\n    still transform arbitrary input silently.\n\n    Returns ValidPlanTitle on success, or InvalidPlanTitle describing the failure.\n\n    Args:\n        title: The plan title string to validate.\n\n    Returns:\n        ValidPlanTitle if valid, InvalidPlanTitle if invalid.\n\n    Examples:\n        >>> validate_plan_title(\"Add User Authentication\")\n        ValidPlanTitle(title='Add User Authentication')\n        >>> validate_plan_title(\"\")\n        InvalidPlanTitle(raw_title='', reason='...')\n        >>> validate_plan_title(\"🚀🎉\")\n        InvalidPlanTitle(raw_title='🚀🎉', reason='...')\n    \"\"\"\n    stripped = title.strip()\n\n    if not stripped:\n        return InvalidPlanTitle(raw_title=title, reason=\"Title is empty or whitespace-only\")\n\n    if len(stripped) < _PLAN_TITLE_MIN_LENGTH:\n        return InvalidPlanTitle(\n            raw_title=title,\n            reason=f\"Too short ({len(stripped)} characters, minimum {_PLAN_TITLE_MIN_LENGTH})\",\n        )\n\n    if len(stripped) > _PLAN_TITLE_MAX_LENGTH:\n        return InvalidPlanTitle(\n            raw_title=title,\n            reason=f\"Too long ({len(stripped)} characters, maximum {_PLAN_TITLE_MAX_LENGTH})\",\n        )\n\n    if not any(c.isalpha() for c in stripped):\n        return InvalidPlanTitle(\n            raw_title=title,\n            reason=\"Must contain at least one alphabetic character\",\n        )\n\n    # Check that sanitization retains meaningful content.\n    # generate_filename_from_title strips emojis, accents, and special chars.\n    # If the result is \"plan.md\" (the fallback), the title has no usable content.\n    filename = generate_filename_from_title(stripped)\n    if filename == \"plan.md\":\n        return InvalidPlanTitle(\n            raw_title=title,\n            reason=\"No usable content after sanitization (only emojis or special characters)\",\n        )\n\n    return ValidPlanTitle(title=stripped)\n\n\n@dataclass(frozen=True)\nclass ValidObjectiveSlug:\n    \"\"\"Validation success for an objective slug.\n\n    Attributes:\n        slug: The validated slug value.\n    \"\"\"\n\n    slug: str\n\n\n@dataclass(frozen=True)\nclass InvalidObjectiveSlug:\n    \"\"\"Validation failure for an objective slug.\n\n    Attributes:\n        raw_slug: The original slug value that failed validation.\n        reason: A short description of why validation failed.\n    \"\"\"\n\n    raw_slug: str\n    reason: str\n\n    @property\n    def message(self) -> str:\n        \"\"\"Full error message with pattern, rules, actual value, and examples.\n\n        Designed so an agent receiving this message can self-correct.\n        \"\"\"\n        return (\n            f\"Invalid objective slug: {self.reason}\\n\"\n            f\"  Actual value: {self.raw_slug!r}\\n\"\n            f\"  Pattern: ^[a-z][a-z0-9]*(-[a-z0-9]+)*$\\n\"\n            f\"  Rules:\\n\"\n            f\"    - 3-40 characters\\n\"\n            f\"    - Lowercase letters and digits only\\n\"\n            f\"    - Must start with a letter\\n\"\n            f\"    - Hyphens allowed between words (no consecutive hyphens)\\n\"\n            f\"  Valid examples: build-auth-system, refactor-gateway, add-dark-mode\\n\"\n            f\"  Invalid examples: Build-Auth, 123-start, my--slug, ab\"\n        )\n\n\ndef validate_objective_slug(slug: str) -> ValidObjectiveSlug | InvalidObjectiveSlug:\n    \"\"\"Validate an objective slug against the required format.\n\n    Returns ValidObjectiveSlug on success, or InvalidObjectiveSlug describing the failure.\n\n    Args:\n        slug: The slug string to validate.\n\n    Returns:\n        ValidObjectiveSlug if valid, InvalidObjectiveSlug if invalid.\n\n    Examples:\n        >>> validate_objective_slug(\"build-auth-system\")  # valid\n        ValidObjectiveSlug(slug='build-auth-system')\n        >>> validate_objective_slug(\"AB\")  # invalid\n        InvalidObjectiveSlug(raw_slug='AB', reason='...')\n    \"\"\"\n    if len(slug) < 3:\n        return InvalidObjectiveSlug(raw_slug=slug, reason=\"Too short (minimum 3 characters)\")\n    if len(slug) > 40:\n        return InvalidObjectiveSlug(raw_slug=slug, reason=\"Too long (maximum 40 characters)\")\n    if _OBJECTIVE_SLUG_PATTERN.match(slug) is None:\n        return InvalidObjectiveSlug(raw_slug=slug, reason=\"Does not match required pattern\")\n    return ValidObjectiveSlug(slug=slug)\n\n\ndef sanitize_worktree_name(name: str) -> str:\n    \"\"\"Sanitize a worktree name for use as a directory name.\n\n    - If name already has timestamp suffix (-MM-DD-HHMM), returns as-is (idempotent)\n    - Lowercases input\n    - Replaces underscores with hyphens\n    - Replaces characters outside `[A-Za-z0-9-]` with `-`\n    - Collapses consecutive `-`\n    - Strips leading/trailing `-`\n    - Truncates to 31 characters maximum (matches branch component sanitization)\n    Returns `\"work\"` if the result is empty.\n\n    The 31-character limit ensures worktree names match their corresponding branch\n    names, maintaining consistency across the worktree/branch model.\n\n    Args:\n        name: Arbitrary string to sanitize\n\n    Returns:\n        Sanitized worktree name (max 31 chars, unless timestamp already present)\n\n    Examples:\n        >>> sanitize_worktree_name(\"My_Feature\")\n        \"my-feature\"\n        >>> sanitize_worktree_name(\"a\" * 40)\n        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"  # 31 chars\n        >>> sanitize_worktree_name(\"42-feature-01-15-1430\")\n        \"42-feature-01-15-1430\"  # timestamp preserved (idempotent)\n    \"\"\"\n    # If name already has a timestamp suffix, return as-is (idempotent)\n    if has_timestamp_suffix(name):\n        return name\n\n    lowered = name.strip().lower()\n    # Replace underscores with hyphens\n    replaced_underscores = lowered.replace(\"_\", \"-\")\n    # Replace unsafe characters with hyphens\n    replaced = re.sub(r\"[^a-z0-9-]+\", \"-\", replaced_underscores)\n    # Collapse consecutive hyphens\n    collapsed = re.sub(r\"-+\", \"-\", replaced)\n    # Strip leading/trailing hyphens\n    trimmed = collapsed.strip(\"-\")\n    result = trimmed or \"work\"\n\n    # Truncate to 31 characters and strip trailing hyphens\n    if len(result) > 31:\n        result = result[:31].rstrip(\"-\")\n\n    return result\n\n\ndef sanitize_branch_component(name: str) -> str:\n    \"\"\"Return a sanitized, predictable branch component from an arbitrary name.\n\n    - Lowercases input\n    - Replaces characters outside `[A-Za-z0-9_/-]` with `-`\n    - Collapses consecutive `-`\n    - Strips leading/trailing `-` and `/`\n    - Truncates to 31 characters maximum (matches worktree behavior)\n    Returns `\"work\"` if the result is empty.\n\n    Args:\n        name: Arbitrary string to sanitize\n\n    Returns:\n        Sanitized branch component name (max 31 chars)\n\n    Examples:\n        >>> sanitize_branch_component(\"My Feature!\")\n        \"my-feature\"\n        >>> sanitize_branch_component(\"fix/bug-123\")\n        \"fix/bug-123\"\n        >>> sanitize_branch_component(\"\")\n        \"work\"\n        >>> sanitize_branch_component(\"a\" * 40)\n        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"  # 31 chars\n    \"\"\"\n    lowered = name.strip().lower()\n    replaced = _SAFE_COMPONENT_RE.sub(\"-\", lowered)\n    collapsed = re.sub(r\"-+\", \"-\", replaced)\n    trimmed = collapsed.strip(\"-/\")\n    result = trimmed or \"work\"\n\n    # Truncate to 31 characters and strip trailing hyphens (matching worktree behavior)\n    if len(result) > 31:\n        result = result[:31].rstrip(\"-\")\n\n    return result\n\n\ndef generate_filename_from_title(title: str) -> str:\n    \"\"\"Convert title to kebab-case filename with -plan.md suffix.\n\n    Comprehensive transformation:\n    1. Lowercase\n    2. Replace spaces with hyphens\n    3. Unicode normalization (NFD)\n    4. Remove emojis and non-alphanumeric characters (except hyphens)\n    5. Collapse consecutive hyphens\n    6. Strip leading/trailing hyphens\n    7. Validate at least one alphanumeric character remains\n    8. Append \"-plan.md\"\n\n    Returns \"plan.md\" if title is empty after cleanup.\n\n    Args:\n        title: Plan title to convert\n\n    Returns:\n        Sanitized filename ending with -plan.md\n\n    Example:\n        >>> generate_filename_from_title(\"User Auth Feature\")\n        'user-auth-feature-plan.md'\n\n        >>> generate_filename_from_title(\"Fix: Bug #123\")\n        'fix-bug-123-plan.md'\n\n        >>> generate_filename_from_title(\"🚀 Feature Launch 🎉\")\n        'feature-launch-plan.md'\n\n        >>> generate_filename_from_title(\"café\")\n        'cafe-plan.md'\n    \"\"\"\n    # Step 1: Lowercase and strip whitespace\n    lowered = title.strip().lower()\n\n    # Step 2: Unicode normalization (NFD form for decomposition)\n    # Decompose combined characters (é → e + ´)\n    normalized = unicodedata.normalize(\"NFD\", lowered)\n\n    # Step 3: Remove emojis and non-ASCII characters, convert to ASCII\n    # Keep only ASCII alphanumeric, spaces, and hyphens\n    cleaned = \"\"\n    for char in normalized:\n        # Keep ASCII alphanumeric, spaces, and hyphens\n        if ord(char) < 128 and (char.isalnum() or char in (\" \", \"-\")):\n            cleaned += char\n        # Skip combining marks (accents) and emoji\n        # Skip non-ASCII characters (CJK, emoji, special symbols)\n\n    # Step 4: Replace spaces with hyphens\n    replaced = cleaned.replace(\" \", \"-\")\n\n    # Step 5: Collapse consecutive hyphens\n    collapsed = re.sub(r\"-+\", \"-\", replaced)\n\n    # Step 6: Strip leading/trailing hyphens\n    trimmed = collapsed.strip(\"-\")\n\n    # Step 7: Validate at least one alphanumeric character\n    if not trimmed or not any(c.isalnum() for c in trimmed):\n        return \"plan.md\"\n\n    return f\"{trimmed}-plan.md\"\n\n\ndef strip_plan_from_filename(filename: str) -> str:\n    \"\"\"Remove 'plan' or 'implementation plan' from a filename stem intelligently.\n\n    Handles case-insensitive matching and common separators (-, _, space).\n    If removal would leave empty string, returns original unchanged.\n\n    Args:\n        filename: Filename stem (without extension) to process\n\n    Returns:\n        Filename with plan-related words removed, or original if would be empty\n\n    Examples:\n        >>> strip_plan_from_filename(\"devclikit-extraction-plan\")\n        \"devclikit-extraction\"\n        >>> strip_plan_from_filename(\"my-feature-plan\")\n        \"my-feature\"\n        >>> strip_plan_from_filename(\"implementation-plan-for-auth\")\n        \"for-auth\"\n        >>> strip_plan_from_filename(\"feature_implementation_plan\")\n        \"feature\"\n        >>> strip_plan_from_filename(\"plan\")\n        \"plan\"  # preserved - would be empty\n    \"\"\"\n    original_trimmed = filename.strip(\"-_ \\t\\n\\r\")\n    original_is_plan = original_trimmed.casefold() == \"plan\" if original_trimmed else False\n\n    # First, handle \"implementation plan\" with various separators\n    # Pattern matches \"implementation\" + separator + \"plan\" as complete words\n    impl_pattern = r\"(^|[-_\\s])(implementation)([-_\\s])(plan)([-_\\s]|$)\"\n\n    def replace_impl_plan(match: re.Match[str]) -> str:\n        prefix = match.group(1)\n        implementation_word = match.group(2)  # Preserves original case\n        suffix = match.group(5)\n\n        if suffix == \"\" and prefix:\n            prefix_start = match.start(1)\n            preceding_segment = filename[:prefix_start]\n            trimmed_segment = preceding_segment.strip(\"-_ \\t\\n\\r\")\n            if trimmed_segment:\n                preceding_tokens = re.split(r\"[-_\\s]+\", trimmed_segment)\n                if preceding_tokens:\n                    preceding_token = preceding_tokens[-1]\n                    if preceding_token.casefold() == \"plan\":\n                        return f\"{prefix}{implementation_word}\"\n\n        # If entire string is \"implementation-plan\", keep just \"implementation\"\n        if not prefix and not suffix:\n            return implementation_word\n\n        # If in the middle, preserve one separator\n        if prefix and suffix:\n            return prefix if prefix.strip() else suffix\n\n        # At start or end: remove it and the adjacent separator\n        return \"\"\n\n    cleaned = re.sub(impl_pattern, replace_impl_plan, filename, flags=re.IGNORECASE)\n\n    # Then handle standalone \"plan\" as a complete word\n    plan_pattern = r\"(^|[-_\\s])(plan)([-_\\s]|$)\"\n\n    def replace_plan(match: re.Match[str]) -> str:\n        prefix = match.group(1)\n        suffix = match.group(3)\n\n        # If both prefix and suffix are empty (entire string is \"plan\"), keep it\n        if not prefix and not suffix:\n            return \"plan\"\n\n        # If plan is in the middle, preserve one separator\n        if prefix and suffix:\n            # Use the prefix separator if available, otherwise use suffix\n            return prefix if prefix.strip() else suffix\n\n        # Plan at start or end: remove it and the adjacent separator\n        return \"\"\n\n    cleaned = re.sub(plan_pattern, replace_plan, cleaned, flags=re.IGNORECASE)\n\n    def clean_separators(text: str) -> str:\n        stripped = text.strip(\"-_ \\t\\n\\r\")\n        stripped = re.sub(r\"--+\", \"-\", stripped)\n        stripped = re.sub(r\"__+\", \"_\", stripped)\n        stripped = re.sub(r\"\\s+\", \" \", stripped)\n        return stripped\n\n    cleaned = clean_separators(cleaned)\n\n    plan_only_cleaned = clean_separators(\n        re.sub(plan_pattern, replace_plan, filename, flags=re.IGNORECASE)\n    )\n\n    if (\n        cleaned.casefold() == \"plan\"\n        and plan_only_cleaned\n        and plan_only_cleaned.casefold() != \"plan\"\n    ):\n        cleaned = plan_only_cleaned\n\n    # If stripping left us with nothing or just \"plan\", preserve original\n    if not cleaned or (cleaned.casefold() == \"plan\" and original_is_plan):\n        return filename\n\n    return cleaned\n\n\ndef extract_trailing_number(name: str) -> tuple[str, int | None]:\n    r\"\"\"Extract trailing number from a name.\n\n    Detects trailing numbers in names using regex pattern `^(.+?)-(\\d+)$`.\n    Returns tuple of (base_name, number) or (name, None).\n\n    Args:\n        name: Name to parse\n\n    Returns:\n        Tuple of (base_name, number) if trailing number found, else (name, None)\n\n    Examples:\n        >>> extract_trailing_number(\"my-feature\")\n        (\"my-feature\", None)\n        >>> extract_trailing_number(\"my-feature-2\")\n        (\"my-feature\", 2)\n        >>> extract_trailing_number(\"fix-42\")\n        (\"fix\", 42)\n    \"\"\"\n    match = re.match(r\"^(.+?)-(\\d+)$\", name)\n    if match:\n        base_name = match.group(1)\n        number = int(match.group(2))\n        return (base_name, number)\n    return (name, None)\n\n\ndef extract_leading_issue_number(branch_name: str) -> int | None:\n    \"\"\"Extract leading issue number from a branch name.\n\n    Branch names follow the pattern: P{issue_number}-{slug}-{timestamp}\n    Examples: \"P2382-convert-erk-create-raw-ext-12-05-2359\"\n\n    Also supports legacy format without \"P\" prefix for backwards compatibility.\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Issue number if branch starts with optional \"P\" followed by digits and hyphen, else None\n\n    Examples:\n        >>> extract_leading_issue_number(\"P2382-convert-erk-create-raw-ext-12-05-2359\")\n        2382\n        >>> extract_leading_issue_number(\"P42-fix-bug\")\n        42\n        >>> extract_leading_issue_number(\"2382-convert-erk-create-raw-ext-12-05-2359\")\n        2382\n        >>> extract_leading_issue_number(\"42-fix-bug\")\n        42\n        >>> extract_leading_issue_number(\"feature-branch\")\n        None\n        >>> extract_leading_issue_number(\"master\")\n        None\n    \"\"\"\n    match = re.match(r\"^[Pp]?(\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n\n\ndef extract_objective_number(branch_name: str) -> int | None:\n    \"\"\"Extract objective number from branch name.\n\n    Supports branch naming patterns:\n\n    - Issue-based: ``P{plan}-O{objective}-{slug}-{timestamp}``\n    - Draft-PR (current): ``plnd/O{objective}-{slug}-{timestamp}``\n    - Draft-PR (legacy): ``planned/O{objective}-{slug}-{timestamp}``\n    - Draft-PR (legacy): ``plan/O{objective}-{slug}-{timestamp}``\n\n    Also supports lowercase \"o\" prefix for case-insensitive matching.\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Objective number if branch contains O{number} after the prefix, else None\n\n    Examples:\n        >>> extract_objective_number(\"P123-O456-fix-auth-bug-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-o456-fix-bug\")\n        456\n        >>> extract_objective_number(\"plnd/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"planned/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"plan/O456-fix-auth-01-15-1430\")\n        456\n        >>> extract_objective_number(\"P123-fix-auth-bug-01-15-1430\")\n        None\n        >>> extract_objective_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^(?:[Pp]?\\d+-|pl(?:an(?:ned)?|nd)/)[Oo](\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n\n\ndef extract_plan_review_issue_number(branch_name: str) -> int | None:\n    \"\"\"Extract issue number from a plan review branch name.\n\n    Plan review branches follow the pattern: planned/review-{issue_number}-{timestamp}\n    Examples: \"planned/review-6214-01-15-1430\"\n\n    Args:\n        branch_name: Branch name to parse\n\n    Returns:\n        Issue number if branch matches planned/review-{number}- pattern, else None\n\n    Examples:\n        >>> extract_plan_review_issue_number(\"planned/review-6214-01-15-1430\")\n        6214\n        >>> extract_plan_review_issue_number(\"planned/review-42-01-28-0930\")\n        42\n        >>> extract_plan_review_issue_number(\"P2382-convert-erk-create-raw-ext\")\n        None\n        >>> extract_plan_review_issue_number(\"feature-branch\")\n        None\n    \"\"\"\n    match = re.match(r\"^planned/review-(\\d+)-\", branch_name)\n    if match:\n        return int(match.group(1))\n    return None\n\n\ndef ensure_unique_worktree_name_with_date(base_name: str, worktrees_dir: Path, git_ops) -> str:\n    \"\"\"Ensure unique worktree name with datetime suffix and smart versioning.\n\n    Adds datetime suffix in format -YY-MM-DD-HHMM to the base name.\n    If a worktree with that name exists, increments numeric suffix starting at 2 AFTER the datetime.\n    Uses LBYL pattern: checks via git_ops.worktree.path_exists() before operations.\n\n    This function is used for plan-derived worktrees where multiple worktrees may be\n    created from the same plan, requiring datetime-based disambiguation.\n\n    Args:\n        base_name: Sanitized worktree base name (without datetime suffix)\n        worktrees_dir: Directory containing worktrees\n        git_ops: Git operations interface for checking path existence\n\n    Returns:\n        Guaranteed unique worktree name with datetime suffix\n\n    Examples:\n        First time: \"my-feature\" → \"my-feature-25-11-08-1430\"\n        Duplicate: \"my-feature\" → \"my-feature-25-11-08-1430-2\"\n        Next minute: \"my-feature\" → \"my-feature-25-11-08-1431\"\n    \"\"\"\n    date_suffix = datetime.now().strftime(WORKTREE_DATE_SUFFIX_FORMAT)\n    candidate_name = f\"{base_name}-{date_suffix}\"\n\n    # Check if the base candidate exists\n    if not git_ops.worktree.path_exists(worktrees_dir / candidate_name):\n        return candidate_name\n\n    # Name exists, find next available number (append after date)\n    counter = 2\n    while True:\n        versioned_name = f\"{base_name}-{date_suffix}-{counter}\"\n        if not git_ops.worktree.path_exists(worktrees_dir / versioned_name):\n            return versioned_name\n        counter += 1\n\n\ndef ensure_simple_worktree_name(base_name: str, worktrees_dir: Path, git_ops) -> str:\n    \"\"\"Ensure simple worktree name without date suffix for manual checkouts.\n\n    Returns the simple name if no worktree exists at that path.\n    If a worktree already exists, returns the simple name (caller validates branch match).\n    Uses LBYL pattern: checks via git_ops.worktree.path_exists() before operations.\n\n    This function is used for manual checkout operations where predictable names are\n    desired (e.g., `erk co feature` → `feature` not `feature-25-11-08`).\n\n    Args:\n        base_name: Sanitized worktree base name\n        worktrees_dir: Directory containing worktrees\n        git_ops: Git operations interface for checking path existence\n\n    Returns:\n        Simple worktree name without date suffix\n\n    Examples:\n        First time: \"my-feature\" → \"my-feature\"\n        Exists: \"my-feature\" → \"my-feature\" (caller handles validation)\n    \"\"\"\n    candidate_name = base_name\n    # Always return simple name - collision handling happens in caller\n    return candidate_name\n\n\ndef ensure_unique_worktree_name(base_name: str, worktrees_dir: Path, git_ops) -> str:\n    \"\"\"Deprecated: Use ensure_unique_worktree_name_with_date for plan-derived worktrees.\n\n    This function is kept for backward compatibility but will be removed in the future.\n    New code should use:\n    - ensure_unique_worktree_name_with_date() for plan-derived worktrees\n    - ensure_simple_worktree_name() for manual checkout operations\n    \"\"\"\n    return ensure_unique_worktree_name_with_date(base_name, worktrees_dir, git_ops)\n\n\ndef default_branch_for_worktree(name: str) -> str:\n    \"\"\"Default branch name for a worktree with the given `name`.\n\n    Returns the sanitized name directly (without any prefix).\n\n    Args:\n        name: Worktree name\n\n    Returns:\n        Default branch name (sanitized)\n\n    Examples:\n        >>> default_branch_for_worktree(\"my-feature\")\n        \"my-feature\"\n        >>> default_branch_for_worktree(\"Fix Bug!\")\n        \"fix-bug\"\n    \"\"\"\n    return sanitize_branch_component(name)\n\n\ndef generate_issue_branch_name(\n    issue_number: int | str,\n    title: str,\n    timestamp: datetime,\n    *,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate branch name for issue-based worktree.\n\n    Format: P{issue_number}-{sanitized_title}-{timestamp}\n    Or with objective: P{issue_number}-O{objective_id}-{sanitized_title}-{timestamp}\n    Example: P123-fix-auth-bug-01-15-1430\n    Example with objective: P123-O456-fix-auth-bug-01-15-1430\n\n    The branch name is constructed as:\n    1. P prefix + issue number + hyphen\n    2. If objective_id provided: O prefix + objective_id + hyphen\n    3. Sanitized title (lowercased, special chars replaced)\n    4. Truncated to 31 chars total (before timestamp)\n    5. Timestamp suffix appended (format: -MM-DD-HHMM)\n\n    Args:\n        issue_number: GitHub issue number\n        title: Issue title to sanitize\n        timestamp: Timestamp for the suffix\n        objective_id: Optional objective ID to encode in branch name\n\n    Returns:\n        Branch name in format P{num}-{slug}-{timestamp} or P{num}-O{obj}-{slug}-{timestamp}\n\n    Examples:\n        >>> from datetime import datetime\n        >>> generate_issue_branch_name(\n        ...     123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n        ... )\n        \"P123-fix-auth-bug-01-15-1430\"\n        >>> generate_issue_branch_name(\n        ...     123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456\n        ... )\n        \"P123-O456-fix-auth-bug-01-15-1430\"\n    \"\"\"\n    prefix = f\"P{issue_number}-\"\n    if objective_id is not None:\n        prefix += f\"O{objective_id}-\"\n    sanitized_title = sanitize_worktree_name(title)\n    base_branch_name = (prefix + sanitized_title)[:31].rstrip(\"-\")\n    timestamp_suffix = format_branch_timestamp_suffix(timestamp)\n    return base_branch_name + timestamp_suffix\n\n\ndef generate_draft_pr_branch_name(\n    title: str,\n    timestamp: datetime,\n    *,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate branch name for draft-PR-backed plans.\n\n    Format: plnd/{sanitized_title}-{timestamp}\n    Or with objective: plnd/O{objective_id}-{sanitized_title}-{timestamp}\n    Example: plnd/fix-auth-bug-01-15-1430\n    Example with objective: plnd/O456-fix-auth-bug-01-15-1430\n\n    No P{issue} prefix since the PR number isn't known until after creation.\n\n    Args:\n        title: Plan title to sanitize\n        timestamp: Timestamp for the suffix\n        objective_id: Optional objective ID to encode in branch name\n\n    Returns:\n        Branch name in format plnd/{slug}-{timestamp}\n\n    Examples:\n        >>> from datetime import datetime\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n        ... )\n        \"plnd/fix-auth-bug-01-15-1430\"\n        >>> generate_draft_pr_branch_name(\n        ...     \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), objective_id=456\n        ... )\n        \"plnd/O456-fix-auth-bug-01-15-1430\"\n    \"\"\"\n    prefix = \"plnd/\"\n    if objective_id is not None:\n        prefix += f\"O{objective_id}-\"\n    sanitized_title = sanitize_worktree_name(title)\n    base_branch_name = (prefix + sanitized_title)[:31].rstrip(\"-\")\n    timestamp_suffix = format_branch_timestamp_suffix(timestamp)\n    return base_branch_name + timestamp_suffix\n\n\ndef derive_branch_name_from_title(title: str) -> str:\n    \"\"\"Derive branch name from issue/plan title.\n\n    This function matches the logic used by the erk-impl workflow\n    to ensure CLI and workflow produce identical branch names.\n\n    Transforms:\n    - Lowercase\n    - Replace non-alphanumeric (except hyphen) with hyphen\n    - Collapse consecutive hyphens\n    - Strip leading/trailing hyphens\n    - Truncate to 30 chars\n    - Strip trailing hyphen after truncation\n\n    Args:\n        title: Issue or plan title\n\n    Returns:\n        Branch name (max 30 chars, kebab-case)\n\n    Examples:\n        >>> derive_branch_name_from_title(\"My Feature\")\n        \"my-feature\"\n        >>> derive_branch_name_from_title(\"Fix Bug #123!\")\n        \"fix-bug-123\"\n        >>> derive_branch_name_from_title(\"A\" * 40)\n        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"  # 30 chars (one less than sanitize_branch_component)\n    \"\"\"\n    # Convert to lowercase\n    branch_name = title.lower()\n    # Replace non-alphanumeric (except hyphen) with hyphen\n    branch_name = re.sub(r\"[^a-z0-9-]\", \"-\", branch_name)\n    # Collapse consecutive hyphens\n    branch_name = re.sub(r\"-+\", \"-\", branch_name)\n    # Strip leading/trailing hyphens\n    branch_name = branch_name.strip(\"-\")\n\n    # Truncate to 30 chars (matches workflow logic)\n    branch_name = branch_name[:30]\n\n    # Strip trailing hyphen after truncation\n    branch_name = branch_name.rstrip(\"-\")\n\n    return branch_name\n","structuredPatch":[{"oldStart":620,"oldLines":26,"newStart":620,"newLines":29,"lines":[" def extract_plan_review_issue_number(branch_name: str) -> int | None:","     \"\"\"Extract issue number from a plan review branch name."," ","-    Plan review branches follow the pattern: planned/review-{issue_number}-{timestamp}","-    Examples: \"planned/review-6214-01-15-1430\"","+    Plan review branches follow the pattern: plnd/review-{issue_number}-{timestamp}","+    Legacy pattern: planned/review-{issue_number}-{timestamp}","+    Examples: \"plnd/review-6214-01-15-1430\""," ","     Args:","         branch_name: Branch name to parse"," ","     Returns:","-        Issue number if branch matches planned/review-{number}- pattern, else None","+        Issue number if branch matches plnd/review-{number}- pattern, else None"," ","     Examples:","-        >>> extract_plan_review_issue_number(\"planned/review-6214-01-15-1430\")","+        >>> extract_plan_review_issue_number(\"plnd/review-6214-01-15-1430\")","         6214","-        >>> extract_plan_review_issue_number(\"planned/review-42-01-28-0930\")","+        >>> extract_plan_review_issue_number(\"plnd/review-42-01-28-0930\")","         42","+        >>> extract_plan_review_issue_number(\"planned/review-6214-01-15-1430\")","+        6214","         >>> extract_plan_review_issue_number(\"P2382-convert-erk-create-raw-ext\")","         None","         >>> extract_plan_review_issue_number(\"feature-branch\")","         None","     \"\"\"","-    match = re.match(r\"^planned/review-(\\d+)-\", branch_name)","+    match = re.match(r\"^pl(?:an(?:ned)?|nd)/review-(\\d+)-\", branch_name)","     if match:","         return int(match.group(1))","     return None"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"8c45b1c1-d9c7-4dad-a5cf-f421fa4efbd2","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_018yRQS1aZSruQ9mL4na24zX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WrJw7egaHgYbNq9avnkxQh","name":"TodoWrite","input":{"todos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"in_progress","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":763,"cache_read_input_tokens":55817,"cache_creation":{"ephemeral_5m_input_tokens":763,"ephemeral_1h_input_tokens":0},"output_tokens":533,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHRajiXErqLFFprrs3B","type":"assistant","uuid":"1d4821b3-515f-48a8-918d-4c934acb056f","timestamp":"2026-02-22T14:42:44.480Z"}
{"parentUuid":"1d4821b3-515f-48a8-918d-4c934acb056f","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WrJw7egaHgYbNq9avnkxQh","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"46164f7d-d86b-4078-8445-25fdb4836b6b","timestamp":"2026-02-22T14:42:44.489Z","toolUseResult":{"oldTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"in_progress","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"pending","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"pending","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}],"newTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"in_progress","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]}}
{"parentUuid":"46164f7d-d86b-4078-8445-25fdb4836b6b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01LW3xUAYPqfSuBA8YnTQymH","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the two `_add_planned_prefix()` functions. These use the constant, so the docstrings just need updating:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":56580,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHS1QnJJJDeJioH1C7R","type":"assistant","uuid":"a6c5ff06-c180-4ab4-ae50-c914abe07733","timestamp":"2026-02-22T14:42:47.140Z"}
{"parentUuid":"a6c5ff06-c180-4ab4-ae50-c914abe07733","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01LW3xUAYPqfSuBA8YnTQymH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01P7vZkBm4b3kzccjNwrxGVi","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/commands/submit.py","old_string":"def _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'planned/' prefix, skipping if already prefixed\n    \"\"\"","new_string":"def _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'plnd/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'plnd/' prefix, skipping if already prefixed\n    \"\"\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":56580,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHS1QnJJJDeJioH1C7R","type":"assistant","uuid":"e9f016e5-896e-4bc9-9635-eeb93d97d37c","timestamp":"2026-02-22T14:42:49.657Z"}
{"parentUuid":"e9f016e5-896e-4bc9-9635-eeb93d97d37c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01P7vZkBm4b3kzccjNwrxGVi","type":"tool_result","content":"The file /home/runner/work/erk/erk/src/erk/cli/commands/submit.py has been updated successfully."}]},"uuid":"b3d6b488-a089-4bf3-a379-88df2095c33e","timestamp":"2026-02-22T14:42:50.330Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/commands/submit.py","oldString":"def _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'planned/' prefix, skipping if already prefixed\n    \"\"\"","newString":"def _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'plnd/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'plnd/' prefix, skipping if already prefixed\n    \"\"\"","originalFile":"\"\"\"Submit issue for remote AI implementation via GitHub Actions.\"\"\"\n\nimport logging\nimport tomllib\nfrom collections.abc import Iterator\nfrom contextlib import contextmanager\nfrom dataclasses import dataclass\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nimport click\n\nfrom erk.cli.commands.pr.metadata_helpers import write_dispatch_metadata\nfrom erk.cli.commands.slot.common import is_placeholder_branch\nfrom erk.cli.commands.submit_helpers import ensure_trunk_synced\nfrom erk.cli.constants import (\n    DISPATCH_WORKFLOW_METADATA_NAME,\n    DISPATCH_WORKFLOW_NAME,\n    ERK_PLAN_LABEL,\n    ERK_PLAN_TITLE_PREFIX,\n    PLAN_HEADING_PREFIX,\n    PLANNED_PR_TITLE_PREFIX,\n)\nfrom erk.cli.core import discover_repo_context\nfrom erk.cli.ensure import Ensure, UserFacingCliError\nfrom erk.core.context import ErkContext\nfrom erk.core.repo_discovery import RepoContext\nfrom erk_shared.gateway.branch_manager.types import SubmitBranchError\nfrom erk_shared.gateway.git.branch_ops.types import BranchAlreadyExists\nfrom erk_shared.gateway.git.remote_ops.types import PullRebaseError, PushError\nfrom erk_shared.gateway.github.issues.types import IssueInfo, IssueNotFound\nfrom erk_shared.gateway.github.metadata.core import (\n    create_submission_queued_block,\n    render_erk_issue_event,\n)\nfrom erk_shared.gateway.github.parsing import (\n    construct_pr_url,\n    construct_workflow_run_url,\n    extract_owner_repo_from_github_url,\n)\nfrom erk_shared.gateway.github.pr_footer import build_pr_body_footer\nfrom erk_shared.gateway.github.types import PRNotFound\nfrom erk_shared.gateway.gt.operations.finalize import ERK_SKIP_LEARN_LABEL\nfrom erk_shared.naming import generate_issue_branch_name\nfrom erk_shared.output.output import user_output\nfrom erk_shared.plan_store.types import PlanNotFound\nfrom erk_shared.worker_impl_folder import (\n    create_worker_impl_folder,\n    remove_worker_impl_folder,\n    worker_impl_folder_exists,\n)\n\nlogger = logging.getLogger(__name__)\n\n\ndef _format_issue_ref(issue_number: int, plans_repo: str | None) -> str:\n    \"\"\"Format issue reference for PR body.\n\n    Args:\n        issue_number: The issue number\n        plans_repo: Target repo in \"owner/repo\" format, or None for same repo\n\n    Returns:\n        \"#N\" for same-repo, \"owner/repo#N\" for cross-repo\n    \"\"\"\n    if plans_repo is None:\n        return f\"#{issue_number}\"\n    return f\"{plans_repo}#{issue_number}\"\n\n\n@contextmanager\ndef branch_rollback(ctx: ErkContext, repo_root: Path, original_branch: str) -> Iterator[None]:\n    \"\"\"Context manager that restores original branch on exception.\n\n    On success, does nothing (caller handles cleanup).\n    On exception, checks out original_branch and re-raises.\n    \"\"\"\n    try:\n        yield\n    except Exception:\n        user_output(\n            click.style(\"Error: \", fg=\"red\") + \"Operation failed, restoring original branch...\"\n        )\n        ctx.branch_manager.checkout_branch(repo_root, original_branch)\n        raise\n\n\ndef is_issue_learn_plan(labels: list[str]) -> bool:\n    \"\"\"Check if an issue is a learn plan by checking for erk-learn label.\n\n    Args:\n        labels: The issue's labels\n\n    Returns:\n        True if the issue has the erk-learn label, False otherwise\n    \"\"\"\n    return \"erk-learn\" in labels\n\n\ndef _find_existing_branches_for_issue(\n    ctx: ErkContext,\n    repo_root: Path,\n    issue_number: int,\n) -> list[str]:\n    \"\"\"Find local branches matching P{issue_number}-* pattern.\"\"\"\n    local_branches = ctx.git.branch.list_local_branches(repo_root)\n    prefix = f\"P{issue_number}-\"\n    return sorted([b for b in local_branches if b.startswith(prefix)])\n\n\ndef _prompt_existing_branch_action(\n    ctx: ErkContext,\n    repo_root: Path,\n    existing_branches: list[str],\n    new_branch_name: str,\n    *,\n    force: bool,\n) -> str | None:\n    \"\"\"Prompt user to decide what to do with existing branch(es).\n\n    Args:\n        ctx: ErkContext with git operations\n        repo_root: Repository root path\n        existing_branches: List of existing branch names matching the issue pattern\n        new_branch_name: Name for new branch if creating fresh\n        force: If True, delete existing branches without prompting\n\n    Returns:\n        - Branch name to use (existing branch)\n        - None to signal \"create new\" (after deleting existing)\n    \"\"\"\n    if force:\n        user_output(f\"\\nDeleting {len(existing_branches)} existing branch(es) (--force mode):\")\n        for branch in existing_branches:\n            ctx.branch_manager.delete_branch(repo_root, branch, force=True)\n            user_output(f\"  Deleted: {branch}\")\n        return None  # Signal \"create new branch\"\n\n    user_output(\"\\nFound existing local branch(es) for this issue:\")\n    for branch in existing_branches:\n        user_output(f\"  • {branch}\")\n    user_output(f\"\\nNew branch would be: {click.style(new_branch_name, fg='cyan')}\")\n    user_output(\"\")\n\n    # Use newest branch (latest timestamp = last alphabetically)\n    branch_to_use = existing_branches[-1]\n\n    # Single binary prompt\n    reuse = ctx.console.confirm(\n        f\"Reuse existing branch '{branch_to_use}'? \"\n        \"If not, a new branch and PR will be created (old draft PR will be closed)\",\n        default=True,\n    )\n\n    if reuse:\n        return branch_to_use\n\n    # Delete existing branches and signal \"create new\"\n    for branch in existing_branches:\n        ctx.branch_manager.delete_branch(repo_root, branch, force=True)\n        user_output(f\"Deleted branch: {branch}\")\n    return None\n\n\ndef get_learn_plan_parent_branch(ctx: ErkContext, repo_root: Path, plan_id: str) -> str | None:\n    \"\"\"Get the parent branch for a learn plan.\n\n    Learn plans should stack on their parent plan's branch.\n    Extracts learned_from_issue via plan_backend, fetches parent's branch_name.\n\n    Args:\n        ctx: ErkContext with plan_backend\n        repo_root: Repository root path\n        plan_id: Plan identifier\n\n    Returns:\n        Parent plan's branch_name if found, None otherwise\n    \"\"\"\n    learned_from = ctx.plan_backend.get_metadata_field(repo_root, plan_id, \"learned_from_issue\")\n    if isinstance(learned_from, PlanNotFound) or learned_from is None:\n        return None\n\n    branch_name = ctx.plan_backend.get_metadata_field(repo_root, str(learned_from), \"branch_name\")\n    if isinstance(branch_name, PlanNotFound) or branch_name is None:\n        return None\n    return str(branch_name)\n\n\ndef load_workflow_config(repo_root: Path, workflow_name: str) -> dict[str, str]:\n    \"\"\"Load workflow config from .erk/config.toml [workflows.<name>] section.\n\n    Args:\n        repo_root: Repository root path\n        workflow_name: Workflow filename (with or without .yml/.yaml extension).\n            Only the basename is used for config lookup.\n\n    Returns:\n        Dict of string key-value pairs for workflow inputs.\n        Returns empty dict if config file or section doesn't exist.\n\n    Example:\n        For workflow_name=\"plan-implement.yml\", reads from:\n        .erk/config.toml -> [workflows.plan-implement] section\n    \"\"\"\n    config_path = repo_root / \".erk\" / \"config.toml\"\n\n    if not config_path.exists():\n        return {}\n\n    with open(config_path, \"rb\") as f:\n        data = tomllib.load(f)\n\n    # Extract basename and strip .yml/.yaml extension\n    basename = Path(workflow_name).name\n    config_name = basename.removesuffix(\".yml\").removesuffix(\".yaml\")\n\n    # Get [workflows.<name>] section\n    workflows_section = data.get(\"workflows\", {})\n    workflow_config = workflows_section.get(config_name, {})\n\n    # Convert all values to strings (workflow inputs are always strings)\n    return {k: str(v) for k, v in workflow_config.items()}\n\n\n@dataclass(frozen=True)\nclass ValidatedIssue:\n    \"\"\"Issue that passed all validation checks.\"\"\"\n\n    number: int\n    issue: IssueInfo\n    branch_name: str\n    branch_exists: bool\n    pr_number: int | None\n    is_learn_origin: bool\n\n\n@dataclass(frozen=True)\nclass SubmitResult:\n    \"\"\"Result of submitting a single issue.\"\"\"\n\n    issue_number: int\n    issue_title: str\n    issue_url: str\n    pr_number: int | None\n    pr_url: str | None\n    workflow_run_id: str\n    workflow_url: str\n\n\ndef _build_workflow_run_url(issue_url: str, run_id: str) -> str:\n    \"\"\"Construct GitHub Actions workflow run URL from issue URL and run ID.\n\n    Args:\n        issue_url: GitHub issue URL (e.g., https://github.com/owner/repo/issues/123)\n        run_id: Workflow run ID\n\n    Returns:\n        Workflow run URL (e.g., https://github.com/owner/repo/actions/runs/1234567890)\n    \"\"\"\n    owner_repo = extract_owner_repo_from_github_url(issue_url)\n    if owner_repo is not None:\n        owner, repo = owner_repo\n        return construct_workflow_run_url(owner, repo, run_id)\n    return f\"https://github.com/actions/runs/{run_id}\"\n\n\ndef _strip_plan_markers(title: str) -> str:\n    \"\"\"Strip '[erk-plan]' prefix and 'Plan:' prefix from issue title for use as PR title.\"\"\"\n    result = title\n    # Strip \"[erk-plan] \" prefix if present\n    if result.startswith(ERK_PLAN_TITLE_PREFIX):\n        result = result[len(ERK_PLAN_TITLE_PREFIX) :]\n    # Strip \"Plan: \" prefix if present\n    if result.startswith(PLAN_HEADING_PREFIX):\n        result = result[len(PLAN_HEADING_PREFIX) :]\n    return result\n\n\ndef _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'planned/' prefix, skipping if already prefixed\n    \"\"\"\n    if title.startswith(PLANNED_PR_TITLE_PREFIX):\n        return title\n    return f\"{PLANNED_PR_TITLE_PREFIX}{title}\"\n\n\ndef _build_pr_url(issue_url: str, pr_number: int) -> str:\n    \"\"\"Construct GitHub PR URL from issue URL and PR number.\n\n    Args:\n        issue_url: GitHub issue URL (e.g., https://github.com/owner/repo/issues/123)\n        pr_number: PR number\n\n    Returns:\n        PR URL (e.g., https://github.com/owner/repo/pull/456)\n    \"\"\"\n    owner_repo = extract_owner_repo_from_github_url(issue_url)\n    if owner_repo is not None:\n        owner, repo = owner_repo\n        return construct_pr_url(owner, repo, pr_number)\n    return f\"https://github.com/pull/{pr_number}\"\n\n\ndef _close_orphaned_draft_prs(\n    ctx: ErkContext,\n    repo_root: Path,\n    issue_number: int,\n    keep_pr_number: int,\n) -> list[int]:\n    \"\"\"Close old draft PRs linked to an issue, keeping the specified one.\n\n    Returns list of PR numbers that were closed.\n    \"\"\"\n    linked_prs = ctx.issues.get_prs_referencing_issue(repo_root, issue_number)\n\n    closed_prs: list[int] = []\n    for pr in linked_prs:\n        # Close orphaned drafts: draft PRs that are OPEN and not the one we just created\n        # Any draft PR linked to an erk-plan issue is fair game to close\n        if pr.is_draft and pr.state == \"OPEN\" and pr.number != keep_pr_number:\n            ctx.github.close_pr(repo_root, pr.number)\n            closed_prs.append(pr.number)\n\n    return closed_prs\n\n\n@dataclass(frozen=True)\nclass ValidatedDraftPR:\n    \"\"\"Draft PR that passed all validation checks.\"\"\"\n\n    number: int\n    title: str\n    url: str\n    branch_name: str\n\n\ndef _validate_draft_pr_for_submit(\n    ctx: ErkContext,\n    repo: RepoContext,\n    plan_number: int,\n) -> ValidatedDraftPR:\n    \"\"\"Validate a draft PR plan for submission.\n\n    Fetches the PR, validates it has the erk-plan label and is OPEN.\n\n    Args:\n        ctx: ErkContext with git operations\n        repo: Repository context\n        plan_number: PR number to validate\n\n    Raises:\n        SystemExit: If PR doesn't exist, missing label, or not OPEN.\n    \"\"\"\n    pr_result = ctx.github.get_pr(repo.root, plan_number)\n    if isinstance(pr_result, PRNotFound):\n        user_output(click.style(\"Error: \", fg=\"red\") + f\"PR #{plan_number} not found\")\n        raise SystemExit(1)\n\n    # Validate: must have erk-plan label\n    if ERK_PLAN_LABEL not in pr_result.labels:\n        user_output(\n            click.style(\"Error: \", fg=\"red\")\n            + f\"PR #{plan_number} does not have {ERK_PLAN_LABEL} label\\n\\n\"\n            \"Cannot submit non-plan PRs for automated implementation.\"\n        )\n        raise SystemExit(1)\n\n    # Validate: must be OPEN\n    if pr_result.state != \"OPEN\":\n        user_output(\n            click.style(\"Error: \", fg=\"red\") + f\"PR #{plan_number} is {pr_result.state}\\n\\n\"\n            \"Cannot submit closed PRs for automated implementation.\"\n        )\n        raise SystemExit(1)\n\n    return ValidatedDraftPR(\n        number=plan_number,\n        title=pr_result.title,\n        url=pr_result.url,\n        branch_name=pr_result.head_ref_name,\n    )\n\n\ndef _submit_draft_pr_plan(\n    ctx: ErkContext,\n    *,\n    repo: RepoContext,\n    validated: ValidatedDraftPR,\n    submitted_by: str,\n    original_branch: str,\n    base_branch: str,\n) -> SubmitResult:\n    \"\"\"Submit a validated draft-PR plan for implementation.\n\n    For draft-PR plans, the branch and PR already exist. This function:\n    - Fetches and checks out the existing plan branch\n    - Creates .worker-impl/ with provider=\"github-draft-pr\"\n    - Commits and pushes .worker-impl/ to existing branch\n    - Triggers the workflow with plan_backend=\"draft_pr\"\n\n    Args:\n        ctx: ErkContext with git operations\n        repo: Repository context\n        validated: Validated draft PR information\n        submitted_by: GitHub username of submitter\n        original_branch: Original branch name (to restore after)\n        base_branch: Base branch for PR\n\n    Returns:\n        SubmitResult with URLs and identifiers.\n    \"\"\"\n    plan_number = validated.number\n    branch_name = validated.branch_name\n\n    # Fetch plan content via PlanBackend\n    user_output(\"Fetching plan content...\")\n    result = ctx.plan_store.get_plan(repo.root, str(plan_number))\n    if isinstance(result, PlanNotFound):\n        user_output(click.style(\"Error: \", fg=\"red\") + f\"PR #{plan_number}: plan content not found\")\n        raise SystemExit(1)\n    plan = result\n\n    # Fetch and checkout the existing plan branch\n    user_output(f\"Checking out existing plan branch: {click.style(branch_name, fg='cyan')}\")\n    ctx.git.remote.fetch_branch(repo.root, \"origin\", branch_name)\n\n    local_branches = ctx.git.branch.list_local_branches(repo.root)\n    if branch_name not in local_branches:\n        remote_ref = f\"origin/{branch_name}\"\n        ctx.branch_manager.create_tracking_branch(repo.root, branch_name, remote_ref)\n\n    ctx.branch_manager.checkout_branch(repo.root, branch_name)\n\n    # Sync local branch with remote (may be behind from prior submission or CI)\n    pull_result = ctx.git.remote.pull_rebase(repo.root, \"origin\", branch_name)\n    if isinstance(pull_result, PullRebaseError):\n        raise UserFacingCliError(\n            f\"Failed to sync branch '{branch_name}' with remote: {pull_result.message}\"\n        )\n\n    # Clean up previous .worker-impl/ if it exists (e.g., from a prior failed submission)\n    if worker_impl_folder_exists(repo.root):\n        user_output(\"Cleaning up previous .worker-impl/ folder...\")\n        remove_worker_impl_folder(repo.root)\n\n    # Create .worker-impl/ with draft-PR provider\n    user_output(\"Creating .worker-impl/ folder...\")\n    create_worker_impl_folder(\n        plan_content=plan.body,\n        plan_id=str(plan_number),\n        url=validated.url,\n        repo_root=repo.root,\n        provider=\"github-draft-pr\",\n        objective_id=plan.objective_id,\n    )\n\n    # Stage, commit, and push\n    ctx.git.commit.stage_files(repo.root, [\".worker-impl\"])\n    ctx.git.commit.commit(repo.root, f\"Add plan for PR #{plan_number}\")\n    push_result = ctx.git.remote.push_to_remote(\n        repo.root, \"origin\", branch_name, set_upstream=False, force=False\n    )\n    if isinstance(push_result, PushError):\n        raise UserFacingCliError(push_result.message)\n    user_output(click.style(\"✓\", fg=\"green\") + \" Branch pushed to remote\")\n\n    # Switch back to original branch\n    ctx.branch_manager.checkout_branch(repo.root, original_branch)\n\n    # Gather submission metadata\n    queued_at = datetime.now(UTC).isoformat()\n\n    # Load workflow-specific config\n    workflow_config = load_workflow_config(repo.root, DISPATCH_WORKFLOW_NAME)\n\n    # Build inputs dict with plan_backend=\"draft_pr\"\n    user_output(\"\")\n    user_output(f\"Triggering workflow: {click.style(DISPATCH_WORKFLOW_NAME, fg='cyan')}\")\n\n    inputs = {\n        \"plan_id\": str(plan_number),\n        \"submitted_by\": submitted_by,\n        \"plan_title\": validated.title,\n        \"branch_name\": branch_name,\n        \"pr_number\": str(plan_number),\n        \"base_branch\": base_branch,\n        \"plan_backend\": \"draft_pr\",\n        **workflow_config,\n    }\n\n    run_id = ctx.github.trigger_workflow(\n        repo_root=repo.root,\n        workflow=DISPATCH_WORKFLOW_NAME,\n        inputs=inputs,\n    )\n    user_output(click.style(\"✓\", fg=\"green\") + \" Workflow triggered.\")\n\n    # Compute workflow URL\n    workflow_url = _build_workflow_run_url(validated.url, run_id)\n\n    # Write dispatch metadata FIRST (before any PR body modification)\n    try:\n        write_dispatch_metadata(\n            plan_backend=ctx.plan_backend,\n            github=ctx.github,\n            repo_root=repo.root,\n            issue_number=plan_number,\n            run_id=run_id,\n            dispatched_at=queued_at,\n        )\n        user_output(click.style(\"✓\", fg=\"green\") + \" Dispatch metadata written\")\n    except Exception as e:\n        user_output(\n            click.style(\"Warning: \", fg=\"yellow\") + f\"Failed to update dispatch metadata: {e}\"\n        )\n\n    # Update PR body with workflow run link (best-effort)\n    # Guard: only append if body is non-empty to avoid overwriting metadata block\n    try:\n        pr_details = ctx.github.get_pr(repo.root, plan_number)\n        if not isinstance(pr_details, PRNotFound) and pr_details.body:\n            updated_body = pr_details.body + f\"\\n\\n**Workflow run:** {workflow_url}\"\n            ctx.github.update_pr_body(repo.root, plan_number, updated_body)\n    except Exception as e:\n        logger.warning(\"Failed to update PR body with workflow run link: %s\", e)\n\n    # Post queued event comment via PlanBackend\n    try:\n        validation_results = {\n            \"pr_is_open\": True,\n            \"has_erk_plan_label\": True,\n        }\n\n        metadata_block = create_submission_queued_block(\n            queued_at=queued_at,\n            submitted_by=submitted_by,\n            issue_number=plan_number,\n            validation_results=validation_results,\n            expected_workflow=DISPATCH_WORKFLOW_METADATA_NAME,\n        )\n\n        comment_body = render_erk_issue_event(\n            title=\"🔄 Plan Queued for Implementation\",\n            metadata=metadata_block,\n            description=(\n                f\"Plan submitted by **{submitted_by}** at {queued_at}.\\n\\n\"\n                f\"The `{DISPATCH_WORKFLOW_METADATA_NAME}` workflow has been \"\n                f\"triggered via direct dispatch.\\n\\n\"\n                f\"**Workflow run:** {workflow_url}\"\n            ),\n        )\n\n        user_output(\"Posting queued event comment...\")\n        ctx.plan_backend.add_comment(repo.root, str(plan_number), comment_body)\n        user_output(click.style(\"✓\", fg=\"green\") + \" Queued event comment posted\")\n    except Exception as e:\n        user_output(\n            click.style(\"Warning: \", fg=\"yellow\")\n            + f\"Failed to post queued comment: {e}\\n\"\n            + \"Workflow is already running.\"\n        )\n\n    pr_url = _build_pr_url(validated.url, plan_number)\n\n    return SubmitResult(\n        issue_number=plan_number,\n        issue_title=validated.title,\n        issue_url=validated.url,\n        pr_number=plan_number,\n        pr_url=pr_url,\n        workflow_run_id=run_id,\n        workflow_url=workflow_url,\n    )\n\n\ndef _validate_issue_for_submit(\n    ctx: ErkContext,\n    repo: RepoContext,\n    issue_number: int,\n    base_branch: str,\n    *,\n    force: bool,\n) -> ValidatedIssue:\n    \"\"\"Validate a single issue for submission.\n\n    Fetches the issue, validates constraints, derives branch name, and checks\n    if branch/PR already exist.\n\n    Args:\n        ctx: ErkContext with git operations\n        repo: Repository context\n        issue_number: GitHub issue number to validate\n        base_branch: Base branch for PR (trunk or custom feature branch)\n\n    Raises:\n        SystemExit: If issue doesn't exist, missing label, or closed.\n    \"\"\"\n    # Fetch issue from GitHub\n    issue = ctx.issues.get_issue(repo.root, issue_number)\n    if isinstance(issue, IssueNotFound):\n        user_output(click.style(\"Error: \", fg=\"red\") + f\"Issue #{issue.issue_number} not found\")\n        raise SystemExit(1)\n\n    # Validate: must have erk-plan label\n    if ERK_PLAN_LABEL not in issue.labels:\n        user_output(\n            click.style(\"Error: \", fg=\"red\")\n            + f\"Issue #{issue_number} does not have {ERK_PLAN_LABEL} label\\n\\n\"\n            \"Cannot submit non-plan issues for automated implementation.\\n\"\n            \"To create a plan, use Plan Mode then /erk:plan-save\"\n        )\n        raise SystemExit(1)\n\n    # Validate: must be OPEN\n    if issue.state != \"OPEN\":\n        user_output(\n            click.style(\"Error: \", fg=\"red\") + f\"Issue #{issue_number} is {issue.state}\\n\\n\"\n            \"Cannot submit closed issues for automated implementation.\"\n        )\n        raise SystemExit(1)\n\n    # Use provided base_branch instead of detecting trunk\n    logger.debug(\"base_branch=%s\", base_branch)\n\n    # Check for existing local branches BEFORE computing new name\n    existing_branches = _find_existing_branches_for_issue(ctx, repo.root, issue_number)\n\n    # Compute branch name using canonical naming function\n    objective_id_raw = ctx.plan_backend.get_metadata_field(\n        repo.root, str(issue_number), \"objective_issue\"\n    )\n    objective_id: int | None = None\n    if isinstance(objective_id_raw, int):\n        objective_id = objective_id_raw\n    elif isinstance(objective_id_raw, str) and objective_id_raw.isdigit():\n        objective_id = int(objective_id_raw)\n    new_branch_name = generate_issue_branch_name(\n        issue_number, issue.title, ctx.time.now(), objective_id=objective_id\n    )\n\n    if existing_branches:\n        chosen = _prompt_existing_branch_action(\n            ctx, repo.root, existing_branches, new_branch_name, force=force\n        )\n        branch_name = chosen if chosen is not None else new_branch_name\n    else:\n        branch_name = new_branch_name\n\n    logger.debug(\"branch_name=%s\", branch_name)\n    user_output(f\"Computed branch: {click.style(branch_name, fg='cyan')}\")\n\n    # Check if branch already exists on remote and has a PR\n    branch_exists = ctx.git.branch.branch_exists_on_remote(repo.root, \"origin\", branch_name)\n    logger.debug(\"branch_exists_on_remote(%s)=%s\", branch_name, branch_exists)\n\n    pr_number: int | None = None\n    if branch_exists:\n        pr_details = ctx.github.get_pr_for_branch(repo.root, branch_name)\n        if not isinstance(pr_details, PRNotFound):\n            pr_number = pr_details.number\n\n    # Check if this issue is a learn plan\n    is_learn_origin = is_issue_learn_plan(issue.labels)\n\n    return ValidatedIssue(\n        number=issue_number,\n        issue=issue,\n        branch_name=branch_name,\n        branch_exists=branch_exists,\n        pr_number=pr_number,\n        is_learn_origin=is_learn_origin,\n    )\n\n\ndef _create_branch_and_pr(\n    ctx: ErkContext,\n    *,\n    repo: RepoContext,\n    validated: ValidatedIssue,\n    branch_name: str,\n    base_branch: str,\n    submitted_by: str,\n    original_branch: str,\n) -> int:\n    \"\"\"Create branch, commit, push, and create draft PR.\n\n    This function is called within the branch_rollback context manager.\n    On any exception, the context manager will restore the original branch.\n\n    Args:\n        ctx: ErkContext with git operations\n        repo: Repository context\n        validated: Validated issue information\n        branch_name: Name of branch to create\n        base_branch: Base branch for PR\n        submitted_by: GitHub username of submitter\n        original_branch: Original branch name (for cleanup on success)\n\n    Returns:\n        PR number of the created draft PR.\n    \"\"\"\n    issue = validated.issue\n    issue_number = validated.number\n\n    ctx.branch_manager.checkout_branch(repo.root, branch_name)\n\n    # Get plan content and create .worker-impl/ folder\n    user_output(\"Fetching plan content...\")\n    result = ctx.plan_store.get_plan(repo.root, str(issue_number))\n    if isinstance(result, PlanNotFound):\n        user_output(click.style(\"Error: \", fg=\"red\") + f\"Issue #{issue_number} not found\")\n        raise SystemExit(1)\n    plan = result\n\n    # Clean up previous .worker-impl/ if it exists (e.g., from a prior failed submission)\n    if worker_impl_folder_exists(repo.root):\n        user_output(\"Cleaning up previous .worker-impl/ folder...\")\n        remove_worker_impl_folder(repo.root)\n\n    user_output(\"Creating .worker-impl/ folder...\")\n    create_worker_impl_folder(\n        plan_content=plan.body,\n        plan_id=str(issue_number),\n        url=issue.url,\n        repo_root=repo.root,\n        provider=\"github\",\n        objective_id=plan.objective_id,\n    )\n\n    # Stage, commit, and push\n    ctx.git.commit.stage_files(repo.root, [\".worker-impl\"])\n    ctx.git.commit.commit(repo.root, f\"Add plan for issue #{issue_number}\")\n    push_result = ctx.git.remote.push_to_remote(\n        repo.root, \"origin\", branch_name, set_upstream=True, force=False\n    )\n    if isinstance(push_result, PushError):\n        raise UserFacingCliError(push_result.message)\n    user_output(click.style(\"✓\", fg=\"green\") + \" Branch pushed to remote\")\n\n    # Create draft PR\n    # IMPORTANT: \"Closes owner/repo#N\" (cross-repo) or \"Closes #N\" (same-repo)\n    # MUST be in the initial body passed to create_pr(), NOT added via update.\n    # GitHub's willCloseTarget API field is set at PR creation time and is NOT\n    # updated when the body is edited afterward.\n    user_output(\"Creating draft PR...\")\n    plans_repo = ctx.local_config.plans_repo if ctx.local_config else None\n    issue_ref = _format_issue_ref(issue_number, plans_repo)\n    pr_body = (\n        f\"**Author:** @{submitted_by}\\n\"\n        f\"**Plan:** {issue_ref}\\n\\n\"\n        f\"**Status:** Queued for implementation\\n\\n\"\n        f\"This PR will be marked ready for review after implementation completes.\\n\\n\"\n        f\"## Implementation Plan\\n\\n\"\n        f\"<details>\\n\"\n        f\"<summary><strong>Implementation Plan</strong> (Issue #{issue_number})</summary>\\n\\n\"\n        f\"{plan.body}\\n\\n\"\n        f\"</details>\\n\\n\"\n        f\"---\\n\\n\"\n        f\"Closes {issue_ref}\"\n    )\n    pr_title = _add_planned_prefix(_strip_plan_markers(issue.title))\n    pr_number = ctx.github.create_pr(\n        repo_root=repo.root,\n        branch=branch_name,\n        title=pr_title,\n        body=pr_body,\n        base=base_branch,\n        draft=True,\n    )\n    user_output(click.style(\"✓\", fg=\"green\") + f\" Draft PR #{pr_number} created\")\n\n    # Update PR body with checkout command footer\n    footer = build_pr_body_footer(\n        pr_number=pr_number, issue_number=issue_number, plans_repo=plans_repo\n    )\n    ctx.github.update_pr_body(repo.root, pr_number, pr_body + footer)\n\n    # Add extraction skip label if this is a learn plan\n    if validated.is_learn_origin:\n        ctx.github.add_label_to_pr(repo.root, pr_number, ERK_SKIP_LEARN_LABEL)\n        # FUTURE ENHANCEMENT: When a learn plan issue gets a PR, update the parent\n        # plan's learn_status from \"completed_with_plan\" to track the PR number.\n        # Currently, the parent only gets updated when the learn plan's PR lands\n        # (in land_cmd._update_parent_learn_status_if_learn_plan). Adding an\n        # intermediate state here would let the TUI show the PR number (e.g.,\n        # \"🚧 #5514\") instead of the learn plan issue number (e.g., \"#5508\")\n        # while the PR is still in review.\n        # See: LearnStatusValue in erk_shared/github/metadata/schemas.py\n\n    # Link PR with Graphite (if enabled)\n    if ctx.branch_manager.is_graphite_managed():\n        user_output(\"Linking PR with Graphite...\")\n        submit_result = ctx.branch_manager.submit_branch(repo.root, branch_name)\n        if isinstance(submit_result, SubmitBranchError):\n            user_output(\n                click.style(\"✗\", fg=\"red\")\n                + f\" Failed to link PR with Graphite: {submit_result.message}\"\n            )\n        else:\n            user_output(click.style(\"✓\", fg=\"green\") + \" PR linked with Graphite\")\n\n    # Close any orphaned draft PRs for this issue\n    closed_prs = _close_orphaned_draft_prs(ctx, repo.root, issue_number, pr_number)\n    if closed_prs:\n        user_output(\n            click.style(\"✓\", fg=\"green\")\n            + f\" Closed {len(closed_prs)} orphaned draft PR(s): \"\n            + \", \".join(f\"#{n}\" for n in closed_prs)\n        )\n\n    # Switch back to original branch (keep the new branch for Graphite lineage)\n    ctx.branch_manager.checkout_branch(repo.root, original_branch)\n\n    return pr_number\n\n\ndef _submit_single_issue(\n    ctx: ErkContext,\n    *,\n    repo: RepoContext,\n    validated: ValidatedIssue,\n    submitted_by: str,\n    original_branch: str,\n    base_branch: str,\n) -> SubmitResult:\n    \"\"\"Submit a single validated issue for implementation.\n\n    Creates branch/PR if needed and triggers workflow.\n\n    Args:\n        ctx: ErkContext with git operations\n        repo: Repository context\n        validated: Validated issue information\n        submitted_by: GitHub username of submitter\n        original_branch: Original branch name (to restore after)\n        base_branch: Base branch for PR (trunk or custom feature branch)\n\n    Returns:\n        SubmitResult with URLs and identifiers.\n    \"\"\"\n    issue = validated.issue\n    issue_number = validated.number\n    branch_name = validated.branch_name\n    branch_exists = validated.branch_exists\n    pr_number = validated.pr_number\n\n    if branch_exists:\n        if pr_number is not None:\n            user_output(\n                f\"PR #{pr_number} already exists for branch '{branch_name}' (state: existing)\"\n            )\n            user_output(\"Skipping branch/PR creation, triggering workflow...\")\n        else:\n            # Branch exists but no PR - need to add a commit for PR creation\n            user_output(f\"Branch '{branch_name}' exists but no PR. Adding placeholder commit...\")\n\n            # Fetch and checkout the remote branch locally\n            ctx.git.remote.fetch_branch(repo.root, \"origin\", branch_name)\n\n            # Only create tracking branch if it doesn't exist locally (LBYL)\n            local_branches = ctx.git.branch.list_local_branches(repo.root)\n            if branch_name not in local_branches:\n                remote_ref = f\"origin/{branch_name}\"\n                ctx.branch_manager.create_tracking_branch(repo.root, branch_name, remote_ref)\n\n            ctx.branch_manager.checkout_branch(repo.root, branch_name)\n\n            # Create empty commit as placeholder for PR creation\n            ctx.git.commit.commit(\n                repo.root,\n                f\"[erk-plan] Initialize implementation for issue #{issue_number}\",\n            )\n            push_result = ctx.git.remote.push_to_remote(\n                repo.root, \"origin\", branch_name, set_upstream=False, force=False\n            )\n            if isinstance(push_result, PushError):\n                raise UserFacingCliError(push_result.message)\n            user_output(click.style(\"✓\", fg=\"green\") + \" Placeholder commit pushed\")\n\n            # Now create the PR\n            # IMPORTANT: \"Closes owner/repo#N\" (cross-repo) or \"Closes #N\" (same-repo)\n            # MUST be in the initial body passed to create_pr(), NOT added via update.\n            # GitHub's willCloseTarget API field is set at PR creation time and is NOT\n            # updated when the body is edited afterward.\n            plans_repo = ctx.local_config.plans_repo if ctx.local_config else None\n            issue_ref = _format_issue_ref(issue_number, plans_repo)\n            pr_body = (\n                f\"**Author:** @{submitted_by}\\n\"\n                f\"**Plan:** {issue_ref}\\n\\n\"\n                f\"**Status:** Queued for implementation\\n\\n\"\n                f\"This PR will be marked ready for review after implementation completes.\\n\\n\"\n                f\"---\\n\\n\"\n                f\"Closes {issue_ref}\"\n            )\n            pr_title = _add_planned_prefix(_strip_plan_markers(issue.title))\n            pr_number = ctx.github.create_pr(\n                repo_root=repo.root,\n                branch=branch_name,\n                title=pr_title,\n                body=pr_body,\n                base=base_branch,\n                draft=True,\n            )\n            user_output(click.style(\"✓\", fg=\"green\") + f\" Draft PR #{pr_number} created\")\n\n            # Update PR body with checkout command footer\n            footer = build_pr_body_footer(\n                pr_number=pr_number, issue_number=issue_number, plans_repo=plans_repo\n            )\n            ctx.github.update_pr_body(repo.root, pr_number, pr_body + footer)\n\n            # Add extraction skip label if this is a learn plan\n            if validated.is_learn_origin:\n                ctx.github.add_label_to_pr(repo.root, pr_number, ERK_SKIP_LEARN_LABEL)\n                # FUTURE ENHANCEMENT: See comment in _create_branch_and_pr for\n                # updating parent plan's learn_status when learn plan gets a PR.\n\n            # Link PR with Graphite (if enabled)\n            if ctx.branch_manager.is_graphite_managed():\n                user_output(\"Linking PR with Graphite...\")\n                submit_result = ctx.branch_manager.submit_branch(repo.root, branch_name)\n                if isinstance(submit_result, SubmitBranchError):\n                    user_output(\n                        click.style(\"✗\", fg=\"red\")\n                        + f\" Failed to link PR with Graphite: {submit_result.message}\"\n                    )\n                else:\n                    user_output(click.style(\"✓\", fg=\"green\") + \" PR linked with Graphite\")\n\n            # Close any orphaned draft PRs\n            closed_prs = _close_orphaned_draft_prs(ctx, repo.root, issue_number, pr_number)\n            if closed_prs:\n                user_output(\n                    click.style(\"✓\", fg=\"green\")\n                    + f\" Closed {len(closed_prs)} orphaned draft PR(s): \"\n                    + \", \".join(f\"#{n}\" for n in closed_prs)\n                )\n\n            # Switch back to original branch (keep the new branch for Graphite lineage)\n            ctx.branch_manager.checkout_branch(repo.root, original_branch)\n    else:\n        # Check if branch exists locally (user chose to reuse existing)\n        local_branches = ctx.git.branch.list_local_branches(repo.root)\n        branch_exists_locally = branch_name in local_branches\n\n        if branch_exists_locally:\n            # Reuse existing local branch\n            user_output(f\"Using existing local branch: {click.style(branch_name, fg='cyan')}\")\n\n            # Track in Graphite if not already tracked\n            if ctx.branch_manager.is_graphite_managed():\n                if not ctx.graphite.is_branch_tracked(repo.root, branch_name):\n                    ctx.branch_manager.track_branch(repo.root, branch_name, base_branch)\n                    user_output(click.style(\"✓\", fg=\"green\") + \" Branch tracked in Graphite\")\n\n            # Checkout existing branch\n            ctx.branch_manager.checkout_branch(repo.root, branch_name)\n\n            # Use context manager to restore original branch on failure\n            with branch_rollback(ctx, repo.root, original_branch):\n                pr_number = _create_branch_and_pr(\n                    ctx=ctx,\n                    repo=repo,\n                    validated=validated,\n                    branch_name=branch_name,\n                    base_branch=base_branch,\n                    submitted_by=submitted_by,\n                    original_branch=original_branch,\n                )\n        else:\n            # Create new branch\n            user_output(f\"Creating branch from origin/{base_branch}...\")\n            ctx.git.remote.fetch_branch(repo.root, \"origin\", base_branch)\n\n            # Verify parent is tracked by Graphite (if enabled)\n            if ctx.branch_manager.is_graphite_managed():\n                parent_branch = base_branch.removeprefix(\"origin/\")\n                if not ctx.graphite.is_branch_tracked(repo.root, parent_branch):\n                    msg = (\n                        f\"Cannot stack on branch '{parent_branch}' - \"\n                        f\"it's not tracked by Graphite.\\n\\n\"\n                        f\"To fix this:\\n\"\n                        f\"  1. gt checkout {parent_branch}\\n\"\n                        f\"  2. gt track --parent <parent-branch>\\n\\n\"\n                        f\"Then retry your command.\"\n                    )\n                    user_output(click.style(\"Error: \", fg=\"red\") + msg)\n                    raise SystemExit(1)\n\n            create_result = ctx.branch_manager.create_branch(\n                repo.root, branch_name, f\"origin/{base_branch}\"\n            )\n            if isinstance(create_result, BranchAlreadyExists):\n                user_output(click.style(\"Error: \", fg=\"red\") + create_result.message)\n                raise SystemExit(1) from None\n            user_output(f\"Created branch: {click.style(branch_name, fg='cyan')}\")\n\n            # Use context manager to restore original branch on failure\n            with branch_rollback(ctx, repo.root, original_branch):\n                pr_number = _create_branch_and_pr(\n                    ctx=ctx,\n                    repo=repo,\n                    validated=validated,\n                    branch_name=branch_name,\n                    base_branch=base_branch,\n                    submitted_by=submitted_by,\n                    original_branch=original_branch,\n                )\n\n    # Gather submission metadata\n    queued_at = datetime.now(UTC).isoformat()\n\n    # Validate pr_number is set before workflow dispatch\n    if pr_number is None:\n        user_output(\n            click.style(\"Error: \", fg=\"red\")\n            + \"Failed to create or find PR. Cannot trigger workflow.\"\n        )\n        raise SystemExit(1)\n\n    # Load workflow-specific config\n    workflow_config = load_workflow_config(repo.root, DISPATCH_WORKFLOW_NAME)\n\n    # Trigger workflow via direct dispatch\n    user_output(\"\")\n    user_output(f\"Triggering workflow: {click.style(DISPATCH_WORKFLOW_NAME, fg='cyan')}\")\n    user_output(f\"  Display name: {DISPATCH_WORKFLOW_METADATA_NAME}\")\n\n    # Build inputs dict, merging workflow config\n    inputs = {\n        # Required inputs (always passed)\n        \"plan_id\": str(issue_number),\n        \"submitted_by\": submitted_by,\n        \"plan_title\": issue.title,\n        \"branch_name\": branch_name,\n        \"pr_number\": str(pr_number),\n        \"base_branch\": base_branch,\n        # Config-based inputs (from .erk/workflows/)\n        **workflow_config,\n    }\n\n    run_id = ctx.github.trigger_workflow(\n        repo_root=repo.root,\n        workflow=DISPATCH_WORKFLOW_NAME,\n        inputs=inputs,\n    )\n    user_output(click.style(\"✓\", fg=\"green\") + \" Workflow triggered.\")\n\n    # Compute workflow URL once (used for PR body update, queued comment, and result)\n    workflow_url = _build_workflow_run_url(issue.url, run_id)\n\n    # Update PR body with workflow run link (best-effort)\n    try:\n        pr_details = ctx.github.get_pr(repo.root, pr_number)\n        if not isinstance(pr_details, PRNotFound):\n            updated_body = pr_details.body + f\"\\n\\n**Workflow run:** {workflow_url}\"\n            ctx.github.update_pr_body(repo.root, pr_number, updated_body)\n    except Exception as e:\n        logger.warning(\"Failed to update PR body with workflow run link: %s\", e)\n\n    # Write dispatch metadata synchronously to fix race condition with erk dash\n    # This ensures the issue body has the run info before we return to the user\n    try:\n        write_dispatch_metadata(\n            plan_backend=ctx.plan_backend,\n            github=ctx.github,\n            repo_root=repo.root,\n            issue_number=issue_number,\n            run_id=run_id,\n            dispatched_at=queued_at,\n        )\n        user_output(click.style(\"✓\", fg=\"green\") + \" Dispatch metadata written to issue\")\n    except Exception as e:\n        # Log warning but don't block - workflow is already triggered\n        user_output(\n            click.style(\"Warning: \", fg=\"yellow\") + f\"Failed to update dispatch metadata: {e}\"\n        )\n\n    validation_results = {\n        \"issue_is_open\": True,\n        \"has_erk_plan_label\": True,\n    }\n\n    # Create and post queued event comment\n    try:\n        metadata_block = create_submission_queued_block(\n            queued_at=queued_at,\n            submitted_by=submitted_by,\n            issue_number=issue_number,\n            validation_results=validation_results,\n            expected_workflow=DISPATCH_WORKFLOW_METADATA_NAME,\n        )\n\n        comment_body = render_erk_issue_event(\n            title=\"🔄 Issue Queued for Implementation\",\n            metadata=metadata_block,\n            description=(\n                f\"Issue submitted by **{submitted_by}** at {queued_at}.\\n\\n\"\n                f\"The `{DISPATCH_WORKFLOW_METADATA_NAME}` workflow has been \"\n                f\"triggered via direct dispatch.\\n\\n\"\n                f\"**Workflow run:** {workflow_url}\\n\\n\"\n                f\"Branch and draft PR were created locally for correct commit attribution.\"\n            ),\n        )\n\n        user_output(\"Posting queued event comment...\")\n        ctx.issues.add_comment(repo.root, issue_number, comment_body)\n        user_output(click.style(\"✓\", fg=\"green\") + \" Queued event comment posted\")\n    except Exception as e:\n        # Log warning but don't block - workflow is already triggered\n        user_output(\n            click.style(\"Warning: \", fg=\"yellow\")\n            + f\"Failed to post queued comment: {e}\\n\"\n            + \"Workflow is already running.\"\n        )\n\n    pr_url = _build_pr_url(issue.url, pr_number) if pr_number else None\n\n    return SubmitResult(\n        issue_number=issue_number,\n        issue_title=issue.title,\n        issue_url=issue.url,\n        pr_number=pr_number,\n        pr_url=pr_url,\n        workflow_run_id=run_id,\n        workflow_url=workflow_url,\n    )\n\n\n@click.command(\"submit\")\n@click.argument(\"issue_numbers\", type=int, nargs=-1, required=True)\n@click.option(\n    \"--base\",\n    type=str,\n    default=None,\n    help=\"Base branch for PR (defaults to current branch).\",\n)\n@click.option(\n    \"-f\",\n    \"--force\",\n    is_flag=True,\n    help=\"Delete existing branches and create fresh without prompting.\",\n)\n@click.pass_obj\ndef submit_cmd(\n    ctx: ErkContext, issue_numbers: tuple[int, ...], base: str | None, force: bool\n) -> None:\n    \"\"\"Submit issues for remote AI implementation via GitHub Actions.\n\n    Creates branch and draft PR locally (for correct commit attribution),\n    then triggers the dispatch-erk-queue.yml GitHub Actions workflow.\n\n    Arguments:\n        ISSUE_NUMBERS: One or more GitHub issue numbers to submit\n\n    Example:\n        erk plan submit 123\n        erk plan submit 123 456 789\n        erk plan submit 123 --base master\n\n    Requires:\n        - All issues must have erk-plan label\n        - All issues must be OPEN\n        - Working directory must be clean (no uncommitted changes)\n    \"\"\"\n    # Validate GitHub CLI prerequisites upfront (LBYL)\n    Ensure.gh_authenticated(ctx)\n\n    # Get repository context\n    if isinstance(ctx.repo, RepoContext):\n        repo = ctx.repo\n    else:\n        repo = discover_repo_context(ctx, ctx.cwd)\n\n    # Ensure trunk is synced before any operations\n    ensure_trunk_synced(ctx, repo)\n\n    # Save current state (needed for both default base and restoration)\n    original_branch = ctx.git.branch.get_current_branch(repo.root)\n    if original_branch is None:\n        user_output(\n            click.style(\"Error: \", fg=\"red\")\n            + \"Not on a branch (detached HEAD state). Cannot submit from here.\"\n        )\n        raise SystemExit(1)\n\n    # Validate base branch if provided, otherwise default to current branch (LBYL)\n    if base is not None:\n        if not ctx.git.branch.branch_exists_on_remote(repo.root, \"origin\", base):\n            user_output(\n                click.style(\"Error: \", fg=\"red\") + f\"Base branch '{base}' does not exist on remote\"\n            )\n            raise SystemExit(1)\n        target_branch = base\n    else:\n        # If on a placeholder branch (local-only), use trunk as base\n        if is_placeholder_branch(original_branch):\n            target_branch = ctx.git.branch.detect_trunk_branch(repo.root)\n        elif not ctx.git.branch.branch_exists_on_remote(repo.root, \"origin\", original_branch):\n            # Current branch not pushed to remote - fall back to trunk\n            target_branch = ctx.git.branch.detect_trunk_branch(repo.root)\n        else:\n            target_branch = original_branch\n\n    # For single-issue learn plan submissions, auto-detect parent branch\n    issue_number = issue_numbers[0] if len(issue_numbers) == 1 else None\n    if (\n        issue_number is not None\n        and base is None\n        and ctx.issues.issue_exists(repo.root, issue_number)\n    ):\n        issue = ctx.issues.get_issue(repo.root, issue_number)\n        # issue_exists check above ensures this won't be IssueNotFound\n        if not isinstance(issue, IssueNotFound) and is_issue_learn_plan(issue.labels):\n            parent_branch = get_learn_plan_parent_branch(ctx, repo.root, str(issue_number))\n            if parent_branch is not None and ctx.git.branch.branch_exists_on_remote(\n                repo.root, \"origin\", parent_branch\n            ):\n                target_branch = parent_branch\n                user_output(\n                    f\"Learn plan detected, stacking on parent branch: \"\n                    f\"{click.style(parent_branch, fg='cyan')}\"\n                )\n            elif parent_branch is not None:\n                user_output(\n                    click.style(\"Warning: \", fg=\"yellow\")\n                    + f\"Parent branch '{parent_branch}' not on remote, using trunk\"\n                )\n\n    # Get GitHub username (authentication already validated)\n    _, username, _ = ctx.github.check_auth_status()\n    submitted_by = username or \"unknown\"\n\n    # Detect draft-PR backend\n    is_draft_pr = ctx.plan_backend.get_provider_name() == \"github-draft-pr\"\n\n    if is_draft_pr:\n        # Draft-PR path: branch and PR already exist, just validate and trigger workflow\n        user_output(f\"Validating {len(issue_numbers)} draft-PR plan(s)...\")\n        user_output(\"\")\n\n        validated_draft_prs: list[ValidatedDraftPR] = []\n        for issue_number in issue_numbers:\n            user_output(f\"Validating PR #{issue_number}...\")\n            validated_pr = _validate_draft_pr_for_submit(ctx, repo, issue_number)\n            validated_draft_prs.append(validated_pr)\n\n        user_output(\"\")\n        user_output(\n            click.style(\"✓\", fg=\"green\") + f\" All {len(validated_draft_prs)} plan(s) validated\"\n        )\n        user_output(\"\")\n\n        for v in validated_draft_prs:\n            user_output(f\"  #{v.number}: {click.style(v.title, fg='yellow')}\")\n        user_output(\"\")\n\n        results: list[SubmitResult] = []\n        for i, v in enumerate(validated_draft_prs):\n            if len(validated_draft_prs) > 1:\n                count = len(validated_draft_prs)\n                user_output(f\"--- Submitting PR {i + 1}/{count}: #{v.number} ---\")\n            else:\n                user_output(f\"Submitting PR #{v.number}...\")\n            user_output(\"\")\n            result = _submit_draft_pr_plan(\n                ctx,\n                repo=repo,\n                validated=v,\n                submitted_by=submitted_by,\n                original_branch=original_branch,\n                base_branch=target_branch,\n            )\n            results.append(result)\n            user_output(\"\")\n    else:\n        # Issue-based path: existing flow\n        # Phase 1: Validate ALL issues upfront (atomic - fail fast before any side effects)\n        user_output(f\"Validating {len(issue_numbers)} issue(s)...\")\n        user_output(\"\")\n\n        validated_issues: list[ValidatedIssue] = []\n        for issue_number in issue_numbers:\n            user_output(f\"Validating issue #{issue_number}...\")\n            validated_issue = _validate_issue_for_submit(\n                ctx, repo, issue_number, target_branch, force=force\n            )\n            validated_issues.append(validated_issue)\n\n        user_output(\"\")\n        user_output(\n            click.style(\"✓\", fg=\"green\") + f\" All {len(validated_issues)} issue(s) validated\"\n        )\n        user_output(\"\")\n\n        # Display validated issues\n        for v in validated_issues:\n            user_output(f\"  #{v.number}: {click.style(v.issue.title, fg='yellow')}\")\n        user_output(\"\")\n\n        # Phase 2: Submit all validated issues\n        results = []\n        for i, v in enumerate(validated_issues):\n            if len(validated_issues) > 1:\n                user_output(\n                    f\"--- Submitting issue {i + 1}/{len(validated_issues)}: #{v.number} ---\"\n                )\n            else:\n                user_output(f\"Submitting issue #{v.number}...\")\n            user_output(\"\")\n            result = _submit_single_issue(\n                ctx,\n                repo=repo,\n                validated=v,\n                submitted_by=submitted_by,\n                original_branch=original_branch,\n                base_branch=target_branch,\n            )\n            results.append(result)\n            user_output(\"\")\n\n    # Success output\n    user_output(\"\")\n    user_output(click.style(\"✓\", fg=\"green\") + f\" {len(results)} issue(s) submitted successfully!\")\n    user_output(\"\")\n    user_output(\"Submitted issues:\")\n    for r in results:\n        user_output(f\"  • #{r.issue_number}: {r.issue_title}\")\n        user_output(f\"    Issue: {r.issue_url}\")\n        if r.pr_url:\n            user_output(f\"    PR: {r.pr_url}\")\n        user_output(f\"    Workflow: {r.workflow_url}\")\n","structuredPatch":[{"oldStart":277,"oldLines":13,"newStart":277,"newLines":13,"lines":[" "," "," def _add_planned_prefix(title: str) -> str:","-    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).","+    \"\"\"Prepend 'plnd/' prefix to PR title (idempotent)."," ","     Args:","         title: The PR title to prefix"," ","     Returns:","-        The title with 'planned/' prefix, skipping if already prefixed","+        The title with 'plnd/' prefix, skipping if already prefixed","     \"\"\"","     if title.startswith(PLANNED_PR_TITLE_PREFIX):","         return title"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"b3d6b488-a089-4bf3-a379-88df2095c33e","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01SqiNmKAyAfZbC8JLLo7Fur","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AzqxXomtSehpiD9f2Zkajp","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/commands/pr/submit_pipeline.py","old_string":"def _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'planned/' prefix, skipping if already prefixed\n    \"\"\"","new_string":"def _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'plnd/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'plnd/' prefix, skipping if already prefixed\n    \"\"\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":332,"cache_read_input_tokens":57155,"cache_creation":{"ephemeral_5m_input_tokens":332,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHSScqVU5F619YfiwjB","type":"assistant","uuid":"a44d739e-36ca-43ba-830a-f629c5f3e509","timestamp":"2026-02-22T14:42:54.270Z"}
{"parentUuid":"a44d739e-36ca-43ba-830a-f629c5f3e509","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AzqxXomtSehpiD9f2Zkajp","type":"tool_result","content":"The file /home/runner/work/erk/erk/src/erk/cli/commands/pr/submit_pipeline.py has been updated successfully."}]},"uuid":"71e44166-fa7e-44b9-81fd-579a871ee9df","timestamp":"2026-02-22T14:42:54.961Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/commands/pr/submit_pipeline.py","oldString":"def _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'planned/' prefix, skipping if already prefixed\n    \"\"\"","newString":"def _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'plnd/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'plnd/' prefix, skipping if already prefixed\n    \"\"\"","originalFile":"\"\"\"Linear pipeline for PR submission.\n\nReplaces the dual-path branching orchestration with a sequence of plain\nfunctions transforming a frozen SubmitState dataclass.\n\nEach step: (ErkContext, SubmitState) -> SubmitState | SubmitError\n\"\"\"\n\nimport dataclasses\nimport uuid\nfrom collections.abc import Callable\nfrom dataclasses import dataclass\nfrom functools import cache\nfrom pathlib import Path\n\nimport click\n\nfrom erk.cli.commands.pr.shared import (\n    assemble_pr_body,\n    echo_plan_context_status,\n    run_commit_message_generation,\n)\nfrom erk.cli.constants import PLANNED_PR_TITLE_PREFIX\nfrom erk.cli.ensure import UserFacingCliError\nfrom erk.core.commit_message_generator import CommitMessageGenerator\nfrom erk.core.context import ErkContext\nfrom erk.core.plan_context_provider import PlanContext, PlanContextProvider\nfrom erk_shared.gateway.git.remote_ops.types import PullRebaseError, PushError\nfrom erk_shared.gateway.github.parsing import parse_git_remote_url\nfrom erk_shared.gateway.github.pr_footer import (\n    ClosingReference,\n    build_pr_body_footer,\n    extract_closing_reference,\n    extract_footer_from_body,\n)\nfrom erk_shared.gateway.github.types import BodyText, GitHubRepoId, PRNotFound\nfrom erk_shared.gateway.gt.operations.finalize import ERK_SKIP_LEARN_LABEL, is_learn_plan\nfrom erk_shared.gateway.gt.prompts import truncate_diff\nfrom erk_shared.gateway.pr.diff_extraction import filter_diff_excluded_files\nfrom erk_shared.gateway.pr.graphite_enhance import should_enhance_with_graphite\nfrom erk_shared.impl_folder import (\n    has_plan_ref,\n    save_plan_ref,\n    validate_plan_linkage,\n)\nfrom erk_shared.plan_store.draft_pr_lifecycle import extract_metadata_prefix\nfrom erk_shared.scratch.scratch import write_scratch_file\n\n# ---------------------------------------------------------------------------\n# Utilities\n# ---------------------------------------------------------------------------\n\n\ndef _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'planned/' prefix, skipping if already prefixed\n    \"\"\"\n    if title.startswith(PLANNED_PR_TITLE_PREFIX):\n        return title\n    return f\"{PLANNED_PR_TITLE_PREFIX}{title}\"\n\n\n# ---------------------------------------------------------------------------\n# Data Types\n# ---------------------------------------------------------------------------\n\n\n@dataclass(frozen=True)\nclass SubmitState:\n    \"\"\"Immutable state threaded through the submit pipeline.\"\"\"\n\n    cwd: Path\n    repo_root: Path\n    branch_name: str\n    parent_branch: str\n    trunk_branch: str\n    use_graphite: bool\n    force: bool\n    debug: bool\n    session_id: str\n    issue_number: int | None\n    pr_number: int | None\n    pr_url: str | None\n    was_created: bool\n    base_branch: str | None\n    graphite_url: str | None\n    diff_file: Path | None\n    plan_context: PlanContext | None\n    title: str | None\n    body: str | None\n\n\n@dataclass(frozen=True)\nclass SubmitError:\n    \"\"\"Error result from a pipeline step.\"\"\"\n\n    phase: str\n    error_type: str\n    message: str\n    details: dict[str, str]\n\n\n# ---------------------------------------------------------------------------\n# Pipeline Steps\n# ---------------------------------------------------------------------------\n\nSubmitStep = Callable[[ErkContext, SubmitState], SubmitState | SubmitError]\n\n\ndef prepare_state(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Resolve repo_root, branch_name, parent_branch, trunk_branch, issue_number.\n\n    Single location for all discovery. Consolidates duplicate parent-branch\n    and issue-number discovery sites.\n    \"\"\"\n    cwd = state.cwd\n    repo_root = ctx.git.repo.get_repository_root(cwd)\n\n    branch_name = ctx.git.branch.get_current_branch(cwd)\n    if branch_name is None:\n        return SubmitError(\n            phase=\"prepare\",\n            error_type=\"no_branch\",\n            message=\"Not on a branch (detached HEAD state)\",\n            details={},\n        )\n\n    trunk_branch = ctx.git.branch.detect_trunk_branch(repo_root)\n    parent_branch = ctx.branch_manager.get_parent_branch(repo_root, branch_name) or trunk_branch\n\n    # Plan ID discovery via .impl/plan-ref.json (or legacy issue.json) or branch name\n    impl_dir = cwd / \".impl\"\n    issue_number: int | None = None\n    try:\n        plan_id = validate_plan_linkage(impl_dir, branch_name)\n        if plan_id is not None:\n            issue_number = int(plan_id)\n    except ValueError as e:\n        return SubmitError(\n            phase=\"prepare\",\n            error_type=\"issue_linkage_mismatch\",\n            message=str(e),\n            details={\"branch\": branch_name},\n        )\n\n    # Auto-repair: create .impl/plan-ref.json if missing but issue inferred from branch\n    if issue_number is not None and not has_plan_ref(impl_dir) and impl_dir.exists():\n        remote_url = ctx.git.remote.get_remote_url(repo_root, \"origin\")\n        owner, repo_name = parse_git_remote_url(remote_url)\n        issue_url = f\"https://github.com/{owner}/{repo_name}/issues/{issue_number}\"\n        save_plan_ref(\n            impl_dir,\n            provider=\"github\",\n            plan_id=str(issue_number),\n            url=issue_url,\n            labels=(),\n            objective_id=None,\n        )\n\n    return dataclasses.replace(\n        state,\n        cwd=cwd,\n        repo_root=repo_root,\n        branch_name=branch_name,\n        parent_branch=parent_branch,\n        trunk_branch=trunk_branch,\n        issue_number=issue_number,\n    )\n\n\ndef commit_wip(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Check for uncommitted changes; if present, add_all + commit.\"\"\"\n    if ctx.git.status.has_uncommitted_changes(state.cwd):\n        click.echo(click.style(\"   Committing uncommitted changes...\", dim=True))\n        ctx.git.commit.add_all(state.cwd)\n        ctx.git.commit.commit(state.cwd, \"WIP: Prepare for PR submission\")\n    return state\n\n\ndef push_and_create_pr(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Push branch and create/find PR.\n\n    Dispatches internally: Graphite-first vs core path.\n    \"\"\"\n    # Determine if Graphite should handle the push\n    graphite_handles_push = (\n        state.use_graphite and should_enhance_with_graphite(ctx, state.cwd).should_enhance\n    )\n\n    if graphite_handles_push:\n        return _graphite_first_flow(ctx, state)\n    return _core_submit_flow(ctx, state)\n\n\ndef _graphite_first_flow(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Graphite-first flow: gt submit handles push + PR creation.\"\"\"\n    click.echo(click.style(\"Phase 1: Graphite Submit\", bold=True))\n\n    # Auto-force for plan implementations (branches always diverge from remote)\n    is_plan_impl = state.issue_number is not None\n    effective_force = state.force or is_plan_impl\n\n    # Pre-check: detect remote divergence before gt submit\n    if ctx.git.branch.branch_exists_on_remote(state.repo_root, \"origin\", state.branch_name):\n        ctx.git.remote.fetch_branch(state.repo_root, \"origin\", state.branch_name)\n        divergence = ctx.git.branch.is_branch_diverged_from_remote(\n            state.cwd, state.branch_name, \"origin\"\n        )\n        if divergence.behind > 0 and not effective_force:\n            ahead_msg = (\n                f\" and ahead by {divergence.ahead} commit(s)\" if divergence.ahead > 0 else \"\"\n            )\n            return SubmitError(\n                phase=\"push_and_create_pr\",\n                error_type=\"remote_diverged\",\n                message=(\n                    f\"Branch '{state.branch_name}' is behind remote by \"\n                    f\"{divergence.behind} commit(s){ahead_msg}.\\n\\n\"\n                    \"The remote branch has been updated (e.g., by CI or another session).\\n\\n\"\n                    \"To fix:\\n\"\n                    \"  erk pr sync-divergence --dangerous   # Fetch, rebase, resolve conflicts\\n\"\n                    \"  erk pr submit -f                     # Force push (overrides remote)\"\n                ),\n                details={\n                    \"branch\": state.branch_name,\n                    \"ahead\": str(divergence.ahead),\n                    \"behind\": str(divergence.behind),\n                },\n            )\n        if is_plan_impl and not state.force and divergence.behind > 0:\n            click.echo(click.style(\"   Auto-forcing: plan implementation branch\", dim=True))\n\n    click.echo(click.style(\"   Running gt submit...\", dim=True))\n    try:\n        ctx.graphite.submit_stack(\n            state.repo_root,\n            publish=True,\n            restack=False,\n            quiet=False,\n            force=effective_force,\n        )\n    except RuntimeError as e:\n        error_str = str(e)\n        if \"restack\" in error_str.lower():\n            return SubmitError(\n                phase=\"push_and_create_pr\",\n                error_type=\"graphite_restack_required\",\n                message=(\n                    \"Your Graphite stack has conflicts that need manual resolution.\\n\\n\"\n                    \"Run these commands:\\n\"\n                    \"  gt restack        # Resolve conflicts interactively\\n\"\n                    \"  erk pr submit     # Re-submit after resolving\"\n                ),\n                details={},\n            )\n        return SubmitError(\n            phase=\"push_and_create_pr\",\n            error_type=\"graphite_submit_failed\",\n            message=f\"Graphite submit failed: {e}\",\n            details={},\n        )\n    click.echo(click.style(\"   Graphite submit completed\", fg=\"green\"))\n    click.echo(\"\")\n\n    # Query GitHub for PR info\n    click.echo(click.style(\"   Getting PR info...\", dim=True))\n    pr_info = ctx.github.get_pr_for_branch(state.repo_root, state.branch_name)\n    if isinstance(pr_info, PRNotFound):\n        return SubmitError(\n            phase=\"push_and_create_pr\",\n            error_type=\"pr_not_found\",\n            message=(\n                f\"PR not found for branch '{state.branch_name}' after gt submit.\\n\"\n                \"This may happen if gt submit didn't create a PR. Try running:\\n\"\n                \"  gt submit --publish\"\n            ),\n            details={\"branch\": state.branch_name},\n        )\n\n    # Get Graphite URL\n    remote_url = ctx.git.remote.get_remote_url(state.repo_root, \"origin\")\n    owner, repo_name = parse_git_remote_url(remote_url)\n    repo_id = GitHubRepoId(owner=owner, repo=repo_name)\n    graphite_url = ctx.graphite.get_graphite_url(repo_id, pr_info.number)\n\n    click.echo(click.style(f\"   PR #{pr_info.number} ready\", fg=\"green\"))\n    click.echo(\"\")\n\n    return dataclasses.replace(\n        state,\n        pr_number=pr_info.number,\n        pr_url=pr_info.url,\n        was_created=True,\n        base_branch=state.parent_branch,\n        graphite_url=graphite_url,\n    )\n\n\ndef _core_submit_flow(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Core submit flow: git push + gh pr create.\"\"\"\n    click.echo(click.style(\"Phase 1: Creating or Updating PR\", bold=True))\n\n    # Check GitHub authentication\n    is_gh_authed, gh_username, _ = ctx.github.check_auth_status()\n    if not is_gh_authed:\n        return SubmitError(\n            phase=\"push_and_create_pr\",\n            error_type=\"github_auth_failed\",\n            message=\"GitHub CLI is not authenticated. Run 'gh auth login'.\",\n            details={},\n        )\n    if state.debug:\n        click.echo(click.style(f\"   Authenticated as {gh_username}\", dim=True))\n\n    # Verify commits to push\n    commit_count = ctx.git.analysis.count_commits_ahead(state.cwd, state.parent_branch)\n    if commit_count == 0:\n        return SubmitError(\n            phase=\"push_and_create_pr\",\n            error_type=\"no_commits\",\n            message=f\"No commits ahead of {state.parent_branch}. Nothing to submit.\",\n            details={\"parent_branch\": state.parent_branch, \"branch\": state.branch_name},\n        )\n\n    # Divergence check and auto-rebase\n    divergence = ctx.git.branch.is_branch_diverged_from_remote(\n        state.cwd, state.branch_name, \"origin\"\n    )\n    if divergence.behind > 0:\n        if state.debug:\n            click.echo(\n                click.style(\n                    f\"   Branch is {divergence.behind} commit(s) behind remote, rebasing...\",\n                    dim=True,\n                )\n            )\n        pull_result = ctx.git.remote.pull_rebase(state.cwd, \"origin\", state.branch_name)\n        if isinstance(pull_result, PullRebaseError):\n            return SubmitError(\n                phase=\"push_and_create_pr\",\n                error_type=\"rebase_failed\",\n                message=(\n                    f\"Failed to rebase '{state.branch_name}' on origin.\\n\"\n                    f\"Error: {pull_result.message}\\n\\n\"\n                    f\"To fix manually: git pull --rebase origin {state.branch_name}\"\n                ),\n                details={\"branch\": state.branch_name},\n            )\n        divergence = ctx.git.branch.is_branch_diverged_from_remote(\n            state.cwd, state.branch_name, \"origin\"\n        )\n\n    if divergence.is_diverged and not state.force:\n        return SubmitError(\n            phase=\"push_and_create_pr\",\n            error_type=\"branch_diverged\",\n            message=(\n                f\"Branch '{state.branch_name}' has diverged from remote.\\n\"\n                f\"Local is {divergence.ahead} commit(s) ahead and \"\n                f\"{divergence.behind} commit(s) behind origin/{state.branch_name}.\\n\\n\"\n                f\"To fix: git pull --rebase origin {state.branch_name}\\n\"\n                f\"Or use: erk pr submit -f (to force push)\"\n            ),\n            details={\n                \"branch\": state.branch_name,\n                \"ahead\": str(divergence.ahead),\n                \"behind\": str(divergence.behind),\n            },\n        )\n\n    # Push\n    push_result = ctx.git.remote.push_to_remote(\n        state.cwd, \"origin\", state.branch_name, set_upstream=True, force=state.force\n    )\n    if isinstance(push_result, PushError):\n        if \"non-fast-forward\" in push_result.message or \"rejected\" in push_result.message.lower():\n            return SubmitError(\n                phase=\"push_and_create_pr\",\n                error_type=\"branch_diverged\",\n                message=(\n                    f\"Branch '{state.branch_name}' has diverged from remote.\\n\"\n                    f\"Your local branch is behind origin/{state.branch_name}.\\n\\n\"\n                    f\"To fix: git pull --rebase origin {state.branch_name}\\n\"\n                    f\"Or use: erk pr submit -f (to force push)\"\n                ),\n                details={\"branch\": state.branch_name},\n            )\n        raise UserFacingCliError(push_result.message)\n\n    # Check for existing PR or create new one\n    existing_pr = ctx.github.get_pr_for_branch(state.repo_root, state.branch_name)\n    plans_repo = ctx.local_config.plans_repo if ctx.local_config else None\n\n    if isinstance(existing_pr, PRNotFound):\n        # Check parent branch has PR (stacked PRs)\n        if state.parent_branch != state.trunk_branch:\n            parent_pr = ctx.github.get_pr_for_branch(state.repo_root, state.parent_branch)\n            if isinstance(parent_pr, PRNotFound):\n                return SubmitError(\n                    phase=\"push_and_create_pr\",\n                    error_type=\"parent_branch_no_pr\",\n                    message=(\n                        f\"Cannot create PR: parent branch '{state.parent_branch}' \"\n                        f\"does not have a PR yet.\\n\\n\"\n                        f\"This branch is part of a Graphite stack. Use 'gt submit' \"\n                        f\"to submit the entire stack at once, which will create PRs \"\n                        f\"for all branches in the correct order.\\n\\n\"\n                        f\"Run: gt submit -s\"\n                    ),\n                    details={\n                        \"branch\": state.branch_name,\n                        \"parent_branch\": state.parent_branch,\n                    },\n                )\n\n        # Build initial PR body with footer\n        footer = build_pr_body_footer(\n            pr_number=0,\n            issue_number=state.issue_number,\n            plans_repo=plans_repo,\n        )\n        full_body = \"\" + footer\n\n        pr_number = ctx.github.create_pr(\n            state.repo_root,\n            branch=state.branch_name,\n            title=\"WIP\",\n            body=full_body,\n            base=state.parent_branch,\n        )\n\n        # Get PR URL\n        pr_details = ctx.github.get_pr(state.repo_root, pr_number)\n        pr_url = (\n            pr_details.url\n            if not isinstance(pr_details, PRNotFound)\n            else f\"https://github.com/{state.branch_name}/pull/{pr_number}\"\n        )\n\n        # Update footer with actual PR number\n        updated_footer = build_pr_body_footer(\n            pr_number=pr_number,\n            issue_number=state.issue_number,\n            plans_repo=plans_repo,\n        )\n        ctx.github.update_pr_body(state.repo_root, pr_number, \"\" + updated_footer)\n\n        click.echo(click.style(f\"   PR #{pr_number} created\", fg=\"green\"))\n        click.echo(\"\")\n\n        return dataclasses.replace(\n            state,\n            pr_number=pr_number,\n            pr_url=pr_url,\n            was_created=True,\n            base_branch=state.parent_branch,\n        )\n\n    # PR exists\n    pr_number = existing_pr.number\n    pr_url = existing_pr.url\n\n    # Add footer if missing\n    pr_details = ctx.github.get_pr(state.repo_root, pr_number)\n    current_body = \"\" if isinstance(pr_details, PRNotFound) else pr_details.body\n    has_footer = \"erk pr checkout\" in current_body\n    if not has_footer:\n        footer = build_pr_body_footer(\n            pr_number=pr_number,\n            issue_number=state.issue_number,\n            plans_repo=plans_repo,\n        )\n        ctx.github.update_pr_body(state.repo_root, pr_number, current_body + footer)\n\n    click.echo(click.style(f\"   PR #{pr_number} found (already exists)\", fg=\"green\"))\n    click.echo(\"\")\n\n    return dataclasses.replace(\n        state,\n        pr_number=pr_number,\n        pr_url=pr_url,\n        was_created=False,\n        base_branch=state.parent_branch,\n    )\n\n\ndef extract_diff(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Local git diff to base branch, filter lock files, truncate, write scratch file.\"\"\"\n    click.echo(click.style(\"Phase 2: Getting diff\", bold=True))\n\n    if state.base_branch is None:\n        return SubmitError(\n            phase=\"extract_diff\",\n            error_type=\"no_base_branch\",\n            message=\"No base branch determined for diff extraction\",\n            details={},\n        )\n\n    pr_diff = ctx.git.analysis.get_diff_to_branch(state.cwd, state.base_branch)\n    if state.debug:\n        diff_lines = len(pr_diff.splitlines())\n        click.echo(click.style(f\"   Diff retrieved ({diff_lines} lines)\", dim=True))\n\n    # Filter lock files, truncate\n    pr_diff = filter_diff_excluded_files(pr_diff)\n    diff_content, was_truncated = truncate_diff(pr_diff)\n    if was_truncated and state.debug:\n        click.echo(click.style(\"   Diff truncated for size\", dim=True))\n\n    # Write scratch file\n    diff_file = write_scratch_file(\n        diff_content,\n        session_id=state.session_id,\n        suffix=\".diff\",\n        prefix=\"pr-diff-\",\n        repo_root=state.repo_root,\n    )\n\n    click.echo(\"\")\n\n    return dataclasses.replace(state, diff_file=diff_file)\n\n\ndef fetch_plan_context(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Fetch plan context from linked erk-plan issue.\"\"\"\n    click.echo(click.style(\"Phase 3: Fetching plan context\", bold=True))\n\n    plan_provider = PlanContextProvider(\n        plan_backend=ctx.plan_backend, github_issues=ctx.github_issues\n    )\n    plan_context = plan_provider.get_plan_context(\n        repo_root=state.repo_root,\n        branch_name=state.branch_name,\n    )\n\n    echo_plan_context_status(plan_context)\n\n    return dataclasses.replace(state, plan_context=plan_context)\n\n\ndef generate_description(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Generate AI PR title and body via CommitMessageGenerator.\"\"\"\n    click.echo(click.style(\"Phase 4: Generating PR description\", bold=True))\n\n    if state.diff_file is None:\n        return SubmitError(\n            phase=\"generate_description\",\n            error_type=\"no_diff_file\",\n            message=\"Failed to extract diff for AI analysis\",\n            details={},\n        )\n\n    # Get commit messages for AI context\n    commit_messages = ctx.git.commit.get_commit_messages_since(state.cwd, state.parent_branch)\n\n    msg_gen = CommitMessageGenerator(ctx.prompt_executor)\n    msg_result = run_commit_message_generation(\n        generator=msg_gen,\n        diff_file=state.diff_file,\n        repo_root=state.repo_root,\n        current_branch=state.branch_name,\n        parent_branch=state.parent_branch,\n        commit_messages=commit_messages,\n        plan_context=state.plan_context,\n        debug=state.debug,\n    )\n\n    if not msg_result.success:\n        return SubmitError(\n            phase=\"generate_description\",\n            error_type=\"ai_generation_failed\",\n            message=f\"Failed to generate message: {msg_result.error_message}\",\n            details={},\n        )\n\n    click.echo(\"\")\n\n    return dataclasses.replace(\n        state,\n        title=msg_result.title or \"Update\",\n        body=msg_result.body or \"\",\n    )\n\n\ndef enhance_with_graphite(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"No-op if graphite_url already set. Otherwise check auth + tracking, run gt submit.\"\"\"\n    # Skip if Graphite already handled the push (graphite-first path)\n    if state.graphite_url is not None:\n        return state\n\n    # Skip if user disabled Graphite\n    if not state.use_graphite:\n        return state\n\n    click.echo(click.style(\"Phase 5: Graphite enhancement\", bold=True))\n\n    if state.pr_number is None:\n        return state\n\n    # Check Graphite auth\n    is_gt_authed, gt_username, _ = ctx.graphite.check_auth_status()\n    if not is_gt_authed:\n        if state.debug:\n            click.echo(click.style(\"   Graphite not authenticated, skipping enhancement\", dim=True))\n        click.echo(\"\")\n        return state\n\n    # Check if branch is tracked\n    repo_root = state.repo_root\n    all_branches = ctx.graphite.get_all_branches(ctx.git, repo_root)\n    if state.branch_name not in all_branches:\n        if state.debug:\n            click.echo(\n                click.style(\"   Branch not tracked by Graphite, skipping enhancement\", dim=True)\n            )\n        click.echo(\"\")\n        return state\n\n    # Run gt submit\n    try:\n        ctx.graphite.submit_stack(\n            repo_root,\n            publish=True,\n            restack=False,\n            quiet=False,\n            force=state.force,\n        )\n    except RuntimeError as e:\n        error_msg = str(e).lower()\n        if \"nothing to submit\" in error_msg or \"no changes\" in error_msg:\n            click.echo(click.style(\"   PR already up to date with Graphite\", fg=\"green\"))\n            click.echo(\"\")\n            return state\n        return SubmitError(\n            phase=\"enhance_with_graphite\",\n            error_type=\"graphite_enhance_failed\",\n            message=f\"Graphite enhancement failed: {e}\",\n            details={},\n        )\n\n    # Get Graphite URL\n    remote_url = ctx.git.remote.get_remote_url(repo_root, \"origin\")\n    owner, repo_name = parse_git_remote_url(remote_url)\n    repo_id = GitHubRepoId(owner=owner, repo=repo_name)\n    graphite_url: str | None = None\n    if state.pr_number is not None:\n        graphite_url = ctx.graphite.get_graphite_url(repo_id, state.pr_number)\n\n    click.echo(\"\")\n\n    return dataclasses.replace(state, graphite_url=graphite_url)\n\n\ndef finalize_pr(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Update PR title/body with footer, add labels, amend local commit, clean up diff file.\"\"\"\n    click.echo(click.style(\"Phase 6: Updating PR metadata\", bold=True))\n\n    if state.pr_number is None:\n        return SubmitError(\n            phase=\"finalize_pr\",\n            error_type=\"no_pr_number\",\n            message=\"No PR number available for finalization\",\n            details={},\n        )\n\n    pr_body = state.body or \"\"\n    pr_title = state.title or \"Update\"\n    plans_repo = ctx.local_config.plans_repo if ctx.local_config else None\n\n    # Detect draft-PR backend and extract metadata prefix\n    metadata_prefix = \"\"\n    issue_number = state.issue_number\n    effective_plans_repo = plans_repo\n\n    if ctx.plan_backend.get_provider_name() == \"github-draft-pr\" and state.pr_number is not None:\n        existing_pr = ctx.github.get_pr(state.repo_root, state.pr_number)\n        if not isinstance(existing_pr, PRNotFound):\n            metadata_prefix = extract_metadata_prefix(existing_pr.body)\n        # Don't self-close: draft PR IS the plan\n        issue_number = None\n        effective_plans_repo = None\n    else:\n        # Fallback: preserve existing closing reference from PR body\n        if issue_number is None:\n            closing_ref = _extract_closing_ref_from_pr(ctx, state.cwd, state.pr_number)\n            if closing_ref is not None:\n                issue_number = closing_ref.issue_number\n                effective_plans_repo = closing_ref.plans_repo\n\n    # Add planned/ prefix for plan-linked PRs\n    if issue_number is not None:\n        pr_title = _add_planned_prefix(pr_title)\n\n    # Check learn plan label\n    impl_dir = state.cwd / \".impl\"\n    is_learn_origin = is_learn_plan(impl_dir)\n\n    # Assemble PR body with plan details and footer\n    final_body = assemble_pr_body(\n        body=pr_body,\n        plan_context=state.plan_context,\n        pr_number=state.pr_number,\n        issue_number=issue_number,\n        plans_repo=effective_plans_repo,\n        header=\"\",\n        metadata_prefix=metadata_prefix,\n    )\n\n    # Update PR metadata\n    ctx.github.update_pr_title_and_body(\n        repo_root=state.repo_root,\n        pr_number=state.pr_number,\n        title=pr_title,\n        body=BodyText(content=final_body),\n    )\n\n    # Publish draft PR if needed\n    pr_draft_check = ctx.github.get_pr(state.repo_root, state.pr_number)\n    if not isinstance(pr_draft_check, PRNotFound) and pr_draft_check.is_draft:\n        click.echo(click.style(\"   Publishing draft PR...\", dim=True))\n        ctx.github.mark_pr_ready(state.repo_root, state.pr_number)\n\n    # Add learn skip label if applicable\n    if is_learn_origin:\n        ctx.github.add_label_to_pr(state.repo_root, state.pr_number, ERK_SKIP_LEARN_LABEL)\n\n    # Amend local commit with title and body (without metadata footer)\n    commit_message = pr_title\n    if pr_body:\n        commit_message = f\"{pr_title}\\n\\n{pr_body}\"\n    ctx.git.commit.amend_commit(state.repo_root, commit_message)\n\n    # Fix Graphite tracking divergence caused by the amend\n    if ctx.graphite_branch_ops is not None:\n        ctx.graphite_branch_ops.retrack_branch(state.repo_root, state.branch_name)\n\n    # Clean up temp diff file\n    if state.diff_file is not None and state.diff_file.exists():\n        try:\n            state.diff_file.unlink()\n        except OSError as e:\n            if state.debug:\n                click.echo(click.style(f\"   Failed to clean up diff file: {e}\", dim=True))\n\n    click.echo(click.style(\"   PR metadata updated\", fg=\"green\"))\n    click.echo(\"\")\n\n    # Get final PR URL\n    pr_result = ctx.github.get_pr_for_branch(state.repo_root, state.branch_name)\n    pr_url = pr_result.url if not isinstance(pr_result, PRNotFound) else state.pr_url or \"\"\n\n    # Get Graphite URL if not already set\n    graphite_url = state.graphite_url\n    if graphite_url is None and state.use_graphite:\n        is_gt_authed, _, _ = ctx.graphite.check_auth_status()\n        if is_gt_authed:\n            remote_url = ctx.git.remote.get_remote_url(state.repo_root, \"origin\")\n            owner, repo_name = parse_git_remote_url(remote_url)\n            repo_id = GitHubRepoId(owner=owner, repo=repo_name)\n            graphite_url = ctx.graphite.get_graphite_url(repo_id, state.pr_number)\n\n    return dataclasses.replace(\n        state,\n        issue_number=issue_number,\n        pr_url=pr_url,\n        graphite_url=graphite_url,\n        title=pr_title,\n        body=pr_body,\n    )\n\n\n# ---------------------------------------------------------------------------\n# Helper\n# ---------------------------------------------------------------------------\n\n\ndef _extract_closing_ref_from_pr(\n    ctx: ErkContext,\n    cwd: Path,\n    pr_number: int,\n) -> ClosingReference | None:\n    \"\"\"Extract closing reference from an existing PR's footer.\"\"\"\n    repo_root = ctx.git.repo.get_repository_root(cwd)\n    current_pr = ctx.github.get_pr(repo_root, pr_number)\n    if isinstance(current_pr, PRNotFound) or not current_pr.body:\n        return None\n    existing_footer = extract_footer_from_body(current_pr.body)\n    if existing_footer is None:\n        return None\n    return extract_closing_reference(existing_footer)\n\n\n# ---------------------------------------------------------------------------\n# Pipeline Runner\n# ---------------------------------------------------------------------------\n\n\n@cache\ndef _submit_pipeline() -> tuple[SubmitStep, ...]:\n    return (\n        prepare_state,\n        commit_wip,\n        push_and_create_pr,\n        extract_diff,\n        fetch_plan_context,\n        generate_description,\n        enhance_with_graphite,\n        finalize_pr,\n    )\n\n\ndef run_submit_pipeline(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Run the submit pipeline, returning final state or first error.\"\"\"\n    for step in _submit_pipeline():\n        try:\n            result = step(ctx, state)\n        except Exception as e:\n            step_name = getattr(step, \"__name__\", repr(step))\n            return SubmitError(\n                phase=step_name,\n                error_type=\"unhandled_exception\",\n                message=f\"Unexpected error in {step_name}: {e}\",\n                details={},\n            )\n        if isinstance(result, SubmitError):\n            return result\n        state = result\n    return state\n\n\ndef make_initial_state(\n    *,\n    cwd: Path,\n    use_graphite: bool,\n    force: bool,\n    debug: bool,\n    session_id: str | None,\n) -> SubmitState:\n    \"\"\"Create initial SubmitState with only CLI-provided values.\n\n    All discovery fields start as empty/None and are populated by prepare_state().\n    \"\"\"\n    resolved_session_id = session_id if session_id is not None else str(uuid.uuid4())\n    return SubmitState(\n        cwd=cwd,\n        repo_root=cwd,\n        branch_name=\"\",\n        parent_branch=\"\",\n        trunk_branch=\"\",\n        use_graphite=use_graphite,\n        force=force,\n        debug=debug,\n        session_id=resolved_session_id,\n        issue_number=None,\n        pr_number=None,\n        pr_url=None,\n        was_created=False,\n        base_branch=None,\n        graphite_url=None,\n        diff_file=None,\n        plan_context=None,\n        title=None,\n        body=None,\n    )\n","structuredPatch":[{"oldStart":52,"oldLines":13,"newStart":52,"newLines":13,"lines":[" "," "," def _add_planned_prefix(title: str) -> str:","-    \"\"\"Prepend 'planned/' prefix to PR title (idempotent).","+    \"\"\"Prepend 'plnd/' prefix to PR title (idempotent)."," ","     Args:","         title: The PR title to prefix"," ","     Returns:","-        The title with 'planned/' prefix, skipping if already prefixed","+        The title with 'plnd/' prefix, skipping if already prefixed","     \"\"\"","     if title.startswith(PLANNED_PR_TITLE_PREFIX):","         return title"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"71e44166-fa7e-44b9-81fd-579a871ee9df","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01LHTtb5Xts77b8d5UhW8RNB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015es5vc8boshJWPnb6WrGGN","name":"TodoWrite","input":{"todos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"in_progress","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":310,"cache_read_input_tokens":57487,"cache_creation":{"ephemeral_5m_input_tokens":310,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHSnE3rEh4QGmBrwnur","type":"assistant","uuid":"b6862dd6-f148-4567-986f-5979c71cf9d0","timestamp":"2026-02-22T14:43:00.988Z"}
{"parentUuid":"b6862dd6-f148-4567-986f-5979c71cf9d0","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015es5vc8boshJWPnb6WrGGN","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"938a56ac-a57c-4c26-8591-fc3747db8c97","timestamp":"2026-02-22T14:43:01.007Z","toolUseResult":{"oldTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"in_progress","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"pending","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"pending","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}],"newTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"in_progress","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]}}
{"parentUuid":"938a56ac-a57c-4c26-8591-fc3747db8c97","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Ck56ci5nv9vtkcu3vrWAm3","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the git-pr-push.md slash command:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":57797,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHTE4p2idPuWYqhUGyq","type":"assistant","uuid":"00d0331d-f6da-46c8-aeba-5fae9e0864b8","timestamp":"2026-02-22T14:43:03.512Z"}
{"parentUuid":"00d0331d-f6da-46c8-aeba-5fae9e0864b8","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Ck56ci5nv9vtkcu3vrWAm3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016DGSHb4fwkCqeY3tueEbyk","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/.claude/commands/erk/git-pr-push.md","old_string":"### Step 3.5: Add Planned Prefix (if from plan)\n\nIf this worktree was created from a plan (`.impl/` directory exists), prepend `planned/` to the PR title:\n\n```bash\nif [ -d \".impl\" ]; then\n    # Extract the title before creating the commit\n    # (we'll apply the prefix when creating the commit message below)\n    has_impl_dir=true\nelse\n    has_impl_dir=false\nfi\n```\n\nWhen generating the commit message in Step 4, if `has_impl_dir` is true, prepend `planned/` to the title:\n\n```bash\nif [ \"$has_impl_dir\" = true ]; then\n    pr_title=\"planned/${pr_title}\"\nfi\n```","new_string":"### Step 3.5: Add Planned Prefix (if from plan)\n\nIf this worktree was created from a plan (`.impl/` directory exists), prepend `plnd/` to the PR title:\n\n```bash\nif [ -d \".impl\" ]; then\n    # Extract the title before creating the commit\n    # (we'll apply the prefix when creating the commit message below)\n    has_impl_dir=true\nelse\n    has_impl_dir=false\nfi\n```\n\nWhen generating the commit message in Step 4, if `has_impl_dir` is true, prepend `plnd/` to the title:\n\n```bash\nif [ \"$has_impl_dir\" = true ]; then\n    pr_title=\"plnd/${pr_title}\"\nfi\n```"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":57797,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHTE4p2idPuWYqhUGyq","type":"assistant","uuid":"8165ac70-fd97-415d-9712-1799341170c9","timestamp":"2026-02-22T14:43:09.698Z"}
{"parentUuid":"8165ac70-fd97-415d-9712-1799341170c9","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016DGSHb4fwkCqeY3tueEbyk","type":"tool_result","content":"The file /home/runner/work/erk/erk/.claude/commands/erk/git-pr-push.md has been updated successfully."}]},"uuid":"5b3041d1-672b-4d0c-b1d2-328168980add","timestamp":"2026-02-22T14:43:10.373Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/.claude/commands/erk/git-pr-push.md","oldString":"### Step 3.5: Add Planned Prefix (if from plan)\n\nIf this worktree was created from a plan (`.impl/` directory exists), prepend `planned/` to the PR title:\n\n```bash\nif [ -d \".impl\" ]; then\n    # Extract the title before creating the commit\n    # (we'll apply the prefix when creating the commit message below)\n    has_impl_dir=true\nelse\n    has_impl_dir=false\nfi\n```\n\nWhen generating the commit message in Step 4, if `has_impl_dir` is true, prepend `planned/` to the title:\n\n```bash\nif [ \"$has_impl_dir\" = true ]; then\n    pr_title=\"planned/${pr_title}\"\nfi\n```","newString":"### Step 3.5: Add Planned Prefix (if from plan)\n\nIf this worktree was created from a plan (`.impl/` directory exists), prepend `plnd/` to the PR title:\n\n```bash\nif [ -d \".impl\" ]; then\n    # Extract the title before creating the commit\n    # (we'll apply the prefix when creating the commit message below)\n    has_impl_dir=true\nelse\n    has_impl_dir=false\nfi\n```\n\nWhen generating the commit message in Step 4, if `has_impl_dir` is true, prepend `plnd/` to the title:\n\n```bash\nif [ \"$has_impl_dir\" = true ]; then\n    pr_title=\"plnd/${pr_title}\"\nfi\n```","originalFile":"---\ndescription: Create git commit and push branch as PR using git + GitHub CLI\nargument-hint: <description>\n---\n\n# Push PR (Git Only)\n\nAutomatically create a git commit with a helpful summary message and push the current branch as a pull request using standard git + GitHub CLI (no Graphite required).\n\n## Usage\n\n```bash\n# Invoke the command (description argument is optional but recommended)\n/erk:git-pr-push \"Add user authentication feature\"\n\n# Without argument (will analyze changes automatically)\n/erk:git-pr-push\n```\n\n## What This Command Does\n\nHandles the complete git-only push-pr workflow:\n\n1. Check for uncommitted changes and stage/commit them if needed\n2. Analyze git diff to generate meaningful commit message\n3. Create commit with AI-generated message\n4. Push to origin with upstream tracking\n5. Create GitHub PR (or find existing one)\n6. Report results with PR URL\n\n## Key Differences from /gt:submit-branch\n\n- Uses standard `git push` instead of `gt submit`\n- Uses `gh pr create` instead of Graphite's PR submission\n- No stack operations (no restack, no stack metadata updates)\n- Simpler workflow: git -> push -> PR (no Graphite layer)\n- Works in any git repository (not just Graphite-enabled repos)\n\n## Prerequisites\n\n- Git repository with remote configured\n- GitHub CLI (`gh`) installed and authenticated\n- Run `gh auth status` to verify authentication\n- Run `gh auth login` if not authenticated\n\n## Implementation\n\nExecute the git-only push-pr workflow with the following steps:\n\n### Step 1: Verify Prerequisites\n\nCheck GitHub CLI authentication and get current git state:\n\n```bash\n# Check GitHub CLI authentication (show status for verification)\ngh auth status\n\n# Get current branch name\ncurrent_branch=$(git branch --show-current)\n\n# Check for uncommitted changes\nhas_changes=$(git status --porcelain)\n```\n\nIf `gh auth status` fails, report error and tell user to run `gh auth login`.\n\n### Step 2: Stage Changes (if needed)\n\nIf `has_changes` is non-empty, stage all changes:\n\n```bash\ngit add .\n```\n\n### Step 3: Analyze Staged Diff\n\nGet the staged diff and analyze it to generate a commit message:\n\n```bash\n# Get repository root for relative paths\nrepo_root=$(git rev-parse --show-toplevel)\n\n# Get staged diff for analysis\ngit diff --staged\n```\n\nLoad the `erk-diff-analysis` skill for commit message generation guidance.\n\n### Step 3.5: Add Planned Prefix (if from plan)\n\nIf this worktree was created from a plan (`.impl/` directory exists), prepend `planned/` to the PR title:\n\n```bash\nif [ -d \".impl\" ]; then\n    # Extract the title before creating the commit\n    # (we'll apply the prefix when creating the commit message below)\n    has_impl_dir=true\nelse\n    has_impl_dir=false\nfi\n```\n\nWhen generating the commit message in Step 4, if `has_impl_dir` is true, prepend `planned/` to the title:\n\n```bash\nif [ \"$has_impl_dir\" = true ]; then\n    pr_title=\"planned/${pr_title}\"\nfi\n```\n\n### Step 4: Create Commit\n\nCreate the commit with your AI-generated message using heredoc:\n\n```bash\ngit commit -m \"$(cat <<'COMMIT_MSG'\n[Your generated commit message here]\nCOMMIT_MSG\n)\"\n```\n\n### Step 5: Push to Remote\n\nPush the branch to origin with upstream tracking:\n\n```bash\ngit push -u origin \"$(git branch --show-current)\"\n```\n\n### Step 6: Get Closing Text\n\nGet the issue closing text if this worktree was created from a GitHub issue:\n\n```bash\nclosing_text=$(erk exec get-closing-text 2>/dev/null || echo \"\")\n```\n\nThis reads `.impl/issue.json` and returns `Closes #N` if an issue reference exists.\n\n### Step 6.5: Check for Existing PR\n\nBefore creating a new PR, check if one already exists for the current branch:\n\n```bash\nexisting_pr=$(gh pr list --head \"$(git branch --show-current)\" --state open --json number,url,isDraft --jq '.[0]')\n```\n\n**Decision logic:**\n\n- If `existing_pr` is empty or null: No existing PR, proceed to Step 7\n- If `existing_pr` has data: PR exists, skip Step 7 and go directly to Step 7.5\n\nIf an existing PR was found, extract its details for reporting:\n\n```bash\npr_url=$(echo \"$existing_pr\" | jq -r '.url')\npr_number=$(echo \"$existing_pr\" | jq -r '.number')\nis_draft=$(echo \"$existing_pr\" | jq -r '.isDraft')\n```\n\n### Step 7: Create GitHub PR (if no existing PR)\n\n**Skip this step if an existing PR was found in Step 6.5.** The push in Step 5 already updated the existing PR with new commits.\n\nExtract PR title (first line) and body (remaining lines) from commit message, then create PR with closing text appended:\n\n```bash\n# Get the commit message\ncommit_msg=$(git log -1 --pretty=%B)\n\n# Extract first line as title\npr_title=$(echo \"$commit_msg\" | head -n 1)\n\n# Extract remaining lines as body (skip empty first line after title)\ncommit_body=$(echo \"$commit_msg\" | tail -n +2)\n\n# Append closing text if present\nif [ -n \"$closing_text\" ]; then\n    pr_body=\"${commit_body}\n\n${closing_text}\"\nelse\n    pr_body=\"${commit_body}\"\nfi\n\n# Create PR using GitHub CLI\npr_output=$(gh pr create --title \"$pr_title\" --body \"$pr_body\")\n\n# Extract PR number from the output URL (last path segment)\npr_number=$(echo \"$pr_output\" | grep -oE '[0-9]+$')\npr_url=\"$pr_output\"\n```\n\n### Step 7.5: Add Checkout Footer\n\nExtract the PR number (from Step 7 if PR was created, or from Step 6.5 if existing PR was found), then generate and append the checkout footer:\n\n**Determining PR number:**\n\n- If Step 7 was executed: Use `pr_number` extracted from `gh pr create` output\n- If Step 7 was skipped: Use `pr_number` extracted from `existing_pr` in Step 6.5\n\n**Generate and append footer:**\n\n```bash\n# Get issue number from .impl/issue.json if present (for proper issue linking)\nissue_number=$(jq -r '.issue_number // empty' .impl/issue.json 2>/dev/null || echo \"\")\n\n# Generate footer with issue number if available\nif [ -n \"$issue_number\" ]; then\n    footer=$(erk exec get-pr-body-footer --pr-number \"$pr_number\" --issue-number \"$issue_number\")\nelse\n    footer=$(erk exec get-pr-body-footer --pr-number \"$pr_number\")\nfi\n\n# Get current PR body using REST API (avoids GraphQL rate limits) and append footer\ncurrent_body=$(erk exec get-pr-view \"$pr_number\" | jq -r '.body')\ngh pr edit \"$pr_number\" --body \"${current_body}${footer}\"\n```\n\n**Note:** The footer includes the checkout command and issue reference (if issue tracking exists). This ensures `erk pr check` passes.\n\n### Step 8: Validate PR Rules\n\nRun the PR check command to validate the PR was created correctly:\n\n```bash\nerk pr check\n```\n\nThis validates:\n\n- Issue closing reference (Closes #N) is present when `.impl/issue.json` exists\n- PR body contains the standard checkout footer\n\nIf any checks fail, display the output and warn the user, but continue to Step 9.\n\n### Step 9: Report Results\n\nDisplay a clear summary based on whether a PR was created or found:\n\n**If a NEW PR was created (Step 7 was executed):**\n\n```\n## Branch Submission Complete\n\n### What Was Done\n\n✓ Staged all uncommitted changes\n✓ Created commit with AI-generated message\n✓ Pushed branch to origin with upstream tracking\n✓ Created GitHub PR\n✓ Linked to issue #N (will auto-close on merge)  [only if closing_text was present]\n\n### View PR\n\n[PR URL from gh pr create output]\n```\n\n**If an EXISTING PR was found (Step 7 was skipped):**\n\n```\n## Branch Submission Complete\n\n### What Was Done\n\n✓ Staged all uncommitted changes\n✓ Created commit with AI-generated message\n✓ Pushed branch to origin with upstream tracking\n✓ Found existing PR #N for this branch (skipped PR creation)\n✓ Linked to issue #M (will auto-close on merge)  [only if closing_text was present]\n\n### Note\n\n[If is_draft is true]: This is a draft PR. When ready for review, run: `gh pr ready`\n\n### View PR\n\n[PR URL extracted from existing_pr]\n```\n\n**Conditional lines:**\n\n- The \"Linked to issue\" line should only appear if `closing_text` was non-empty\n- The \"Note\" section with draft guidance should only appear if `is_draft` is true\n\n**CRITICAL**: The PR URL MUST be the absolute last line of your output. Do not add any text after it.\n\n## Error Handling\n\nWhen errors occur, provide clear guidance:\n\n**GitHub CLI not authenticated:**\n\n```\n❌ GitHub CLI is not authenticated\n\nTo use this command, authenticate with GitHub:\n    gh auth login\n```\n\n**Nothing to commit:**\n\n```\n❌ No changes to commit\n\nYour working directory is clean. Make some changes first.\n```\n\n**Push failed (diverged branches):**\n\n```\n❌ Push failed: branch has diverged\n\nOption 1: Pull and merge\n    git pull origin [branch]\n\nOption 2: Force push (⚠️ overwrites remote)\n    git push -f origin [branch]\n```\n\nNote: The \"PR already exists\" case is now handled automatically in Step 6.5. If a PR exists for the current branch, the command will skip PR creation and report the existing PR URL instead.\n\n## Best Practices\n\n### Never Change Directory\n\n**NEVER use `cd` during execution.** Always use absolute paths or git's `-C` flag.\n\n```bash\n# ❌ WRONG\ncd /path/to/repo && git status\n\n# ✅ CORRECT\ngit -C /path/to/repo status\n```\n\n**Rationale:** Changing directories pollutes the execution context and makes it harder to reason about state. The working directory should remain stable throughout the entire workflow.\n\n### Never Write to Temporary Files\n\n**NEVER write commit messages or other content to temporary files.** Always use in-context manipulation and shell built-ins.\n\n```bash\n# ❌ WRONG - Triggers permission prompts\necho \"$message\" > \"${TMPDIR:-/tmp}/commit_msg.txt\"\ngit commit -F \"${TMPDIR:-/tmp}/commit_msg.txt\"\n\n# ✅ CORRECT - In-memory heredoc\ngit commit -m \"$(cat <<'EOF'\n$message\nEOF\n)\"\n```\n\n**Rationale:** Temporary files require filesystem permissions and create unnecessary I/O. Since agents operate in isolated contexts, there's no risk of context pollution from in-memory manipulation.\n\n## Quality Standards\n\n### Always\n\n- Be concise and strategic in analysis\n- Use component-level descriptions\n- Highlight breaking changes prominently\n- Note test coverage patterns\n- Use relative paths from repository root\n- Provide clear error guidance\n- Use standard git + GitHub CLI commands (no Graphite dependencies)\n\n### Never\n\n- Add Claude attribution or footer to commit messages\n- Speculate about intentions without code evidence\n- Provide exhaustive lists of every function touched\n- Include implementation details (specific variable names, line numbers)\n- Provide time estimates\n- Use vague language like \"various changes\"\n- Retry failed operations automatically\n- Write to temporary files (use in-context quoting and shell built-ins instead)\n- Use Graphite-specific commands (`gt submit`, `gt restack`, etc.)\n\n## Self-Verification\n\nBefore completing, verify:\n\n- [ ] GitHub CLI authentication checked\n- [ ] Git status verified\n- [ ] Uncommitted changes staged (if any existed)\n- [ ] Staged diff analyzed\n- [ ] Diff analysis is concise and strategic (3-5 key changes max)\n- [ ] Commit message has no Claude footer\n- [ ] File paths are relative to repository root\n- [ ] Commit created successfully\n- [ ] Branch pushed to origin with upstream tracking\n- [ ] Closing text obtained (if issue reference exists)\n- [ ] GitHub PR created successfully (or existing PR found)\n- [ ] PR URL extracted from output\n- [ ] Results displayed with \"What Was Done\" section listing actions\n- [ ] PR URL placed at end under \"View PR\" section\n- [ ] Any errors handled with helpful guidance\n","structuredPatch":[{"oldStart":88,"oldLines":7,"newStart":88,"newLines":7,"lines":[" "," ### Step 3.5: Add Planned Prefix (if from plan)"," ","-If this worktree was created from a plan (`.impl/` directory exists), prepend `planned/` to the PR title:","+If this worktree was created from a plan (`.impl/` directory exists), prepend `plnd/` to the PR title:"," "," ```bash"," if [ -d \".impl\" ]; then"]},{"oldStart":100,"oldLines":11,"newStart":100,"newLines":11,"lines":[" fi"," ```"," ","-When generating the commit message in Step 4, if `has_impl_dir` is true, prepend `planned/` to the title:","+When generating the commit message in Step 4, if `has_impl_dir` is true, prepend `plnd/` to the title:"," "," ```bash"," if [ \"$has_impl_dir\" = true ]; then","-    pr_title=\"planned/${pr_title}\"","+    pr_title=\"plnd/${pr_title}\""," fi"," ```"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"5b3041d1-672b-4d0c-b1d2-328168980add","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01H3YoXBAGUpQ9Rr18zM27sK","type":"message","role":"assistant","content":[{"type":"text","text":"Now update plan_create_review_branch.py:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":531,"cache_read_input_tokens":58372,"cache_creation":{"ephemeral_5m_input_tokens":531,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHTv86MCq61tqoe7EDR","type":"assistant","uuid":"14be1b22-01f0-4e98-8f29-ae1d0ec84af2","timestamp":"2026-02-22T14:43:12.362Z"}
{"parentUuid":"14be1b22-01f0-4e98-8f29-ae1d0ec84af2","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01H3YoXBAGUpQ9Rr18zM27sK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0157ZQi7qgzswXouXmgJU2dH","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/commands/exec/scripts/plan_create_review_branch.py","old_string":"    # Define branch and file names with timestamp (format: planned/review-{issue}-{MM-DD-HHMM})\n    timestamp_suffix = format_branch_timestamp_suffix(time.now())\n    branch_name = f\"planned/review-{issue_number}{timestamp_suffix}\"","new_string":"    # Define branch and file names with timestamp (format: plnd/review-{issue}-{MM-DD-HHMM})\n    timestamp_suffix = format_branch_timestamp_suffix(time.now())\n    branch_name = f\"plnd/review-{issue_number}{timestamp_suffix}\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":531,"cache_read_input_tokens":58372,"cache_creation":{"ephemeral_5m_input_tokens":531,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHTv86MCq61tqoe7EDR","type":"assistant","uuid":"08df543c-bd81-40f3-8b17-25a01080b51c","timestamp":"2026-02-22T14:43:15.497Z"}
{"parentUuid":"08df543c-bd81-40f3-8b17-25a01080b51c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0157ZQi7qgzswXouXmgJU2dH","type":"tool_result","content":"The file /home/runner/work/erk/erk/src/erk/cli/commands/exec/scripts/plan_create_review_branch.py has been updated successfully."}]},"uuid":"6256561c-3d6d-45ba-8002-29ef91e88559","timestamp":"2026-02-22T14:43:16.242Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/commands/exec/scripts/plan_create_review_branch.py","oldString":"    # Define branch and file names with timestamp (format: planned/review-{issue}-{MM-DD-HHMM})\n    timestamp_suffix = format_branch_timestamp_suffix(time.now())\n    branch_name = f\"planned/review-{issue_number}{timestamp_suffix}\"","newString":"    # Define branch and file names with timestamp (format: plnd/review-{issue}-{MM-DD-HHMM})\n    timestamp_suffix = format_branch_timestamp_suffix(time.now())\n    branch_name = f\"plnd/review-{issue_number}{timestamp_suffix}\"","originalFile":"\"\"\"Create a plan review branch and push to remote.\n\nUsage:\n    erk exec plan-create-review-branch <issue-number>\n\nOutput:\n    JSON with branch name, file path, and plan title\n\nExit Codes:\n    0: Success\n    1: Error (issue not found, missing erk-plan label, no plan content, branch exists, or git error)\n\"\"\"\n\nimport json\nfrom dataclasses import asdict, dataclass\nfrom pathlib import Path\n\nimport click\n\nfrom erk.cli.ensure import UserFacingCliError\nfrom erk_shared.context.helpers import require_git, require_repo_root, require_time\nfrom erk_shared.context.helpers import require_issues as require_github_issues\nfrom erk_shared.gateway.git.abc import Git\nfrom erk_shared.gateway.git.branch_ops.types import BranchAlreadyExists\nfrom erk_shared.gateway.git.remote_ops.types import PushError\nfrom erk_shared.gateway.github.issues.abc import GitHubIssues\nfrom erk_shared.gateway.github.issues.types import IssueNotFound\nfrom erk_shared.gateway.github.metadata.plan_header import (\n    extract_plan_from_comment,\n    extract_plan_header_comment_id,\n)\nfrom erk_shared.gateway.time.abc import Time\nfrom erk_shared.naming import format_branch_timestamp_suffix\n\n\n@dataclass(frozen=True)\nclass PlanReviewBranchSuccess:\n    \"\"\"Success response for plan review branch creation.\"\"\"\n\n    success: bool\n    issue_number: int\n    branch: str\n    file_path: str\n    plan_title: str\n\n\n@dataclass(frozen=True)\nclass PlanReviewBranchError:\n    \"\"\"Error response for plan review branch creation.\"\"\"\n\n    success: bool\n    error: str\n    message: str\n\n\nclass PlanReviewBranchException(Exception):\n    \"\"\"Exception raised during plan review branch creation.\"\"\"\n\n    def __init__(self, error: str, message: str) -> None:\n        super().__init__(message)\n        self.error = error\n        self.message = message\n\n\ndef _fetch_plan_content(\n    github_issues: GitHubIssues,\n    repo_root: Path,\n    issue_number: int,\n) -> tuple[str, str]:\n    \"\"\"Fetch plan content from GitHub issue.\n\n    Args:\n        github_issues: GitHub issues gateway\n        repo_root: Repository root path\n        issue_number: Issue number to fetch\n\n    Returns:\n        Tuple of (plan_title, plan_content) on success\n\n    Raises:\n        PlanReviewBranchException: If issue not found, missing label, or no plan content\n    \"\"\"\n    # LBYL: Check if issue exists before fetching\n    if not github_issues.issue_exists(repo_root, issue_number):\n        raise PlanReviewBranchException(\n            error=\"issue_not_found\",\n            message=f\"Issue #{issue_number} not found\",\n        )\n\n    # Issue exists, safe to fetch\n    issue = github_issues.get_issue(repo_root, issue_number)\n    if isinstance(issue, IssueNotFound):\n        raise PlanReviewBranchException(\n            error=\"issue_not_found\",\n            message=f\"Issue #{issue_number} not found\",\n        )\n\n    # Validate erk-plan label\n    if \"erk-plan\" not in issue.labels:\n        raise PlanReviewBranchException(\n            error=\"missing_erk_plan_label\",\n            message=f\"Issue #{issue_number} does not have the erk-plan label\",\n        )\n\n    # Extract plan comment ID from metadata\n    plan_comment_id = extract_plan_header_comment_id(issue.body)\n    if plan_comment_id is None:\n        raise PlanReviewBranchException(\n            error=\"no_plan_content\",\n            message=f\"Issue #{issue_number} has no plan_comment_id in metadata\",\n        )\n\n    # Fetch comments\n    comments = github_issues.get_issue_comments_with_urls(repo_root, issue_number)\n\n    if not comments:\n        raise PlanReviewBranchException(\n            error=\"no_plan_content\",\n            message=f\"Issue #{issue_number} has no comments\",\n        )\n\n    # Find the comment with the plan content\n    for comment in comments:\n        if comment.id == plan_comment_id:\n            content = extract_plan_from_comment(comment.body)\n            if content:\n                return (issue.title, content)\n\n    raise PlanReviewBranchException(\n        error=\"no_plan_content\",\n        message=f\"Issue #{issue_number} comment {plan_comment_id} has no plan markers\",\n    )\n\n\ndef _create_review_branch_impl(\n    git: Git,\n    *,\n    github_issues: GitHubIssues,\n    time: Time,\n    repo_root: Path,\n    issue_number: int,\n) -> PlanReviewBranchSuccess:\n    \"\"\"Create a plan review branch and push to remote.\n\n    Args:\n        git: Git gateway\n        github_issues: GitHub issues gateway\n        time: Time gateway for timestamps\n        repo_root: Repository root path\n        issue_number: Issue number to create review branch for\n\n    Returns:\n        PlanReviewBranchSuccess on success\n\n    Raises:\n        PlanReviewBranchException: If plan content cannot be fetched or validated\n    \"\"\"\n    # Fetch plan content (raises PlanReviewBranchException on failure)\n    plan_title, plan_content = _fetch_plan_content(github_issues, repo_root, issue_number)\n\n    # Define branch and file names with timestamp (format: planned/review-{issue}-{MM-DD-HHMM})\n    timestamp_suffix = format_branch_timestamp_suffix(time.now())\n    branch_name = f\"planned/review-{issue_number}{timestamp_suffix}\"\n    file_name = f\"PLAN-REVIEW-{issue_number}.md\"\n\n    # Fetch origin/master, create branch, commit, and push\n    # These operations let exceptions escape as they represent invariant violations\n    # if they fail (network/disk/auth issues are exceptional, not expected states)\n    git.remote.fetch_branch(repo_root, \"origin\", \"master\")\n    create_result = git.branch.create_branch(repo_root, branch_name, \"origin/master\", force=False)\n    if isinstance(create_result, BranchAlreadyExists):\n        raise UserFacingCliError(create_result.message)\n    git.branch.checkout_branch(repo_root, branch_name)\n\n    # Write plan file at repo root\n    file_path = repo_root / file_name\n    file_path.write_text(plan_content, encoding=\"utf-8\")\n\n    # Stage, commit, and push\n    git.commit.stage_files(repo_root, [file_name])\n    commit_message = f\"Add plan #{issue_number} for review\"\n    git.commit.commit(repo_root, commit_message)\n    push_result = git.remote.push_to_remote(\n        repo_root, \"origin\", branch_name, set_upstream=True, force=False\n    )\n    if isinstance(push_result, PushError):\n        raise UserFacingCliError(push_result.message)\n\n    return PlanReviewBranchSuccess(\n        success=True,\n        issue_number=issue_number,\n        branch=branch_name,\n        file_path=file_name,\n        plan_title=plan_title,\n    )\n\n\n@click.command(name=\"plan-create-review-branch\")\n@click.argument(\"issue_number\", type=int)\n@click.pass_context\ndef plan_create_review_branch(\n    ctx: click.Context,\n    issue_number: int,\n) -> None:\n    \"\"\"Create a plan review branch and push to remote.\n\n    Creates a branch planned/review-{issue}-{timestamp} from origin/master, writes plan\n    to PLAN-REVIEW-{issue}.md, commits, and pushes to origin.\n    \"\"\"\n    git = require_git(ctx)\n    github_issues = require_github_issues(ctx)\n    time = require_time(ctx)\n    repo_root = require_repo_root(ctx)\n\n    try:\n        result = _create_review_branch_impl(\n            git,\n            github_issues=github_issues,\n            time=time,\n            repo_root=repo_root,\n            issue_number=issue_number,\n        )\n        click.echo(json.dumps(asdict(result)))\n    except PlanReviewBranchException as e:\n        error_response = PlanReviewBranchError(\n            success=False,\n            error=e.error,\n            message=e.message,\n        )\n        click.echo(json.dumps(asdict(error_response)))\n        raise SystemExit(1) from None\n","structuredPatch":[{"oldStart":158,"oldLines":9,"newStart":158,"newLines":9,"lines":["     # Fetch plan content (raises PlanReviewBranchException on failure)","     plan_title, plan_content = _fetch_plan_content(github_issues, repo_root, issue_number)"," ","-    # Define branch and file names with timestamp (format: planned/review-{issue}-{MM-DD-HHMM})","+    # Define branch and file names with timestamp (format: plnd/review-{issue}-{MM-DD-HHMM})","     timestamp_suffix = format_branch_timestamp_suffix(time.now())","-    branch_name = f\"planned/review-{issue_number}{timestamp_suffix}\"","+    branch_name = f\"plnd/review-{issue_number}{timestamp_suffix}\"","     file_name = f\"PLAN-REVIEW-{issue_number}.md\""," ","     # Fetch origin/master, create branch, commit, and push"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"6256561c-3d6d-45ba-8002-29ef91e88559","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_011NjjLYhs4cc3X2rD2QF1nE","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also update the docstring of plan_create_review_branch:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":327,"cache_read_input_tokens":58903,"cache_creation":{"ephemeral_5m_input_tokens":327,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHUMECRixZ4b8kazruK","type":"assistant","uuid":"6792703e-81a7-4c3a-99bd-4c7a953584eb","timestamp":"2026-02-22T14:43:20.239Z"}
{"parentUuid":"6792703e-81a7-4c3a-99bd-4c7a953584eb","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_011NjjLYhs4cc3X2rD2QF1nE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0167cMQ5uZYdxpQZRLHpBw8n","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/commands/exec/scripts/plan_create_review_branch.py","offset":200,"limit":20},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":327,"cache_read_input_tokens":58903,"cache_creation":{"ephemeral_5m_input_tokens":327,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHUMECRixZ4b8kazruK","type":"assistant","uuid":"4707b724-1958-4e0c-84e7-fd5284ef7a35","timestamp":"2026-02-22T14:43:21.021Z"}
{"parentUuid":"4707b724-1958-4e0c-84e7-fd5284ef7a35","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0167cMQ5uZYdxpQZRLHpBw8n","type":"tool_result","content":"   200→@click.pass_context\n   201→def plan_create_review_branch(\n   202→    ctx: click.Context,\n   203→    issue_number: int,\n   204→) -> None:\n   205→    \"\"\"Create a plan review branch and push to remote.\n   206→\n   207→    Creates a branch planned/review-{issue}-{timestamp} from origin/master, writes plan\n   208→    to PLAN-REVIEW-{issue}.md, commits, and pushes to origin.\n   209→    \"\"\"\n   210→    git = require_git(ctx)\n   211→    github_issues = require_github_issues(ctx)\n   212→    time = require_time(ctx)\n   213→    repo_root = require_repo_root(ctx)\n   214→\n   215→    try:\n   216→        result = _create_review_branch_impl(\n   217→            git,\n   218→            github_issues=github_issues,\n   219→            time=time,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"12caccce-f4a0-4c0b-bd0d-5bdda0dcb03c","timestamp":"2026-02-22T14:43:21.050Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/commands/exec/scripts/plan_create_review_branch.py","content":"@click.pass_context\ndef plan_create_review_branch(\n    ctx: click.Context,\n    issue_number: int,\n) -> None:\n    \"\"\"Create a plan review branch and push to remote.\n\n    Creates a branch planned/review-{issue}-{timestamp} from origin/master, writes plan\n    to PLAN-REVIEW-{issue}.md, commits, and pushes to origin.\n    \"\"\"\n    git = require_git(ctx)\n    github_issues = require_github_issues(ctx)\n    time = require_time(ctx)\n    repo_root = require_repo_root(ctx)\n\n    try:\n        result = _create_review_branch_impl(\n            git,\n            github_issues=github_issues,\n            time=time,","numLines":20,"startLine":200,"totalLines":232}}}
{"parentUuid":"12caccce-f4a0-4c0b-bd0d-5bdda0dcb03c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Pb2sY1rQdcaMDfJ11FULyX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VN4kNHghnAedmL6ybBvF8v","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/commands/exec/scripts/plan_create_review_branch.py","old_string":"    Creates a branch planned/review-{issue}-{timestamp} from origin/master, writes plan","new_string":"    Creates a branch plnd/review-{issue}-{timestamp} from origin/master, writes plan"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":810,"cache_read_input_tokens":59230,"cache_creation":{"ephemeral_5m_input_tokens":810,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHUhni93S4EHqvtQR6y","type":"assistant","uuid":"f616c9f6-2179-4656-bb95-be3d64ea1302","timestamp":"2026-02-22T14:43:24.737Z"}
{"parentUuid":"f616c9f6-2179-4656-bb95-be3d64ea1302","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VN4kNHghnAedmL6ybBvF8v","type":"tool_result","content":"The file /home/runner/work/erk/erk/src/erk/cli/commands/exec/scripts/plan_create_review_branch.py has been updated successfully."}]},"uuid":"a1c33f5e-abf7-4306-9977-fe06dab05b40","timestamp":"2026-02-22T14:43:25.425Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/commands/exec/scripts/plan_create_review_branch.py","oldString":"    Creates a branch planned/review-{issue}-{timestamp} from origin/master, writes plan","newString":"    Creates a branch plnd/review-{issue}-{timestamp} from origin/master, writes plan","originalFile":"\"\"\"Create a plan review branch and push to remote.\n\nUsage:\n    erk exec plan-create-review-branch <issue-number>\n\nOutput:\n    JSON with branch name, file path, and plan title\n\nExit Codes:\n    0: Success\n    1: Error (issue not found, missing erk-plan label, no plan content, branch exists, or git error)\n\"\"\"\n\nimport json\nfrom dataclasses import asdict, dataclass\nfrom pathlib import Path\n\nimport click\n\nfrom erk.cli.ensure import UserFacingCliError\nfrom erk_shared.context.helpers import require_git, require_repo_root, require_time\nfrom erk_shared.context.helpers import require_issues as require_github_issues\nfrom erk_shared.gateway.git.abc import Git\nfrom erk_shared.gateway.git.branch_ops.types import BranchAlreadyExists\nfrom erk_shared.gateway.git.remote_ops.types import PushError\nfrom erk_shared.gateway.github.issues.abc import GitHubIssues\nfrom erk_shared.gateway.github.issues.types import IssueNotFound\nfrom erk_shared.gateway.github.metadata.plan_header import (\n    extract_plan_from_comment,\n    extract_plan_header_comment_id,\n)\nfrom erk_shared.gateway.time.abc import Time\nfrom erk_shared.naming import format_branch_timestamp_suffix\n\n\n@dataclass(frozen=True)\nclass PlanReviewBranchSuccess:\n    \"\"\"Success response for plan review branch creation.\"\"\"\n\n    success: bool\n    issue_number: int\n    branch: str\n    file_path: str\n    plan_title: str\n\n\n@dataclass(frozen=True)\nclass PlanReviewBranchError:\n    \"\"\"Error response for plan review branch creation.\"\"\"\n\n    success: bool\n    error: str\n    message: str\n\n\nclass PlanReviewBranchException(Exception):\n    \"\"\"Exception raised during plan review branch creation.\"\"\"\n\n    def __init__(self, error: str, message: str) -> None:\n        super().__init__(message)\n        self.error = error\n        self.message = message\n\n\ndef _fetch_plan_content(\n    github_issues: GitHubIssues,\n    repo_root: Path,\n    issue_number: int,\n) -> tuple[str, str]:\n    \"\"\"Fetch plan content from GitHub issue.\n\n    Args:\n        github_issues: GitHub issues gateway\n        repo_root: Repository root path\n        issue_number: Issue number to fetch\n\n    Returns:\n        Tuple of (plan_title, plan_content) on success\n\n    Raises:\n        PlanReviewBranchException: If issue not found, missing label, or no plan content\n    \"\"\"\n    # LBYL: Check if issue exists before fetching\n    if not github_issues.issue_exists(repo_root, issue_number):\n        raise PlanReviewBranchException(\n            error=\"issue_not_found\",\n            message=f\"Issue #{issue_number} not found\",\n        )\n\n    # Issue exists, safe to fetch\n    issue = github_issues.get_issue(repo_root, issue_number)\n    if isinstance(issue, IssueNotFound):\n        raise PlanReviewBranchException(\n            error=\"issue_not_found\",\n            message=f\"Issue #{issue_number} not found\",\n        )\n\n    # Validate erk-plan label\n    if \"erk-plan\" not in issue.labels:\n        raise PlanReviewBranchException(\n            error=\"missing_erk_plan_label\",\n            message=f\"Issue #{issue_number} does not have the erk-plan label\",\n        )\n\n    # Extract plan comment ID from metadata\n    plan_comment_id = extract_plan_header_comment_id(issue.body)\n    if plan_comment_id is None:\n        raise PlanReviewBranchException(\n            error=\"no_plan_content\",\n            message=f\"Issue #{issue_number} has no plan_comment_id in metadata\",\n        )\n\n    # Fetch comments\n    comments = github_issues.get_issue_comments_with_urls(repo_root, issue_number)\n\n    if not comments:\n        raise PlanReviewBranchException(\n            error=\"no_plan_content\",\n            message=f\"Issue #{issue_number} has no comments\",\n        )\n\n    # Find the comment with the plan content\n    for comment in comments:\n        if comment.id == plan_comment_id:\n            content = extract_plan_from_comment(comment.body)\n            if content:\n                return (issue.title, content)\n\n    raise PlanReviewBranchException(\n        error=\"no_plan_content\",\n        message=f\"Issue #{issue_number} comment {plan_comment_id} has no plan markers\",\n    )\n\n\ndef _create_review_branch_impl(\n    git: Git,\n    *,\n    github_issues: GitHubIssues,\n    time: Time,\n    repo_root: Path,\n    issue_number: int,\n) -> PlanReviewBranchSuccess:\n    \"\"\"Create a plan review branch and push to remote.\n\n    Args:\n        git: Git gateway\n        github_issues: GitHub issues gateway\n        time: Time gateway for timestamps\n        repo_root: Repository root path\n        issue_number: Issue number to create review branch for\n\n    Returns:\n        PlanReviewBranchSuccess on success\n\n    Raises:\n        PlanReviewBranchException: If plan content cannot be fetched or validated\n    \"\"\"\n    # Fetch plan content (raises PlanReviewBranchException on failure)\n    plan_title, plan_content = _fetch_plan_content(github_issues, repo_root, issue_number)\n\n    # Define branch and file names with timestamp (format: plnd/review-{issue}-{MM-DD-HHMM})\n    timestamp_suffix = format_branch_timestamp_suffix(time.now())\n    branch_name = f\"plnd/review-{issue_number}{timestamp_suffix}\"\n    file_name = f\"PLAN-REVIEW-{issue_number}.md\"\n\n    # Fetch origin/master, create branch, commit, and push\n    # These operations let exceptions escape as they represent invariant violations\n    # if they fail (network/disk/auth issues are exceptional, not expected states)\n    git.remote.fetch_branch(repo_root, \"origin\", \"master\")\n    create_result = git.branch.create_branch(repo_root, branch_name, \"origin/master\", force=False)\n    if isinstance(create_result, BranchAlreadyExists):\n        raise UserFacingCliError(create_result.message)\n    git.branch.checkout_branch(repo_root, branch_name)\n\n    # Write plan file at repo root\n    file_path = repo_root / file_name\n    file_path.write_text(plan_content, encoding=\"utf-8\")\n\n    # Stage, commit, and push\n    git.commit.stage_files(repo_root, [file_name])\n    commit_message = f\"Add plan #{issue_number} for review\"\n    git.commit.commit(repo_root, commit_message)\n    push_result = git.remote.push_to_remote(\n        repo_root, \"origin\", branch_name, set_upstream=True, force=False\n    )\n    if isinstance(push_result, PushError):\n        raise UserFacingCliError(push_result.message)\n\n    return PlanReviewBranchSuccess(\n        success=True,\n        issue_number=issue_number,\n        branch=branch_name,\n        file_path=file_name,\n        plan_title=plan_title,\n    )\n\n\n@click.command(name=\"plan-create-review-branch\")\n@click.argument(\"issue_number\", type=int)\n@click.pass_context\ndef plan_create_review_branch(\n    ctx: click.Context,\n    issue_number: int,\n) -> None:\n    \"\"\"Create a plan review branch and push to remote.\n\n    Creates a branch planned/review-{issue}-{timestamp} from origin/master, writes plan\n    to PLAN-REVIEW-{issue}.md, commits, and pushes to origin.\n    \"\"\"\n    git = require_git(ctx)\n    github_issues = require_github_issues(ctx)\n    time = require_time(ctx)\n    repo_root = require_repo_root(ctx)\n\n    try:\n        result = _create_review_branch_impl(\n            git,\n            github_issues=github_issues,\n            time=time,\n            repo_root=repo_root,\n            issue_number=issue_number,\n        )\n        click.echo(json.dumps(asdict(result)))\n    except PlanReviewBranchException as e:\n        error_response = PlanReviewBranchError(\n            success=False,\n            error=e.error,\n            message=e.message,\n        )\n        click.echo(json.dumps(asdict(error_response)))\n        raise SystemExit(1) from None\n","structuredPatch":[{"oldStart":204,"oldLines":7,"newStart":204,"newLines":7,"lines":[" ) -> None:","     \"\"\"Create a plan review branch and push to remote."," ","-    Creates a branch planned/review-{issue}-{timestamp} from origin/master, writes plan","+    Creates a branch plnd/review-{issue}-{timestamp} from origin/master, writes plan","     to PLAN-REVIEW-{issue}.md, commits, and pushes to origin.","     \"\"\"","     git = require_git(ctx)"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"a1c33f5e-abf7-4306-9977-fe06dab05b40","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01TmuziE9zRuCCpxXeMzjMdD","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the one_shot_dispatch.py comments:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":219,"cache_read_input_tokens":60040,"cache_creation":{"ephemeral_5m_input_tokens":219,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHV2VbwKL6bcmJHAD3k","type":"assistant","uuid":"5f3e40fd-60ee-4c61-9b97-4411f0f581f0","timestamp":"2026-02-22T14:43:27.485Z"}
{"parentUuid":"5f3e40fd-60ee-4c61-9b97-4411f0f581f0","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01TmuziE9zRuCCpxXeMzjMdD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LYBpzaiqk7kqnnLLR12qj8","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/commands/one_shot_dispatch.py","old_string":"    # draft_pr backend: skip skeleton issue, use planned/ branch naming, PR is the plan","new_string":"    # draft_pr backend: skip skeleton issue, use plnd/ branch naming, PR is the plan"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":219,"cache_read_input_tokens":60040,"cache_creation":{"ephemeral_5m_input_tokens":219,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHV2VbwKL6bcmJHAD3k","type":"assistant","uuid":"6e5ac614-ab10-4151-8f91-0bf917542b02","timestamp":"2026-02-22T14:43:29.320Z"}
{"parentUuid":"6e5ac614-ab10-4151-8f91-0bf917542b02","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LYBpzaiqk7kqnnLLR12qj8","type":"tool_result","content":"The file /home/runner/work/erk/erk/src/erk/cli/commands/one_shot_dispatch.py has been updated successfully."}]},"uuid":"4e96902e-ccef-4acb-8812-e3133424b840","timestamp":"2026-02-22T14:43:29.999Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/commands/one_shot_dispatch.py","oldString":"    # draft_pr backend: skip skeleton issue, use planned/ branch naming, PR is the plan","newString":"    # draft_pr backend: skip skeleton issue, use plnd/ branch naming, PR is the plan","originalFile":"\"\"\"Shared dispatch logic for one-shot autonomous execution.\n\nExtracts the branch-create/push/PR/workflow-trigger sequence into reusable\npieces so both `erk one-shot` and `erk objective plan --one-shot` can\ndispatch tasks through the same CI workflow.\n\"\"\"\n\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import UTC\n\nimport click\n\nfrom erk.cli.commands.pr.metadata_helpers import write_dispatch_metadata\nfrom erk.cli.ensure import Ensure\nfrom erk.core.context import ErkContext, NoRepoSentinel, RepoContext\nfrom erk_shared.gateway.git.remote_ops.types import PushError\nfrom erk_shared.gateway.github.metadata.core import (\n    create_submission_queued_block,\n    render_erk_issue_event,\n)\nfrom erk_shared.gateway.github.metadata.plan_header import format_plan_header_body\nfrom erk_shared.gateway.github.parsing import construct_workflow_run_url\nfrom erk_shared.gateway.github.plan_issues import create_plan_issue\nfrom erk_shared.gateway.github.pr_footer import build_pr_body_footer\nfrom erk_shared.gateway.time.abc import Time\nfrom erk_shared.naming import (\n    format_branch_timestamp_suffix,\n    generate_draft_pr_branch_name,\n    generate_issue_branch_name,\n    sanitize_worktree_name,\n)\nfrom erk_shared.output.output import user_output\nfrom erk_shared.plan_store.draft_pr_lifecycle import build_plan_stage_body\n\nlogger = logging.getLogger(__name__)\n\nONE_SHOT_WORKFLOW = \"one-shot.yml\"\n\n\n@dataclass(frozen=True)\nclass OneShotDispatchParams:\n    \"\"\"Parameters for dispatching a one-shot workflow.\"\"\"\n\n    prompt: str\n    model: str | None\n    extra_workflow_inputs: dict[str, str]\n\n\n@dataclass(frozen=True)\nclass OneShotDispatchResult:\n    \"\"\"Result of a successful one-shot dispatch.\"\"\"\n\n    pr_number: int\n    run_id: str\n    branch_name: str\n\n\ndef generate_branch_name(\n    prompt: str,\n    *,\n    time: Time,\n    plan_issue_number: int | None,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate a branch name from the prompt.\n\n    Format: P{N}-{slug}-{MM-DD-HHMM} (with optional O{M} objective encoding)\n    when plan_issue_number is provided, otherwise oneshot-{slug}-{MM-DD-HHMM}.\n\n    Args:\n        prompt: The task description\n        time: Time gateway for deterministic timestamps\n        plan_issue_number: If provided, delegate to generate_issue_branch_name\n        objective_id: If provided with plan_issue_number, encode O{N} in branch name\n\n    Returns:\n        Branch name string\n    \"\"\"\n    if plan_issue_number is not None:\n        return generate_issue_branch_name(\n            plan_issue_number, prompt, time.now(), objective_id=objective_id\n        )\n    slug = sanitize_worktree_name(prompt)\n    prefix = \"oneshot-\"\n    max_slug_len = 31 - len(prefix)\n    if len(slug) > max_slug_len:\n        slug = slug[:max_slug_len].rstrip(\"-\")\n    timestamp = format_branch_timestamp_suffix(time.now())\n    return f\"{prefix}{slug}{timestamp}\"\n\n\ndef dispatch_one_shot(\n    ctx: ErkContext,\n    *,\n    params: OneShotDispatchParams,\n    dry_run: bool,\n) -> OneShotDispatchResult | None:\n    \"\"\"Execute the full dispatch sequence for a one-shot workflow.\n\n    Creates branch, commits prompt file directly to branch (no checkout),\n    pushes, creates draft PR, and triggers workflow. In dry-run mode,\n    prints what would happen without executing.\n\n    Args:\n        ctx: Erk context with git/github gateways\n        params: Dispatch parameters\n        dry_run: If True, print preview without executing\n\n    Returns:\n        OneShotDispatchResult with pr_number, run_id, branch_name,\n        or None in dry-run mode\n    \"\"\"\n    # Validate we're in a git repo\n    Ensure.invariant(\n        not isinstance(ctx.repo, NoRepoSentinel),\n        \"Not in a git repository\",\n    )\n    assert not isinstance(ctx.repo, NoRepoSentinel)\n    repo: RepoContext = ctx.repo\n\n    # Validate GitHub authentication\n    Ensure.gh_authenticated(ctx)\n\n    # Get GitHub username\n    _, username, _ = ctx.github.check_auth_status()\n    submitted_by = username or \"unknown\"\n\n    # Detect trunk branch\n    trunk = ctx.git.branch.detect_trunk_branch(repo.root)\n\n    # Build PR title\n    max_title_len = 60\n    suffix = \"...\" if len(params.prompt) > max_title_len else \"\"\n    pr_title = f\"One-shot: {params.prompt[:max_title_len]}{suffix}\"\n\n    if dry_run:\n        # In dry-run, show preview without creating skeleton issue\n        branch_name = generate_branch_name(\n            params.prompt,\n            time=ctx.time,\n            plan_issue_number=None,\n            objective_id=None,\n        )\n        user_output(\n            click.style(\"Dry-run mode:\", fg=\"cyan\", bold=True) + \" No changes will be made\\n\"\n        )\n        user_output(f\"Prompt: {params.prompt}\")\n        user_output(f\"Branch: {branch_name}\")\n        user_output(f\"PR title: {pr_title}\")\n        user_output(f\"Base branch: {trunk}\")\n        user_output(f\"Submitted by: {submitted_by}\")\n        if params.model is not None:\n            user_output(f\"Model: {params.model}\")\n        user_output(f\"Workflow: {ONE_SHOT_WORKFLOW}\")\n        if params.extra_workflow_inputs:\n            for key, value in params.extra_workflow_inputs.items():\n                user_output(f\"Extra input: {key}={value}\")\n        return None\n\n    objective_issue_str = params.extra_workflow_inputs.get(\"objective_issue\")\n    objective_id = int(objective_issue_str) if objective_issue_str else None\n\n    is_draft_pr = ctx.plan_backend.get_provider_name() == \"github-draft-pr\"\n\n    # --- Backend-conditional entity creation ---\n    # github backend: create skeleton issue first for P<N>- branch naming\n    # draft_pr backend: skip skeleton issue, use planned/ branch naming, PR is the plan\n    plan_issue_number: int | None = None\n    if not is_draft_pr:\n        skeleton_plan_content = (\n            f\"_One-shot: plan content will be populated by one-shot workflow._\\n\\n\"\n            f\"**Prompt:** {params.prompt}\"\n        )\n        skeleton_result = create_plan_issue(\n            github_issues=ctx.github.issues,\n            repo_root=repo.root,\n            plan_content=skeleton_plan_content,\n            title=f\"One-shot: {params.prompt[:max_title_len]}{suffix}\",\n            extra_labels=None,\n            title_tag=None,\n            source_repo=None,\n            objective_id=objective_id,\n            created_from_session=None,\n            created_from_workflow_run_url=None,\n            learned_from_issue=None,\n            lifecycle_stage=\"prompted\",\n        )\n        plan_issue_number = skeleton_result.issue_number\n\n    # Generate branch name\n    if is_draft_pr:\n        # draft_pr: planned/ prefix (no issue number needed)\n        branch_name = generate_draft_pr_branch_name(\n            params.prompt,\n            ctx.time.now(),\n            objective_id=objective_id,\n        )\n    else:\n        # github: P<N>- prefix using skeleton issue number\n        branch_name = generate_branch_name(\n            params.prompt,\n            time=ctx.time,\n            plan_issue_number=plan_issue_number,\n            objective_id=objective_id,\n        )\n\n    # Save current branch for restoration after workflow trigger\n    original_branch = ctx.git.branch.get_current_branch(repo.root)\n    if original_branch is None:\n        user_output(\n            click.style(\"Error: \", fg=\"red\")\n            + \"Not on a branch (detached HEAD state). Cannot submit from here.\"\n        )\n        raise SystemExit(1)\n\n    # Create branch from trunk\n    user_output(\"Creating branch...\")\n    ctx.git.branch.create_branch(repo.root, branch_name, trunk, force=False)\n\n    # Write prompt to .worker-impl/prompt.md directly on the branch (no checkout).\n    # (.impl/ is in .gitignore; .worker-impl/ is the committable counterpart\n    # that the remote workflow copies into .impl/)\n    ctx.git.commit.commit_files_to_branch(\n        repo.root,\n        branch=branch_name,\n        files={\".worker-impl/prompt.md\": params.prompt + \"\\n\"},\n        message=f\"One-shot: {params.prompt[:60]}\",\n    )\n\n    # Push to remote\n    user_output(\"Pushing to remote...\")\n    push_result = ctx.git.remote.push_to_remote(\n        repo.root, \"origin\", branch_name, set_upstream=True, force=False\n    )\n    if isinstance(push_result, PushError):\n        Ensure.invariant(False, f\"Failed to push branch: {push_result.message}\")\n\n    # --- Create draft PR ---\n    user_output(\"Creating draft PR...\")\n    if is_draft_pr:\n        # draft_pr: create PR with plan-header metadata block\n        _, username_for_header, _ = ctx.github.check_auth_status()\n        created_at = ctx.time.now().replace(tzinfo=UTC).isoformat()\n        metadata_body = format_plan_header_body(\n            created_at=created_at,\n            created_by=username_for_header or \"unknown\",\n            worktree_name=None,\n            branch_name=branch_name,\n            plan_comment_id=None,\n            last_dispatched_run_id=None,\n            last_dispatched_node_id=None,\n            last_dispatched_at=None,\n            last_local_impl_at=None,\n            last_local_impl_event=None,\n            last_local_impl_session=None,\n            last_local_impl_user=None,\n            last_remote_impl_at=None,\n            last_remote_impl_run_id=None,\n            last_remote_impl_session_id=None,\n            source_repo=None,\n            objective_issue=objective_id,\n            created_from_session=None,\n            created_from_workflow_run_url=None,\n            last_learn_session=None,\n            last_learn_at=None,\n            learn_status=None,\n            learn_plan_issue=None,\n            learn_plan_pr=None,\n            learned_from_issue=None,\n            lifecycle_stage=\"prompted\",\n        )\n        placeholder_content = (\n            f\"_One-shot: plan content will be populated by one-shot workflow._\\n\\n\"\n            f\"**Prompt:** {params.prompt}\"\n        )\n        pr_body_initial = build_plan_stage_body(metadata_body, placeholder_content)\n        pr_number = ctx.github.create_pr(\n            repo.root,\n            branch_name,\n            pr_title,\n            pr_body_initial,\n            trunk,\n            draft=True,\n        )\n        # Add footer now that we have the PR number.\n        # No issue_number — draft PR IS the plan, Closes #N would be self-referential.\n        footer = build_pr_body_footer(pr_number, issue_number=None, plans_repo=None)\n        ctx.github.update_pr_body(repo.root, pr_number, pr_body_initial + footer)\n        # Add erk-plan label\n        ctx.github.add_label_to_pr(repo.root, pr_number, \"erk-plan\")\n\n        # Key: set plan_issue_number = pr_number so downstream code\n        # (workflow inputs, metadata writing, comments) targets the PR\n        plan_issue_number = pr_number\n    else:\n        # github: create plain draft PR with closing reference\n        closing_ref = \"\"\n        if plan_issue_number is not None:\n            plans_repo = ctx.local_config.plans_repo\n            closing_ref = (\n                f\"\\n\\nCloses {plans_repo}#{plan_issue_number}\"\n                if plans_repo\n                else f\"\\n\\nCloses #{plan_issue_number}\"\n            )\n        pr_number = ctx.github.create_pr(\n            repo.root,\n            branch_name,\n            pr_title,\n            f\"Autonomous one-shot execution.\\n\\n**Prompt:** {params.prompt}{closing_ref}\",\n            trunk,\n            draft=True,\n        )\n    user_output(f\"Created draft PR #{pr_number}\")\n\n    # Build workflow inputs\n    # Truncate prompt for workflow input (full text is in .worker-impl/prompt.md)\n    max_input_len = 500\n    truncated_prompt = params.prompt[:max_input_len]\n    if len(params.prompt) > max_input_len:\n        truncated_prompt += \"... (full prompt committed to .worker-impl/prompt.md)\"\n\n    inputs: dict[str, str] = {\n        \"prompt\": truncated_prompt,\n        \"branch_name\": branch_name,\n        \"pr_number\": str(pr_number),\n        \"submitted_by\": submitted_by,\n        \"plan_backend\": \"draft_pr\" if is_draft_pr else \"github\",\n    }\n    if params.model is not None:\n        inputs[\"model_name\"] = params.model\n    if plan_issue_number is not None:\n        inputs[\"plan_issue_number\"] = str(plan_issue_number)\n\n    # Merge extra workflow inputs\n    inputs.update(params.extra_workflow_inputs)\n\n    # Trigger workflow\n    user_output(\"Triggering one-shot workflow...\")\n    run_id = ctx.github.trigger_workflow(\n        repo_root=repo.root,\n        workflow=ONE_SHOT_WORKFLOW,\n        inputs=inputs,\n    )\n\n    # Compute run_url and queued_at for use in PR body update, metadata, and comment\n    run_url: str | None = None\n    if repo.github is not None:\n        run_url = construct_workflow_run_url(repo.github.owner, repo.github.repo, run_id)\n    queued_at = ctx.time.now().replace(tzinfo=UTC).isoformat()\n\n    # Update PR body with workflow run link (best-effort)\n    # For github backend: rewrite with prompt + run link + closing ref\n    # For draft_pr backend: skip — metadata block body should not be overwritten\n    if not is_draft_pr and run_url is not None:\n        try:\n            closing_ref = \"\"\n            if plan_issue_number is not None:\n                plans_repo = ctx.local_config.plans_repo\n                closing_ref = (\n                    f\"\\n\\nCloses {plans_repo}#{plan_issue_number}\"\n                    if plans_repo\n                    else f\"\\n\\nCloses #{plan_issue_number}\"\n                )\n            pr_body = (\n                f\"Autonomous one-shot execution.\\n\\n\"\n                f\"**Prompt:** {params.prompt}\\n\\n\"\n                f\"**Workflow run:** {run_url}{closing_ref}\"\n            )\n            ctx.github.update_pr_body(repo.root, pr_number, pr_body)\n        except Exception as e:\n            logger.warning(\"Failed to update stub PR body with workflow run link: %s\", e)\n\n    # Write dispatch metadata and post queued comment (best-effort)\n    if plan_issue_number is not None:\n        # Write dispatch metadata to plan entity (issue for github, PR for draft_pr)\n        try:\n            write_dispatch_metadata(\n                plan_backend=ctx.plan_backend,\n                github=ctx.github,\n                repo_root=repo.root,\n                issue_number=plan_issue_number,\n                run_id=run_id,\n                dispatched_at=queued_at,\n            )\n            user_output(click.style(\"\\u2713\", fg=\"green\") + \" Dispatch metadata written\")\n        except Exception as e:\n            user_output(\n                click.style(\"Warning: \", fg=\"yellow\") + f\"Failed to update dispatch metadata: {e}\"\n            )\n\n        # Post queued event comment to plan entity\n        try:\n            metadata_block = create_submission_queued_block(\n                queued_at=queued_at,\n                submitted_by=submitted_by,\n                issue_number=plan_issue_number,\n                validation_results={\"issue_is_open\": True, \"has_erk_plan_label\": True},\n                expected_workflow=\"one-shot\",\n            )\n            comment_body = render_erk_issue_event(\n                title=\"\\U0001f504 One-Shot Dispatched\",\n                metadata=metadata_block,\n                description=(\n                    f\"One-shot submitted by **{submitted_by}** at {queued_at}.\\n\\n\"\n                    f\"**Workflow run:** {run_url or 'N/A'}\\n\\n\"\n                    f\"**Prompt:** {params.prompt}\"\n                ),\n            )\n            ctx.issues.add_comment(repo.root, plan_issue_number, comment_body)\n            user_output(click.style(\"\\u2713\", fg=\"green\") + \" Queued event comment posted\")\n        except Exception as e:\n            user_output(\n                click.style(\"Warning: \", fg=\"yellow\") + f\"Failed to post queued comment: {e}\"\n            )\n\n    # Display results\n    user_output(\"\")\n    user_output(click.style(\"Done!\", fg=\"green\", bold=True))\n    if repo.github is not None and run_url is not None:\n        pr_url = f\"https://github.com/{repo.github.owner}/{repo.github.repo}/pull/{pr_number}\"\n        user_output(f\"PR: {click.style(pr_url, fg='cyan')}\")\n        user_output(f\"Run: {click.style(run_url, fg='cyan')}\")\n    else:\n        user_output(f\"PR #{pr_number} created, workflow run {run_id} triggered\")\n\n    return OneShotDispatchResult(\n        pr_number=pr_number,\n        run_id=run_id,\n        branch_name=branch_name,\n    )\n","structuredPatch":[{"oldStart":165,"oldLines":7,"newStart":165,"newLines":7,"lines":[" ","     # --- Backend-conditional entity creation ---","     # github backend: create skeleton issue first for P<N>- branch naming","-    # draft_pr backend: skip skeleton issue, use planned/ branch naming, PR is the plan","+    # draft_pr backend: skip skeleton issue, use plnd/ branch naming, PR is the plan","     plan_issue_number: int | None = None","     if not is_draft_pr:","         skeleton_plan_content = ("]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"4e96902e-ccef-4acb-8812-e3133424b840","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01QeVkDS8AiNGYFKiZeFVW48","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AMd9o99aXZ85g4RfknbCCy","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/commands/one_shot_dispatch.py","old_string":"        # draft_pr: planned/ prefix (no issue number needed)","new_string":"        # draft_pr: plnd/ prefix (no issue number needed)"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":558,"cache_read_input_tokens":60259,"cache_creation":{"ephemeral_5m_input_tokens":558,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHVN36PLyKJYqopjUpr","type":"assistant","uuid":"6ba854e2-504b-499f-b993-8d31308ea5f7","timestamp":"2026-02-22T14:43:33.165Z"}
{"parentUuid":"6ba854e2-504b-499f-b993-8d31308ea5f7","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AMd9o99aXZ85g4RfknbCCy","type":"tool_result","content":"The file /home/runner/work/erk/erk/src/erk/cli/commands/one_shot_dispatch.py has been updated successfully."}]},"uuid":"a3e6821b-1054-4952-97ee-20bcbbb20dc1","timestamp":"2026-02-22T14:43:33.846Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/commands/one_shot_dispatch.py","oldString":"        # draft_pr: planned/ prefix (no issue number needed)","newString":"        # draft_pr: plnd/ prefix (no issue number needed)","originalFile":"\"\"\"Shared dispatch logic for one-shot autonomous execution.\n\nExtracts the branch-create/push/PR/workflow-trigger sequence into reusable\npieces so both `erk one-shot` and `erk objective plan --one-shot` can\ndispatch tasks through the same CI workflow.\n\"\"\"\n\nimport logging\nfrom dataclasses import dataclass\nfrom datetime import UTC\n\nimport click\n\nfrom erk.cli.commands.pr.metadata_helpers import write_dispatch_metadata\nfrom erk.cli.ensure import Ensure\nfrom erk.core.context import ErkContext, NoRepoSentinel, RepoContext\nfrom erk_shared.gateway.git.remote_ops.types import PushError\nfrom erk_shared.gateway.github.metadata.core import (\n    create_submission_queued_block,\n    render_erk_issue_event,\n)\nfrom erk_shared.gateway.github.metadata.plan_header import format_plan_header_body\nfrom erk_shared.gateway.github.parsing import construct_workflow_run_url\nfrom erk_shared.gateway.github.plan_issues import create_plan_issue\nfrom erk_shared.gateway.github.pr_footer import build_pr_body_footer\nfrom erk_shared.gateway.time.abc import Time\nfrom erk_shared.naming import (\n    format_branch_timestamp_suffix,\n    generate_draft_pr_branch_name,\n    generate_issue_branch_name,\n    sanitize_worktree_name,\n)\nfrom erk_shared.output.output import user_output\nfrom erk_shared.plan_store.draft_pr_lifecycle import build_plan_stage_body\n\nlogger = logging.getLogger(__name__)\n\nONE_SHOT_WORKFLOW = \"one-shot.yml\"\n\n\n@dataclass(frozen=True)\nclass OneShotDispatchParams:\n    \"\"\"Parameters for dispatching a one-shot workflow.\"\"\"\n\n    prompt: str\n    model: str | None\n    extra_workflow_inputs: dict[str, str]\n\n\n@dataclass(frozen=True)\nclass OneShotDispatchResult:\n    \"\"\"Result of a successful one-shot dispatch.\"\"\"\n\n    pr_number: int\n    run_id: str\n    branch_name: str\n\n\ndef generate_branch_name(\n    prompt: str,\n    *,\n    time: Time,\n    plan_issue_number: int | None,\n    objective_id: int | None,\n) -> str:\n    \"\"\"Generate a branch name from the prompt.\n\n    Format: P{N}-{slug}-{MM-DD-HHMM} (with optional O{M} objective encoding)\n    when plan_issue_number is provided, otherwise oneshot-{slug}-{MM-DD-HHMM}.\n\n    Args:\n        prompt: The task description\n        time: Time gateway for deterministic timestamps\n        plan_issue_number: If provided, delegate to generate_issue_branch_name\n        objective_id: If provided with plan_issue_number, encode O{N} in branch name\n\n    Returns:\n        Branch name string\n    \"\"\"\n    if plan_issue_number is not None:\n        return generate_issue_branch_name(\n            plan_issue_number, prompt, time.now(), objective_id=objective_id\n        )\n    slug = sanitize_worktree_name(prompt)\n    prefix = \"oneshot-\"\n    max_slug_len = 31 - len(prefix)\n    if len(slug) > max_slug_len:\n        slug = slug[:max_slug_len].rstrip(\"-\")\n    timestamp = format_branch_timestamp_suffix(time.now())\n    return f\"{prefix}{slug}{timestamp}\"\n\n\ndef dispatch_one_shot(\n    ctx: ErkContext,\n    *,\n    params: OneShotDispatchParams,\n    dry_run: bool,\n) -> OneShotDispatchResult | None:\n    \"\"\"Execute the full dispatch sequence for a one-shot workflow.\n\n    Creates branch, commits prompt file directly to branch (no checkout),\n    pushes, creates draft PR, and triggers workflow. In dry-run mode,\n    prints what would happen without executing.\n\n    Args:\n        ctx: Erk context with git/github gateways\n        params: Dispatch parameters\n        dry_run: If True, print preview without executing\n\n    Returns:\n        OneShotDispatchResult with pr_number, run_id, branch_name,\n        or None in dry-run mode\n    \"\"\"\n    # Validate we're in a git repo\n    Ensure.invariant(\n        not isinstance(ctx.repo, NoRepoSentinel),\n        \"Not in a git repository\",\n    )\n    assert not isinstance(ctx.repo, NoRepoSentinel)\n    repo: RepoContext = ctx.repo\n\n    # Validate GitHub authentication\n    Ensure.gh_authenticated(ctx)\n\n    # Get GitHub username\n    _, username, _ = ctx.github.check_auth_status()\n    submitted_by = username or \"unknown\"\n\n    # Detect trunk branch\n    trunk = ctx.git.branch.detect_trunk_branch(repo.root)\n\n    # Build PR title\n    max_title_len = 60\n    suffix = \"...\" if len(params.prompt) > max_title_len else \"\"\n    pr_title = f\"One-shot: {params.prompt[:max_title_len]}{suffix}\"\n\n    if dry_run:\n        # In dry-run, show preview without creating skeleton issue\n        branch_name = generate_branch_name(\n            params.prompt,\n            time=ctx.time,\n            plan_issue_number=None,\n            objective_id=None,\n        )\n        user_output(\n            click.style(\"Dry-run mode:\", fg=\"cyan\", bold=True) + \" No changes will be made\\n\"\n        )\n        user_output(f\"Prompt: {params.prompt}\")\n        user_output(f\"Branch: {branch_name}\")\n        user_output(f\"PR title: {pr_title}\")\n        user_output(f\"Base branch: {trunk}\")\n        user_output(f\"Submitted by: {submitted_by}\")\n        if params.model is not None:\n            user_output(f\"Model: {params.model}\")\n        user_output(f\"Workflow: {ONE_SHOT_WORKFLOW}\")\n        if params.extra_workflow_inputs:\n            for key, value in params.extra_workflow_inputs.items():\n                user_output(f\"Extra input: {key}={value}\")\n        return None\n\n    objective_issue_str = params.extra_workflow_inputs.get(\"objective_issue\")\n    objective_id = int(objective_issue_str) if objective_issue_str else None\n\n    is_draft_pr = ctx.plan_backend.get_provider_name() == \"github-draft-pr\"\n\n    # --- Backend-conditional entity creation ---\n    # github backend: create skeleton issue first for P<N>- branch naming\n    # draft_pr backend: skip skeleton issue, use plnd/ branch naming, PR is the plan\n    plan_issue_number: int | None = None\n    if not is_draft_pr:\n        skeleton_plan_content = (\n            f\"_One-shot: plan content will be populated by one-shot workflow._\\n\\n\"\n            f\"**Prompt:** {params.prompt}\"\n        )\n        skeleton_result = create_plan_issue(\n            github_issues=ctx.github.issues,\n            repo_root=repo.root,\n            plan_content=skeleton_plan_content,\n            title=f\"One-shot: {params.prompt[:max_title_len]}{suffix}\",\n            extra_labels=None,\n            title_tag=None,\n            source_repo=None,\n            objective_id=objective_id,\n            created_from_session=None,\n            created_from_workflow_run_url=None,\n            learned_from_issue=None,\n            lifecycle_stage=\"prompted\",\n        )\n        plan_issue_number = skeleton_result.issue_number\n\n    # Generate branch name\n    if is_draft_pr:\n        # draft_pr: planned/ prefix (no issue number needed)\n        branch_name = generate_draft_pr_branch_name(\n            params.prompt,\n            ctx.time.now(),\n            objective_id=objective_id,\n        )\n    else:\n        # github: P<N>- prefix using skeleton issue number\n        branch_name = generate_branch_name(\n            params.prompt,\n            time=ctx.time,\n            plan_issue_number=plan_issue_number,\n            objective_id=objective_id,\n        )\n\n    # Save current branch for restoration after workflow trigger\n    original_branch = ctx.git.branch.get_current_branch(repo.root)\n    if original_branch is None:\n        user_output(\n            click.style(\"Error: \", fg=\"red\")\n            + \"Not on a branch (detached HEAD state). Cannot submit from here.\"\n        )\n        raise SystemExit(1)\n\n    # Create branch from trunk\n    user_output(\"Creating branch...\")\n    ctx.git.branch.create_branch(repo.root, branch_name, trunk, force=False)\n\n    # Write prompt to .worker-impl/prompt.md directly on the branch (no checkout).\n    # (.impl/ is in .gitignore; .worker-impl/ is the committable counterpart\n    # that the remote workflow copies into .impl/)\n    ctx.git.commit.commit_files_to_branch(\n        repo.root,\n        branch=branch_name,\n        files={\".worker-impl/prompt.md\": params.prompt + \"\\n\"},\n        message=f\"One-shot: {params.prompt[:60]}\",\n    )\n\n    # Push to remote\n    user_output(\"Pushing to remote...\")\n    push_result = ctx.git.remote.push_to_remote(\n        repo.root, \"origin\", branch_name, set_upstream=True, force=False\n    )\n    if isinstance(push_result, PushError):\n        Ensure.invariant(False, f\"Failed to push branch: {push_result.message}\")\n\n    # --- Create draft PR ---\n    user_output(\"Creating draft PR...\")\n    if is_draft_pr:\n        # draft_pr: create PR with plan-header metadata block\n        _, username_for_header, _ = ctx.github.check_auth_status()\n        created_at = ctx.time.now().replace(tzinfo=UTC).isoformat()\n        metadata_body = format_plan_header_body(\n            created_at=created_at,\n            created_by=username_for_header or \"unknown\",\n            worktree_name=None,\n            branch_name=branch_name,\n            plan_comment_id=None,\n            last_dispatched_run_id=None,\n            last_dispatched_node_id=None,\n            last_dispatched_at=None,\n            last_local_impl_at=None,\n            last_local_impl_event=None,\n            last_local_impl_session=None,\n            last_local_impl_user=None,\n            last_remote_impl_at=None,\n            last_remote_impl_run_id=None,\n            last_remote_impl_session_id=None,\n            source_repo=None,\n            objective_issue=objective_id,\n            created_from_session=None,\n            created_from_workflow_run_url=None,\n            last_learn_session=None,\n            last_learn_at=None,\n            learn_status=None,\n            learn_plan_issue=None,\n            learn_plan_pr=None,\n            learned_from_issue=None,\n            lifecycle_stage=\"prompted\",\n        )\n        placeholder_content = (\n            f\"_One-shot: plan content will be populated by one-shot workflow._\\n\\n\"\n            f\"**Prompt:** {params.prompt}\"\n        )\n        pr_body_initial = build_plan_stage_body(metadata_body, placeholder_content)\n        pr_number = ctx.github.create_pr(\n            repo.root,\n            branch_name,\n            pr_title,\n            pr_body_initial,\n            trunk,\n            draft=True,\n        )\n        # Add footer now that we have the PR number.\n        # No issue_number — draft PR IS the plan, Closes #N would be self-referential.\n        footer = build_pr_body_footer(pr_number, issue_number=None, plans_repo=None)\n        ctx.github.update_pr_body(repo.root, pr_number, pr_body_initial + footer)\n        # Add erk-plan label\n        ctx.github.add_label_to_pr(repo.root, pr_number, \"erk-plan\")\n\n        # Key: set plan_issue_number = pr_number so downstream code\n        # (workflow inputs, metadata writing, comments) targets the PR\n        plan_issue_number = pr_number\n    else:\n        # github: create plain draft PR with closing reference\n        closing_ref = \"\"\n        if plan_issue_number is not None:\n            plans_repo = ctx.local_config.plans_repo\n            closing_ref = (\n                f\"\\n\\nCloses {plans_repo}#{plan_issue_number}\"\n                if plans_repo\n                else f\"\\n\\nCloses #{plan_issue_number}\"\n            )\n        pr_number = ctx.github.create_pr(\n            repo.root,\n            branch_name,\n            pr_title,\n            f\"Autonomous one-shot execution.\\n\\n**Prompt:** {params.prompt}{closing_ref}\",\n            trunk,\n            draft=True,\n        )\n    user_output(f\"Created draft PR #{pr_number}\")\n\n    # Build workflow inputs\n    # Truncate prompt for workflow input (full text is in .worker-impl/prompt.md)\n    max_input_len = 500\n    truncated_prompt = params.prompt[:max_input_len]\n    if len(params.prompt) > max_input_len:\n        truncated_prompt += \"... (full prompt committed to .worker-impl/prompt.md)\"\n\n    inputs: dict[str, str] = {\n        \"prompt\": truncated_prompt,\n        \"branch_name\": branch_name,\n        \"pr_number\": str(pr_number),\n        \"submitted_by\": submitted_by,\n        \"plan_backend\": \"draft_pr\" if is_draft_pr else \"github\",\n    }\n    if params.model is not None:\n        inputs[\"model_name\"] = params.model\n    if plan_issue_number is not None:\n        inputs[\"plan_issue_number\"] = str(plan_issue_number)\n\n    # Merge extra workflow inputs\n    inputs.update(params.extra_workflow_inputs)\n\n    # Trigger workflow\n    user_output(\"Triggering one-shot workflow...\")\n    run_id = ctx.github.trigger_workflow(\n        repo_root=repo.root,\n        workflow=ONE_SHOT_WORKFLOW,\n        inputs=inputs,\n    )\n\n    # Compute run_url and queued_at for use in PR body update, metadata, and comment\n    run_url: str | None = None\n    if repo.github is not None:\n        run_url = construct_workflow_run_url(repo.github.owner, repo.github.repo, run_id)\n    queued_at = ctx.time.now().replace(tzinfo=UTC).isoformat()\n\n    # Update PR body with workflow run link (best-effort)\n    # For github backend: rewrite with prompt + run link + closing ref\n    # For draft_pr backend: skip — metadata block body should not be overwritten\n    if not is_draft_pr and run_url is not None:\n        try:\n            closing_ref = \"\"\n            if plan_issue_number is not None:\n                plans_repo = ctx.local_config.plans_repo\n                closing_ref = (\n                    f\"\\n\\nCloses {plans_repo}#{plan_issue_number}\"\n                    if plans_repo\n                    else f\"\\n\\nCloses #{plan_issue_number}\"\n                )\n            pr_body = (\n                f\"Autonomous one-shot execution.\\n\\n\"\n                f\"**Prompt:** {params.prompt}\\n\\n\"\n                f\"**Workflow run:** {run_url}{closing_ref}\"\n            )\n            ctx.github.update_pr_body(repo.root, pr_number, pr_body)\n        except Exception as e:\n            logger.warning(\"Failed to update stub PR body with workflow run link: %s\", e)\n\n    # Write dispatch metadata and post queued comment (best-effort)\n    if plan_issue_number is not None:\n        # Write dispatch metadata to plan entity (issue for github, PR for draft_pr)\n        try:\n            write_dispatch_metadata(\n                plan_backend=ctx.plan_backend,\n                github=ctx.github,\n                repo_root=repo.root,\n                issue_number=plan_issue_number,\n                run_id=run_id,\n                dispatched_at=queued_at,\n            )\n            user_output(click.style(\"\\u2713\", fg=\"green\") + \" Dispatch metadata written\")\n        except Exception as e:\n            user_output(\n                click.style(\"Warning: \", fg=\"yellow\") + f\"Failed to update dispatch metadata: {e}\"\n            )\n\n        # Post queued event comment to plan entity\n        try:\n            metadata_block = create_submission_queued_block(\n                queued_at=queued_at,\n                submitted_by=submitted_by,\n                issue_number=plan_issue_number,\n                validation_results={\"issue_is_open\": True, \"has_erk_plan_label\": True},\n                expected_workflow=\"one-shot\",\n            )\n            comment_body = render_erk_issue_event(\n                title=\"\\U0001f504 One-Shot Dispatched\",\n                metadata=metadata_block,\n                description=(\n                    f\"One-shot submitted by **{submitted_by}** at {queued_at}.\\n\\n\"\n                    f\"**Workflow run:** {run_url or 'N/A'}\\n\\n\"\n                    f\"**Prompt:** {params.prompt}\"\n                ),\n            )\n            ctx.issues.add_comment(repo.root, plan_issue_number, comment_body)\n            user_output(click.style(\"\\u2713\", fg=\"green\") + \" Queued event comment posted\")\n        except Exception as e:\n            user_output(\n                click.style(\"Warning: \", fg=\"yellow\") + f\"Failed to post queued comment: {e}\"\n            )\n\n    # Display results\n    user_output(\"\")\n    user_output(click.style(\"Done!\", fg=\"green\", bold=True))\n    if repo.github is not None and run_url is not None:\n        pr_url = f\"https://github.com/{repo.github.owner}/{repo.github.repo}/pull/{pr_number}\"\n        user_output(f\"PR: {click.style(pr_url, fg='cyan')}\")\n        user_output(f\"Run: {click.style(run_url, fg='cyan')}\")\n    else:\n        user_output(f\"PR #{pr_number} created, workflow run {run_id} triggered\")\n\n    return OneShotDispatchResult(\n        pr_number=pr_number,\n        run_id=run_id,\n        branch_name=branch_name,\n    )\n","structuredPatch":[{"oldStart":190,"oldLines":7,"newStart":190,"newLines":7,"lines":[" ","     # Generate branch name","     if is_draft_pr:","-        # draft_pr: planned/ prefix (no issue number needed)","+        # draft_pr: plnd/ prefix (no issue number needed)","         branch_name = generate_draft_pr_branch_name(","             params.prompt,","             ctx.time.now(),"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"a3e6821b-1054-4952-97ee-20bcbbb20dc1","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_019ir3pP1Jgfu7oPGuRfHVjN","type":"message","role":"assistant","content":[{"type":"text","text":"Now update plan_data_provider/real.py - the `.startswith(\"planned/\")` check needs to match both old and new prefixes:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":193,"cache_read_input_tokens":60817,"cache_creation":{"ephemeral_5m_input_tokens":193,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHVeV41DNUQAAQcc7yZ","type":"assistant","uuid":"b1c6a77f-6e55-4d75-a5aa-79e49a49d640","timestamp":"2026-02-22T14:43:36.621Z"}
{"parentUuid":"b1c6a77f-6e55-4d75-a5aa-79e49a49d640","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_019ir3pP1Jgfu7oPGuRfHVjN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01L4BKQQHQGYTeyJDLQJ4w5q","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py","old_string":"        For draft-PR plan branches (planned/{slug}-{timestamp}), falls back to\n        reading .impl/plan-ref.json from the worktree to get the plan ID,\n        since the PR number is not encoded in the branch name.","new_string":"        For draft-PR plan branches (plnd/{slug}-{timestamp}), falls back to\n        reading .impl/plan-ref.json from the worktree to get the plan ID,\n        since the PR number is not encoded in the branch name."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":193,"cache_read_input_tokens":60817,"cache_creation":{"ephemeral_5m_input_tokens":193,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHVeV41DNUQAAQcc7yZ","type":"assistant","uuid":"51adc003-c100-44ec-91d4-87d2db900b7b","timestamp":"2026-02-22T14:43:39.720Z"}
{"parentUuid":"51adc003-c100-44ec-91d4-87d2db900b7b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01L4BKQQHQGYTeyJDLQJ4w5q","type":"tool_result","content":"The file /home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py has been updated successfully."}]},"uuid":"ac72cc07-16a6-4bbf-b4f9-1fb0e830b8c1","timestamp":"2026-02-22T14:43:40.419Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py","oldString":"        For draft-PR plan branches (planned/{slug}-{timestamp}), falls back to\n        reading .impl/plan-ref.json from the worktree to get the plan ID,\n        since the PR number is not encoded in the branch name.","newString":"        For draft-PR plan branches (plnd/{slug}-{timestamp}), falls back to\n        reading .impl/plan-ref.json from the worktree to get the plan ID,\n        since the PR number is not encoded in the branch name.","originalFile":"\"\"\"Real implementation of PlanDataProvider for production use.\"\"\"\n\nimport logging\nimport subprocess\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom erk.core.context import ErkContext\nfrom erk.core.display_utils import (\n    format_relative_time,\n    format_workflow_outcome,\n    format_workflow_run_id,\n    get_workflow_run_state,\n)\nfrom erk.core.pr_utils import select_display_pr\nfrom erk.core.repo_discovery import NoRepoSentinel, RepoContext, ensure_erk_metadata_dir\nfrom erk.tui.data.types import PlanFilters, PlanRowData\nfrom erk.tui.sorting.types import BranchActivity\nfrom erk_shared.gateway.browser.abc import BrowserLauncher\nfrom erk_shared.gateway.clipboard.abc import Clipboard\nfrom erk_shared.gateway.github.emoji import format_checks_cell, get_pr_status_emoji\nfrom erk_shared.gateway.github.issues.types import IssueNotFound\nfrom erk_shared.gateway.github.metadata.core import (\n    extract_objective_from_comment,\n    extract_objective_header_comment_id,\n    find_metadata_block,\n)\nfrom erk_shared.gateway.github.metadata.dependency_graph import (\n    _TERMINAL_STATUSES,\n    build_graph,\n    compute_graph_summary,\n    find_graph_next_node,\n)\nfrom erk_shared.gateway.github.metadata.plan_header import extract_plan_from_comment\nfrom erk_shared.gateway.github.metadata.roadmap import (\n    parse_roadmap,\n)\nfrom erk_shared.gateway.github.metadata.schemas import (\n    LAST_LOCAL_IMPL_AT,\n    LAST_REMOTE_IMPL_AT,\n    LEARN_PLAN_ISSUE,\n    LEARN_PLAN_PR,\n    LEARN_RUN_ID,\n    LEARN_STATUS,\n    OBJECTIVE_ISSUE,\n    PLAN_COMMENT_ID,\n    REVIEW_PR,\n    WORKTREE_NAME,\n)\nfrom erk_shared.gateway.github.types import (\n    GitHubRepoId,\n    GitHubRepoLocation,\n    PRReviewThread,\n    PullRequestInfo,\n    WorkflowRun,\n)\nfrom erk_shared.gateway.http.abc import HttpClient\nfrom erk_shared.gateway.plan_data_provider.abc import PlanDataProvider\nfrom erk_shared.gateway.plan_data_provider.lifecycle import format_lifecycle_with_status\nfrom erk_shared.impl_folder import read_plan_ref\nfrom erk_shared.naming import extract_leading_issue_number\nfrom erk_shared.plan_store.conversion import (\n    header_datetime,\n    header_int,\n    header_str,\n)\nfrom erk_shared.plan_store.types import Plan\n\nlogger = logging.getLogger(__name__)\n\n\nclass RealPlanDataProvider(PlanDataProvider):\n    \"\"\"Production implementation that wraps PlanListService.\n\n    Transforms PlanListData into PlanRowData for TUI display.\n    \"\"\"\n\n    def __init__(\n        self,\n        ctx: ErkContext,\n        *,\n        location: GitHubRepoLocation,\n        clipboard: Clipboard,\n        browser: BrowserLauncher,\n        http_client: HttpClient,\n    ) -> None:\n        \"\"\"Initialize with context and repository info.\n\n        Args:\n            ctx: ErkContext with all dependencies\n            location: GitHub repository location (local root + repo identity)\n            clipboard: Clipboard interface for copy operations\n            browser: BrowserLauncher interface for opening URLs\n            http_client: HTTP client for direct API calls (faster than subprocess)\n        \"\"\"\n        self._ctx = ctx\n        self._location = location\n        self._clipboard = clipboard\n        self._browser = browser\n        self._http_client = http_client\n\n    @property\n    def repo_root(self) -> Path:\n        \"\"\"Get the repository root path.\"\"\"\n        return self._location.root\n\n    @property\n    def clipboard(self) -> Clipboard:\n        \"\"\"Get the clipboard interface for copy operations.\"\"\"\n        return self._clipboard\n\n    @property\n    def browser(self) -> BrowserLauncher:\n        \"\"\"Get the browser launcher interface for opening URLs.\"\"\"\n        return self._browser\n\n    def fetch_plans(self, filters: PlanFilters) -> list[PlanRowData]:\n        \"\"\"Fetch plans and transform to TUI row format.\n\n        Args:\n            filters: Filter options for the query\n\n        Returns:\n            List of PlanRowData objects for display\n        \"\"\"\n        # Determine if we need workflow runs\n        needs_workflow_runs = filters.show_runs or filters.run_state is not None\n\n        # Route to the appropriate service based on the view's labels\n        if \"erk-plan\" in filters.labels:\n            plan_data = self._ctx.plan_list_service.get_plan_list_data(\n                location=self._location,\n                labels=list(filters.labels),\n                state=filters.state,\n                limit=filters.limit,\n                skip_workflow_runs=not needs_workflow_runs,\n                creator=filters.creator,\n            )\n        else:\n            # Objectives use a dedicated service that always fetches via issues,\n            # regardless of the configured plan backend (draft PR vs issue)\n            plan_data = self._ctx.objective_list_service.get_objective_list_data(\n                location=self._location,\n                state=filters.state,\n                limit=filters.limit,\n                skip_workflow_runs=not needs_workflow_runs,\n                creator=filters.creator,\n            )\n\n        # Build local worktree mapping\n        worktree_by_plan_id = self._build_worktree_mapping()\n\n        # Use pre-converted Plan objects from PlanListData\n        plans = plan_data.plans\n\n        # First pass: collect learn_plan_issue numbers for batch fetch\n        learn_issue_numbers: set[int] = set()\n        for plan in plans:\n            learn_plan_issue = header_int(plan.header_fields, LEARN_PLAN_ISSUE)\n            if learn_plan_issue is not None:\n                learn_issue_numbers.add(learn_plan_issue)\n\n        # Batch fetch learn issue states\n        learn_issue_states = self._fetch_learn_issue_states(learn_issue_numbers)\n\n        # Transform to PlanRowData\n        rows: list[PlanRowData] = []\n        use_graphite = self._ctx.global_config.use_graphite if self._ctx.global_config else False\n\n        for plan in plans:\n            plan_id = int(plan.plan_identifier)\n\n            # Get workflow run for filtering\n            workflow_run = plan_data.workflow_runs.get(plan_id)\n\n            # Apply run_state filter\n            if filters.run_state is not None:\n                if workflow_run is None:\n                    continue\n                if get_workflow_run_state(workflow_run) != filters.run_state:\n                    continue\n\n            # Build row data\n            row = self._build_row_data(\n                plan=plan,\n                plan_id=plan_id,\n                pr_linkages=plan_data.pr_linkages,\n                workflow_run=workflow_run,\n                worktree_by_plan_id=worktree_by_plan_id,\n                use_graphite=use_graphite,\n                learn_issue_states=learn_issue_states,\n            )\n            rows.append(row)\n\n        return rows\n\n    def _fetch_learn_issue_states(\n        self,\n        issue_numbers: set[int],\n    ) -> dict[int, bool]:\n        \"\"\"Batch fetch issue closed states for learn plan issues.\n\n        Args:\n            issue_numbers: Set of issue numbers to fetch\n\n        Returns:\n            Mapping of issue number to is_closed (True if closed, False if open)\n        \"\"\"\n        result: dict[int, bool] = {}\n        for issue_number in issue_numbers:\n            issue_info = self._ctx.github.issues.get_issue(self._location.root, issue_number)\n            if isinstance(issue_info, IssueNotFound):\n                # Issue not found - log and skip\n                logger.debug(\"Could not fetch learn issue %d: issue not found\", issue_number)\n                continue\n            result[issue_number] = issue_info.state == \"CLOSED\"\n        return result\n\n    def close_plan(self, plan_id: int, plan_url: str) -> list[int]:\n        \"\"\"Close a plan and its linked PRs using direct HTTP calls.\n\n        This method uses the HTTP client directly instead of subprocess calls\n        for significantly faster execution in the TUI.\n\n        Args:\n            plan_id: The plan ID to close\n            plan_url: The plan URL for PR linkage lookup\n\n        Returns:\n            List of PR numbers that were also closed\n        \"\"\"\n        # Parse owner/repo from issue URL\n        owner_repo = self._parse_owner_repo_from_url(plan_url)\n        if owner_repo is None:\n            return []\n        owner, repo = owner_repo\n\n        # Close linked PRs first\n        closed_prs = self._close_linked_prs_http(plan_id, owner, repo)\n\n        # Close the plan (issue) via HTTP\n        self._http_client.patch(\n            f\"repos/{owner}/{repo}/issues/{plan_id}\",\n            data={\"state\": \"closed\"},\n        )\n\n        return closed_prs\n\n    def _parse_owner_repo_from_url(self, url: str) -> tuple[str, str] | None:\n        \"\"\"Parse owner and repo from a GitHub URL.\n\n        Args:\n            url: GitHub URL (e.g., \"https://github.com/owner/repo/issues/123\")\n\n        Returns:\n            Tuple of (owner, repo) or None if parsing fails\n        \"\"\"\n        # URL format: https://github.com/owner/repo/...\n        if not url.startswith(\"https://github.com/\"):\n            return None\n        parts = url.split(\"/\")\n        # parts: ['https:', '', 'github.com', 'owner', 'repo', ...]\n        if len(parts) < 5:\n            return None\n        return (parts[3], parts[4])\n\n    def _close_linked_prs_http(\n        self,\n        plan_id: int,\n        owner: str,\n        repo: str,\n    ) -> list[int]:\n        \"\"\"Close all OPEN PRs linked to an issue using HTTP.\n\n        Uses the GitHub REST API via HTTP client for fast execution.\n\n        Args:\n            plan_id: The plan ID\n            owner: Repository owner\n            repo: Repository name\n\n        Returns:\n            List of PR numbers that were closed\n        \"\"\"\n        # Use the existing gateway to get PR linkages (still efficient for read)\n        location = GitHubRepoLocation(\n            root=self._location.root,\n            repo_id=GitHubRepoId(owner=owner, repo=repo),\n        )\n        pr_linkages = self._ctx.github.get_prs_linked_to_issues(location, [plan_id])\n        linked_prs = pr_linkages.get(plan_id, [])\n\n        closed_prs: list[int] = []\n        for pr in linked_prs:\n            if pr.state == \"OPEN\":\n                # Close via HTTP client for speed\n                self._http_client.patch(\n                    f\"repos/{owner}/{repo}/pulls/{pr.number}\",\n                    data={\"state\": \"closed\"},\n                )\n                closed_prs.append(pr.number)\n\n        return closed_prs\n\n    def update_objective_after_land(\n        self,\n        *,\n        objective_issue: int,\n        pr_num: int,\n        branch: str,\n    ) -> None:\n        \"\"\"Update an objective after landing a PR.\n\n        Runs 'erk exec objective-update-after-land' as a subprocess.\n\n        Args:\n            objective_issue: The objective issue number to update\n            pr_num: The PR number that was landed\n            branch: The PR head branch name\n        \"\"\"\n        result = subprocess.run(\n            [\n                \"erk\",\n                \"exec\",\n                \"objective-update-after-land\",\n                f\"--objective={objective_issue}\",\n                f\"--pr={pr_num}\",\n                f\"--branch={branch}\",\n            ],\n            cwd=self._location.root,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            stdin=subprocess.DEVNULL,\n            text=True,\n            check=False,\n        )\n        if result.returncode != 0:\n            raise RuntimeError(f\"objective-update-after-land failed: {result.stdout}\")\n\n    def submit_to_queue(self, plan_id: int, plan_url: str) -> None:\n        \"\"\"Submit a plan to the implementation queue.\n\n        Runs 'erk plan submit' as a subprocess to handle the complex workflow\n        of creating branches, PRs, and triggering GitHub Actions.\n\n        Args:\n            plan_id: The plan ID to submit\n            plan_url: The plan URL (unused, kept for interface consistency)\n        \"\"\"\n        # Run erk plan submit command from the repository root\n        # -f flag prevents blocking on existing branch prompts in TUI context\n        subprocess.run(\n            [\"erk\", \"plan\", \"submit\", str(plan_id), \"-f\"],\n            cwd=self._location.root,\n            check=True,\n            capture_output=True,\n        )\n\n    def fetch_branch_activity(self, rows: list[PlanRowData]) -> dict[int, BranchActivity]:\n        \"\"\"Fetch branch activity for plans that exist locally.\n\n        Args:\n            rows: List of plan rows to fetch activity for\n\n        Returns:\n            Mapping of plan_id to BranchActivity for plans with local worktrees.\n        \"\"\"\n        result: dict[int, BranchActivity] = {}\n\n        # Get trunk branch\n        trunk = self._ctx.git.branch.detect_trunk_branch(self._location.root)\n\n        for row in rows:\n            # Only fetch for plans with local branches\n            if not row.exists_locally or row.worktree_branch is None:\n                continue\n\n            # Get commits on branch not in trunk\n            commits = self._ctx.git.branch.get_branch_commits_with_authors(\n                self._location.root,\n                row.worktree_branch,\n                trunk,\n                limit=1,  # Only need most recent\n            )\n\n            if commits:\n                # Parse ISO timestamp from git\n                timestamp_str = commits[0][\"timestamp\"]\n                commit_at = datetime.fromisoformat(timestamp_str)\n                result[row.plan_id] = BranchActivity(\n                    last_commit_at=commit_at,\n                    last_commit_author=commits[0][\"author\"],\n                )\n            else:\n                result[row.plan_id] = BranchActivity.empty()\n\n        return result\n\n    def fetch_plan_content(self, plan_id: int, plan_body: str) -> str | None:\n        \"\"\"Fetch plan content from the first comment of an issue, or return body directly.\n\n        For issue-based plans: uses plan_comment_id from the issue body metadata to\n        fetch the specific comment containing the plan content.\n\n        For draft PR plans: plan_body IS the plan content (already extracted from the\n        PR body by DraftPRPlanListService). No metadata block is present, so return\n        plan_body directly.\n\n        Args:\n            plan_id: The GitHub issue/PR number\n            plan_body: The body text — either an issue body (with plan-header metadata\n                and plan_comment_id) or already-extracted plan content (draft PR case)\n\n        Returns:\n            The extracted plan content, or None if not found\n        \"\"\"\n        # Check for plan-header metadata block to distinguish plan types:\n        # - Draft PR plans: no metadata block; plan_body IS the extracted content\n        # - Issue-based plans: metadata block with plan_comment_id pointing to the comment\n        block = find_metadata_block(plan_body, \"plan-header\")\n        if block is None:\n            return plan_body if plan_body.strip() else None\n\n        comment_id = block.data.get(PLAN_COMMENT_ID)\n        if not isinstance(comment_id, int):\n            return None\n\n        # Fetch the comment via HTTP client\n        owner = self._location.repo_id.owner\n        repo = self._location.repo_id.repo\n        endpoint = f\"repos/{owner}/{repo}/issues/comments/{comment_id}\"\n\n        response = self._http_client.get(endpoint)\n        comment_body = response.get(\"body\", \"\")\n\n        # Extract plan content from comment\n        return extract_plan_from_comment(comment_body)\n\n    def fetch_objective_content(self, plan_id: int, plan_body: str) -> str | None:\n        \"\"\"Fetch objective content from the first comment of an issue.\n\n        Uses the objective_comment_id from the issue body metadata to fetch\n        the specific comment containing the objective content.\n\n        Args:\n            plan_id: The GitHub issue number\n            plan_body: The issue body (to extract objective_comment_id from metadata)\n\n        Returns:\n            The extracted objective content, or None if not found\n        \"\"\"\n        comment_id = extract_objective_header_comment_id(plan_body)\n        if comment_id is None:\n            return None\n\n        owner = self._location.repo_id.owner\n        repo = self._location.repo_id.repo\n        endpoint = f\"repos/{owner}/{repo}/issues/comments/{comment_id}\"\n\n        response = self._http_client.get(endpoint)\n        comment_body = response.get(\"body\", \"\")\n\n        return extract_objective_from_comment(comment_body)\n\n    def fetch_unresolved_comments(self, pr_number: int) -> list[PRReviewThread]:\n        \"\"\"Fetch unresolved review threads for a pull request.\n\n        Args:\n            pr_number: The PR number to fetch threads for\n\n        Returns:\n            List of unresolved PRReviewThread objects sorted by (path, line)\n        \"\"\"\n        return self._ctx.github.get_pr_review_threads(\n            self._location.root, pr_number, include_resolved=False\n        )\n\n    def _build_worktree_mapping(self) -> dict[int, tuple[str, str | None]]:\n        \"\"\"Build mapping of plan ID to (worktree name, branch).\n\n        Uses PXXXX prefix matching on branch names to associate worktrees\n        with issues. Branch names follow pattern: P{plan_id}-{slug}-{timestamp}\n\n        For draft-PR plan branches (planned/{slug}-{timestamp}), falls back to\n        reading .impl/plan-ref.json from the worktree to get the plan ID,\n        since the PR number is not encoded in the branch name.\n\n        Returns:\n            Mapping of plan ID to tuple of (worktree_name, branch_name)\n        \"\"\"\n        _ensure_erk_metadata_dir_from_context(self._ctx.repo)\n        worktree_by_plan_id: dict[int, tuple[str, str | None]] = {}\n        worktrees = self._ctx.git.worktree.list_worktrees(self._location.root)\n        for worktree in worktrees:\n            issue_number = (\n                extract_leading_issue_number(worktree.branch) if worktree.branch else None\n            )\n\n            # Fallback for draft-PR branches: read .impl/plan-ref.json\n            if issue_number is None and worktree.branch and worktree.branch.startswith(\"planned/\"):\n                impl_dir = worktree.path / \".impl\"\n                plan_ref = read_plan_ref(impl_dir)\n                if plan_ref is not None and plan_ref.plan_id.isdigit():\n                    issue_number = int(plan_ref.plan_id)\n\n            if issue_number is not None:\n                if issue_number not in worktree_by_plan_id:\n                    worktree_by_plan_id[issue_number] = (\n                        worktree.path.name,\n                        worktree.branch,\n                    )\n        return worktree_by_plan_id\n\n    def _build_row_data(\n        self,\n        *,\n        plan: Plan,\n        plan_id: int,\n        pr_linkages: dict[int, list[PullRequestInfo]],\n        workflow_run: WorkflowRun | None,\n        worktree_by_plan_id: dict[int, tuple[str, str | None]],\n        use_graphite: bool,\n        learn_issue_states: dict[int, bool],\n    ) -> PlanRowData:\n        \"\"\"Build a single PlanRowData from plan and related data.\"\"\"\n        full_title = plan.title\n\n        # Worktree info\n        worktree_name = \"\"\n        worktree_branch: str | None = None\n        exists_locally = False\n\n        if plan_id in worktree_by_plan_id:\n            worktree_name, worktree_branch = worktree_by_plan_id[plan_id]\n            exists_locally = True\n\n        # Extract from pre-parsed header fields (no repeated YAML parsing)\n        local_impl_str: str | None = None\n        remote_impl_str: str | None = None\n        learn_status: str | None = None\n        learn_plan_issue: int | None = None\n        learn_plan_pr: int | None = None\n        learn_run_id: str | None = None\n        review_pr: int | None = None\n        if plan.header_fields:\n            extracted = header_str(plan.header_fields, WORKTREE_NAME)\n            if extracted and not worktree_name:\n                worktree_name = extracted\n            local_impl_str = header_str(plan.header_fields, LAST_LOCAL_IMPL_AT)\n            remote_impl_str = header_str(plan.header_fields, LAST_REMOTE_IMPL_AT)\n            learn_status = header_str(plan.header_fields, LEARN_STATUS)\n            learn_plan_issue = header_int(plan.header_fields, LEARN_PLAN_ISSUE)\n            learn_plan_pr = header_int(plan.header_fields, LEARN_PLAN_PR)\n            learn_run_id = header_str(plan.header_fields, LEARN_RUN_ID)\n            review_pr = header_int(plan.header_fields, REVIEW_PR)\n\n        # Extract objective_issue from pre-parsed header fields\n        objective_issue = header_int(plan.header_fields, OBJECTIVE_ISSUE)\n\n        # Look up learn plan issue closed state\n        learn_plan_issue_closed: bool | None = None\n        if learn_plan_issue is not None and learn_plan_issue in learn_issue_states:\n            learn_plan_issue_closed = learn_issue_states[learn_plan_issue]\n\n        # Format learn display (full text for detail modal, icon-only for table)\n        learn_display = _format_learn_display(\n            learn_status,\n            learn_plan_issue,\n            learn_plan_pr,\n            learn_plan_issue_closed=learn_plan_issue_closed,\n        )\n        learn_display_icon = _format_learn_display_icon(\n            learn_status,\n            learn_plan_issue,\n            learn_plan_pr,\n            learn_plan_issue_closed=learn_plan_issue_closed,\n        )\n\n        # Get datetime versions for storage (already parsed by YAML)\n        last_local_impl_at = header_datetime(plan.header_fields, LAST_LOCAL_IMPL_AT)\n        last_remote_impl_at = header_datetime(plan.header_fields, LAST_REMOTE_IMPL_AT)\n\n        # Format time displays\n        local_impl = format_relative_time(local_impl_str)\n        local_impl_display = local_impl if local_impl else \"-\"\n        remote_impl = format_relative_time(remote_impl_str)\n        remote_impl_display = remote_impl if remote_impl else \"-\"\n\n        # PR info\n        pr_number: int | None = None\n        pr_url: str | None = None\n        pr_title: str | None = None\n        pr_state: str | None = None\n        pr_head_branch: str | None = None\n        pr_display = \"-\"\n        checks_display = \"-\"\n\n        # Comment counts - \"-\" when no PR\n        resolved_comment_count = 0\n        total_comment_count = 0\n        comments_display = \"-\"\n\n        # PR status fields for lifecycle enrichment\n        pr_is_draft: bool | None = None\n        pr_has_conflicts: bool | None = None\n        pr_review_decision: str | None = None\n\n        if plan_id in pr_linkages:\n            issue_prs = pr_linkages[plan_id]\n            if review_pr is not None:\n                exclude_pr_numbers: set[int] | None = {review_pr}\n            else:\n                exclude_pr_numbers = None\n            selected_pr = select_display_pr(issue_prs, exclude_pr_numbers=exclude_pr_numbers)\n            if selected_pr is not None:\n                pr_number = selected_pr.number\n                pr_title = selected_pr.title\n                pr_state = selected_pr.state\n                pr_head_branch = selected_pr.head_branch\n                graphite_url = self._ctx.graphite.get_graphite_url(\n                    GitHubRepoId(selected_pr.owner, selected_pr.repo), selected_pr.number\n                )\n                pr_url = graphite_url if use_graphite and graphite_url else selected_pr.url\n                emoji = get_pr_status_emoji(selected_pr)\n                if selected_pr.will_close_target:\n                    emoji += \"🔗\"\n                pr_display = f\"#{selected_pr.number} {emoji}\"\n                checks_display = format_checks_cell(selected_pr)\n\n                # Extract status fields for lifecycle enrichment\n                pr_is_draft = selected_pr.is_draft\n                pr_has_conflicts = selected_pr.has_conflicts\n                pr_review_decision = selected_pr.review_decision\n\n                # Get review thread counts from batched PR data\n                if selected_pr.review_thread_counts is not None:\n                    resolved_comment_count, total_comment_count = selected_pr.review_thread_counts\n                    comments_display = f\"{resolved_comment_count}/{total_comment_count}\"\n                else:\n                    comments_display = \"0/0\"\n\n        # Workflow run info\n        run_id: str | None = None\n        run_status: str | None = None\n        run_conclusion: str | None = None\n        run_id_display = \"-\"\n        run_state_display = \"-\"\n        run_url: str | None = None\n\n        if workflow_run is not None:\n            run_id = str(workflow_run.run_id)\n            run_status = workflow_run.status\n            run_conclusion = workflow_run.conclusion\n            if plan.url:\n                parts = plan.url.split(\"/\")\n                if len(parts) >= 5:\n                    owner = parts[-4]\n                    repo_name = parts[-3]\n                    run_url = (\n                        f\"https://github.com/{owner}/{repo_name}/actions/runs/{workflow_run.run_id}\"\n                    )\n            run_id_display = format_workflow_run_id(workflow_run, run_url)\n            run_state_display = format_workflow_outcome(workflow_run)\n\n        # Log entries (empty for now - will be fetched on demand in the modal)\n        log_entries: tuple[tuple[str, str, str], ...] = ()\n\n        # Build learn_run_url for pending status\n        learn_run_url: str | None = None\n        if learn_run_id is not None and plan.url is not None:\n            parts = plan.url.split(\"/\")\n            if len(parts) >= 5:\n                owner = parts[-4]\n                repo_name = parts[-3]\n                learn_run_url = (\n                    f\"https://github.com/{owner}/{repo_name}/actions/runs/{learn_run_id}\"\n                )\n\n        # Format objective display\n        objective_display = f\"#{objective_issue}\" if objective_issue is not None else \"-\"\n\n        # Parse roadmap for objective-specific fields\n        objective_done_nodes = 0\n        objective_total_nodes = 0\n        objective_progress_display = \"-\"\n        objective_next_node_display = \"-\"\n        objective_deps_display = \"-\"\n        objective_in_flight_display = \"-\"\n        if plan.body:\n            phases, _errors = parse_roadmap(plan.body)\n            if phases:\n                graph = build_graph(phases)\n                summary = compute_graph_summary(graph)\n                objective_done_nodes = summary[\"done\"]\n                objective_total_nodes = summary[\"total_nodes\"]\n                objective_progress_display = f\"{objective_done_nodes}/{objective_total_nodes}\"\n\n                # Compute in-flight count (planning + in_progress)\n                in_flight = summary[\"planning\"] + summary[\"in_progress\"]\n                objective_in_flight_display = str(in_flight) if in_flight > 0 else \"-\"\n\n                # Compute next node display with unblocked count prefix\n                pending_unblocked = graph.pending_unblocked_nodes()\n                next_node = find_graph_next_node(graph, phases)\n                if next_node is not None:\n                    step_text = f\"{next_node['id']} {next_node['description']}\"\n                    if len(pending_unblocked) > 1:\n                        step_text = f\"({len(pending_unblocked)}) {step_text}\"\n                    if len(step_text) > 60:\n                        step_text = step_text[:57] + \"...\"\n                    objective_next_node_display = step_text\n                    min_status = graph.min_dep_status(next_node[\"id\"])\n                    if min_status is None or min_status in _TERMINAL_STATUSES:\n                        objective_deps_display = \"ready\"\n                    else:\n                        objective_deps_display = min_status.replace(\"_\", \" \")\n\n        # Format updated_at display\n        updated_display = format_relative_time(plan.updated_at.isoformat()) or \"-\"\n\n        # Format created_at display\n        created_display = format_relative_time(plan.created_at.isoformat()) or \"-\"\n\n        # Determine if this is a learn plan\n        is_learn_plan = \"erk-learn\" in plan.labels\n\n        # Compute lifecycle display from header or infer from metadata\n        lifecycle_display = _compute_lifecycle_display(\n            plan, has_workflow_run=workflow_run is not None\n        )\n\n        # Enrich lifecycle display with PR status indicators\n        lifecycle_display = format_lifecycle_with_status(\n            lifecycle_display,\n            is_draft=pr_is_draft,\n            has_conflicts=pr_has_conflicts,\n            review_decision=pr_review_decision,\n        )\n\n        return PlanRowData(\n            plan_id=plan_id,\n            plan_url=plan.url,\n            pr_number=pr_number,\n            pr_url=pr_url,\n            pr_display=pr_display,\n            checks_display=checks_display,\n            worktree_name=worktree_name,\n            exists_locally=exists_locally,\n            local_impl_display=local_impl_display,\n            remote_impl_display=remote_impl_display,\n            run_id_display=run_id_display,\n            run_state_display=run_state_display,\n            run_url=run_url,\n            full_title=full_title,\n            plan_body=plan.body or \"\",\n            pr_title=pr_title,\n            pr_state=pr_state,\n            pr_head_branch=pr_head_branch,\n            worktree_branch=worktree_branch,\n            last_local_impl_at=last_local_impl_at,\n            last_remote_impl_at=last_remote_impl_at,\n            run_id=run_id,\n            run_status=run_status,\n            run_conclusion=run_conclusion,\n            log_entries=log_entries,\n            resolved_comment_count=resolved_comment_count,\n            total_comment_count=total_comment_count,\n            comments_display=comments_display,\n            learn_status=learn_status,\n            learn_plan_issue=learn_plan_issue,\n            learn_plan_issue_closed=learn_plan_issue_closed,\n            learn_plan_pr=learn_plan_pr,\n            learn_run_url=learn_run_url,\n            learn_display=learn_display,\n            learn_display_icon=learn_display_icon,\n            objective_issue=objective_issue,\n            objective_display=objective_display,\n            objective_done_nodes=objective_done_nodes,\n            objective_total_nodes=objective_total_nodes,\n            objective_progress_display=objective_progress_display,\n            objective_next_node_display=objective_next_node_display,\n            objective_deps_display=objective_deps_display,\n            objective_in_flight_display=objective_in_flight_display,\n            updated_at=plan.updated_at,\n            updated_display=updated_display,\n            created_at=plan.created_at,\n            created_display=created_display,\n            author=str(plan.metadata.get(\"author\", \"\")),\n            is_learn_plan=is_learn_plan,\n            lifecycle_display=lifecycle_display,\n        )\n\n\ndef _format_learn_display(\n    learn_status: str | None,\n    learn_plan_issue: int | None,\n    learn_plan_pr: int | None,\n    *,\n    learn_plan_issue_closed: bool | None,\n) -> str:\n    \"\"\"Format learn status for display with inline descriptions.\n\n    Args:\n        learn_status: Raw status value from plan header\n        learn_plan_issue: Issue number of generated learn plan\n        learn_plan_pr: PR number that implemented the learn plan\n        learn_plan_issue_closed: Whether the learn plan issue is closed\n\n    Returns:\n        Formatted display string based on status:\n        - None or \"not_started\" -> \"- not started\"\n        - \"pending\" -> \"⟳ in progress\"\n        - \"completed_no_plan\" -> \"∅ no insights\"\n        - \"completed_with_plan\" + closed -> \"✅ #456\" (using learn_plan_issue)\n        - \"completed_with_plan\" + open -> \"📋 #456\" (using learn_plan_issue)\n        - \"pending_review\" -> \"🚧 #789\" (using learn_plan_pr for draft PR)\n        - \"plan_completed\" -> \"✓ #12\" (using learn_plan_pr)\n    \"\"\"\n    if learn_status is None or learn_status == \"not_started\":\n        return \"- not started\"\n    if learn_status == \"pending\":\n        return \"⟳ in progress\"\n    if learn_status == \"completed_no_plan\":\n        return \"∅ no insights\"\n    if learn_status == \"completed_with_plan\" and learn_plan_issue is not None:\n        if learn_plan_issue_closed is True:\n            return f\"✅ #{learn_plan_issue}\"\n        return f\"📋 #{learn_plan_issue}\"\n    if learn_status == \"pending_review\" and learn_plan_pr is not None:\n        return f\"🚧 #{learn_plan_pr}\"\n    if learn_status == \"plan_completed\" and learn_plan_pr is not None:\n        return f\"✓ #{learn_plan_pr}\"\n    # Fallback for unknown status\n    return \"- not started\"\n\n\ndef _format_learn_display_icon(\n    learn_status: str | None,\n    learn_plan_issue: int | None,\n    learn_plan_pr: int | None,\n    *,\n    learn_plan_issue_closed: bool | None,\n) -> str:\n    \"\"\"Format learn status as icon-only for table display.\n\n    Args:\n        learn_status: Raw status value from plan header\n        learn_plan_issue: Issue number of generated learn plan\n        learn_plan_pr: PR number that implemented the learn plan\n        learn_plan_issue_closed: Whether the learn plan issue is closed\n\n    Returns:\n        Icon-only display string based on status:\n        - None or \"not_started\" -> \"-\"\n        - \"pending\" -> \"⟳\"\n        - \"completed_no_plan\" -> \"∅\"\n        - \"completed_with_plan\" + closed -> \"✅ #456\" (using learn_plan_issue)\n        - \"completed_with_plan\" + open -> \"📋 #456\" (using learn_plan_issue)\n        - \"pending_review\" -> \"🚧 #789\" (using learn_plan_pr for draft PR)\n        - \"plan_completed\" -> \"✓ #12\" (using learn_plan_pr)\n    \"\"\"\n    if learn_status is None or learn_status == \"not_started\":\n        return \"-\"\n    if learn_status == \"pending\":\n        return \"⟳\"\n    if learn_status == \"completed_no_plan\":\n        return \"∅\"\n    if learn_status == \"completed_with_plan\" and learn_plan_issue is not None:\n        if learn_plan_issue_closed is True:\n            return f\"✅ #{learn_plan_issue}\"\n        return f\"📋 #{learn_plan_issue}\"\n    if learn_status == \"pending_review\" and learn_plan_pr is not None:\n        return f\"🚧 #{learn_plan_pr}\"\n    if learn_status == \"plan_completed\" and learn_plan_pr is not None:\n        return f\"✓ #{learn_plan_pr}\"\n    # Fallback for unknown status\n    return \"-\"\n\n\ndef _compute_lifecycle_display(plan: Plan, *, has_workflow_run: bool) -> str:\n    \"\"\"Compute lifecycle stage display string for a plan.\n\n    Delegates to lifecycle.compute_lifecycle_display. This wrapper preserves\n    the module-private name used by callers within this file.\n    \"\"\"\n    from erk_shared.gateway.plan_data_provider.lifecycle import compute_lifecycle_display\n\n    return compute_lifecycle_display(plan, has_workflow_run=has_workflow_run)\n\n\ndef _ensure_erk_metadata_dir_from_context(repo: RepoContext | NoRepoSentinel) -> None:\n    \"\"\"Ensure erk metadata directory exists, handling sentinel case.\"\"\"\n    if isinstance(repo, RepoContext):\n        ensure_erk_metadata_dir(repo)\n","structuredPatch":[{"oldStart":481,"oldLines":7,"newStart":481,"newLines":7,"lines":["         Uses PXXXX prefix matching on branch names to associate worktrees","         with issues. Branch names follow pattern: P{plan_id}-{slug}-{timestamp}"," ","-        For draft-PR plan branches (planned/{slug}-{timestamp}), falls back to","+        For draft-PR plan branches (plnd/{slug}-{timestamp}), falls back to","         reading .impl/plan-ref.json from the worktree to get the plan ID,","         since the PR number is not encoded in the branch name."," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"ac72cc07-16a6-4bbf-b4f9-1fb0e830b8c1","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_018BhjVxp9GW6e99hJkxQvtf","type":"message","role":"assistant","content":[{"type":"text","text":"Now for the `.startswith(\"planned/\")` check - this needs to match both `plnd/` and `planned/` for existing branches:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":662,"cache_read_input_tokens":61010,"cache_creation":{"ephemeral_5m_input_tokens":662,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHW8byqPZW3cfQkxUcM","type":"assistant","uuid":"3226e70d-0d63-45c7-8d14-832d2a9cea94","timestamp":"2026-02-22T14:43:43.752Z"}
{"parentUuid":"3226e70d-0d63-45c7-8d14-832d2a9cea94","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_018BhjVxp9GW6e99hJkxQvtf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AwrnNZ6NWAgJWeGA3BZhQ2","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py","old_string":"            # Fallback for draft-PR branches: read .impl/plan-ref.json\n            if issue_number is None and worktree.branch and worktree.branch.startswith(\"planned/\"):","new_string":"            # Fallback for draft-PR branches: read .impl/plan-ref.json\n            if issue_number is None and worktree.branch and (worktree.branch.startswith(\"plnd/\") or worktree.branch.startswith(\"planned/\")):"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":662,"cache_read_input_tokens":61010,"cache_creation":{"ephemeral_5m_input_tokens":662,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHW8byqPZW3cfQkxUcM","type":"assistant","uuid":"fa9cf257-751c-475b-970f-9618df197a70","timestamp":"2026-02-22T14:43:46.038Z"}
{"parentUuid":"fa9cf257-751c-475b-970f-9618df197a70","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AwrnNZ6NWAgJWeGA3BZhQ2","type":"tool_result","content":"The file /home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py has been updated successfully."}]},"uuid":"03747b8f-ae6b-48c6-87b3-8094009a0c8f","timestamp":"2026-02-22T14:43:46.722Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py","oldString":"            # Fallback for draft-PR branches: read .impl/plan-ref.json\n            if issue_number is None and worktree.branch and worktree.branch.startswith(\"planned/\"):","newString":"            # Fallback for draft-PR branches: read .impl/plan-ref.json\n            if issue_number is None and worktree.branch and (worktree.branch.startswith(\"plnd/\") or worktree.branch.startswith(\"planned/\")):","originalFile":"\"\"\"Real implementation of PlanDataProvider for production use.\"\"\"\n\nimport logging\nimport subprocess\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom erk.core.context import ErkContext\nfrom erk.core.display_utils import (\n    format_relative_time,\n    format_workflow_outcome,\n    format_workflow_run_id,\n    get_workflow_run_state,\n)\nfrom erk.core.pr_utils import select_display_pr\nfrom erk.core.repo_discovery import NoRepoSentinel, RepoContext, ensure_erk_metadata_dir\nfrom erk.tui.data.types import PlanFilters, PlanRowData\nfrom erk.tui.sorting.types import BranchActivity\nfrom erk_shared.gateway.browser.abc import BrowserLauncher\nfrom erk_shared.gateway.clipboard.abc import Clipboard\nfrom erk_shared.gateway.github.emoji import format_checks_cell, get_pr_status_emoji\nfrom erk_shared.gateway.github.issues.types import IssueNotFound\nfrom erk_shared.gateway.github.metadata.core import (\n    extract_objective_from_comment,\n    extract_objective_header_comment_id,\n    find_metadata_block,\n)\nfrom erk_shared.gateway.github.metadata.dependency_graph import (\n    _TERMINAL_STATUSES,\n    build_graph,\n    compute_graph_summary,\n    find_graph_next_node,\n)\nfrom erk_shared.gateway.github.metadata.plan_header import extract_plan_from_comment\nfrom erk_shared.gateway.github.metadata.roadmap import (\n    parse_roadmap,\n)\nfrom erk_shared.gateway.github.metadata.schemas import (\n    LAST_LOCAL_IMPL_AT,\n    LAST_REMOTE_IMPL_AT,\n    LEARN_PLAN_ISSUE,\n    LEARN_PLAN_PR,\n    LEARN_RUN_ID,\n    LEARN_STATUS,\n    OBJECTIVE_ISSUE,\n    PLAN_COMMENT_ID,\n    REVIEW_PR,\n    WORKTREE_NAME,\n)\nfrom erk_shared.gateway.github.types import (\n    GitHubRepoId,\n    GitHubRepoLocation,\n    PRReviewThread,\n    PullRequestInfo,\n    WorkflowRun,\n)\nfrom erk_shared.gateway.http.abc import HttpClient\nfrom erk_shared.gateway.plan_data_provider.abc import PlanDataProvider\nfrom erk_shared.gateway.plan_data_provider.lifecycle import format_lifecycle_with_status\nfrom erk_shared.impl_folder import read_plan_ref\nfrom erk_shared.naming import extract_leading_issue_number\nfrom erk_shared.plan_store.conversion import (\n    header_datetime,\n    header_int,\n    header_str,\n)\nfrom erk_shared.plan_store.types import Plan\n\nlogger = logging.getLogger(__name__)\n\n\nclass RealPlanDataProvider(PlanDataProvider):\n    \"\"\"Production implementation that wraps PlanListService.\n\n    Transforms PlanListData into PlanRowData for TUI display.\n    \"\"\"\n\n    def __init__(\n        self,\n        ctx: ErkContext,\n        *,\n        location: GitHubRepoLocation,\n        clipboard: Clipboard,\n        browser: BrowserLauncher,\n        http_client: HttpClient,\n    ) -> None:\n        \"\"\"Initialize with context and repository info.\n\n        Args:\n            ctx: ErkContext with all dependencies\n            location: GitHub repository location (local root + repo identity)\n            clipboard: Clipboard interface for copy operations\n            browser: BrowserLauncher interface for opening URLs\n            http_client: HTTP client for direct API calls (faster than subprocess)\n        \"\"\"\n        self._ctx = ctx\n        self._location = location\n        self._clipboard = clipboard\n        self._browser = browser\n        self._http_client = http_client\n\n    @property\n    def repo_root(self) -> Path:\n        \"\"\"Get the repository root path.\"\"\"\n        return self._location.root\n\n    @property\n    def clipboard(self) -> Clipboard:\n        \"\"\"Get the clipboard interface for copy operations.\"\"\"\n        return self._clipboard\n\n    @property\n    def browser(self) -> BrowserLauncher:\n        \"\"\"Get the browser launcher interface for opening URLs.\"\"\"\n        return self._browser\n\n    def fetch_plans(self, filters: PlanFilters) -> list[PlanRowData]:\n        \"\"\"Fetch plans and transform to TUI row format.\n\n        Args:\n            filters: Filter options for the query\n\n        Returns:\n            List of PlanRowData objects for display\n        \"\"\"\n        # Determine if we need workflow runs\n        needs_workflow_runs = filters.show_runs or filters.run_state is not None\n\n        # Route to the appropriate service based on the view's labels\n        if \"erk-plan\" in filters.labels:\n            plan_data = self._ctx.plan_list_service.get_plan_list_data(\n                location=self._location,\n                labels=list(filters.labels),\n                state=filters.state,\n                limit=filters.limit,\n                skip_workflow_runs=not needs_workflow_runs,\n                creator=filters.creator,\n            )\n        else:\n            # Objectives use a dedicated service that always fetches via issues,\n            # regardless of the configured plan backend (draft PR vs issue)\n            plan_data = self._ctx.objective_list_service.get_objective_list_data(\n                location=self._location,\n                state=filters.state,\n                limit=filters.limit,\n                skip_workflow_runs=not needs_workflow_runs,\n                creator=filters.creator,\n            )\n\n        # Build local worktree mapping\n        worktree_by_plan_id = self._build_worktree_mapping()\n\n        # Use pre-converted Plan objects from PlanListData\n        plans = plan_data.plans\n\n        # First pass: collect learn_plan_issue numbers for batch fetch\n        learn_issue_numbers: set[int] = set()\n        for plan in plans:\n            learn_plan_issue = header_int(plan.header_fields, LEARN_PLAN_ISSUE)\n            if learn_plan_issue is not None:\n                learn_issue_numbers.add(learn_plan_issue)\n\n        # Batch fetch learn issue states\n        learn_issue_states = self._fetch_learn_issue_states(learn_issue_numbers)\n\n        # Transform to PlanRowData\n        rows: list[PlanRowData] = []\n        use_graphite = self._ctx.global_config.use_graphite if self._ctx.global_config else False\n\n        for plan in plans:\n            plan_id = int(plan.plan_identifier)\n\n            # Get workflow run for filtering\n            workflow_run = plan_data.workflow_runs.get(plan_id)\n\n            # Apply run_state filter\n            if filters.run_state is not None:\n                if workflow_run is None:\n                    continue\n                if get_workflow_run_state(workflow_run) != filters.run_state:\n                    continue\n\n            # Build row data\n            row = self._build_row_data(\n                plan=plan,\n                plan_id=plan_id,\n                pr_linkages=plan_data.pr_linkages,\n                workflow_run=workflow_run,\n                worktree_by_plan_id=worktree_by_plan_id,\n                use_graphite=use_graphite,\n                learn_issue_states=learn_issue_states,\n            )\n            rows.append(row)\n\n        return rows\n\n    def _fetch_learn_issue_states(\n        self,\n        issue_numbers: set[int],\n    ) -> dict[int, bool]:\n        \"\"\"Batch fetch issue closed states for learn plan issues.\n\n        Args:\n            issue_numbers: Set of issue numbers to fetch\n\n        Returns:\n            Mapping of issue number to is_closed (True if closed, False if open)\n        \"\"\"\n        result: dict[int, bool] = {}\n        for issue_number in issue_numbers:\n            issue_info = self._ctx.github.issues.get_issue(self._location.root, issue_number)\n            if isinstance(issue_info, IssueNotFound):\n                # Issue not found - log and skip\n                logger.debug(\"Could not fetch learn issue %d: issue not found\", issue_number)\n                continue\n            result[issue_number] = issue_info.state == \"CLOSED\"\n        return result\n\n    def close_plan(self, plan_id: int, plan_url: str) -> list[int]:\n        \"\"\"Close a plan and its linked PRs using direct HTTP calls.\n\n        This method uses the HTTP client directly instead of subprocess calls\n        for significantly faster execution in the TUI.\n\n        Args:\n            plan_id: The plan ID to close\n            plan_url: The plan URL for PR linkage lookup\n\n        Returns:\n            List of PR numbers that were also closed\n        \"\"\"\n        # Parse owner/repo from issue URL\n        owner_repo = self._parse_owner_repo_from_url(plan_url)\n        if owner_repo is None:\n            return []\n        owner, repo = owner_repo\n\n        # Close linked PRs first\n        closed_prs = self._close_linked_prs_http(plan_id, owner, repo)\n\n        # Close the plan (issue) via HTTP\n        self._http_client.patch(\n            f\"repos/{owner}/{repo}/issues/{plan_id}\",\n            data={\"state\": \"closed\"},\n        )\n\n        return closed_prs\n\n    def _parse_owner_repo_from_url(self, url: str) -> tuple[str, str] | None:\n        \"\"\"Parse owner and repo from a GitHub URL.\n\n        Args:\n            url: GitHub URL (e.g., \"https://github.com/owner/repo/issues/123\")\n\n        Returns:\n            Tuple of (owner, repo) or None if parsing fails\n        \"\"\"\n        # URL format: https://github.com/owner/repo/...\n        if not url.startswith(\"https://github.com/\"):\n            return None\n        parts = url.split(\"/\")\n        # parts: ['https:', '', 'github.com', 'owner', 'repo', ...]\n        if len(parts) < 5:\n            return None\n        return (parts[3], parts[4])\n\n    def _close_linked_prs_http(\n        self,\n        plan_id: int,\n        owner: str,\n        repo: str,\n    ) -> list[int]:\n        \"\"\"Close all OPEN PRs linked to an issue using HTTP.\n\n        Uses the GitHub REST API via HTTP client for fast execution.\n\n        Args:\n            plan_id: The plan ID\n            owner: Repository owner\n            repo: Repository name\n\n        Returns:\n            List of PR numbers that were closed\n        \"\"\"\n        # Use the existing gateway to get PR linkages (still efficient for read)\n        location = GitHubRepoLocation(\n            root=self._location.root,\n            repo_id=GitHubRepoId(owner=owner, repo=repo),\n        )\n        pr_linkages = self._ctx.github.get_prs_linked_to_issues(location, [plan_id])\n        linked_prs = pr_linkages.get(plan_id, [])\n\n        closed_prs: list[int] = []\n        for pr in linked_prs:\n            if pr.state == \"OPEN\":\n                # Close via HTTP client for speed\n                self._http_client.patch(\n                    f\"repos/{owner}/{repo}/pulls/{pr.number}\",\n                    data={\"state\": \"closed\"},\n                )\n                closed_prs.append(pr.number)\n\n        return closed_prs\n\n    def update_objective_after_land(\n        self,\n        *,\n        objective_issue: int,\n        pr_num: int,\n        branch: str,\n    ) -> None:\n        \"\"\"Update an objective after landing a PR.\n\n        Runs 'erk exec objective-update-after-land' as a subprocess.\n\n        Args:\n            objective_issue: The objective issue number to update\n            pr_num: The PR number that was landed\n            branch: The PR head branch name\n        \"\"\"\n        result = subprocess.run(\n            [\n                \"erk\",\n                \"exec\",\n                \"objective-update-after-land\",\n                f\"--objective={objective_issue}\",\n                f\"--pr={pr_num}\",\n                f\"--branch={branch}\",\n            ],\n            cwd=self._location.root,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            stdin=subprocess.DEVNULL,\n            text=True,\n            check=False,\n        )\n        if result.returncode != 0:\n            raise RuntimeError(f\"objective-update-after-land failed: {result.stdout}\")\n\n    def submit_to_queue(self, plan_id: int, plan_url: str) -> None:\n        \"\"\"Submit a plan to the implementation queue.\n\n        Runs 'erk plan submit' as a subprocess to handle the complex workflow\n        of creating branches, PRs, and triggering GitHub Actions.\n\n        Args:\n            plan_id: The plan ID to submit\n            plan_url: The plan URL (unused, kept for interface consistency)\n        \"\"\"\n        # Run erk plan submit command from the repository root\n        # -f flag prevents blocking on existing branch prompts in TUI context\n        subprocess.run(\n            [\"erk\", \"plan\", \"submit\", str(plan_id), \"-f\"],\n            cwd=self._location.root,\n            check=True,\n            capture_output=True,\n        )\n\n    def fetch_branch_activity(self, rows: list[PlanRowData]) -> dict[int, BranchActivity]:\n        \"\"\"Fetch branch activity for plans that exist locally.\n\n        Args:\n            rows: List of plan rows to fetch activity for\n\n        Returns:\n            Mapping of plan_id to BranchActivity for plans with local worktrees.\n        \"\"\"\n        result: dict[int, BranchActivity] = {}\n\n        # Get trunk branch\n        trunk = self._ctx.git.branch.detect_trunk_branch(self._location.root)\n\n        for row in rows:\n            # Only fetch for plans with local branches\n            if not row.exists_locally or row.worktree_branch is None:\n                continue\n\n            # Get commits on branch not in trunk\n            commits = self._ctx.git.branch.get_branch_commits_with_authors(\n                self._location.root,\n                row.worktree_branch,\n                trunk,\n                limit=1,  # Only need most recent\n            )\n\n            if commits:\n                # Parse ISO timestamp from git\n                timestamp_str = commits[0][\"timestamp\"]\n                commit_at = datetime.fromisoformat(timestamp_str)\n                result[row.plan_id] = BranchActivity(\n                    last_commit_at=commit_at,\n                    last_commit_author=commits[0][\"author\"],\n                )\n            else:\n                result[row.plan_id] = BranchActivity.empty()\n\n        return result\n\n    def fetch_plan_content(self, plan_id: int, plan_body: str) -> str | None:\n        \"\"\"Fetch plan content from the first comment of an issue, or return body directly.\n\n        For issue-based plans: uses plan_comment_id from the issue body metadata to\n        fetch the specific comment containing the plan content.\n\n        For draft PR plans: plan_body IS the plan content (already extracted from the\n        PR body by DraftPRPlanListService). No metadata block is present, so return\n        plan_body directly.\n\n        Args:\n            plan_id: The GitHub issue/PR number\n            plan_body: The body text — either an issue body (with plan-header metadata\n                and plan_comment_id) or already-extracted plan content (draft PR case)\n\n        Returns:\n            The extracted plan content, or None if not found\n        \"\"\"\n        # Check for plan-header metadata block to distinguish plan types:\n        # - Draft PR plans: no metadata block; plan_body IS the extracted content\n        # - Issue-based plans: metadata block with plan_comment_id pointing to the comment\n        block = find_metadata_block(plan_body, \"plan-header\")\n        if block is None:\n            return plan_body if plan_body.strip() else None\n\n        comment_id = block.data.get(PLAN_COMMENT_ID)\n        if not isinstance(comment_id, int):\n            return None\n\n        # Fetch the comment via HTTP client\n        owner = self._location.repo_id.owner\n        repo = self._location.repo_id.repo\n        endpoint = f\"repos/{owner}/{repo}/issues/comments/{comment_id}\"\n\n        response = self._http_client.get(endpoint)\n        comment_body = response.get(\"body\", \"\")\n\n        # Extract plan content from comment\n        return extract_plan_from_comment(comment_body)\n\n    def fetch_objective_content(self, plan_id: int, plan_body: str) -> str | None:\n        \"\"\"Fetch objective content from the first comment of an issue.\n\n        Uses the objective_comment_id from the issue body metadata to fetch\n        the specific comment containing the objective content.\n\n        Args:\n            plan_id: The GitHub issue number\n            plan_body: The issue body (to extract objective_comment_id from metadata)\n\n        Returns:\n            The extracted objective content, or None if not found\n        \"\"\"\n        comment_id = extract_objective_header_comment_id(plan_body)\n        if comment_id is None:\n            return None\n\n        owner = self._location.repo_id.owner\n        repo = self._location.repo_id.repo\n        endpoint = f\"repos/{owner}/{repo}/issues/comments/{comment_id}\"\n\n        response = self._http_client.get(endpoint)\n        comment_body = response.get(\"body\", \"\")\n\n        return extract_objective_from_comment(comment_body)\n\n    def fetch_unresolved_comments(self, pr_number: int) -> list[PRReviewThread]:\n        \"\"\"Fetch unresolved review threads for a pull request.\n\n        Args:\n            pr_number: The PR number to fetch threads for\n\n        Returns:\n            List of unresolved PRReviewThread objects sorted by (path, line)\n        \"\"\"\n        return self._ctx.github.get_pr_review_threads(\n            self._location.root, pr_number, include_resolved=False\n        )\n\n    def _build_worktree_mapping(self) -> dict[int, tuple[str, str | None]]:\n        \"\"\"Build mapping of plan ID to (worktree name, branch).\n\n        Uses PXXXX prefix matching on branch names to associate worktrees\n        with issues. Branch names follow pattern: P{plan_id}-{slug}-{timestamp}\n\n        For draft-PR plan branches (plnd/{slug}-{timestamp}), falls back to\n        reading .impl/plan-ref.json from the worktree to get the plan ID,\n        since the PR number is not encoded in the branch name.\n\n        Returns:\n            Mapping of plan ID to tuple of (worktree_name, branch_name)\n        \"\"\"\n        _ensure_erk_metadata_dir_from_context(self._ctx.repo)\n        worktree_by_plan_id: dict[int, tuple[str, str | None]] = {}\n        worktrees = self._ctx.git.worktree.list_worktrees(self._location.root)\n        for worktree in worktrees:\n            issue_number = (\n                extract_leading_issue_number(worktree.branch) if worktree.branch else None\n            )\n\n            # Fallback for draft-PR branches: read .impl/plan-ref.json\n            if issue_number is None and worktree.branch and worktree.branch.startswith(\"planned/\"):\n                impl_dir = worktree.path / \".impl\"\n                plan_ref = read_plan_ref(impl_dir)\n                if plan_ref is not None and plan_ref.plan_id.isdigit():\n                    issue_number = int(plan_ref.plan_id)\n\n            if issue_number is not None:\n                if issue_number not in worktree_by_plan_id:\n                    worktree_by_plan_id[issue_number] = (\n                        worktree.path.name,\n                        worktree.branch,\n                    )\n        return worktree_by_plan_id\n\n    def _build_row_data(\n        self,\n        *,\n        plan: Plan,\n        plan_id: int,\n        pr_linkages: dict[int, list[PullRequestInfo]],\n        workflow_run: WorkflowRun | None,\n        worktree_by_plan_id: dict[int, tuple[str, str | None]],\n        use_graphite: bool,\n        learn_issue_states: dict[int, bool],\n    ) -> PlanRowData:\n        \"\"\"Build a single PlanRowData from plan and related data.\"\"\"\n        full_title = plan.title\n\n        # Worktree info\n        worktree_name = \"\"\n        worktree_branch: str | None = None\n        exists_locally = False\n\n        if plan_id in worktree_by_plan_id:\n            worktree_name, worktree_branch = worktree_by_plan_id[plan_id]\n            exists_locally = True\n\n        # Extract from pre-parsed header fields (no repeated YAML parsing)\n        local_impl_str: str | None = None\n        remote_impl_str: str | None = None\n        learn_status: str | None = None\n        learn_plan_issue: int | None = None\n        learn_plan_pr: int | None = None\n        learn_run_id: str | None = None\n        review_pr: int | None = None\n        if plan.header_fields:\n            extracted = header_str(plan.header_fields, WORKTREE_NAME)\n            if extracted and not worktree_name:\n                worktree_name = extracted\n            local_impl_str = header_str(plan.header_fields, LAST_LOCAL_IMPL_AT)\n            remote_impl_str = header_str(plan.header_fields, LAST_REMOTE_IMPL_AT)\n            learn_status = header_str(plan.header_fields, LEARN_STATUS)\n            learn_plan_issue = header_int(plan.header_fields, LEARN_PLAN_ISSUE)\n            learn_plan_pr = header_int(plan.header_fields, LEARN_PLAN_PR)\n            learn_run_id = header_str(plan.header_fields, LEARN_RUN_ID)\n            review_pr = header_int(plan.header_fields, REVIEW_PR)\n\n        # Extract objective_issue from pre-parsed header fields\n        objective_issue = header_int(plan.header_fields, OBJECTIVE_ISSUE)\n\n        # Look up learn plan issue closed state\n        learn_plan_issue_closed: bool | None = None\n        if learn_plan_issue is not None and learn_plan_issue in learn_issue_states:\n            learn_plan_issue_closed = learn_issue_states[learn_plan_issue]\n\n        # Format learn display (full text for detail modal, icon-only for table)\n        learn_display = _format_learn_display(\n            learn_status,\n            learn_plan_issue,\n            learn_plan_pr,\n            learn_plan_issue_closed=learn_plan_issue_closed,\n        )\n        learn_display_icon = _format_learn_display_icon(\n            learn_status,\n            learn_plan_issue,\n            learn_plan_pr,\n            learn_plan_issue_closed=learn_plan_issue_closed,\n        )\n\n        # Get datetime versions for storage (already parsed by YAML)\n        last_local_impl_at = header_datetime(plan.header_fields, LAST_LOCAL_IMPL_AT)\n        last_remote_impl_at = header_datetime(plan.header_fields, LAST_REMOTE_IMPL_AT)\n\n        # Format time displays\n        local_impl = format_relative_time(local_impl_str)\n        local_impl_display = local_impl if local_impl else \"-\"\n        remote_impl = format_relative_time(remote_impl_str)\n        remote_impl_display = remote_impl if remote_impl else \"-\"\n\n        # PR info\n        pr_number: int | None = None\n        pr_url: str | None = None\n        pr_title: str | None = None\n        pr_state: str | None = None\n        pr_head_branch: str | None = None\n        pr_display = \"-\"\n        checks_display = \"-\"\n\n        # Comment counts - \"-\" when no PR\n        resolved_comment_count = 0\n        total_comment_count = 0\n        comments_display = \"-\"\n\n        # PR status fields for lifecycle enrichment\n        pr_is_draft: bool | None = None\n        pr_has_conflicts: bool | None = None\n        pr_review_decision: str | None = None\n\n        if plan_id in pr_linkages:\n            issue_prs = pr_linkages[plan_id]\n            if review_pr is not None:\n                exclude_pr_numbers: set[int] | None = {review_pr}\n            else:\n                exclude_pr_numbers = None\n            selected_pr = select_display_pr(issue_prs, exclude_pr_numbers=exclude_pr_numbers)\n            if selected_pr is not None:\n                pr_number = selected_pr.number\n                pr_title = selected_pr.title\n                pr_state = selected_pr.state\n                pr_head_branch = selected_pr.head_branch\n                graphite_url = self._ctx.graphite.get_graphite_url(\n                    GitHubRepoId(selected_pr.owner, selected_pr.repo), selected_pr.number\n                )\n                pr_url = graphite_url if use_graphite and graphite_url else selected_pr.url\n                emoji = get_pr_status_emoji(selected_pr)\n                if selected_pr.will_close_target:\n                    emoji += \"🔗\"\n                pr_display = f\"#{selected_pr.number} {emoji}\"\n                checks_display = format_checks_cell(selected_pr)\n\n                # Extract status fields for lifecycle enrichment\n                pr_is_draft = selected_pr.is_draft\n                pr_has_conflicts = selected_pr.has_conflicts\n                pr_review_decision = selected_pr.review_decision\n\n                # Get review thread counts from batched PR data\n                if selected_pr.review_thread_counts is not None:\n                    resolved_comment_count, total_comment_count = selected_pr.review_thread_counts\n                    comments_display = f\"{resolved_comment_count}/{total_comment_count}\"\n                else:\n                    comments_display = \"0/0\"\n\n        # Workflow run info\n        run_id: str | None = None\n        run_status: str | None = None\n        run_conclusion: str | None = None\n        run_id_display = \"-\"\n        run_state_display = \"-\"\n        run_url: str | None = None\n\n        if workflow_run is not None:\n            run_id = str(workflow_run.run_id)\n            run_status = workflow_run.status\n            run_conclusion = workflow_run.conclusion\n            if plan.url:\n                parts = plan.url.split(\"/\")\n                if len(parts) >= 5:\n                    owner = parts[-4]\n                    repo_name = parts[-3]\n                    run_url = (\n                        f\"https://github.com/{owner}/{repo_name}/actions/runs/{workflow_run.run_id}\"\n                    )\n            run_id_display = format_workflow_run_id(workflow_run, run_url)\n            run_state_display = format_workflow_outcome(workflow_run)\n\n        # Log entries (empty for now - will be fetched on demand in the modal)\n        log_entries: tuple[tuple[str, str, str], ...] = ()\n\n        # Build learn_run_url for pending status\n        learn_run_url: str | None = None\n        if learn_run_id is not None and plan.url is not None:\n            parts = plan.url.split(\"/\")\n            if len(parts) >= 5:\n                owner = parts[-4]\n                repo_name = parts[-3]\n                learn_run_url = (\n                    f\"https://github.com/{owner}/{repo_name}/actions/runs/{learn_run_id}\"\n                )\n\n        # Format objective display\n        objective_display = f\"#{objective_issue}\" if objective_issue is not None else \"-\"\n\n        # Parse roadmap for objective-specific fields\n        objective_done_nodes = 0\n        objective_total_nodes = 0\n        objective_progress_display = \"-\"\n        objective_next_node_display = \"-\"\n        objective_deps_display = \"-\"\n        objective_in_flight_display = \"-\"\n        if plan.body:\n            phases, _errors = parse_roadmap(plan.body)\n            if phases:\n                graph = build_graph(phases)\n                summary = compute_graph_summary(graph)\n                objective_done_nodes = summary[\"done\"]\n                objective_total_nodes = summary[\"total_nodes\"]\n                objective_progress_display = f\"{objective_done_nodes}/{objective_total_nodes}\"\n\n                # Compute in-flight count (planning + in_progress)\n                in_flight = summary[\"planning\"] + summary[\"in_progress\"]\n                objective_in_flight_display = str(in_flight) if in_flight > 0 else \"-\"\n\n                # Compute next node display with unblocked count prefix\n                pending_unblocked = graph.pending_unblocked_nodes()\n                next_node = find_graph_next_node(graph, phases)\n                if next_node is not None:\n                    step_text = f\"{next_node['id']} {next_node['description']}\"\n                    if len(pending_unblocked) > 1:\n                        step_text = f\"({len(pending_unblocked)}) {step_text}\"\n                    if len(step_text) > 60:\n                        step_text = step_text[:57] + \"...\"\n                    objective_next_node_display = step_text\n                    min_status = graph.min_dep_status(next_node[\"id\"])\n                    if min_status is None or min_status in _TERMINAL_STATUSES:\n                        objective_deps_display = \"ready\"\n                    else:\n                        objective_deps_display = min_status.replace(\"_\", \" \")\n\n        # Format updated_at display\n        updated_display = format_relative_time(plan.updated_at.isoformat()) or \"-\"\n\n        # Format created_at display\n        created_display = format_relative_time(plan.created_at.isoformat()) or \"-\"\n\n        # Determine if this is a learn plan\n        is_learn_plan = \"erk-learn\" in plan.labels\n\n        # Compute lifecycle display from header or infer from metadata\n        lifecycle_display = _compute_lifecycle_display(\n            plan, has_workflow_run=workflow_run is not None\n        )\n\n        # Enrich lifecycle display with PR status indicators\n        lifecycle_display = format_lifecycle_with_status(\n            lifecycle_display,\n            is_draft=pr_is_draft,\n            has_conflicts=pr_has_conflicts,\n            review_decision=pr_review_decision,\n        )\n\n        return PlanRowData(\n            plan_id=plan_id,\n            plan_url=plan.url,\n            pr_number=pr_number,\n            pr_url=pr_url,\n            pr_display=pr_display,\n            checks_display=checks_display,\n            worktree_name=worktree_name,\n            exists_locally=exists_locally,\n            local_impl_display=local_impl_display,\n            remote_impl_display=remote_impl_display,\n            run_id_display=run_id_display,\n            run_state_display=run_state_display,\n            run_url=run_url,\n            full_title=full_title,\n            plan_body=plan.body or \"\",\n            pr_title=pr_title,\n            pr_state=pr_state,\n            pr_head_branch=pr_head_branch,\n            worktree_branch=worktree_branch,\n            last_local_impl_at=last_local_impl_at,\n            last_remote_impl_at=last_remote_impl_at,\n            run_id=run_id,\n            run_status=run_status,\n            run_conclusion=run_conclusion,\n            log_entries=log_entries,\n            resolved_comment_count=resolved_comment_count,\n            total_comment_count=total_comment_count,\n            comments_display=comments_display,\n            learn_status=learn_status,\n            learn_plan_issue=learn_plan_issue,\n            learn_plan_issue_closed=learn_plan_issue_closed,\n            learn_plan_pr=learn_plan_pr,\n            learn_run_url=learn_run_url,\n            learn_display=learn_display,\n            learn_display_icon=learn_display_icon,\n            objective_issue=objective_issue,\n            objective_display=objective_display,\n            objective_done_nodes=objective_done_nodes,\n            objective_total_nodes=objective_total_nodes,\n            objective_progress_display=objective_progress_display,\n            objective_next_node_display=objective_next_node_display,\n            objective_deps_display=objective_deps_display,\n            objective_in_flight_display=objective_in_flight_display,\n            updated_at=plan.updated_at,\n            updated_display=updated_display,\n            created_at=plan.created_at,\n            created_display=created_display,\n            author=str(plan.metadata.get(\"author\", \"\")),\n            is_learn_plan=is_learn_plan,\n            lifecycle_display=lifecycle_display,\n        )\n\n\ndef _format_learn_display(\n    learn_status: str | None,\n    learn_plan_issue: int | None,\n    learn_plan_pr: int | None,\n    *,\n    learn_plan_issue_closed: bool | None,\n) -> str:\n    \"\"\"Format learn status for display with inline descriptions.\n\n    Args:\n        learn_status: Raw status value from plan header\n        learn_plan_issue: Issue number of generated learn plan\n        learn_plan_pr: PR number that implemented the learn plan\n        learn_plan_issue_closed: Whether the learn plan issue is closed\n\n    Returns:\n        Formatted display string based on status:\n        - None or \"not_started\" -> \"- not started\"\n        - \"pending\" -> \"⟳ in progress\"\n        - \"completed_no_plan\" -> \"∅ no insights\"\n        - \"completed_with_plan\" + closed -> \"✅ #456\" (using learn_plan_issue)\n        - \"completed_with_plan\" + open -> \"📋 #456\" (using learn_plan_issue)\n        - \"pending_review\" -> \"🚧 #789\" (using learn_plan_pr for draft PR)\n        - \"plan_completed\" -> \"✓ #12\" (using learn_plan_pr)\n    \"\"\"\n    if learn_status is None or learn_status == \"not_started\":\n        return \"- not started\"\n    if learn_status == \"pending\":\n        return \"⟳ in progress\"\n    if learn_status == \"completed_no_plan\":\n        return \"∅ no insights\"\n    if learn_status == \"completed_with_plan\" and learn_plan_issue is not None:\n        if learn_plan_issue_closed is True:\n            return f\"✅ #{learn_plan_issue}\"\n        return f\"📋 #{learn_plan_issue}\"\n    if learn_status == \"pending_review\" and learn_plan_pr is not None:\n        return f\"🚧 #{learn_plan_pr}\"\n    if learn_status == \"plan_completed\" and learn_plan_pr is not None:\n        return f\"✓ #{learn_plan_pr}\"\n    # Fallback for unknown status\n    return \"- not started\"\n\n\ndef _format_learn_display_icon(\n    learn_status: str | None,\n    learn_plan_issue: int | None,\n    learn_plan_pr: int | None,\n    *,\n    learn_plan_issue_closed: bool | None,\n) -> str:\n    \"\"\"Format learn status as icon-only for table display.\n\n    Args:\n        learn_status: Raw status value from plan header\n        learn_plan_issue: Issue number of generated learn plan\n        learn_plan_pr: PR number that implemented the learn plan\n        learn_plan_issue_closed: Whether the learn plan issue is closed\n\n    Returns:\n        Icon-only display string based on status:\n        - None or \"not_started\" -> \"-\"\n        - \"pending\" -> \"⟳\"\n        - \"completed_no_plan\" -> \"∅\"\n        - \"completed_with_plan\" + closed -> \"✅ #456\" (using learn_plan_issue)\n        - \"completed_with_plan\" + open -> \"📋 #456\" (using learn_plan_issue)\n        - \"pending_review\" -> \"🚧 #789\" (using learn_plan_pr for draft PR)\n        - \"plan_completed\" -> \"✓ #12\" (using learn_plan_pr)\n    \"\"\"\n    if learn_status is None or learn_status == \"not_started\":\n        return \"-\"\n    if learn_status == \"pending\":\n        return \"⟳\"\n    if learn_status == \"completed_no_plan\":\n        return \"∅\"\n    if learn_status == \"completed_with_plan\" and learn_plan_issue is not None:\n        if learn_plan_issue_closed is True:\n            return f\"✅ #{learn_plan_issue}\"\n        return f\"📋 #{learn_plan_issue}\"\n    if learn_status == \"pending_review\" and learn_plan_pr is not None:\n        return f\"🚧 #{learn_plan_pr}\"\n    if learn_status == \"plan_completed\" and learn_plan_pr is not None:\n        return f\"✓ #{learn_plan_pr}\"\n    # Fallback for unknown status\n    return \"-\"\n\n\ndef _compute_lifecycle_display(plan: Plan, *, has_workflow_run: bool) -> str:\n    \"\"\"Compute lifecycle stage display string for a plan.\n\n    Delegates to lifecycle.compute_lifecycle_display. This wrapper preserves\n    the module-private name used by callers within this file.\n    \"\"\"\n    from erk_shared.gateway.plan_data_provider.lifecycle import compute_lifecycle_display\n\n    return compute_lifecycle_display(plan, has_workflow_run=has_workflow_run)\n\n\ndef _ensure_erk_metadata_dir_from_context(repo: RepoContext | NoRepoSentinel) -> None:\n    \"\"\"Ensure erk metadata directory exists, handling sentinel case.\"\"\"\n    if isinstance(repo, RepoContext):\n        ensure_erk_metadata_dir(repo)\n","structuredPatch":[{"oldStart":497,"oldLines":7,"newStart":497,"newLines":7,"lines":["             )"," ","             # Fallback for draft-PR branches: read .impl/plan-ref.json","-            if issue_number is None and worktree.branch and worktree.branch.startswith(\"planned/\"):","+            if issue_number is None and worktree.branch and (worktree.branch.startswith(\"plnd/\") or worktree.branch.startswith(\"planned/\")):","                 impl_dir = worktree.path / \".impl\"","                 plan_ref = read_plan_ref(impl_dir)","                 if plan_ref is not None and plan_ref.plan_id.isdigit():"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"03747b8f-ae6b-48c6-87b3-8094009a0c8f","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Jev5WqRVV3gDVyU6Vztj2o","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Bf5fd4htX8GWGxhEwojW6w","name":"TodoWrite","input":{"todos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"completed","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"completed","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"completed","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"completed","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"in_progress","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":324,"cache_read_input_tokens":61672,"cache_creation":{"ephemeral_5m_input_tokens":324,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHWbZU9UNZnsaj5S2RR","type":"assistant","uuid":"9bd0a1a6-73f1-4dad-86ba-f1ca8cf35980","timestamp":"2026-02-22T14:43:52.877Z"}
{"parentUuid":"9bd0a1a6-73f1-4dad-86ba-f1ca8cf35980","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Bf5fd4htX8GWGxhEwojW6w","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"660c00dd-35cb-4873-811e-3cc203aa3a5d","timestamp":"2026-02-22T14:43:52.902Z","toolUseResult":{"oldTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"in_progress","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"pending","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"pending","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"pending","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"pending","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}],"newTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"completed","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"completed","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"completed","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"completed","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"in_progress","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]}}
{"parentUuid":"660c00dd-35cb-4873-811e-3cc203aa3a5d","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01RxaEqfLCa5hKTNYFWyznoh","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the documentation files. Let me read them first:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":61996,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHX3yhfyqtqf7JHzZhq","type":"assistant","uuid":"fb04964b-f06a-4417-8dbf-ba4dd16f3811","timestamp":"2026-02-22T14:43:55.172Z"}
{"parentUuid":"fb04964b-f06a-4417-8dbf-ba4dd16f3811","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01RxaEqfLCa5hKTNYFWyznoh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01A2QDqFE5bRyrf9hqYaGPkz","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/planning/plan-title-prefix-system.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":61996,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHX3yhfyqtqf7JHzZhq","type":"assistant","uuid":"7ed1cbf7-0266-4d43-8d40-19ec35136789","timestamp":"2026-02-22T14:43:56.069Z"}
{"parentUuid":"7ed1cbf7-0266-4d43-8d40-19ec35136789","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01RxaEqfLCa5hKTNYFWyznoh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LTrvr8zLN1g7aWTjQ6K9RM","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/erk/branch-naming.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":61996,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHX3yhfyqtqf7JHzZhq","type":"assistant","uuid":"61556a99-d06d-46d5-84eb-ba521c1e9e0a","timestamp":"2026-02-22T14:43:56.636Z"}
{"parentUuid":"61556a99-d06d-46d5-84eb-ba521c1e9e0a","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01RxaEqfLCa5hKTNYFWyznoh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01M9D15afzG5J2WxsBbZ123F","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/planning/branch-name-inference.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":61996,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHX3yhfyqtqf7JHzZhq","type":"assistant","uuid":"1cebbd4c-8aff-481f-bb2f-689a03d88617","timestamp":"2026-02-22T14:43:57.226Z"}
{"parentUuid":"1cebbd4c-8aff-481f-bb2f-689a03d88617","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01A2QDqFE5bRyrf9hqYaGPkz","type":"tool_result","content":"     1→---\n     2→title: Plan Title Prefix System\n     3→read_when:\n     4→  - \"working with PR titles for plan implementations\"\n     5→  - \"understanding the planned/ prefix on PR titles\"\n     6→  - \"debugging why a PR title has or lacks the planned/ prefix\"\n     7→---\n     8→\n     9→# Plan Title Prefix System\n    10→\n    11→Plan-linked PRs use a `planned/` prefix in their title to distinguish them from regular PRs at a glance. The prefix is managed by a constant and applied idempotently across three independent code paths.\n    12→\n    13→## Constant\n    14→\n    15→`PLANNED_PR_TITLE_PREFIX = \"planned/\"` is defined in `src/erk/cli/constants.py:13`.\n    16→\n    17→## Three Code Paths\n    18→\n    19→The prefix is applied in three places, each serving a different submission flow:\n    20→\n    21→<!-- Source: src/erk/cli/commands/submit.py, _add_planned_prefix -->\n    22→<!-- Source: src/erk/cli/commands/pr/submit_pipeline.py, _add_planned_prefix -->\n    23→\n    24→| File                                         | Symbol                  | When Used                                     |\n    25→| -------------------------------------------- | ----------------------- | --------------------------------------------- |\n    26→| `src/erk/cli/commands/submit.py`             | `_add_planned_prefix()` | Direct `erk submit` command                   |\n    27→| `src/erk/cli/commands/pr/submit_pipeline.py` | `_add_planned_prefix()` | `erk pr submit` pipeline                      |\n    28→| `.claude/commands/erk/git-pr-push.md`        | Slash command template  | `/erk:git-pr-push` (non-Graphite PR creation) |\n    29→\n    30→## Idempotency Pattern\n    31→\n    32→All three implementations check `title.startswith(PLANNED_PR_TITLE_PREFIX)` before applying, making the prefix application idempotent. This prevents double-prefixing when a PR title is rewritten or resubmitted.\n    33→\n    34→## Intentional Duplication\n    35→\n    36→The `_add_planned_prefix()` function exists in both `submit.py` and `submit_pipeline.py`. This is intentional — the two modules operate in different command flows with different state threading patterns, and sharing the function would create an undesirable coupling. The slash command uses a shell-level check (`planned/${pr_title}`) for the same reason.\n    37→\n    38→## Title Tag vs Title Prefix\n    39→\n    40→Two separate systems modify PR titles:\n    41→\n    42→- **Title tag**: `[erk-plan]` or `[erk-learn]` — added by `get_title_tag_from_labels()` in `packages/erk-shared/src/erk_shared/plan_utils.py:178-190`. This identifies the plan type.\n    43→- **Title prefix**: `planned/` — added by `_add_planned_prefix()`. This signals that the PR is an active plan implementation.\n    44→\n    45→Both can apply simultaneously, producing titles like `planned/[erk-plan] My Feature`.\n    46→\n    47→## Related Documentation\n    48→\n    49→- [Draft PR Plan Backend](draft-pr-plan-backend.md) — Backend that uses title prefixing\n    50→- [PR Submit Pipeline](../cli/pr-submit-pipeline.md) — Pipeline that applies the prefix\n    51→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b2b0dec4-3c15-47d1-b0dd-3f39d1ee7f11","timestamp":"2026-02-22T14:43:57.248Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/docs/learned/planning/plan-title-prefix-system.md","content":"---\ntitle: Plan Title Prefix System\nread_when:\n  - \"working with PR titles for plan implementations\"\n  - \"understanding the planned/ prefix on PR titles\"\n  - \"debugging why a PR title has or lacks the planned/ prefix\"\n---\n\n# Plan Title Prefix System\n\nPlan-linked PRs use a `planned/` prefix in their title to distinguish them from regular PRs at a glance. The prefix is managed by a constant and applied idempotently across three independent code paths.\n\n## Constant\n\n`PLANNED_PR_TITLE_PREFIX = \"planned/\"` is defined in `src/erk/cli/constants.py:13`.\n\n## Three Code Paths\n\nThe prefix is applied in three places, each serving a different submission flow:\n\n<!-- Source: src/erk/cli/commands/submit.py, _add_planned_prefix -->\n<!-- Source: src/erk/cli/commands/pr/submit_pipeline.py, _add_planned_prefix -->\n\n| File                                         | Symbol                  | When Used                                     |\n| -------------------------------------------- | ----------------------- | --------------------------------------------- |\n| `src/erk/cli/commands/submit.py`             | `_add_planned_prefix()` | Direct `erk submit` command                   |\n| `src/erk/cli/commands/pr/submit_pipeline.py` | `_add_planned_prefix()` | `erk pr submit` pipeline                      |\n| `.claude/commands/erk/git-pr-push.md`        | Slash command template  | `/erk:git-pr-push` (non-Graphite PR creation) |\n\n## Idempotency Pattern\n\nAll three implementations check `title.startswith(PLANNED_PR_TITLE_PREFIX)` before applying, making the prefix application idempotent. This prevents double-prefixing when a PR title is rewritten or resubmitted.\n\n## Intentional Duplication\n\nThe `_add_planned_prefix()` function exists in both `submit.py` and `submit_pipeline.py`. This is intentional — the two modules operate in different command flows with different state threading patterns, and sharing the function would create an undesirable coupling. The slash command uses a shell-level check (`planned/${pr_title}`) for the same reason.\n\n## Title Tag vs Title Prefix\n\nTwo separate systems modify PR titles:\n\n- **Title tag**: `[erk-plan]` or `[erk-learn]` — added by `get_title_tag_from_labels()` in `packages/erk-shared/src/erk_shared/plan_utils.py:178-190`. This identifies the plan type.\n- **Title prefix**: `planned/` — added by `_add_planned_prefix()`. This signals that the PR is an active plan implementation.\n\nBoth can apply simultaneously, producing titles like `planned/[erk-plan] My Feature`.\n\n## Related Documentation\n\n- [Draft PR Plan Backend](draft-pr-plan-backend.md) — Backend that uses title prefixing\n- [PR Submit Pipeline](../cli/pr-submit-pipeline.md) — Pipeline that applies the prefix\n","numLines":51,"startLine":1,"totalLines":51}}}
{"parentUuid":"b2b0dec4-3c15-47d1-b0dd-3f39d1ee7f11","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LTrvr8zLN1g7aWTjQ6K9RM","type":"tool_result","content":"     1→---\n     2→title: Branch Naming Conventions\n     3→read_when:\n     4→  - \"creating or modifying branch name generation\"\n     5→  - \"extracting issue or objective numbers from branch names\"\n     6→  - \"working with generate_issue_branch_name(), generate_draft_pr_branch_name(), or extract functions\"\n     7→tripwires:\n     8→  - action: \"constructing branch names manually\"\n     9→    warning: \"Use generate_issue_branch_name() for consistent objective ID encoding.\"\n    10→last_audited: \"2026-02-17 00:00 PT\"\n    11→audit_result: clean\n    12→---\n    13→\n    14→# Branch Naming Conventions\n    15→\n    16→All erk-managed branches follow a canonical naming pattern that encodes plan and objective references for downstream inference.\n    17→\n    18→## Canonical Function\n    19→\n    20→<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_issue_branch_name -->\n    21→\n    22→See `generate_issue_branch_name()` in `packages/erk-shared/src/erk_shared/naming.py`. Accepts `issue_number`, `title`, `timestamp`, and optional `objective_id` keyword argument.\n    23→\n    24→## Branch Format\n    25→\n    26→### Issue-Based Branches\n    27→\n    28→**Without objective:**\n    29→\n    30→```\n    31→P{issue}-{slug}-{MM-DD-HHMM}\n    32→```\n    33→\n    34→**With objective:**\n    35→\n    36→```\n    37→P{issue}-O{objective}-{slug}-{MM-DD-HHMM}\n    38→```\n    39→\n    40→**Examples:**\n    41→\n    42→- `P123-fix-auth-bug-01-15-1430`\n    43→- `P123-O456-fix-auth-bug-01-15-1430`\n    44→\n    45→### Draft-PR Branches\n    46→\n    47→**Without objective:**\n    48→\n    49→```\n    50→planned/{slug}-{MM-DD-HHMM}\n    51→```\n    52→\n    53→**With objective:**\n    54→\n    55→```\n    56→planned/O{objective}-{slug}-{MM-DD-HHMM}\n    57→```\n    58→\n    59→**Examples:**\n    60→\n    61→- `planned/fix-auth-bug-01-15-1430`\n    62→- `planned/O456-fix-auth-bug-01-15-1430`\n    63→\n    64→Draft-PR branches have no extractable plan ID from the branch name. `plan-ref.json` is the sole source of truth.\n    65→\n    66→**Constraints:**\n    67→\n    68→- Prefix (`P{num}-` or `P{num}-O{obj}-` or `planned/`) + sanitized title must not exceed 31 characters\n    69→- Title is sanitized via `sanitize_worktree_name()` (lowercased, special chars replaced with hyphens)\n    70→- Timestamp suffix: `-MM-DD-HHMM` format\n    71→- Trailing hyphens stripped before timestamp\n    72→\n    73→## Extraction Functions\n    74→\n    75→### extract_leading_issue_number()\n    76→\n    77→<!-- Source: packages/erk-shared/src/erk_shared/naming.py, extract_leading_issue_number -->\n    78→\n    79→Extracts the plan issue number from a branch name. See `extract_leading_issue_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n    80→\n    81→- `\"P2382-convert-erk-create-12-05-2359\"` -> `2382`\n    82→- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `123`\n    83→- Supports legacy format without `P` prefix for backwards compatibility\n    84→\n    85→### extract_objective_number()\n    86→\n    87→<!-- Source: packages/erk-shared/src/erk_shared/naming.py, extract_objective_number -->\n    88→\n    89→Extracts the optional objective ID from a branch name. Supports both issue-based (`P{issue}-O{obj}-`) and draft-PR (`planned/O{obj}-`) patterns. See `extract_objective_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n    90→\n    91→- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `456`\n    92→- `\"planned/O456-fix-auth-01-15-1430\"` -> `456`\n    93→- `\"P123-fix-auth-bug-01-15-1430\"` -> `None`\n    94→- `\"planned/fix-auth-bug-01-15-1430\"` -> `None`\n    95→- Case-insensitive: `\"P123-o456-fix-bug\"` -> `456`\n    96→\n    97→## Usage Sites\n    98→\n    99→Branch creation codepaths delegate to one of two functions depending on whether a plan issue exists:\n   100→\n   101→**`generate_issue_branch_name()`** — for issue-backed plans (`P{issue}-...`):\n   102→\n   103→| Codepath              | File                                        |\n   104→| --------------------- | ------------------------------------------- |\n   105→| Plan submit           | `src/erk/cli/commands/submit.py`            |\n   106→| One-shot dispatch     | `src/erk/cli/commands/one_shot_dispatch.py` |\n   107→| setup-impl-from-issue | Branch creation during implementation       |\n   108→\n   109→**`generate_draft_pr_branch_name()`** — for draft-PR plans (`planned/...`):\n   110→\n   111→| Codepath                 | File                                                            |\n   112→| ------------------------ | --------------------------------------------------------------- |\n   113→| Plan save (draft-PR)     | `src/erk/cli/commands/exec/scripts/plan_save.py`                |\n   114→| Plan migrate to draft-PR | `src/erk/cli/commands/exec/scripts/plan_migrate_to_draft_pr.py` |\n   115→\n   116→The one-shot dispatch also has a fallback for non-plan tasks: `oneshot-{slug}-{MM-DD-HHMM}`.\n   117→\n   118→## Related Topics\n   119→\n   120→- [Branch Name Inference](../planning/branch-name-inference.md) - How plan/PR recovery uses the P{issue} prefix contract\n   121→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"59de8949-54f3-4143-909f-c3309a3868c2","timestamp":"2026-02-22T14:43:57.248Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/docs/learned/erk/branch-naming.md","content":"---\ntitle: Branch Naming Conventions\nread_when:\n  - \"creating or modifying branch name generation\"\n  - \"extracting issue or objective numbers from branch names\"\n  - \"working with generate_issue_branch_name(), generate_draft_pr_branch_name(), or extract functions\"\ntripwires:\n  - action: \"constructing branch names manually\"\n    warning: \"Use generate_issue_branch_name() for consistent objective ID encoding.\"\nlast_audited: \"2026-02-17 00:00 PT\"\naudit_result: clean\n---\n\n# Branch Naming Conventions\n\nAll erk-managed branches follow a canonical naming pattern that encodes plan and objective references for downstream inference.\n\n## Canonical Function\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_issue_branch_name -->\n\nSee `generate_issue_branch_name()` in `packages/erk-shared/src/erk_shared/naming.py`. Accepts `issue_number`, `title`, `timestamp`, and optional `objective_id` keyword argument.\n\n## Branch Format\n\n### Issue-Based Branches\n\n**Without objective:**\n\n```\nP{issue}-{slug}-{MM-DD-HHMM}\n```\n\n**With objective:**\n\n```\nP{issue}-O{objective}-{slug}-{MM-DD-HHMM}\n```\n\n**Examples:**\n\n- `P123-fix-auth-bug-01-15-1430`\n- `P123-O456-fix-auth-bug-01-15-1430`\n\n### Draft-PR Branches\n\n**Without objective:**\n\n```\nplanned/{slug}-{MM-DD-HHMM}\n```\n\n**With objective:**\n\n```\nplanned/O{objective}-{slug}-{MM-DD-HHMM}\n```\n\n**Examples:**\n\n- `planned/fix-auth-bug-01-15-1430`\n- `planned/O456-fix-auth-bug-01-15-1430`\n\nDraft-PR branches have no extractable plan ID from the branch name. `plan-ref.json` is the sole source of truth.\n\n**Constraints:**\n\n- Prefix (`P{num}-` or `P{num}-O{obj}-` or `planned/`) + sanitized title must not exceed 31 characters\n- Title is sanitized via `sanitize_worktree_name()` (lowercased, special chars replaced with hyphens)\n- Timestamp suffix: `-MM-DD-HHMM` format\n- Trailing hyphens stripped before timestamp\n\n## Extraction Functions\n\n### extract_leading_issue_number()\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, extract_leading_issue_number -->\n\nExtracts the plan issue number from a branch name. See `extract_leading_issue_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n\n- `\"P2382-convert-erk-create-12-05-2359\"` -> `2382`\n- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `123`\n- Supports legacy format without `P` prefix for backwards compatibility\n\n### extract_objective_number()\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, extract_objective_number -->\n\nExtracts the optional objective ID from a branch name. Supports both issue-based (`P{issue}-O{obj}-`) and draft-PR (`planned/O{obj}-`) patterns. See `extract_objective_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n\n- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `456`\n- `\"planned/O456-fix-auth-01-15-1430\"` -> `456`\n- `\"P123-fix-auth-bug-01-15-1430\"` -> `None`\n- `\"planned/fix-auth-bug-01-15-1430\"` -> `None`\n- Case-insensitive: `\"P123-o456-fix-bug\"` -> `456`\n\n## Usage Sites\n\nBranch creation codepaths delegate to one of two functions depending on whether a plan issue exists:\n\n**`generate_issue_branch_name()`** — for issue-backed plans (`P{issue}-...`):\n\n| Codepath              | File                                        |\n| --------------------- | ------------------------------------------- |\n| Plan submit           | `src/erk/cli/commands/submit.py`            |\n| One-shot dispatch     | `src/erk/cli/commands/one_shot_dispatch.py` |\n| setup-impl-from-issue | Branch creation during implementation       |\n\n**`generate_draft_pr_branch_name()`** — for draft-PR plans (`planned/...`):\n\n| Codepath                 | File                                                            |\n| ------------------------ | --------------------------------------------------------------- |\n| Plan save (draft-PR)     | `src/erk/cli/commands/exec/scripts/plan_save.py`                |\n| Plan migrate to draft-PR | `src/erk/cli/commands/exec/scripts/plan_migrate_to_draft_pr.py` |\n\nThe one-shot dispatch also has a fallback for non-plan tasks: `oneshot-{slug}-{MM-DD-HHMM}`.\n\n## Related Topics\n\n- [Branch Name Inference](../planning/branch-name-inference.md) - How plan/PR recovery uses the P{issue} prefix contract\n","numLines":121,"startLine":1,"totalLines":121}}}
{"parentUuid":"59de8949-54f3-4143-909f-c3309a3868c2","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01M9D15afzG5J2WxsBbZ123F","type":"tool_result","content":"     1→---\n     2→title: Branch Name Inference\n     3→last_audited: \"2026-02-08 00:00 PT\"\n     4→audit_result: clean\n     5→tripwires:\n     6→  - action: \"changing branch naming convention (P{issue}- or planned/ prefix)\"\n     7→    warning: \"The P{issue}- prefix (issue-based) and planned/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\"\n     8→  - action: \"adding branch_name to plan-header at creation time\"\n     9→    warning: \"branch_name is intentionally omitted at creation because the branch doesn't exist yet. The plan-save → branch-create → impl-signal lifecycle requires this gap. See the temporal gap section below.\"\n    10→read_when:\n    11→  - \"debugging missing branch_name in plan issues\"\n    12→  - \"implementing PR lookup from plan issues\"\n    13→  - \"modifying branch creation or naming conventions\"\n    14→---\n    15→\n    16→# Branch Name Inference\n    17→\n    18→## The Temporal Gap Problem\n    19→\n    20→Plan metadata (`plan-header` block) intentionally omits `branch_name` at creation time because of a temporal gap in the plan lifecycle:\n    21→\n    22→1. **Plan saved** → GitHub issue created (no branch exists yet)\n    23→2. **Branch created** → User runs `erk br co --for-plan {issue}` (branch now exists)\n    24→3. **Implementation starts** → `impl-signal started` writes `branch_name` into the plan-header\n    25→\n    26→The gap between steps 1 and 2 is unavoidable: the plan must exist before the branch can be named after it (the branch name contains the issue number). Attempting to set `branch_name` during save would require either predicting the branch name (fragile — the user might choose a custom name) or creating the branch immediately (wrong — the user hasn't started work yet).\n    27→\n    28→## Two-Layer Resolution\n    29→\n    30→When code needs to look up a PR from a plan issue, `branch_name` may be missing from metadata. The system uses two layers:\n    31→\n    32→<!-- Source: src/erk/cli/commands/exec/scripts/get_pr_for_plan.py, get_pr_for_plan -->\n    33→\n    34→**Layer 1 — Metadata lookup**: Read `branch_name` from the `plan-header` block. This succeeds when `impl-signal started` ran successfully.\n    35→\n    36→**Layer 2 — Git context inference**: If `branch_name` is missing, check whether the current git branch matches the `P{issue_number}-` prefix. If it does, use it. This is a fail-open recovery that handles two scenarios:\n    37→\n    38→- `impl-signal` never ran (user created branch manually following the naming convention)\n    39→- `impl-signal` failed (command errored but user continued working)\n    40→\n    41→If neither layer produces a match, the command fails with an actionable error.\n    42→\n    43→## Branch Prefix Contracts\n    44→\n    45→The inference recovery depends on **cross-cutting naming contracts**. There are two branch patterns:\n    46→\n    47→### Issue-Based Branches: `P{issue}-`\n    48→\n    49→Branches for issue-based plans start with `P{issue_number}-`. This prefix is generated by two independent code paths that must stay in sync:\n    50→\n    51→<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_issue_branch_name -->\n    52→\n    53→- **Branch creation**: `generate_issue_branch_name()` produces `P{issue}-{slug}-{timestamp}` format (with optional `O{objective_id}` segment)\n    54→\n    55→<!-- Source: src/erk/cli/commands/exec/scripts/get_pr_for_plan.py, get_pr_for_plan -->\n    56→\n    57→- **PR recovery**: `get_pr_for_plan` checks `current_branch.startswith(f\"P{issue_number}-\")`\n    58→\n    59→The prefix is the stable part of the contract. The slug and timestamp segments after the prefix vary, but inference only needs the prefix to establish the plan-to-branch mapping.\n    60→\n    61→### Draft-PR Branches: `planned/`\n    62→\n    63→Branches for draft-PR plans start with `planned/` and follow the pattern `planned/{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone.\n    64→\n    65→<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_draft_pr_branch_name -->\n    66→\n    67→- **Branch creation**: `generate_draft_pr_branch_name()` produces `planned/{slug}-{timestamp}`\n    68→- **Plan ID resolution**: `DraftPRPlanBackend.resolve_plan_id_for_branch()` uses an API call, not regex\n    69→- **Source of truth**: `plan-ref.json` is the sole source of plan ID for draft-PR branches\n    70→- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `planned/` branches; `extract_objective_number()` handles both `P{issue}-O{obj}-` and `planned/O{obj}-` patterns\n    71→\n    72→## When Inference Fails\n    73→\n    74→Common failure scenarios and their fixes:\n    75→\n    76→| Symptom                                | Cause                                                | Fix                                                                     |\n    77→| -------------------------------------- | ---------------------------------------------------- | ----------------------------------------------------------------------- |\n    78→| \"plan-header has no branch_name field\" | On wrong branch (e.g., `master`)                     | Switch to the plan's feature branch                                     |\n    79→| \"plan-header has no branch_name field\" | Branch uses non-standard name (e.g., `feature/1234`) | Rename branch to `P{issue}-...` or manually update plan-header metadata |\n    80→| \"No PR found for branch\"               | Branch exists but no PR was created                  | Push branch and create PR first                                         |\n    81→\n    82→## Relationship to Fail-Open Pattern\n    83→\n    84→This is an instance of the [fail-open pattern](../architecture/fail-open-patterns.md) with defense-in-depth:\n    85→\n    86→- **Primary mechanism**: `impl-signal started` explicitly writes `branch_name` into metadata (reliable when the full workflow runs)\n    87→- **Fallback mechanism**: Pattern matching against git context (enables manual workflows and recovers from signal failures)\n    88→- **Key distinction**: The fallback isn't just error recovery — it actively enables workflows where `impl-signal` was never intended to run (e.g., implementing a plan created by another developer, or plans created before `impl-signal` existed)\n    89→\n    90→## Related Documentation\n    91→\n    92→- [Fail-Open Patterns](../architecture/fail-open-patterns.md) — Defense-in-depth design pattern\n    93→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"674dfbb1-a000-4f40-9c96-98fc3e9e1674","timestamp":"2026-02-22T14:43:57.248Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/docs/learned/planning/branch-name-inference.md","content":"---\ntitle: Branch Name Inference\nlast_audited: \"2026-02-08 00:00 PT\"\naudit_result: clean\ntripwires:\n  - action: \"changing branch naming convention (P{issue}- or planned/ prefix)\"\n    warning: \"The P{issue}- prefix (issue-based) and planned/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\"\n  - action: \"adding branch_name to plan-header at creation time\"\n    warning: \"branch_name is intentionally omitted at creation because the branch doesn't exist yet. The plan-save → branch-create → impl-signal lifecycle requires this gap. See the temporal gap section below.\"\nread_when:\n  - \"debugging missing branch_name in plan issues\"\n  - \"implementing PR lookup from plan issues\"\n  - \"modifying branch creation or naming conventions\"\n---\n\n# Branch Name Inference\n\n## The Temporal Gap Problem\n\nPlan metadata (`plan-header` block) intentionally omits `branch_name` at creation time because of a temporal gap in the plan lifecycle:\n\n1. **Plan saved** → GitHub issue created (no branch exists yet)\n2. **Branch created** → User runs `erk br co --for-plan {issue}` (branch now exists)\n3. **Implementation starts** → `impl-signal started` writes `branch_name` into the plan-header\n\nThe gap between steps 1 and 2 is unavoidable: the plan must exist before the branch can be named after it (the branch name contains the issue number). Attempting to set `branch_name` during save would require either predicting the branch name (fragile — the user might choose a custom name) or creating the branch immediately (wrong — the user hasn't started work yet).\n\n## Two-Layer Resolution\n\nWhen code needs to look up a PR from a plan issue, `branch_name` may be missing from metadata. The system uses two layers:\n\n<!-- Source: src/erk/cli/commands/exec/scripts/get_pr_for_plan.py, get_pr_for_plan -->\n\n**Layer 1 — Metadata lookup**: Read `branch_name` from the `plan-header` block. This succeeds when `impl-signal started` ran successfully.\n\n**Layer 2 — Git context inference**: If `branch_name` is missing, check whether the current git branch matches the `P{issue_number}-` prefix. If it does, use it. This is a fail-open recovery that handles two scenarios:\n\n- `impl-signal` never ran (user created branch manually following the naming convention)\n- `impl-signal` failed (command errored but user continued working)\n\nIf neither layer produces a match, the command fails with an actionable error.\n\n## Branch Prefix Contracts\n\nThe inference recovery depends on **cross-cutting naming contracts**. There are two branch patterns:\n\n### Issue-Based Branches: `P{issue}-`\n\nBranches for issue-based plans start with `P{issue_number}-`. This prefix is generated by two independent code paths that must stay in sync:\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_issue_branch_name -->\n\n- **Branch creation**: `generate_issue_branch_name()` produces `P{issue}-{slug}-{timestamp}` format (with optional `O{objective_id}` segment)\n\n<!-- Source: src/erk/cli/commands/exec/scripts/get_pr_for_plan.py, get_pr_for_plan -->\n\n- **PR recovery**: `get_pr_for_plan` checks `current_branch.startswith(f\"P{issue_number}-\")`\n\nThe prefix is the stable part of the contract. The slug and timestamp segments after the prefix vary, but inference only needs the prefix to establish the plan-to-branch mapping.\n\n### Draft-PR Branches: `planned/`\n\nBranches for draft-PR plans start with `planned/` and follow the pattern `planned/{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone.\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_draft_pr_branch_name -->\n\n- **Branch creation**: `generate_draft_pr_branch_name()` produces `planned/{slug}-{timestamp}`\n- **Plan ID resolution**: `DraftPRPlanBackend.resolve_plan_id_for_branch()` uses an API call, not regex\n- **Source of truth**: `plan-ref.json` is the sole source of plan ID for draft-PR branches\n- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `planned/` branches; `extract_objective_number()` handles both `P{issue}-O{obj}-` and `planned/O{obj}-` patterns\n\n## When Inference Fails\n\nCommon failure scenarios and their fixes:\n\n| Symptom                                | Cause                                                | Fix                                                                     |\n| -------------------------------------- | ---------------------------------------------------- | ----------------------------------------------------------------------- |\n| \"plan-header has no branch_name field\" | On wrong branch (e.g., `master`)                     | Switch to the plan's feature branch                                     |\n| \"plan-header has no branch_name field\" | Branch uses non-standard name (e.g., `feature/1234`) | Rename branch to `P{issue}-...` or manually update plan-header metadata |\n| \"No PR found for branch\"               | Branch exists but no PR was created                  | Push branch and create PR first                                         |\n\n## Relationship to Fail-Open Pattern\n\nThis is an instance of the [fail-open pattern](../architecture/fail-open-patterns.md) with defense-in-depth:\n\n- **Primary mechanism**: `impl-signal started` explicitly writes `branch_name` into metadata (reliable when the full workflow runs)\n- **Fallback mechanism**: Pattern matching against git context (enables manual workflows and recovers from signal failures)\n- **Key distinction**: The fallback isn't just error recovery — it actively enables workflows where `impl-signal` was never intended to run (e.g., implementing a plan created by another developer, or plans created before `impl-signal` existed)\n\n## Related Documentation\n\n- [Fail-Open Patterns](../architecture/fail-open-patterns.md) — Defense-in-depth design pattern\n","numLines":93,"startLine":1,"totalLines":93}}}
{"parentUuid":"674dfbb1-a000-4f40-9c96-98fc3e9e1674","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_016TjGJYPFZjFYLGGqs4feZW","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update all three documentation files:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4966,"cache_read_input_tokens":62571,"cache_creation":{"ephemeral_5m_input_tokens":4966,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHXNdNX6yHhPm7uwAQ1","type":"assistant","uuid":"04b8d4a1-2015-4906-a78e-38a637b856fd","timestamp":"2026-02-22T14:44:00.148Z"}
{"parentUuid":"04b8d4a1-2015-4906-a78e-38a637b856fd","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_016TjGJYPFZjFYLGGqs4feZW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018WMy5a7ttGqbhWXe6STgTr","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/planning/plan-title-prefix-system.md","old_string":"---\ntitle: Plan Title Prefix System\nread_when:\n  - \"working with PR titles for plan implementations\"\n  - \"understanding the planned/ prefix on PR titles\"\n  - \"debugging why a PR title has or lacks the planned/ prefix\"\n---\n\n# Plan Title Prefix System\n\nPlan-linked PRs use a `planned/` prefix in their title to distinguish them from regular PRs at a glance. The prefix is managed by a constant and applied idempotently across three independent code paths.\n\n## Constant\n\n`PLANNED_PR_TITLE_PREFIX = \"planned/\"` is defined in `src/erk/cli/constants.py:13`.","new_string":"---\ntitle: Plan Title Prefix System\nread_when:\n  - \"working with PR titles for plan implementations\"\n  - \"understanding the plnd/ prefix on PR titles\"\n  - \"debugging why a PR title has or lacks the plnd/ prefix\"\n---\n\n# Plan Title Prefix System\n\nPlan-linked PRs use a `plnd/` prefix in their title to distinguish them from regular PRs at a glance. The prefix is managed by a constant and applied idempotently across three independent code paths.\n\n## Constant\n\n`PLANNED_PR_TITLE_PREFIX = \"plnd/\"` is defined in `src/erk/cli/constants.py:13`."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4966,"cache_read_input_tokens":62571,"cache_creation":{"ephemeral_5m_input_tokens":4966,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHXNdNX6yHhPm7uwAQ1","type":"assistant","uuid":"6e4c3cd5-8b1c-439d-9595-962a54b3a5b6","timestamp":"2026-02-22T14:44:05.649Z"}
{"parentUuid":"6e4c3cd5-8b1c-439d-9595-962a54b3a5b6","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018WMy5a7ttGqbhWXe6STgTr","type":"tool_result","content":"The file /home/runner/work/erk/erk/docs/learned/planning/plan-title-prefix-system.md has been updated successfully."}]},"uuid":"76540495-56a8-4fbb-916b-ff5c4a3e7d19","timestamp":"2026-02-22T14:44:06.330Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/docs/learned/planning/plan-title-prefix-system.md","oldString":"---\ntitle: Plan Title Prefix System\nread_when:\n  - \"working with PR titles for plan implementations\"\n  - \"understanding the planned/ prefix on PR titles\"\n  - \"debugging why a PR title has or lacks the planned/ prefix\"\n---\n\n# Plan Title Prefix System\n\nPlan-linked PRs use a `planned/` prefix in their title to distinguish them from regular PRs at a glance. The prefix is managed by a constant and applied idempotently across three independent code paths.\n\n## Constant\n\n`PLANNED_PR_TITLE_PREFIX = \"planned/\"` is defined in `src/erk/cli/constants.py:13`.","newString":"---\ntitle: Plan Title Prefix System\nread_when:\n  - \"working with PR titles for plan implementations\"\n  - \"understanding the plnd/ prefix on PR titles\"\n  - \"debugging why a PR title has or lacks the plnd/ prefix\"\n---\n\n# Plan Title Prefix System\n\nPlan-linked PRs use a `plnd/` prefix in their title to distinguish them from regular PRs at a glance. The prefix is managed by a constant and applied idempotently across three independent code paths.\n\n## Constant\n\n`PLANNED_PR_TITLE_PREFIX = \"plnd/\"` is defined in `src/erk/cli/constants.py:13`.","originalFile":"---\ntitle: Plan Title Prefix System\nread_when:\n  - \"working with PR titles for plan implementations\"\n  - \"understanding the planned/ prefix on PR titles\"\n  - \"debugging why a PR title has or lacks the planned/ prefix\"\n---\n\n# Plan Title Prefix System\n\nPlan-linked PRs use a `planned/` prefix in their title to distinguish them from regular PRs at a glance. The prefix is managed by a constant and applied idempotently across three independent code paths.\n\n## Constant\n\n`PLANNED_PR_TITLE_PREFIX = \"planned/\"` is defined in `src/erk/cli/constants.py:13`.\n\n## Three Code Paths\n\nThe prefix is applied in three places, each serving a different submission flow:\n\n<!-- Source: src/erk/cli/commands/submit.py, _add_planned_prefix -->\n<!-- Source: src/erk/cli/commands/pr/submit_pipeline.py, _add_planned_prefix -->\n\n| File                                         | Symbol                  | When Used                                     |\n| -------------------------------------------- | ----------------------- | --------------------------------------------- |\n| `src/erk/cli/commands/submit.py`             | `_add_planned_prefix()` | Direct `erk submit` command                   |\n| `src/erk/cli/commands/pr/submit_pipeline.py` | `_add_planned_prefix()` | `erk pr submit` pipeline                      |\n| `.claude/commands/erk/git-pr-push.md`        | Slash command template  | `/erk:git-pr-push` (non-Graphite PR creation) |\n\n## Idempotency Pattern\n\nAll three implementations check `title.startswith(PLANNED_PR_TITLE_PREFIX)` before applying, making the prefix application idempotent. This prevents double-prefixing when a PR title is rewritten or resubmitted.\n\n## Intentional Duplication\n\nThe `_add_planned_prefix()` function exists in both `submit.py` and `submit_pipeline.py`. This is intentional — the two modules operate in different command flows with different state threading patterns, and sharing the function would create an undesirable coupling. The slash command uses a shell-level check (`planned/${pr_title}`) for the same reason.\n\n## Title Tag vs Title Prefix\n\nTwo separate systems modify PR titles:\n\n- **Title tag**: `[erk-plan]` or `[erk-learn]` — added by `get_title_tag_from_labels()` in `packages/erk-shared/src/erk_shared/plan_utils.py:178-190`. This identifies the plan type.\n- **Title prefix**: `planned/` — added by `_add_planned_prefix()`. This signals that the PR is an active plan implementation.\n\nBoth can apply simultaneously, producing titles like `planned/[erk-plan] My Feature`.\n\n## Related Documentation\n\n- [Draft PR Plan Backend](draft-pr-plan-backend.md) — Backend that uses title prefixing\n- [PR Submit Pipeline](../cli/pr-submit-pipeline.md) — Pipeline that applies the prefix\n","structuredPatch":[{"oldStart":2,"oldLines":17,"newStart":2,"newLines":17,"lines":[" title: Plan Title Prefix System"," read_when:","   - \"working with PR titles for plan implementations\"","-  - \"understanding the planned/ prefix on PR titles\"","-  - \"debugging why a PR title has or lacks the planned/ prefix\"","+  - \"understanding the plnd/ prefix on PR titles\"","+  - \"debugging why a PR title has or lacks the plnd/ prefix\""," ---"," "," # Plan Title Prefix System"," ","-Plan-linked PRs use a `planned/` prefix in their title to distinguish them from regular PRs at a glance. The prefix is managed by a constant and applied idempotently across three independent code paths.","+Plan-linked PRs use a `plnd/` prefix in their title to distinguish them from regular PRs at a glance. The prefix is managed by a constant and applied idempotently across three independent code paths."," "," ## Constant"," ","-`PLANNED_PR_TITLE_PREFIX = \"planned/\"` is defined in `src/erk/cli/constants.py:13`.","+`PLANNED_PR_TITLE_PREFIX = \"plnd/\"` is defined in `src/erk/cli/constants.py:13`."," "," ## Three Code Paths"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"76540495-56a8-4fbb-916b-ff5c4a3e7d19","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01RcwnHwqFy8FbsDMCq2W5KW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XrXxpwgMKZozakfpd5RfNJ","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/planning/plan-title-prefix-system.md","old_string":"All three implementations check `title.startswith(PLANNED_PR_TITLE_PREFIX)` before applying, making the prefix application idempotent. This prevents double-prefixing when a PR title is rewritten or resubmitted.\n\n## Intentional Duplication\n\nThe `_add_planned_prefix()` function exists in both `submit.py` and `submit_pipeline.py`. This is intentional — the two modules operate in different command flows with different state threading patterns, and sharing the function would create an undesirable coupling. The slash command uses a shell-level check (`planned/${pr_title}`) for the same reason.","new_string":"All three implementations check `title.startswith(PLANNED_PR_TITLE_PREFIX)` before applying, making the prefix application idempotent. This prevents double-prefixing when a PR title is rewritten or resubmitted.\n\n## Intentional Duplication\n\nThe `_add_planned_prefix()` function exists in both `submit.py` and `submit_pipeline.py`. This is intentional — the two modules operate in different command flows with different state threading patterns, and sharing the function would create an undesirable coupling. The slash command uses a shell-level check (`plnd/${pr_title}`) for the same reason."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":812,"cache_read_input_tokens":67537,"cache_creation":{"ephemeral_5m_input_tokens":812,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHY3PkoKAhPbuua6ZrV","type":"assistant","uuid":"4602b89e-7d00-42a8-8c7c-3c84f3ae08d3","timestamp":"2026-02-22T14:44:14.143Z"}
{"parentUuid":"4602b89e-7d00-42a8-8c7c-3c84f3ae08d3","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XrXxpwgMKZozakfpd5RfNJ","type":"tool_result","content":"The file /home/runner/work/erk/erk/docs/learned/planning/plan-title-prefix-system.md has been updated successfully."}]},"uuid":"962286fc-09d4-46d2-9aad-df061a62d7bb","timestamp":"2026-02-22T14:44:14.836Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/docs/learned/planning/plan-title-prefix-system.md","oldString":"All three implementations check `title.startswith(PLANNED_PR_TITLE_PREFIX)` before applying, making the prefix application idempotent. This prevents double-prefixing when a PR title is rewritten or resubmitted.\n\n## Intentional Duplication\n\nThe `_add_planned_prefix()` function exists in both `submit.py` and `submit_pipeline.py`. This is intentional — the two modules operate in different command flows with different state threading patterns, and sharing the function would create an undesirable coupling. The slash command uses a shell-level check (`planned/${pr_title}`) for the same reason.","newString":"All three implementations check `title.startswith(PLANNED_PR_TITLE_PREFIX)` before applying, making the prefix application idempotent. This prevents double-prefixing when a PR title is rewritten or resubmitted.\n\n## Intentional Duplication\n\nThe `_add_planned_prefix()` function exists in both `submit.py` and `submit_pipeline.py`. This is intentional — the two modules operate in different command flows with different state threading patterns, and sharing the function would create an undesirable coupling. The slash command uses a shell-level check (`plnd/${pr_title}`) for the same reason.","originalFile":"---\ntitle: Plan Title Prefix System\nread_when:\n  - \"working with PR titles for plan implementations\"\n  - \"understanding the plnd/ prefix on PR titles\"\n  - \"debugging why a PR title has or lacks the plnd/ prefix\"\n---\n\n# Plan Title Prefix System\n\nPlan-linked PRs use a `plnd/` prefix in their title to distinguish them from regular PRs at a glance. The prefix is managed by a constant and applied idempotently across three independent code paths.\n\n## Constant\n\n`PLANNED_PR_TITLE_PREFIX = \"plnd/\"` is defined in `src/erk/cli/constants.py:13`.\n\n## Three Code Paths\n\nThe prefix is applied in three places, each serving a different submission flow:\n\n<!-- Source: src/erk/cli/commands/submit.py, _add_planned_prefix -->\n<!-- Source: src/erk/cli/commands/pr/submit_pipeline.py, _add_planned_prefix -->\n\n| File                                         | Symbol                  | When Used                                     |\n| -------------------------------------------- | ----------------------- | --------------------------------------------- |\n| `src/erk/cli/commands/submit.py`             | `_add_planned_prefix()` | Direct `erk submit` command                   |\n| `src/erk/cli/commands/pr/submit_pipeline.py` | `_add_planned_prefix()` | `erk pr submit` pipeline                      |\n| `.claude/commands/erk/git-pr-push.md`        | Slash command template  | `/erk:git-pr-push` (non-Graphite PR creation) |\n\n## Idempotency Pattern\n\nAll three implementations check `title.startswith(PLANNED_PR_TITLE_PREFIX)` before applying, making the prefix application idempotent. This prevents double-prefixing when a PR title is rewritten or resubmitted.\n\n## Intentional Duplication\n\nThe `_add_planned_prefix()` function exists in both `submit.py` and `submit_pipeline.py`. This is intentional — the two modules operate in different command flows with different state threading patterns, and sharing the function would create an undesirable coupling. The slash command uses a shell-level check (`planned/${pr_title}`) for the same reason.\n\n## Title Tag vs Title Prefix\n\nTwo separate systems modify PR titles:\n\n- **Title tag**: `[erk-plan]` or `[erk-learn]` — added by `get_title_tag_from_labels()` in `packages/erk-shared/src/erk_shared/plan_utils.py:178-190`. This identifies the plan type.\n- **Title prefix**: `planned/` — added by `_add_planned_prefix()`. This signals that the PR is an active plan implementation.\n\nBoth can apply simultaneously, producing titles like `planned/[erk-plan] My Feature`.\n\n## Related Documentation\n\n- [Draft PR Plan Backend](draft-pr-plan-backend.md) — Backend that uses title prefixing\n- [PR Submit Pipeline](../cli/pr-submit-pipeline.md) — Pipeline that applies the prefix\n","structuredPatch":[{"oldStart":33,"oldLines":7,"newStart":33,"newLines":7,"lines":[" "," ## Intentional Duplication"," ","-The `_add_planned_prefix()` function exists in both `submit.py` and `submit_pipeline.py`. This is intentional — the two modules operate in different command flows with different state threading patterns, and sharing the function would create an undesirable coupling. The slash command uses a shell-level check (`planned/${pr_title}`) for the same reason.","+The `_add_planned_prefix()` function exists in both `submit.py` and `submit_pipeline.py`. This is intentional — the two modules operate in different command flows with different state threading patterns, and sharing the function would create an undesirable coupling. The slash command uses a shell-level check (`plnd/${pr_title}`) for the same reason."," "," ## Title Tag vs Title Prefix"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"962286fc-09d4-46d2-9aad-df061a62d7bb","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_013GEakPFgav2kJc3DJu1AtP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013jESvbJkXdYMfwPArpQz8x","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/planning/plan-title-prefix-system.md","old_string":"- **Title prefix**: `planned/` — added by `_add_planned_prefix()`. This signals that the PR is an active plan implementation.\n\nBoth can apply simultaneously, producing titles like `planned/[erk-plan] My Feature`.","new_string":"- **Title prefix**: `plnd/` — added by `_add_planned_prefix()`. This signals that the PR is an active plan implementation.\n\nBoth can apply simultaneously, producing titles like `plnd/[erk-plan] My Feature`."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":445,"cache_read_input_tokens":68349,"cache_creation":{"ephemeral_5m_input_tokens":445,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHYfmXpDwBmKPd1hyAf","type":"assistant","uuid":"d83cf99a-de59-4480-a5d9-709a34b4d36f","timestamp":"2026-02-22T14:44:19.813Z"}
{"parentUuid":"d83cf99a-de59-4480-a5d9-709a34b4d36f","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013jESvbJkXdYMfwPArpQz8x","type":"tool_result","content":"The file /home/runner/work/erk/erk/docs/learned/planning/plan-title-prefix-system.md has been updated successfully."}]},"uuid":"23a37a44-bb77-465d-a68c-fc35d8c77f97","timestamp":"2026-02-22T14:44:20.488Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/docs/learned/planning/plan-title-prefix-system.md","oldString":"- **Title prefix**: `planned/` — added by `_add_planned_prefix()`. This signals that the PR is an active plan implementation.\n\nBoth can apply simultaneously, producing titles like `planned/[erk-plan] My Feature`.","newString":"- **Title prefix**: `plnd/` — added by `_add_planned_prefix()`. This signals that the PR is an active plan implementation.\n\nBoth can apply simultaneously, producing titles like `plnd/[erk-plan] My Feature`.","originalFile":"---\ntitle: Plan Title Prefix System\nread_when:\n  - \"working with PR titles for plan implementations\"\n  - \"understanding the plnd/ prefix on PR titles\"\n  - \"debugging why a PR title has or lacks the plnd/ prefix\"\n---\n\n# Plan Title Prefix System\n\nPlan-linked PRs use a `plnd/` prefix in their title to distinguish them from regular PRs at a glance. The prefix is managed by a constant and applied idempotently across three independent code paths.\n\n## Constant\n\n`PLANNED_PR_TITLE_PREFIX = \"plnd/\"` is defined in `src/erk/cli/constants.py:13`.\n\n## Three Code Paths\n\nThe prefix is applied in three places, each serving a different submission flow:\n\n<!-- Source: src/erk/cli/commands/submit.py, _add_planned_prefix -->\n<!-- Source: src/erk/cli/commands/pr/submit_pipeline.py, _add_planned_prefix -->\n\n| File                                         | Symbol                  | When Used                                     |\n| -------------------------------------------- | ----------------------- | --------------------------------------------- |\n| `src/erk/cli/commands/submit.py`             | `_add_planned_prefix()` | Direct `erk submit` command                   |\n| `src/erk/cli/commands/pr/submit_pipeline.py` | `_add_planned_prefix()` | `erk pr submit` pipeline                      |\n| `.claude/commands/erk/git-pr-push.md`        | Slash command template  | `/erk:git-pr-push` (non-Graphite PR creation) |\n\n## Idempotency Pattern\n\nAll three implementations check `title.startswith(PLANNED_PR_TITLE_PREFIX)` before applying, making the prefix application idempotent. This prevents double-prefixing when a PR title is rewritten or resubmitted.\n\n## Intentional Duplication\n\nThe `_add_planned_prefix()` function exists in both `submit.py` and `submit_pipeline.py`. This is intentional — the two modules operate in different command flows with different state threading patterns, and sharing the function would create an undesirable coupling. The slash command uses a shell-level check (`plnd/${pr_title}`) for the same reason.\n\n## Title Tag vs Title Prefix\n\nTwo separate systems modify PR titles:\n\n- **Title tag**: `[erk-plan]` or `[erk-learn]` — added by `get_title_tag_from_labels()` in `packages/erk-shared/src/erk_shared/plan_utils.py:178-190`. This identifies the plan type.\n- **Title prefix**: `planned/` — added by `_add_planned_prefix()`. This signals that the PR is an active plan implementation.\n\nBoth can apply simultaneously, producing titles like `planned/[erk-plan] My Feature`.\n\n## Related Documentation\n\n- [Draft PR Plan Backend](draft-pr-plan-backend.md) — Backend that uses title prefixing\n- [PR Submit Pipeline](../cli/pr-submit-pipeline.md) — Pipeline that applies the prefix\n","structuredPatch":[{"oldStart":40,"oldLines":9,"newStart":40,"newLines":9,"lines":[" Two separate systems modify PR titles:"," "," - **Title tag**: `[erk-plan]` or `[erk-learn]` — added by `get_title_tag_from_labels()` in `packages/erk-shared/src/erk_shared/plan_utils.py:178-190`. This identifies the plan type.","-- **Title prefix**: `planned/` — added by `_add_planned_prefix()`. This signals that the PR is an active plan implementation.","+- **Title prefix**: `plnd/` — added by `_add_planned_prefix()`. This signals that the PR is an active plan implementation."," ","-Both can apply simultaneously, producing titles like `planned/[erk-plan] My Feature`.","+Both can apply simultaneously, producing titles like `plnd/[erk-plan] My Feature`."," "," ## Related Documentation"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"23a37a44-bb77-465d-a68c-fc35d8c77f97","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01TeFjr619Zy7LibDt8F9Zp3","type":"message","role":"assistant","content":[{"type":"text","text":"Now update branch-naming.md:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":270,"cache_read_input_tokens":68794,"cache_creation":{"ephemeral_5m_input_tokens":270,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHZ5u6jUzqYxENAM5HV","type":"assistant","uuid":"49586720-c5ae-4a0b-be32-a300c093d270","timestamp":"2026-02-22T14:44:22.595Z"}
{"parentUuid":"49586720-c5ae-4a0b-be32-a300c093d270","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01TeFjr619Zy7LibDt8F9Zp3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TXrmjzgj2gXcgCckTWmrRP","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/erk/branch-naming.md","old_string":"### Draft-PR Branches\n\n**Without objective:**\n\n```\nplanned/{slug}-{MM-DD-HHMM}\n```\n\n**With objective:**\n\n```\nplanned/O{objective}-{slug}-{MM-DD-HHMM}\n```\n\n**Examples:**\n\n- `planned/fix-auth-bug-01-15-1430`\n- `planned/O456-fix-auth-bug-01-15-1430`","new_string":"### Draft-PR Branches\n\n**Without objective:**\n\n```\nplnd/{slug}-{MM-DD-HHMM}\n```\n\n**With objective:**\n\n```\nplnd/O{objective}-{slug}-{MM-DD-HHMM}\n```\n\n**Examples:**\n\n- `plnd/fix-auth-bug-01-15-1430`\n- `plnd/O456-fix-auth-bug-01-15-1430`"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":270,"cache_read_input_tokens":68794,"cache_creation":{"ephemeral_5m_input_tokens":270,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHZ5u6jUzqYxENAM5HV","type":"assistant","uuid":"e3238737-08e9-4555-8a78-73cafdf87f6b","timestamp":"2026-02-22T14:44:25.646Z"}
{"parentUuid":"e3238737-08e9-4555-8a78-73cafdf87f6b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TXrmjzgj2gXcgCckTWmrRP","type":"tool_result","content":"The file /home/runner/work/erk/erk/docs/learned/erk/branch-naming.md has been updated successfully."}]},"uuid":"ba3da7f9-98bd-4ec4-aeaf-d49e798ca638","timestamp":"2026-02-22T14:44:26.316Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/docs/learned/erk/branch-naming.md","oldString":"### Draft-PR Branches\n\n**Without objective:**\n\n```\nplanned/{slug}-{MM-DD-HHMM}\n```\n\n**With objective:**\n\n```\nplanned/O{objective}-{slug}-{MM-DD-HHMM}\n```\n\n**Examples:**\n\n- `planned/fix-auth-bug-01-15-1430`\n- `planned/O456-fix-auth-bug-01-15-1430`","newString":"### Draft-PR Branches\n\n**Without objective:**\n\n```\nplnd/{slug}-{MM-DD-HHMM}\n```\n\n**With objective:**\n\n```\nplnd/O{objective}-{slug}-{MM-DD-HHMM}\n```\n\n**Examples:**\n\n- `plnd/fix-auth-bug-01-15-1430`\n- `plnd/O456-fix-auth-bug-01-15-1430`","originalFile":"---\ntitle: Branch Naming Conventions\nread_when:\n  - \"creating or modifying branch name generation\"\n  - \"extracting issue or objective numbers from branch names\"\n  - \"working with generate_issue_branch_name(), generate_draft_pr_branch_name(), or extract functions\"\ntripwires:\n  - action: \"constructing branch names manually\"\n    warning: \"Use generate_issue_branch_name() for consistent objective ID encoding.\"\nlast_audited: \"2026-02-17 00:00 PT\"\naudit_result: clean\n---\n\n# Branch Naming Conventions\n\nAll erk-managed branches follow a canonical naming pattern that encodes plan and objective references for downstream inference.\n\n## Canonical Function\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_issue_branch_name -->\n\nSee `generate_issue_branch_name()` in `packages/erk-shared/src/erk_shared/naming.py`. Accepts `issue_number`, `title`, `timestamp`, and optional `objective_id` keyword argument.\n\n## Branch Format\n\n### Issue-Based Branches\n\n**Without objective:**\n\n```\nP{issue}-{slug}-{MM-DD-HHMM}\n```\n\n**With objective:**\n\n```\nP{issue}-O{objective}-{slug}-{MM-DD-HHMM}\n```\n\n**Examples:**\n\n- `P123-fix-auth-bug-01-15-1430`\n- `P123-O456-fix-auth-bug-01-15-1430`\n\n### Draft-PR Branches\n\n**Without objective:**\n\n```\nplanned/{slug}-{MM-DD-HHMM}\n```\n\n**With objective:**\n\n```\nplanned/O{objective}-{slug}-{MM-DD-HHMM}\n```\n\n**Examples:**\n\n- `planned/fix-auth-bug-01-15-1430`\n- `planned/O456-fix-auth-bug-01-15-1430`\n\nDraft-PR branches have no extractable plan ID from the branch name. `plan-ref.json` is the sole source of truth.\n\n**Constraints:**\n\n- Prefix (`P{num}-` or `P{num}-O{obj}-` or `planned/`) + sanitized title must not exceed 31 characters\n- Title is sanitized via `sanitize_worktree_name()` (lowercased, special chars replaced with hyphens)\n- Timestamp suffix: `-MM-DD-HHMM` format\n- Trailing hyphens stripped before timestamp\n\n## Extraction Functions\n\n### extract_leading_issue_number()\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, extract_leading_issue_number -->\n\nExtracts the plan issue number from a branch name. See `extract_leading_issue_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n\n- `\"P2382-convert-erk-create-12-05-2359\"` -> `2382`\n- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `123`\n- Supports legacy format without `P` prefix for backwards compatibility\n\n### extract_objective_number()\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, extract_objective_number -->\n\nExtracts the optional objective ID from a branch name. Supports both issue-based (`P{issue}-O{obj}-`) and draft-PR (`planned/O{obj}-`) patterns. See `extract_objective_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n\n- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `456`\n- `\"planned/O456-fix-auth-01-15-1430\"` -> `456`\n- `\"P123-fix-auth-bug-01-15-1430\"` -> `None`\n- `\"planned/fix-auth-bug-01-15-1430\"` -> `None`\n- Case-insensitive: `\"P123-o456-fix-bug\"` -> `456`\n\n## Usage Sites\n\nBranch creation codepaths delegate to one of two functions depending on whether a plan issue exists:\n\n**`generate_issue_branch_name()`** — for issue-backed plans (`P{issue}-...`):\n\n| Codepath              | File                                        |\n| --------------------- | ------------------------------------------- |\n| Plan submit           | `src/erk/cli/commands/submit.py`            |\n| One-shot dispatch     | `src/erk/cli/commands/one_shot_dispatch.py` |\n| setup-impl-from-issue | Branch creation during implementation       |\n\n**`generate_draft_pr_branch_name()`** — for draft-PR plans (`planned/...`):\n\n| Codepath                 | File                                                            |\n| ------------------------ | --------------------------------------------------------------- |\n| Plan save (draft-PR)     | `src/erk/cli/commands/exec/scripts/plan_save.py`                |\n| Plan migrate to draft-PR | `src/erk/cli/commands/exec/scripts/plan_migrate_to_draft_pr.py` |\n\nThe one-shot dispatch also has a fallback for non-plan tasks: `oneshot-{slug}-{MM-DD-HHMM}`.\n\n## Related Topics\n\n- [Branch Name Inference](../planning/branch-name-inference.md) - How plan/PR recovery uses the P{issue} prefix contract\n","structuredPatch":[{"oldStart":47,"oldLines":19,"newStart":47,"newLines":19,"lines":[" **Without objective:**"," "," ```","-planned/{slug}-{MM-DD-HHMM}","+plnd/{slug}-{MM-DD-HHMM}"," ```"," "," **With objective:**"," "," ```","-planned/O{objective}-{slug}-{MM-DD-HHMM}","+plnd/O{objective}-{slug}-{MM-DD-HHMM}"," ```"," "," **Examples:**"," ","-- `planned/fix-auth-bug-01-15-1430`","-- `planned/O456-fix-auth-bug-01-15-1430`","+- `plnd/fix-auth-bug-01-15-1430`","+- `plnd/O456-fix-auth-bug-01-15-1430`"," "," Draft-PR branches have no extractable plan ID from the branch name. `plan-ref.json` is the sole source of truth."," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"ba3da7f9-98bd-4ec4-aeaf-d49e798ca638","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01VSMwACfdeVkAXqwMtD4LgY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KCYEzpS4JegaLkQCZYxYTf","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/erk/branch-naming.md","old_string":"- Prefix (`P{num}-` or `P{num}-O{obj}-` or `planned/`) + sanitized title must not exceed 31 characters","new_string":"- Prefix (`P{num}-` or `P{num}-O{obj}-` or `plnd/`) + sanitized title must not exceed 31 characters"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":711,"cache_read_input_tokens":69064,"cache_creation":{"ephemeral_5m_input_tokens":711,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHZWr2hSmAWozDo6Yzk","type":"assistant","uuid":"6ff452e5-a684-4ac9-84c4-c20e9020f3ec","timestamp":"2026-02-22T14:44:30.009Z"}
{"parentUuid":"6ff452e5-a684-4ac9-84c4-c20e9020f3ec","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KCYEzpS4JegaLkQCZYxYTf","type":"tool_result","content":"The file /home/runner/work/erk/erk/docs/learned/erk/branch-naming.md has been updated successfully."}]},"uuid":"dbf0cbb6-3b7d-48a2-8e2e-ca2e7a8b7141","timestamp":"2026-02-22T14:44:30.689Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/docs/learned/erk/branch-naming.md","oldString":"- Prefix (`P{num}-` or `P{num}-O{obj}-` or `planned/`) + sanitized title must not exceed 31 characters","newString":"- Prefix (`P{num}-` or `P{num}-O{obj}-` or `plnd/`) + sanitized title must not exceed 31 characters","originalFile":"---\ntitle: Branch Naming Conventions\nread_when:\n  - \"creating or modifying branch name generation\"\n  - \"extracting issue or objective numbers from branch names\"\n  - \"working with generate_issue_branch_name(), generate_draft_pr_branch_name(), or extract functions\"\ntripwires:\n  - action: \"constructing branch names manually\"\n    warning: \"Use generate_issue_branch_name() for consistent objective ID encoding.\"\nlast_audited: \"2026-02-17 00:00 PT\"\naudit_result: clean\n---\n\n# Branch Naming Conventions\n\nAll erk-managed branches follow a canonical naming pattern that encodes plan and objective references for downstream inference.\n\n## Canonical Function\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_issue_branch_name -->\n\nSee `generate_issue_branch_name()` in `packages/erk-shared/src/erk_shared/naming.py`. Accepts `issue_number`, `title`, `timestamp`, and optional `objective_id` keyword argument.\n\n## Branch Format\n\n### Issue-Based Branches\n\n**Without objective:**\n\n```\nP{issue}-{slug}-{MM-DD-HHMM}\n```\n\n**With objective:**\n\n```\nP{issue}-O{objective}-{slug}-{MM-DD-HHMM}\n```\n\n**Examples:**\n\n- `P123-fix-auth-bug-01-15-1430`\n- `P123-O456-fix-auth-bug-01-15-1430`\n\n### Draft-PR Branches\n\n**Without objective:**\n\n```\nplnd/{slug}-{MM-DD-HHMM}\n```\n\n**With objective:**\n\n```\nplnd/O{objective}-{slug}-{MM-DD-HHMM}\n```\n\n**Examples:**\n\n- `plnd/fix-auth-bug-01-15-1430`\n- `plnd/O456-fix-auth-bug-01-15-1430`\n\nDraft-PR branches have no extractable plan ID from the branch name. `plan-ref.json` is the sole source of truth.\n\n**Constraints:**\n\n- Prefix (`P{num}-` or `P{num}-O{obj}-` or `planned/`) + sanitized title must not exceed 31 characters\n- Title is sanitized via `sanitize_worktree_name()` (lowercased, special chars replaced with hyphens)\n- Timestamp suffix: `-MM-DD-HHMM` format\n- Trailing hyphens stripped before timestamp\n\n## Extraction Functions\n\n### extract_leading_issue_number()\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, extract_leading_issue_number -->\n\nExtracts the plan issue number from a branch name. See `extract_leading_issue_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n\n- `\"P2382-convert-erk-create-12-05-2359\"` -> `2382`\n- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `123`\n- Supports legacy format without `P` prefix for backwards compatibility\n\n### extract_objective_number()\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, extract_objective_number -->\n\nExtracts the optional objective ID from a branch name. Supports both issue-based (`P{issue}-O{obj}-`) and draft-PR (`planned/O{obj}-`) patterns. See `extract_objective_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n\n- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `456`\n- `\"planned/O456-fix-auth-01-15-1430\"` -> `456`\n- `\"P123-fix-auth-bug-01-15-1430\"` -> `None`\n- `\"planned/fix-auth-bug-01-15-1430\"` -> `None`\n- Case-insensitive: `\"P123-o456-fix-bug\"` -> `456`\n\n## Usage Sites\n\nBranch creation codepaths delegate to one of two functions depending on whether a plan issue exists:\n\n**`generate_issue_branch_name()`** — for issue-backed plans (`P{issue}-...`):\n\n| Codepath              | File                                        |\n| --------------------- | ------------------------------------------- |\n| Plan submit           | `src/erk/cli/commands/submit.py`            |\n| One-shot dispatch     | `src/erk/cli/commands/one_shot_dispatch.py` |\n| setup-impl-from-issue | Branch creation during implementation       |\n\n**`generate_draft_pr_branch_name()`** — for draft-PR plans (`planned/...`):\n\n| Codepath                 | File                                                            |\n| ------------------------ | --------------------------------------------------------------- |\n| Plan save (draft-PR)     | `src/erk/cli/commands/exec/scripts/plan_save.py`                |\n| Plan migrate to draft-PR | `src/erk/cli/commands/exec/scripts/plan_migrate_to_draft_pr.py` |\n\nThe one-shot dispatch also has a fallback for non-plan tasks: `oneshot-{slug}-{MM-DD-HHMM}`.\n\n## Related Topics\n\n- [Branch Name Inference](../planning/branch-name-inference.md) - How plan/PR recovery uses the P{issue} prefix contract\n","structuredPatch":[{"oldStart":65,"oldLines":7,"newStart":65,"newLines":7,"lines":[" "," **Constraints:**"," ","-- Prefix (`P{num}-` or `P{num}-O{obj}-` or `planned/`) + sanitized title must not exceed 31 characters","+- Prefix (`P{num}-` or `P{num}-O{obj}-` or `plnd/`) + sanitized title must not exceed 31 characters"," - Title is sanitized via `sanitize_worktree_name()` (lowercased, special chars replaced with hyphens)"," - Timestamp suffix: `-MM-DD-HHMM` format"," - Trailing hyphens stripped before timestamp"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"dbf0cbb6-3b7d-48a2-8e2e-ca2e7a8b7141","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_016wkM6woNbJ3cm3hRbXcGHz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HnKAmEPrpbpFh4hSKu3DUM","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/erk/branch-naming.md","old_string":"Extracts the optional objective ID from a branch name. Supports both issue-based (`P{issue}-O{obj}-`) and draft-PR (`planned/O{obj}-`) patterns. See `extract_objective_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n\n- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `456`\n- `\"planned/O456-fix-auth-01-15-1430\"` -> `456`\n- `\"P123-fix-auth-bug-01-15-1430\"` -> `None`\n- `\"planned/fix-auth-bug-01-15-1430\"` -> `None`","new_string":"Extracts the optional objective ID from a branch name. Supports both issue-based (`P{issue}-O{obj}-`) and draft-PR (`plnd/O{obj}-`) patterns. See `extract_objective_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n\n- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `456`\n- `\"plnd/O456-fix-auth-01-15-1430\"` -> `456`\n- `\"P123-fix-auth-bug-01-15-1430\"` -> `None`\n- `\"plnd/fix-auth-bug-01-15-1430\"` -> `None`"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":229,"cache_read_input_tokens":69775,"cache_creation":{"ephemeral_5m_input_tokens":229,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHZqZAfWVkEGCu7qR13","type":"assistant","uuid":"19209156-a1a5-4424-88a0-02f418092c73","timestamp":"2026-02-22T14:44:37.508Z"}
{"parentUuid":"19209156-a1a5-4424-88a0-02f418092c73","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HnKAmEPrpbpFh4hSKu3DUM","type":"tool_result","content":"The file /home/runner/work/erk/erk/docs/learned/erk/branch-naming.md has been updated successfully."}]},"uuid":"5704a37e-4320-4f94-af96-6e3a5a3cb6d1","timestamp":"2026-02-22T14:44:38.186Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/docs/learned/erk/branch-naming.md","oldString":"Extracts the optional objective ID from a branch name. Supports both issue-based (`P{issue}-O{obj}-`) and draft-PR (`planned/O{obj}-`) patterns. See `extract_objective_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n\n- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `456`\n- `\"planned/O456-fix-auth-01-15-1430\"` -> `456`\n- `\"P123-fix-auth-bug-01-15-1430\"` -> `None`\n- `\"planned/fix-auth-bug-01-15-1430\"` -> `None`","newString":"Extracts the optional objective ID from a branch name. Supports both issue-based (`P{issue}-O{obj}-`) and draft-PR (`plnd/O{obj}-`) patterns. See `extract_objective_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n\n- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `456`\n- `\"plnd/O456-fix-auth-01-15-1430\"` -> `456`\n- `\"P123-fix-auth-bug-01-15-1430\"` -> `None`\n- `\"plnd/fix-auth-bug-01-15-1430\"` -> `None`","originalFile":"---\ntitle: Branch Naming Conventions\nread_when:\n  - \"creating or modifying branch name generation\"\n  - \"extracting issue or objective numbers from branch names\"\n  - \"working with generate_issue_branch_name(), generate_draft_pr_branch_name(), or extract functions\"\ntripwires:\n  - action: \"constructing branch names manually\"\n    warning: \"Use generate_issue_branch_name() for consistent objective ID encoding.\"\nlast_audited: \"2026-02-17 00:00 PT\"\naudit_result: clean\n---\n\n# Branch Naming Conventions\n\nAll erk-managed branches follow a canonical naming pattern that encodes plan and objective references for downstream inference.\n\n## Canonical Function\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_issue_branch_name -->\n\nSee `generate_issue_branch_name()` in `packages/erk-shared/src/erk_shared/naming.py`. Accepts `issue_number`, `title`, `timestamp`, and optional `objective_id` keyword argument.\n\n## Branch Format\n\n### Issue-Based Branches\n\n**Without objective:**\n\n```\nP{issue}-{slug}-{MM-DD-HHMM}\n```\n\n**With objective:**\n\n```\nP{issue}-O{objective}-{slug}-{MM-DD-HHMM}\n```\n\n**Examples:**\n\n- `P123-fix-auth-bug-01-15-1430`\n- `P123-O456-fix-auth-bug-01-15-1430`\n\n### Draft-PR Branches\n\n**Without objective:**\n\n```\nplnd/{slug}-{MM-DD-HHMM}\n```\n\n**With objective:**\n\n```\nplnd/O{objective}-{slug}-{MM-DD-HHMM}\n```\n\n**Examples:**\n\n- `plnd/fix-auth-bug-01-15-1430`\n- `plnd/O456-fix-auth-bug-01-15-1430`\n\nDraft-PR branches have no extractable plan ID from the branch name. `plan-ref.json` is the sole source of truth.\n\n**Constraints:**\n\n- Prefix (`P{num}-` or `P{num}-O{obj}-` or `plnd/`) + sanitized title must not exceed 31 characters\n- Title is sanitized via `sanitize_worktree_name()` (lowercased, special chars replaced with hyphens)\n- Timestamp suffix: `-MM-DD-HHMM` format\n- Trailing hyphens stripped before timestamp\n\n## Extraction Functions\n\n### extract_leading_issue_number()\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, extract_leading_issue_number -->\n\nExtracts the plan issue number from a branch name. See `extract_leading_issue_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n\n- `\"P2382-convert-erk-create-12-05-2359\"` -> `2382`\n- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `123`\n- Supports legacy format without `P` prefix for backwards compatibility\n\n### extract_objective_number()\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, extract_objective_number -->\n\nExtracts the optional objective ID from a branch name. Supports both issue-based (`P{issue}-O{obj}-`) and draft-PR (`planned/O{obj}-`) patterns. See `extract_objective_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n\n- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `456`\n- `\"planned/O456-fix-auth-01-15-1430\"` -> `456`\n- `\"P123-fix-auth-bug-01-15-1430\"` -> `None`\n- `\"planned/fix-auth-bug-01-15-1430\"` -> `None`\n- Case-insensitive: `\"P123-o456-fix-bug\"` -> `456`\n\n## Usage Sites\n\nBranch creation codepaths delegate to one of two functions depending on whether a plan issue exists:\n\n**`generate_issue_branch_name()`** — for issue-backed plans (`P{issue}-...`):\n\n| Codepath              | File                                        |\n| --------------------- | ------------------------------------------- |\n| Plan submit           | `src/erk/cli/commands/submit.py`            |\n| One-shot dispatch     | `src/erk/cli/commands/one_shot_dispatch.py` |\n| setup-impl-from-issue | Branch creation during implementation       |\n\n**`generate_draft_pr_branch_name()`** — for draft-PR plans (`planned/...`):\n\n| Codepath                 | File                                                            |\n| ------------------------ | --------------------------------------------------------------- |\n| Plan save (draft-PR)     | `src/erk/cli/commands/exec/scripts/plan_save.py`                |\n| Plan migrate to draft-PR | `src/erk/cli/commands/exec/scripts/plan_migrate_to_draft_pr.py` |\n\nThe one-shot dispatch also has a fallback for non-plan tasks: `oneshot-{slug}-{MM-DD-HHMM}`.\n\n## Related Topics\n\n- [Branch Name Inference](../planning/branch-name-inference.md) - How plan/PR recovery uses the P{issue} prefix contract\n","structuredPatch":[{"oldStart":86,"oldLines":12,"newStart":86,"newLines":12,"lines":[" "," <!-- Source: packages/erk-shared/src/erk_shared/naming.py, extract_objective_number -->"," ","-Extracts the optional objective ID from a branch name. Supports both issue-based (`P{issue}-O{obj}-`) and draft-PR (`planned/O{obj}-`) patterns. See `extract_objective_number()` in `packages/erk-shared/src/erk_shared/naming.py`.","+Extracts the optional objective ID from a branch name. Supports both issue-based (`P{issue}-O{obj}-`) and draft-PR (`plnd/O{obj}-`) patterns. See `extract_objective_number()` in `packages/erk-shared/src/erk_shared/naming.py`."," "," - `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `456`","-- `\"planned/O456-fix-auth-01-15-1430\"` -> `456`","+- `\"plnd/O456-fix-auth-01-15-1430\"` -> `456`"," - `\"P123-fix-auth-bug-01-15-1430\"` -> `None`","-- `\"planned/fix-auth-bug-01-15-1430\"` -> `None`","+- `\"plnd/fix-auth-bug-01-15-1430\"` -> `None`"," - Case-insensitive: `\"P123-o456-fix-bug\"` -> `456`"," "," ## Usage Sites"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"5704a37e-4320-4f94-af96-6e3a5a3cb6d1","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01BSs72MZNw376eJxEfCezYL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LuDK5nFxc15uN7rq8mQMtw","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/erk/branch-naming.md","old_string":"**`generate_draft_pr_branch_name()`** — for draft-PR plans (`planned/...`):","new_string":"**`generate_draft_pr_branch_name()`** — for draft-PR plans (`plnd/...`):"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":505,"cache_read_input_tokens":70004,"cache_creation":{"ephemeral_5m_input_tokens":505,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHaPbVUn2HYBVLpfqnD","type":"assistant","uuid":"815e9872-a53a-442a-a7d8-cec6beecd520","timestamp":"2026-02-22T14:44:42.824Z"}
{"parentUuid":"815e9872-a53a-442a-a7d8-cec6beecd520","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LuDK5nFxc15uN7rq8mQMtw","type":"tool_result","content":"The file /home/runner/work/erk/erk/docs/learned/erk/branch-naming.md has been updated successfully."}]},"uuid":"5c4a9549-0d3d-4a42-9b7d-68947aea85d0","timestamp":"2026-02-22T14:44:44.221Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/docs/learned/erk/branch-naming.md","oldString":"**`generate_draft_pr_branch_name()`** — for draft-PR plans (`planned/...`):","newString":"**`generate_draft_pr_branch_name()`** — for draft-PR plans (`plnd/...`):","originalFile":"---\ntitle: Branch Naming Conventions\nread_when:\n  - \"creating or modifying branch name generation\"\n  - \"extracting issue or objective numbers from branch names\"\n  - \"working with generate_issue_branch_name(), generate_draft_pr_branch_name(), or extract functions\"\ntripwires:\n  - action: \"constructing branch names manually\"\n    warning: \"Use generate_issue_branch_name() for consistent objective ID encoding.\"\nlast_audited: \"2026-02-17 00:00 PT\"\naudit_result: clean\n---\n\n# Branch Naming Conventions\n\nAll erk-managed branches follow a canonical naming pattern that encodes plan and objective references for downstream inference.\n\n## Canonical Function\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_issue_branch_name -->\n\nSee `generate_issue_branch_name()` in `packages/erk-shared/src/erk_shared/naming.py`. Accepts `issue_number`, `title`, `timestamp`, and optional `objective_id` keyword argument.\n\n## Branch Format\n\n### Issue-Based Branches\n\n**Without objective:**\n\n```\nP{issue}-{slug}-{MM-DD-HHMM}\n```\n\n**With objective:**\n\n```\nP{issue}-O{objective}-{slug}-{MM-DD-HHMM}\n```\n\n**Examples:**\n\n- `P123-fix-auth-bug-01-15-1430`\n- `P123-O456-fix-auth-bug-01-15-1430`\n\n### Draft-PR Branches\n\n**Without objective:**\n\n```\nplnd/{slug}-{MM-DD-HHMM}\n```\n\n**With objective:**\n\n```\nplnd/O{objective}-{slug}-{MM-DD-HHMM}\n```\n\n**Examples:**\n\n- `plnd/fix-auth-bug-01-15-1430`\n- `plnd/O456-fix-auth-bug-01-15-1430`\n\nDraft-PR branches have no extractable plan ID from the branch name. `plan-ref.json` is the sole source of truth.\n\n**Constraints:**\n\n- Prefix (`P{num}-` or `P{num}-O{obj}-` or `plnd/`) + sanitized title must not exceed 31 characters\n- Title is sanitized via `sanitize_worktree_name()` (lowercased, special chars replaced with hyphens)\n- Timestamp suffix: `-MM-DD-HHMM` format\n- Trailing hyphens stripped before timestamp\n\n## Extraction Functions\n\n### extract_leading_issue_number()\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, extract_leading_issue_number -->\n\nExtracts the plan issue number from a branch name. See `extract_leading_issue_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n\n- `\"P2382-convert-erk-create-12-05-2359\"` -> `2382`\n- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `123`\n- Supports legacy format without `P` prefix for backwards compatibility\n\n### extract_objective_number()\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, extract_objective_number -->\n\nExtracts the optional objective ID from a branch name. Supports both issue-based (`P{issue}-O{obj}-`) and draft-PR (`plnd/O{obj}-`) patterns. See `extract_objective_number()` in `packages/erk-shared/src/erk_shared/naming.py`.\n\n- `\"P123-O456-fix-auth-bug-01-15-1430\"` -> `456`\n- `\"plnd/O456-fix-auth-01-15-1430\"` -> `456`\n- `\"P123-fix-auth-bug-01-15-1430\"` -> `None`\n- `\"plnd/fix-auth-bug-01-15-1430\"` -> `None`\n- Case-insensitive: `\"P123-o456-fix-bug\"` -> `456`\n\n## Usage Sites\n\nBranch creation codepaths delegate to one of two functions depending on whether a plan issue exists:\n\n**`generate_issue_branch_name()`** — for issue-backed plans (`P{issue}-...`):\n\n| Codepath              | File                                        |\n| --------------------- | ------------------------------------------- |\n| Plan submit           | `src/erk/cli/commands/submit.py`            |\n| One-shot dispatch     | `src/erk/cli/commands/one_shot_dispatch.py` |\n| setup-impl-from-issue | Branch creation during implementation       |\n\n**`generate_draft_pr_branch_name()`** — for draft-PR plans (`planned/...`):\n\n| Codepath                 | File                                                            |\n| ------------------------ | --------------------------------------------------------------- |\n| Plan save (draft-PR)     | `src/erk/cli/commands/exec/scripts/plan_save.py`                |\n| Plan migrate to draft-PR | `src/erk/cli/commands/exec/scripts/plan_migrate_to_draft_pr.py` |\n\nThe one-shot dispatch also has a fallback for non-plan tasks: `oneshot-{slug}-{MM-DD-HHMM}`.\n\n## Related Topics\n\n- [Branch Name Inference](../planning/branch-name-inference.md) - How plan/PR recovery uses the P{issue} prefix contract\n","structuredPatch":[{"oldStart":106,"oldLines":7,"newStart":106,"newLines":7,"lines":[" | One-shot dispatch     | `src/erk/cli/commands/one_shot_dispatch.py` |"," | setup-impl-from-issue | Branch creation during implementation       |"," ","-**`generate_draft_pr_branch_name()`** — for draft-PR plans (`planned/...`):","+**`generate_draft_pr_branch_name()`** — for draft-PR plans (`plnd/...`):"," "," | Codepath                 | File                                                            |"," | ------------------------ | --------------------------------------------------------------- |"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"5c4a9549-0d3d-4a42-9b7d-68947aea85d0","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01GfUVXkTQ83SxMrx68W1zrM","type":"message","role":"assistant","content":[{"type":"text","text":"Now update branch-name-inference.md:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":545,"cache_read_input_tokens":70509,"cache_creation":{"ephemeral_5m_input_tokens":545,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHaqPXPN63o4GzKWLNq","type":"assistant","uuid":"8267ca04-b51d-4a94-bc78-5110acf9be6f","timestamp":"2026-02-22T14:44:46.469Z"}
{"parentUuid":"8267ca04-b51d-4a94-bc78-5110acf9be6f","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01GfUVXkTQ83SxMrx68W1zrM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JPfYnyP2XGVvWrErJj8vzp","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/planning/branch-name-inference.md","old_string":"  - action: \"changing branch naming convention (P{issue}- or planned/ prefix)\"\n    warning: \"The P{issue}- prefix (issue-based) and planned/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\"","new_string":"  - action: \"changing branch naming convention (P{issue}- or plnd/ prefix)\"\n    warning: \"The P{issue}- prefix (issue-based) and plnd/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\""},"caller":{"type":"direct"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":545,"cache_read_input_tokens":70509,"cache_creation":{"ephemeral_5m_input_tokens":545,"ephemeral_1h_input_tokens":0},"output_tokens":269,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHaqPXPN63o4GzKWLNq","type":"assistant","uuid":"158f619b-48f7-4fa4-bc15-393b0cf95a0d","timestamp":"2026-02-22T14:44:49.948Z"}
{"parentUuid":"158f619b-48f7-4fa4-bc15-393b0cf95a0d","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JPfYnyP2XGVvWrErJj8vzp","type":"tool_result","content":"The file /home/runner/work/erk/erk/docs/learned/planning/branch-name-inference.md has been updated successfully."}]},"uuid":"e8010039-ff1f-4ac7-a4c6-75b7b0aa187a","timestamp":"2026-02-22T14:44:50.610Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/docs/learned/planning/branch-name-inference.md","oldString":"  - action: \"changing branch naming convention (P{issue}- or planned/ prefix)\"\n    warning: \"The P{issue}- prefix (issue-based) and planned/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\"","newString":"  - action: \"changing branch naming convention (P{issue}- or plnd/ prefix)\"\n    warning: \"The P{issue}- prefix (issue-based) and plnd/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\"","originalFile":"---\ntitle: Branch Name Inference\nlast_audited: \"2026-02-08 00:00 PT\"\naudit_result: clean\ntripwires:\n  - action: \"changing branch naming convention (P{issue}- or planned/ prefix)\"\n    warning: \"The P{issue}- prefix (issue-based) and planned/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\"\n  - action: \"adding branch_name to plan-header at creation time\"\n    warning: \"branch_name is intentionally omitted at creation because the branch doesn't exist yet. The plan-save → branch-create → impl-signal lifecycle requires this gap. See the temporal gap section below.\"\nread_when:\n  - \"debugging missing branch_name in plan issues\"\n  - \"implementing PR lookup from plan issues\"\n  - \"modifying branch creation or naming conventions\"\n---\n\n# Branch Name Inference\n\n## The Temporal Gap Problem\n\nPlan metadata (`plan-header` block) intentionally omits `branch_name` at creation time because of a temporal gap in the plan lifecycle:\n\n1. **Plan saved** → GitHub issue created (no branch exists yet)\n2. **Branch created** → User runs `erk br co --for-plan {issue}` (branch now exists)\n3. **Implementation starts** → `impl-signal started` writes `branch_name` into the plan-header\n\nThe gap between steps 1 and 2 is unavoidable: the plan must exist before the branch can be named after it (the branch name contains the issue number). Attempting to set `branch_name` during save would require either predicting the branch name (fragile — the user might choose a custom name) or creating the branch immediately (wrong — the user hasn't started work yet).\n\n## Two-Layer Resolution\n\nWhen code needs to look up a PR from a plan issue, `branch_name` may be missing from metadata. The system uses two layers:\n\n<!-- Source: src/erk/cli/commands/exec/scripts/get_pr_for_plan.py, get_pr_for_plan -->\n\n**Layer 1 — Metadata lookup**: Read `branch_name` from the `plan-header` block. This succeeds when `impl-signal started` ran successfully.\n\n**Layer 2 — Git context inference**: If `branch_name` is missing, check whether the current git branch matches the `P{issue_number}-` prefix. If it does, use it. This is a fail-open recovery that handles two scenarios:\n\n- `impl-signal` never ran (user created branch manually following the naming convention)\n- `impl-signal` failed (command errored but user continued working)\n\nIf neither layer produces a match, the command fails with an actionable error.\n\n## Branch Prefix Contracts\n\nThe inference recovery depends on **cross-cutting naming contracts**. There are two branch patterns:\n\n### Issue-Based Branches: `P{issue}-`\n\nBranches for issue-based plans start with `P{issue_number}-`. This prefix is generated by two independent code paths that must stay in sync:\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_issue_branch_name -->\n\n- **Branch creation**: `generate_issue_branch_name()` produces `P{issue}-{slug}-{timestamp}` format (with optional `O{objective_id}` segment)\n\n<!-- Source: src/erk/cli/commands/exec/scripts/get_pr_for_plan.py, get_pr_for_plan -->\n\n- **PR recovery**: `get_pr_for_plan` checks `current_branch.startswith(f\"P{issue_number}-\")`\n\nThe prefix is the stable part of the contract. The slug and timestamp segments after the prefix vary, but inference only needs the prefix to establish the plan-to-branch mapping.\n\n### Draft-PR Branches: `planned/`\n\nBranches for draft-PR plans start with `planned/` and follow the pattern `planned/{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone.\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_draft_pr_branch_name -->\n\n- **Branch creation**: `generate_draft_pr_branch_name()` produces `planned/{slug}-{timestamp}`\n- **Plan ID resolution**: `DraftPRPlanBackend.resolve_plan_id_for_branch()` uses an API call, not regex\n- **Source of truth**: `plan-ref.json` is the sole source of plan ID for draft-PR branches\n- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `planned/` branches; `extract_objective_number()` handles both `P{issue}-O{obj}-` and `planned/O{obj}-` patterns\n\n## When Inference Fails\n\nCommon failure scenarios and their fixes:\n\n| Symptom                                | Cause                                                | Fix                                                                     |\n| -------------------------------------- | ---------------------------------------------------- | ----------------------------------------------------------------------- |\n| \"plan-header has no branch_name field\" | On wrong branch (e.g., `master`)                     | Switch to the plan's feature branch                                     |\n| \"plan-header has no branch_name field\" | Branch uses non-standard name (e.g., `feature/1234`) | Rename branch to `P{issue}-...` or manually update plan-header metadata |\n| \"No PR found for branch\"               | Branch exists but no PR was created                  | Push branch and create PR first                                         |\n\n## Relationship to Fail-Open Pattern\n\nThis is an instance of the [fail-open pattern](../architecture/fail-open-patterns.md) with defense-in-depth:\n\n- **Primary mechanism**: `impl-signal started` explicitly writes `branch_name` into metadata (reliable when the full workflow runs)\n- **Fallback mechanism**: Pattern matching against git context (enables manual workflows and recovers from signal failures)\n- **Key distinction**: The fallback isn't just error recovery — it actively enables workflows where `impl-signal` was never intended to run (e.g., implementing a plan created by another developer, or plans created before `impl-signal` existed)\n\n## Related Documentation\n\n- [Fail-Open Patterns](../architecture/fail-open-patterns.md) — Defense-in-depth design pattern\n","structuredPatch":[{"oldStart":3,"oldLines":8,"newStart":3,"newLines":8,"lines":[" last_audited: \"2026-02-08 00:00 PT\""," audit_result: clean"," tripwires:","-  - action: \"changing branch naming convention (P{issue}- or planned/ prefix)\"","-    warning: \"The P{issue}- prefix (issue-based) and planned/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\"","+  - action: \"changing branch naming convention (P{issue}- or plnd/ prefix)\"","+    warning: \"The P{issue}- prefix (issue-based) and plnd/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\"","   - action: \"adding branch_name to plan-header at creation time\"","     warning: \"branch_name is intentionally omitted at creation because the branch doesn't exist yet. The plan-save → branch-create → impl-signal lifecycle requires this gap. See the temporal gap section below.\""," read_when:"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"e8010039-ff1f-4ac7-a4c6-75b7b0aa187a","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Q7ukwdLriy7rEvtBXKEYT2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PDEkkR1qNmYCacydVjt25p","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/planning/branch-name-inference.md","old_string":"### Draft-PR Branches: `planned/`\n\nBranches for draft-PR plans start with `planned/` and follow the pattern `planned/{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone.\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_draft_pr_branch_name -->\n\n- **Branch creation**: `generate_draft_pr_branch_name()` produces `planned/{slug}-{timestamp}`\n- **Plan ID resolution**: `DraftPRPlanBackend.resolve_plan_id_for_branch()` uses an API call, not regex\n- **Source of truth**: `plan-ref.json` is the sole source of plan ID for draft-PR branches\n- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `planned/` branches; `extract_objective_number()` handles both `P{issue}-O{obj}-` and `planned/O{obj}-` patterns","new_string":"### Draft-PR Branches: `plnd/`\n\nBranches for draft-PR plans start with `plnd/` and follow the pattern `plnd/{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone. Legacy branches may use `planned/` prefix.\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_draft_pr_branch_name -->\n\n- **Branch creation**: `generate_draft_pr_branch_name()` produces `plnd/{slug}-{timestamp}`\n- **Plan ID resolution**: `DraftPRPlanBackend.resolve_plan_id_for_branch()` uses an API call, not regex\n- **Source of truth**: `plan-ref.json` is the sole source of plan ID for draft-PR branches\n- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `plnd/` branches; `extract_objective_number()` handles `P{issue}-O{obj}-`, `plnd/O{obj}-`, and legacy `planned/O{obj}-` patterns"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":313,"cache_read_input_tokens":71054,"cache_creation":{"ephemeral_5m_input_tokens":313,"ephemeral_1h_input_tokens":0},"output_tokens":628,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHbJgr7YaAi1kTkocKz","type":"assistant","uuid":"0ed3abb2-1244-4135-9cd5-7bb8e59a3156","timestamp":"2026-02-22T14:45:00.762Z"}
{"parentUuid":"0ed3abb2-1244-4135-9cd5-7bb8e59a3156","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PDEkkR1qNmYCacydVjt25p","type":"tool_result","content":"The file /home/runner/work/erk/erk/docs/learned/planning/branch-name-inference.md has been updated successfully."}]},"uuid":"8a6d7ad2-4110-4918-9655-13e42b620e50","timestamp":"2026-02-22T14:45:01.545Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/docs/learned/planning/branch-name-inference.md","oldString":"### Draft-PR Branches: `planned/`\n\nBranches for draft-PR plans start with `planned/` and follow the pattern `planned/{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone.\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_draft_pr_branch_name -->\n\n- **Branch creation**: `generate_draft_pr_branch_name()` produces `planned/{slug}-{timestamp}`\n- **Plan ID resolution**: `DraftPRPlanBackend.resolve_plan_id_for_branch()` uses an API call, not regex\n- **Source of truth**: `plan-ref.json` is the sole source of plan ID for draft-PR branches\n- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `planned/` branches; `extract_objective_number()` handles both `P{issue}-O{obj}-` and `planned/O{obj}-` patterns","newString":"### Draft-PR Branches: `plnd/`\n\nBranches for draft-PR plans start with `plnd/` and follow the pattern `plnd/{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone. Legacy branches may use `planned/` prefix.\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_draft_pr_branch_name -->\n\n- **Branch creation**: `generate_draft_pr_branch_name()` produces `plnd/{slug}-{timestamp}`\n- **Plan ID resolution**: `DraftPRPlanBackend.resolve_plan_id_for_branch()` uses an API call, not regex\n- **Source of truth**: `plan-ref.json` is the sole source of plan ID for draft-PR branches\n- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `plnd/` branches; `extract_objective_number()` handles `P{issue}-O{obj}-`, `plnd/O{obj}-`, and legacy `planned/O{obj}-` patterns","originalFile":"---\ntitle: Branch Name Inference\nlast_audited: \"2026-02-08 00:00 PT\"\naudit_result: clean\ntripwires:\n  - action: \"changing branch naming convention (P{issue}- or plnd/ prefix)\"\n    warning: \"The P{issue}- prefix (issue-based) and plnd/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\"\n  - action: \"adding branch_name to plan-header at creation time\"\n    warning: \"branch_name is intentionally omitted at creation because the branch doesn't exist yet. The plan-save → branch-create → impl-signal lifecycle requires this gap. See the temporal gap section below.\"\nread_when:\n  - \"debugging missing branch_name in plan issues\"\n  - \"implementing PR lookup from plan issues\"\n  - \"modifying branch creation or naming conventions\"\n---\n\n# Branch Name Inference\n\n## The Temporal Gap Problem\n\nPlan metadata (`plan-header` block) intentionally omits `branch_name` at creation time because of a temporal gap in the plan lifecycle:\n\n1. **Plan saved** → GitHub issue created (no branch exists yet)\n2. **Branch created** → User runs `erk br co --for-plan {issue}` (branch now exists)\n3. **Implementation starts** → `impl-signal started` writes `branch_name` into the plan-header\n\nThe gap between steps 1 and 2 is unavoidable: the plan must exist before the branch can be named after it (the branch name contains the issue number). Attempting to set `branch_name` during save would require either predicting the branch name (fragile — the user might choose a custom name) or creating the branch immediately (wrong — the user hasn't started work yet).\n\n## Two-Layer Resolution\n\nWhen code needs to look up a PR from a plan issue, `branch_name` may be missing from metadata. The system uses two layers:\n\n<!-- Source: src/erk/cli/commands/exec/scripts/get_pr_for_plan.py, get_pr_for_plan -->\n\n**Layer 1 — Metadata lookup**: Read `branch_name` from the `plan-header` block. This succeeds when `impl-signal started` ran successfully.\n\n**Layer 2 — Git context inference**: If `branch_name` is missing, check whether the current git branch matches the `P{issue_number}-` prefix. If it does, use it. This is a fail-open recovery that handles two scenarios:\n\n- `impl-signal` never ran (user created branch manually following the naming convention)\n- `impl-signal` failed (command errored but user continued working)\n\nIf neither layer produces a match, the command fails with an actionable error.\n\n## Branch Prefix Contracts\n\nThe inference recovery depends on **cross-cutting naming contracts**. There are two branch patterns:\n\n### Issue-Based Branches: `P{issue}-`\n\nBranches for issue-based plans start with `P{issue_number}-`. This prefix is generated by two independent code paths that must stay in sync:\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_issue_branch_name -->\n\n- **Branch creation**: `generate_issue_branch_name()` produces `P{issue}-{slug}-{timestamp}` format (with optional `O{objective_id}` segment)\n\n<!-- Source: src/erk/cli/commands/exec/scripts/get_pr_for_plan.py, get_pr_for_plan -->\n\n- **PR recovery**: `get_pr_for_plan` checks `current_branch.startswith(f\"P{issue_number}-\")`\n\nThe prefix is the stable part of the contract. The slug and timestamp segments after the prefix vary, but inference only needs the prefix to establish the plan-to-branch mapping.\n\n### Draft-PR Branches: `planned/`\n\nBranches for draft-PR plans start with `planned/` and follow the pattern `planned/{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone.\n\n<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_draft_pr_branch_name -->\n\n- **Branch creation**: `generate_draft_pr_branch_name()` produces `planned/{slug}-{timestamp}`\n- **Plan ID resolution**: `DraftPRPlanBackend.resolve_plan_id_for_branch()` uses an API call, not regex\n- **Source of truth**: `plan-ref.json` is the sole source of plan ID for draft-PR branches\n- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `planned/` branches; `extract_objective_number()` handles both `P{issue}-O{obj}-` and `planned/O{obj}-` patterns\n\n## When Inference Fails\n\nCommon failure scenarios and their fixes:\n\n| Symptom                                | Cause                                                | Fix                                                                     |\n| -------------------------------------- | ---------------------------------------------------- | ----------------------------------------------------------------------- |\n| \"plan-header has no branch_name field\" | On wrong branch (e.g., `master`)                     | Switch to the plan's feature branch                                     |\n| \"plan-header has no branch_name field\" | Branch uses non-standard name (e.g., `feature/1234`) | Rename branch to `P{issue}-...` or manually update plan-header metadata |\n| \"No PR found for branch\"               | Branch exists but no PR was created                  | Push branch and create PR first                                         |\n\n## Relationship to Fail-Open Pattern\n\nThis is an instance of the [fail-open pattern](../architecture/fail-open-patterns.md) with defense-in-depth:\n\n- **Primary mechanism**: `impl-signal started` explicitly writes `branch_name` into metadata (reliable when the full workflow runs)\n- **Fallback mechanism**: Pattern matching against git context (enables manual workflows and recovers from signal failures)\n- **Key distinction**: The fallback isn't just error recovery — it actively enables workflows where `impl-signal` was never intended to run (e.g., implementing a plan created by another developer, or plans created before `impl-signal` existed)\n\n## Related Documentation\n\n- [Fail-Open Patterns](../architecture/fail-open-patterns.md) — Defense-in-depth design pattern\n","structuredPatch":[{"oldStart":58,"oldLines":16,"newStart":58,"newLines":16,"lines":[" "," The prefix is the stable part of the contract. The slug and timestamp segments after the prefix vary, but inference only needs the prefix to establish the plan-to-branch mapping."," ","-### Draft-PR Branches: `planned/`","+### Draft-PR Branches: `plnd/`"," ","-Branches for draft-PR plans start with `planned/` and follow the pattern `planned/{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone.","+Branches for draft-PR plans start with `plnd/` and follow the pattern `plnd/{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone. Legacy branches may use `planned/` prefix."," "," <!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_draft_pr_branch_name -->"," ","-- **Branch creation**: `generate_draft_pr_branch_name()` produces `planned/{slug}-{timestamp}`","+- **Branch creation**: `generate_draft_pr_branch_name()` produces `plnd/{slug}-{timestamp}`"," - **Plan ID resolution**: `DraftPRPlanBackend.resolve_plan_id_for_branch()` uses an API call, not regex"," - **Source of truth**: `plan-ref.json` is the sole source of plan ID for draft-PR branches","-- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `planned/` branches; `extract_objective_number()` handles both `P{issue}-O{obj}-` and `planned/O{obj}-` patterns","+- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `plnd/` branches; `extract_objective_number()` handles `P{issue}-O{obj}-`, `plnd/O{obj}-`, and legacy `planned/O{obj}-` patterns"," "," ## When Inference Fails"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"8a6d7ad2-4110-4918-9655-13e42b620e50","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Lvf5d6H3TArvFVHYAmEvYL","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check if there are any other references to `planned/` I might have missed in the broader codebase (e.g., workflow files, other scripts):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1010,"cache_read_input_tokens":71367,"cache_creation":{"ephemeral_5m_input_tokens":1010,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHc7VBVNAa8mENNn436","type":"assistant","uuid":"5d336468-cea4-4569-8144-a3738f39f52d","timestamp":"2026-02-22T14:45:04.663Z"}
{"parentUuid":"5d336468-cea4-4569-8144-a3738f39f52d","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Lvf5d6H3TArvFVHYAmEvYL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PYknU98gnsjiyvhQmrzW53","name":"Grep","input":{"pattern":"planned/","glob":"*.py","output_mode":"content","path":"/home/runner/work/erk/erk/src"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1010,"cache_read_input_tokens":71367,"cache_creation":{"ephemeral_5m_input_tokens":1010,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHc7VBVNAa8mENNn436","type":"assistant","uuid":"4fd62304-ef3c-434e-a1ca-270f9fe0bd52","timestamp":"2026-02-22T14:45:05.657Z"}
{"parentUuid":"4fd62304-ef3c-434e-a1ca-270f9fe0bd52","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Lvf5d6H3TArvFVHYAmEvYL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015aPVCbVHmrhZpcM6sAeYY9","name":"Grep","input":{"pattern":"planned/","glob":"*.py","output_mode":"content","path":"/home/runner/work/erk/erk/packages"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1010,"cache_read_input_tokens":71367,"cache_creation":{"ephemeral_5m_input_tokens":1010,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHc7VBVNAa8mENNn436","type":"assistant","uuid":"22ea088f-ef85-41d0-a7cf-7b9c3229fc6d","timestamp":"2026-02-22T14:45:06.419Z"}
{"parentUuid":"22ea088f-ef85-41d0-a7cf-7b9c3229fc6d","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Lvf5d6H3TArvFVHYAmEvYL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019VdGi2Vd2TVcTDAfHv8FBx","name":"Grep","input":{"pattern":"\"planned/\"","glob":"*.yml","output_mode":"content","path":"/home/runner/work/erk/erk/.github"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1010,"cache_read_input_tokens":71367,"cache_creation":{"ephemeral_5m_input_tokens":1010,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHc7VBVNAa8mENNn436","type":"assistant","uuid":"0bf7d16d-bf83-4173-8ffd-5d96fe31fefc","timestamp":"2026-02-22T14:45:07.192Z"}
{"parentUuid":"0bf7d16d-bf83-4173-8ffd-5d96fe31fefc","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015aPVCbVHmrhZpcM6sAeYY9","type":"tool_result","content":"packages/erk-shared/src/erk_shared/naming.py:587:    - Draft-PR (legacy): ``planned/O{objective}-{slug}-{timestamp}``\npackages/erk-shared/src/erk_shared/naming.py:605:        >>> extract_objective_number(\"planned/O456-fix-auth-01-15-1430\")\npackages/erk-shared/src/erk_shared/naming.py:624:    Legacy pattern: planned/review-{issue_number}-{timestamp}\npackages/erk-shared/src/erk_shared/naming.py:638:        >>> extract_plan_review_issue_number(\"planned/review-6214-01-15-1430\")\npackages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py:500:            if issue_number is None and worktree.branch and (worktree.branch.startswith(\"plnd/\") or worktree.branch.startswith(\"planned/\")):"}]},"uuid":"54944c95-bd47-46c5-ad45-061305c5ac3e","timestamp":"2026-02-22T14:45:07.821Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"packages/erk-shared/src/erk_shared/naming.py:587:    - Draft-PR (legacy): ``planned/O{objective}-{slug}-{timestamp}``\npackages/erk-shared/src/erk_shared/naming.py:605:        >>> extract_objective_number(\"planned/O456-fix-auth-01-15-1430\")\npackages/erk-shared/src/erk_shared/naming.py:624:    Legacy pattern: planned/review-{issue_number}-{timestamp}\npackages/erk-shared/src/erk_shared/naming.py:638:        >>> extract_plan_review_issue_number(\"planned/review-6214-01-15-1430\")\npackages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py:500:            if issue_number is None and worktree.branch and (worktree.branch.startswith(\"plnd/\") or worktree.branch.startswith(\"planned/\")):","numLines":5}}
{"parentUuid":"54944c95-bd47-46c5-ad45-061305c5ac3e","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019VdGi2Vd2TVcTDAfHv8FBx","type":"tool_result","content":"No matches found"}]},"uuid":"1bf36f0f-9cc3-4776-8be1-fc1a2cfa9401","timestamp":"2026-02-22T14:45:07.897Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"parentUuid":"1bf36f0f-9cc3-4776-8be1-fc1a2cfa9401","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PYknU98gnsjiyvhQmrzW53","type":"tool_result","content":"src/erk/cli/commands/pr/submit_pipeline.py:695:    # Add planned/ prefix for plan-linked PRs"}]},"uuid":"6c6e3761-b533-41df-a239-8a0933971fc5","timestamp":"2026-02-22T14:45:07.908Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"src/erk/cli/commands/pr/submit_pipeline.py:695:    # Add planned/ prefix for plan-linked PRs","numLines":1}}
{"parentUuid":"6c6e3761-b533-41df-a239-8a0933971fc5","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01NN2q6XhzxHvCr6bDCzrDce","type":"message","role":"assistant","content":[{"type":"text","text":"There's one more comment in submit_pipeline.py I need to update:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":299,"cache_creation_input_tokens":763,"cache_read_input_tokens":72377,"cache_creation":{"ephemeral_5m_input_tokens":763,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHcae51mF7dzvj97LRB","type":"assistant","uuid":"594638bd-2481-4519-90d0-29bf0a487bd3","timestamp":"2026-02-22T14:45:10.384Z"}
{"parentUuid":"594638bd-2481-4519-90d0-29bf0a487bd3","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01NN2q6XhzxHvCr6bDCzrDce","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XVXt8yqnstKMwWdTUknLGe","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/commands/pr/submit_pipeline.py","offset":690,"limit":10},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":299,"cache_creation_input_tokens":763,"cache_read_input_tokens":72377,"cache_creation":{"ephemeral_5m_input_tokens":763,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHcae51mF7dzvj97LRB","type":"assistant","uuid":"ec95bd0d-396b-4b97-b2ee-77779e8968b2","timestamp":"2026-02-22T14:45:11.223Z"}
{"parentUuid":"ec95bd0d-396b-4b97-b2ee-77779e8968b2","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XVXt8yqnstKMwWdTUknLGe","type":"tool_result","content":"   690→            closing_ref = _extract_closing_ref_from_pr(ctx, state.cwd, state.pr_number)\n   691→            if closing_ref is not None:\n   692→                issue_number = closing_ref.issue_number\n   693→                effective_plans_repo = closing_ref.plans_repo\n   694→\n   695→    # Add planned/ prefix for plan-linked PRs\n   696→    if issue_number is not None:\n   697→        pr_title = _add_planned_prefix(pr_title)\n   698→\n   699→    # Check learn plan label\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"317a7f53-c22e-4a45-b2bd-1f8ed7fc47ff","timestamp":"2026-02-22T14:45:11.269Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/commands/pr/submit_pipeline.py","content":"            closing_ref = _extract_closing_ref_from_pr(ctx, state.cwd, state.pr_number)\n            if closing_ref is not None:\n                issue_number = closing_ref.issue_number\n                effective_plans_repo = closing_ref.plans_repo\n\n    # Add planned/ prefix for plan-linked PRs\n    if issue_number is not None:\n        pr_title = _add_planned_prefix(pr_title)\n\n    # Check learn plan label","numLines":10,"startLine":690,"totalLines":870}}}
{"parentUuid":"317a7f53-c22e-4a45-b2bd-1f8ed7fc47ff","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_019vyYYEDKZxcgPMTfLrghmY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TwERimt3sGNTUxHydFzwUZ","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/src/erk/cli/commands/pr/submit_pipeline.py","old_string":"    # Add planned/ prefix for plan-linked PRs","new_string":"    # Add plnd/ prefix for plan-linked PRs"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":668,"cache_read_input_tokens":73140,"cache_creation":{"ephemeral_5m_input_tokens":668,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHcq1m3b5a6a565E2zn","type":"assistant","uuid":"8a461e16-d7cd-4906-9cd1-d8bc882f4367","timestamp":"2026-02-22T14:45:14.467Z"}
{"parentUuid":"8a461e16-d7cd-4906-9cd1-d8bc882f4367","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TwERimt3sGNTUxHydFzwUZ","type":"tool_result","content":"The file /home/runner/work/erk/erk/src/erk/cli/commands/pr/submit_pipeline.py has been updated successfully."}]},"uuid":"3b3eb425-e3bf-4371-8d0f-f4a5e71b9c53","timestamp":"2026-02-22T14:45:15.154Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/src/erk/cli/commands/pr/submit_pipeline.py","oldString":"    # Add planned/ prefix for plan-linked PRs","newString":"    # Add plnd/ prefix for plan-linked PRs","originalFile":"\"\"\"Linear pipeline for PR submission.\n\nReplaces the dual-path branching orchestration with a sequence of plain\nfunctions transforming a frozen SubmitState dataclass.\n\nEach step: (ErkContext, SubmitState) -> SubmitState | SubmitError\n\"\"\"\n\nimport dataclasses\nimport uuid\nfrom collections.abc import Callable\nfrom dataclasses import dataclass\nfrom functools import cache\nfrom pathlib import Path\n\nimport click\n\nfrom erk.cli.commands.pr.shared import (\n    assemble_pr_body,\n    echo_plan_context_status,\n    run_commit_message_generation,\n)\nfrom erk.cli.constants import PLANNED_PR_TITLE_PREFIX\nfrom erk.cli.ensure import UserFacingCliError\nfrom erk.core.commit_message_generator import CommitMessageGenerator\nfrom erk.core.context import ErkContext\nfrom erk.core.plan_context_provider import PlanContext, PlanContextProvider\nfrom erk_shared.gateway.git.remote_ops.types import PullRebaseError, PushError\nfrom erk_shared.gateway.github.parsing import parse_git_remote_url\nfrom erk_shared.gateway.github.pr_footer import (\n    ClosingReference,\n    build_pr_body_footer,\n    extract_closing_reference,\n    extract_footer_from_body,\n)\nfrom erk_shared.gateway.github.types import BodyText, GitHubRepoId, PRNotFound\nfrom erk_shared.gateway.gt.operations.finalize import ERK_SKIP_LEARN_LABEL, is_learn_plan\nfrom erk_shared.gateway.gt.prompts import truncate_diff\nfrom erk_shared.gateway.pr.diff_extraction import filter_diff_excluded_files\nfrom erk_shared.gateway.pr.graphite_enhance import should_enhance_with_graphite\nfrom erk_shared.impl_folder import (\n    has_plan_ref,\n    save_plan_ref,\n    validate_plan_linkage,\n)\nfrom erk_shared.plan_store.draft_pr_lifecycle import extract_metadata_prefix\nfrom erk_shared.scratch.scratch import write_scratch_file\n\n# ---------------------------------------------------------------------------\n# Utilities\n# ---------------------------------------------------------------------------\n\n\ndef _add_planned_prefix(title: str) -> str:\n    \"\"\"Prepend 'plnd/' prefix to PR title (idempotent).\n\n    Args:\n        title: The PR title to prefix\n\n    Returns:\n        The title with 'plnd/' prefix, skipping if already prefixed\n    \"\"\"\n    if title.startswith(PLANNED_PR_TITLE_PREFIX):\n        return title\n    return f\"{PLANNED_PR_TITLE_PREFIX}{title}\"\n\n\n# ---------------------------------------------------------------------------\n# Data Types\n# ---------------------------------------------------------------------------\n\n\n@dataclass(frozen=True)\nclass SubmitState:\n    \"\"\"Immutable state threaded through the submit pipeline.\"\"\"\n\n    cwd: Path\n    repo_root: Path\n    branch_name: str\n    parent_branch: str\n    trunk_branch: str\n    use_graphite: bool\n    force: bool\n    debug: bool\n    session_id: str\n    issue_number: int | None\n    pr_number: int | None\n    pr_url: str | None\n    was_created: bool\n    base_branch: str | None\n    graphite_url: str | None\n    diff_file: Path | None\n    plan_context: PlanContext | None\n    title: str | None\n    body: str | None\n\n\n@dataclass(frozen=True)\nclass SubmitError:\n    \"\"\"Error result from a pipeline step.\"\"\"\n\n    phase: str\n    error_type: str\n    message: str\n    details: dict[str, str]\n\n\n# ---------------------------------------------------------------------------\n# Pipeline Steps\n# ---------------------------------------------------------------------------\n\nSubmitStep = Callable[[ErkContext, SubmitState], SubmitState | SubmitError]\n\n\ndef prepare_state(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Resolve repo_root, branch_name, parent_branch, trunk_branch, issue_number.\n\n    Single location for all discovery. Consolidates duplicate parent-branch\n    and issue-number discovery sites.\n    \"\"\"\n    cwd = state.cwd\n    repo_root = ctx.git.repo.get_repository_root(cwd)\n\n    branch_name = ctx.git.branch.get_current_branch(cwd)\n    if branch_name is None:\n        return SubmitError(\n            phase=\"prepare\",\n            error_type=\"no_branch\",\n            message=\"Not on a branch (detached HEAD state)\",\n            details={},\n        )\n\n    trunk_branch = ctx.git.branch.detect_trunk_branch(repo_root)\n    parent_branch = ctx.branch_manager.get_parent_branch(repo_root, branch_name) or trunk_branch\n\n    # Plan ID discovery via .impl/plan-ref.json (or legacy issue.json) or branch name\n    impl_dir = cwd / \".impl\"\n    issue_number: int | None = None\n    try:\n        plan_id = validate_plan_linkage(impl_dir, branch_name)\n        if plan_id is not None:\n            issue_number = int(plan_id)\n    except ValueError as e:\n        return SubmitError(\n            phase=\"prepare\",\n            error_type=\"issue_linkage_mismatch\",\n            message=str(e),\n            details={\"branch\": branch_name},\n        )\n\n    # Auto-repair: create .impl/plan-ref.json if missing but issue inferred from branch\n    if issue_number is not None and not has_plan_ref(impl_dir) and impl_dir.exists():\n        remote_url = ctx.git.remote.get_remote_url(repo_root, \"origin\")\n        owner, repo_name = parse_git_remote_url(remote_url)\n        issue_url = f\"https://github.com/{owner}/{repo_name}/issues/{issue_number}\"\n        save_plan_ref(\n            impl_dir,\n            provider=\"github\",\n            plan_id=str(issue_number),\n            url=issue_url,\n            labels=(),\n            objective_id=None,\n        )\n\n    return dataclasses.replace(\n        state,\n        cwd=cwd,\n        repo_root=repo_root,\n        branch_name=branch_name,\n        parent_branch=parent_branch,\n        trunk_branch=trunk_branch,\n        issue_number=issue_number,\n    )\n\n\ndef commit_wip(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Check for uncommitted changes; if present, add_all + commit.\"\"\"\n    if ctx.git.status.has_uncommitted_changes(state.cwd):\n        click.echo(click.style(\"   Committing uncommitted changes...\", dim=True))\n        ctx.git.commit.add_all(state.cwd)\n        ctx.git.commit.commit(state.cwd, \"WIP: Prepare for PR submission\")\n    return state\n\n\ndef push_and_create_pr(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Push branch and create/find PR.\n\n    Dispatches internally: Graphite-first vs core path.\n    \"\"\"\n    # Determine if Graphite should handle the push\n    graphite_handles_push = (\n        state.use_graphite and should_enhance_with_graphite(ctx, state.cwd).should_enhance\n    )\n\n    if graphite_handles_push:\n        return _graphite_first_flow(ctx, state)\n    return _core_submit_flow(ctx, state)\n\n\ndef _graphite_first_flow(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Graphite-first flow: gt submit handles push + PR creation.\"\"\"\n    click.echo(click.style(\"Phase 1: Graphite Submit\", bold=True))\n\n    # Auto-force for plan implementations (branches always diverge from remote)\n    is_plan_impl = state.issue_number is not None\n    effective_force = state.force or is_plan_impl\n\n    # Pre-check: detect remote divergence before gt submit\n    if ctx.git.branch.branch_exists_on_remote(state.repo_root, \"origin\", state.branch_name):\n        ctx.git.remote.fetch_branch(state.repo_root, \"origin\", state.branch_name)\n        divergence = ctx.git.branch.is_branch_diverged_from_remote(\n            state.cwd, state.branch_name, \"origin\"\n        )\n        if divergence.behind > 0 and not effective_force:\n            ahead_msg = (\n                f\" and ahead by {divergence.ahead} commit(s)\" if divergence.ahead > 0 else \"\"\n            )\n            return SubmitError(\n                phase=\"push_and_create_pr\",\n                error_type=\"remote_diverged\",\n                message=(\n                    f\"Branch '{state.branch_name}' is behind remote by \"\n                    f\"{divergence.behind} commit(s){ahead_msg}.\\n\\n\"\n                    \"The remote branch has been updated (e.g., by CI or another session).\\n\\n\"\n                    \"To fix:\\n\"\n                    \"  erk pr sync-divergence --dangerous   # Fetch, rebase, resolve conflicts\\n\"\n                    \"  erk pr submit -f                     # Force push (overrides remote)\"\n                ),\n                details={\n                    \"branch\": state.branch_name,\n                    \"ahead\": str(divergence.ahead),\n                    \"behind\": str(divergence.behind),\n                },\n            )\n        if is_plan_impl and not state.force and divergence.behind > 0:\n            click.echo(click.style(\"   Auto-forcing: plan implementation branch\", dim=True))\n\n    click.echo(click.style(\"   Running gt submit...\", dim=True))\n    try:\n        ctx.graphite.submit_stack(\n            state.repo_root,\n            publish=True,\n            restack=False,\n            quiet=False,\n            force=effective_force,\n        )\n    except RuntimeError as e:\n        error_str = str(e)\n        if \"restack\" in error_str.lower():\n            return SubmitError(\n                phase=\"push_and_create_pr\",\n                error_type=\"graphite_restack_required\",\n                message=(\n                    \"Your Graphite stack has conflicts that need manual resolution.\\n\\n\"\n                    \"Run these commands:\\n\"\n                    \"  gt restack        # Resolve conflicts interactively\\n\"\n                    \"  erk pr submit     # Re-submit after resolving\"\n                ),\n                details={},\n            )\n        return SubmitError(\n            phase=\"push_and_create_pr\",\n            error_type=\"graphite_submit_failed\",\n            message=f\"Graphite submit failed: {e}\",\n            details={},\n        )\n    click.echo(click.style(\"   Graphite submit completed\", fg=\"green\"))\n    click.echo(\"\")\n\n    # Query GitHub for PR info\n    click.echo(click.style(\"   Getting PR info...\", dim=True))\n    pr_info = ctx.github.get_pr_for_branch(state.repo_root, state.branch_name)\n    if isinstance(pr_info, PRNotFound):\n        return SubmitError(\n            phase=\"push_and_create_pr\",\n            error_type=\"pr_not_found\",\n            message=(\n                f\"PR not found for branch '{state.branch_name}' after gt submit.\\n\"\n                \"This may happen if gt submit didn't create a PR. Try running:\\n\"\n                \"  gt submit --publish\"\n            ),\n            details={\"branch\": state.branch_name},\n        )\n\n    # Get Graphite URL\n    remote_url = ctx.git.remote.get_remote_url(state.repo_root, \"origin\")\n    owner, repo_name = parse_git_remote_url(remote_url)\n    repo_id = GitHubRepoId(owner=owner, repo=repo_name)\n    graphite_url = ctx.graphite.get_graphite_url(repo_id, pr_info.number)\n\n    click.echo(click.style(f\"   PR #{pr_info.number} ready\", fg=\"green\"))\n    click.echo(\"\")\n\n    return dataclasses.replace(\n        state,\n        pr_number=pr_info.number,\n        pr_url=pr_info.url,\n        was_created=True,\n        base_branch=state.parent_branch,\n        graphite_url=graphite_url,\n    )\n\n\ndef _core_submit_flow(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Core submit flow: git push + gh pr create.\"\"\"\n    click.echo(click.style(\"Phase 1: Creating or Updating PR\", bold=True))\n\n    # Check GitHub authentication\n    is_gh_authed, gh_username, _ = ctx.github.check_auth_status()\n    if not is_gh_authed:\n        return SubmitError(\n            phase=\"push_and_create_pr\",\n            error_type=\"github_auth_failed\",\n            message=\"GitHub CLI is not authenticated. Run 'gh auth login'.\",\n            details={},\n        )\n    if state.debug:\n        click.echo(click.style(f\"   Authenticated as {gh_username}\", dim=True))\n\n    # Verify commits to push\n    commit_count = ctx.git.analysis.count_commits_ahead(state.cwd, state.parent_branch)\n    if commit_count == 0:\n        return SubmitError(\n            phase=\"push_and_create_pr\",\n            error_type=\"no_commits\",\n            message=f\"No commits ahead of {state.parent_branch}. Nothing to submit.\",\n            details={\"parent_branch\": state.parent_branch, \"branch\": state.branch_name},\n        )\n\n    # Divergence check and auto-rebase\n    divergence = ctx.git.branch.is_branch_diverged_from_remote(\n        state.cwd, state.branch_name, \"origin\"\n    )\n    if divergence.behind > 0:\n        if state.debug:\n            click.echo(\n                click.style(\n                    f\"   Branch is {divergence.behind} commit(s) behind remote, rebasing...\",\n                    dim=True,\n                )\n            )\n        pull_result = ctx.git.remote.pull_rebase(state.cwd, \"origin\", state.branch_name)\n        if isinstance(pull_result, PullRebaseError):\n            return SubmitError(\n                phase=\"push_and_create_pr\",\n                error_type=\"rebase_failed\",\n                message=(\n                    f\"Failed to rebase '{state.branch_name}' on origin.\\n\"\n                    f\"Error: {pull_result.message}\\n\\n\"\n                    f\"To fix manually: git pull --rebase origin {state.branch_name}\"\n                ),\n                details={\"branch\": state.branch_name},\n            )\n        divergence = ctx.git.branch.is_branch_diverged_from_remote(\n            state.cwd, state.branch_name, \"origin\"\n        )\n\n    if divergence.is_diverged and not state.force:\n        return SubmitError(\n            phase=\"push_and_create_pr\",\n            error_type=\"branch_diverged\",\n            message=(\n                f\"Branch '{state.branch_name}' has diverged from remote.\\n\"\n                f\"Local is {divergence.ahead} commit(s) ahead and \"\n                f\"{divergence.behind} commit(s) behind origin/{state.branch_name}.\\n\\n\"\n                f\"To fix: git pull --rebase origin {state.branch_name}\\n\"\n                f\"Or use: erk pr submit -f (to force push)\"\n            ),\n            details={\n                \"branch\": state.branch_name,\n                \"ahead\": str(divergence.ahead),\n                \"behind\": str(divergence.behind),\n            },\n        )\n\n    # Push\n    push_result = ctx.git.remote.push_to_remote(\n        state.cwd, \"origin\", state.branch_name, set_upstream=True, force=state.force\n    )\n    if isinstance(push_result, PushError):\n        if \"non-fast-forward\" in push_result.message or \"rejected\" in push_result.message.lower():\n            return SubmitError(\n                phase=\"push_and_create_pr\",\n                error_type=\"branch_diverged\",\n                message=(\n                    f\"Branch '{state.branch_name}' has diverged from remote.\\n\"\n                    f\"Your local branch is behind origin/{state.branch_name}.\\n\\n\"\n                    f\"To fix: git pull --rebase origin {state.branch_name}\\n\"\n                    f\"Or use: erk pr submit -f (to force push)\"\n                ),\n                details={\"branch\": state.branch_name},\n            )\n        raise UserFacingCliError(push_result.message)\n\n    # Check for existing PR or create new one\n    existing_pr = ctx.github.get_pr_for_branch(state.repo_root, state.branch_name)\n    plans_repo = ctx.local_config.plans_repo if ctx.local_config else None\n\n    if isinstance(existing_pr, PRNotFound):\n        # Check parent branch has PR (stacked PRs)\n        if state.parent_branch != state.trunk_branch:\n            parent_pr = ctx.github.get_pr_for_branch(state.repo_root, state.parent_branch)\n            if isinstance(parent_pr, PRNotFound):\n                return SubmitError(\n                    phase=\"push_and_create_pr\",\n                    error_type=\"parent_branch_no_pr\",\n                    message=(\n                        f\"Cannot create PR: parent branch '{state.parent_branch}' \"\n                        f\"does not have a PR yet.\\n\\n\"\n                        f\"This branch is part of a Graphite stack. Use 'gt submit' \"\n                        f\"to submit the entire stack at once, which will create PRs \"\n                        f\"for all branches in the correct order.\\n\\n\"\n                        f\"Run: gt submit -s\"\n                    ),\n                    details={\n                        \"branch\": state.branch_name,\n                        \"parent_branch\": state.parent_branch,\n                    },\n                )\n\n        # Build initial PR body with footer\n        footer = build_pr_body_footer(\n            pr_number=0,\n            issue_number=state.issue_number,\n            plans_repo=plans_repo,\n        )\n        full_body = \"\" + footer\n\n        pr_number = ctx.github.create_pr(\n            state.repo_root,\n            branch=state.branch_name,\n            title=\"WIP\",\n            body=full_body,\n            base=state.parent_branch,\n        )\n\n        # Get PR URL\n        pr_details = ctx.github.get_pr(state.repo_root, pr_number)\n        pr_url = (\n            pr_details.url\n            if not isinstance(pr_details, PRNotFound)\n            else f\"https://github.com/{state.branch_name}/pull/{pr_number}\"\n        )\n\n        # Update footer with actual PR number\n        updated_footer = build_pr_body_footer(\n            pr_number=pr_number,\n            issue_number=state.issue_number,\n            plans_repo=plans_repo,\n        )\n        ctx.github.update_pr_body(state.repo_root, pr_number, \"\" + updated_footer)\n\n        click.echo(click.style(f\"   PR #{pr_number} created\", fg=\"green\"))\n        click.echo(\"\")\n\n        return dataclasses.replace(\n            state,\n            pr_number=pr_number,\n            pr_url=pr_url,\n            was_created=True,\n            base_branch=state.parent_branch,\n        )\n\n    # PR exists\n    pr_number = existing_pr.number\n    pr_url = existing_pr.url\n\n    # Add footer if missing\n    pr_details = ctx.github.get_pr(state.repo_root, pr_number)\n    current_body = \"\" if isinstance(pr_details, PRNotFound) else pr_details.body\n    has_footer = \"erk pr checkout\" in current_body\n    if not has_footer:\n        footer = build_pr_body_footer(\n            pr_number=pr_number,\n            issue_number=state.issue_number,\n            plans_repo=plans_repo,\n        )\n        ctx.github.update_pr_body(state.repo_root, pr_number, current_body + footer)\n\n    click.echo(click.style(f\"   PR #{pr_number} found (already exists)\", fg=\"green\"))\n    click.echo(\"\")\n\n    return dataclasses.replace(\n        state,\n        pr_number=pr_number,\n        pr_url=pr_url,\n        was_created=False,\n        base_branch=state.parent_branch,\n    )\n\n\ndef extract_diff(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Local git diff to base branch, filter lock files, truncate, write scratch file.\"\"\"\n    click.echo(click.style(\"Phase 2: Getting diff\", bold=True))\n\n    if state.base_branch is None:\n        return SubmitError(\n            phase=\"extract_diff\",\n            error_type=\"no_base_branch\",\n            message=\"No base branch determined for diff extraction\",\n            details={},\n        )\n\n    pr_diff = ctx.git.analysis.get_diff_to_branch(state.cwd, state.base_branch)\n    if state.debug:\n        diff_lines = len(pr_diff.splitlines())\n        click.echo(click.style(f\"   Diff retrieved ({diff_lines} lines)\", dim=True))\n\n    # Filter lock files, truncate\n    pr_diff = filter_diff_excluded_files(pr_diff)\n    diff_content, was_truncated = truncate_diff(pr_diff)\n    if was_truncated and state.debug:\n        click.echo(click.style(\"   Diff truncated for size\", dim=True))\n\n    # Write scratch file\n    diff_file = write_scratch_file(\n        diff_content,\n        session_id=state.session_id,\n        suffix=\".diff\",\n        prefix=\"pr-diff-\",\n        repo_root=state.repo_root,\n    )\n\n    click.echo(\"\")\n\n    return dataclasses.replace(state, diff_file=diff_file)\n\n\ndef fetch_plan_context(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Fetch plan context from linked erk-plan issue.\"\"\"\n    click.echo(click.style(\"Phase 3: Fetching plan context\", bold=True))\n\n    plan_provider = PlanContextProvider(\n        plan_backend=ctx.plan_backend, github_issues=ctx.github_issues\n    )\n    plan_context = plan_provider.get_plan_context(\n        repo_root=state.repo_root,\n        branch_name=state.branch_name,\n    )\n\n    echo_plan_context_status(plan_context)\n\n    return dataclasses.replace(state, plan_context=plan_context)\n\n\ndef generate_description(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Generate AI PR title and body via CommitMessageGenerator.\"\"\"\n    click.echo(click.style(\"Phase 4: Generating PR description\", bold=True))\n\n    if state.diff_file is None:\n        return SubmitError(\n            phase=\"generate_description\",\n            error_type=\"no_diff_file\",\n            message=\"Failed to extract diff for AI analysis\",\n            details={},\n        )\n\n    # Get commit messages for AI context\n    commit_messages = ctx.git.commit.get_commit_messages_since(state.cwd, state.parent_branch)\n\n    msg_gen = CommitMessageGenerator(ctx.prompt_executor)\n    msg_result = run_commit_message_generation(\n        generator=msg_gen,\n        diff_file=state.diff_file,\n        repo_root=state.repo_root,\n        current_branch=state.branch_name,\n        parent_branch=state.parent_branch,\n        commit_messages=commit_messages,\n        plan_context=state.plan_context,\n        debug=state.debug,\n    )\n\n    if not msg_result.success:\n        return SubmitError(\n            phase=\"generate_description\",\n            error_type=\"ai_generation_failed\",\n            message=f\"Failed to generate message: {msg_result.error_message}\",\n            details={},\n        )\n\n    click.echo(\"\")\n\n    return dataclasses.replace(\n        state,\n        title=msg_result.title or \"Update\",\n        body=msg_result.body or \"\",\n    )\n\n\ndef enhance_with_graphite(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"No-op if graphite_url already set. Otherwise check auth + tracking, run gt submit.\"\"\"\n    # Skip if Graphite already handled the push (graphite-first path)\n    if state.graphite_url is not None:\n        return state\n\n    # Skip if user disabled Graphite\n    if not state.use_graphite:\n        return state\n\n    click.echo(click.style(\"Phase 5: Graphite enhancement\", bold=True))\n\n    if state.pr_number is None:\n        return state\n\n    # Check Graphite auth\n    is_gt_authed, gt_username, _ = ctx.graphite.check_auth_status()\n    if not is_gt_authed:\n        if state.debug:\n            click.echo(click.style(\"   Graphite not authenticated, skipping enhancement\", dim=True))\n        click.echo(\"\")\n        return state\n\n    # Check if branch is tracked\n    repo_root = state.repo_root\n    all_branches = ctx.graphite.get_all_branches(ctx.git, repo_root)\n    if state.branch_name not in all_branches:\n        if state.debug:\n            click.echo(\n                click.style(\"   Branch not tracked by Graphite, skipping enhancement\", dim=True)\n            )\n        click.echo(\"\")\n        return state\n\n    # Run gt submit\n    try:\n        ctx.graphite.submit_stack(\n            repo_root,\n            publish=True,\n            restack=False,\n            quiet=False,\n            force=state.force,\n        )\n    except RuntimeError as e:\n        error_msg = str(e).lower()\n        if \"nothing to submit\" in error_msg or \"no changes\" in error_msg:\n            click.echo(click.style(\"   PR already up to date with Graphite\", fg=\"green\"))\n            click.echo(\"\")\n            return state\n        return SubmitError(\n            phase=\"enhance_with_graphite\",\n            error_type=\"graphite_enhance_failed\",\n            message=f\"Graphite enhancement failed: {e}\",\n            details={},\n        )\n\n    # Get Graphite URL\n    remote_url = ctx.git.remote.get_remote_url(repo_root, \"origin\")\n    owner, repo_name = parse_git_remote_url(remote_url)\n    repo_id = GitHubRepoId(owner=owner, repo=repo_name)\n    graphite_url: str | None = None\n    if state.pr_number is not None:\n        graphite_url = ctx.graphite.get_graphite_url(repo_id, state.pr_number)\n\n    click.echo(\"\")\n\n    return dataclasses.replace(state, graphite_url=graphite_url)\n\n\ndef finalize_pr(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Update PR title/body with footer, add labels, amend local commit, clean up diff file.\"\"\"\n    click.echo(click.style(\"Phase 6: Updating PR metadata\", bold=True))\n\n    if state.pr_number is None:\n        return SubmitError(\n            phase=\"finalize_pr\",\n            error_type=\"no_pr_number\",\n            message=\"No PR number available for finalization\",\n            details={},\n        )\n\n    pr_body = state.body or \"\"\n    pr_title = state.title or \"Update\"\n    plans_repo = ctx.local_config.plans_repo if ctx.local_config else None\n\n    # Detect draft-PR backend and extract metadata prefix\n    metadata_prefix = \"\"\n    issue_number = state.issue_number\n    effective_plans_repo = plans_repo\n\n    if ctx.plan_backend.get_provider_name() == \"github-draft-pr\" and state.pr_number is not None:\n        existing_pr = ctx.github.get_pr(state.repo_root, state.pr_number)\n        if not isinstance(existing_pr, PRNotFound):\n            metadata_prefix = extract_metadata_prefix(existing_pr.body)\n        # Don't self-close: draft PR IS the plan\n        issue_number = None\n        effective_plans_repo = None\n    else:\n        # Fallback: preserve existing closing reference from PR body\n        if issue_number is None:\n            closing_ref = _extract_closing_ref_from_pr(ctx, state.cwd, state.pr_number)\n            if closing_ref is not None:\n                issue_number = closing_ref.issue_number\n                effective_plans_repo = closing_ref.plans_repo\n\n    # Add planned/ prefix for plan-linked PRs\n    if issue_number is not None:\n        pr_title = _add_planned_prefix(pr_title)\n\n    # Check learn plan label\n    impl_dir = state.cwd / \".impl\"\n    is_learn_origin = is_learn_plan(impl_dir)\n\n    # Assemble PR body with plan details and footer\n    final_body = assemble_pr_body(\n        body=pr_body,\n        plan_context=state.plan_context,\n        pr_number=state.pr_number,\n        issue_number=issue_number,\n        plans_repo=effective_plans_repo,\n        header=\"\",\n        metadata_prefix=metadata_prefix,\n    )\n\n    # Update PR metadata\n    ctx.github.update_pr_title_and_body(\n        repo_root=state.repo_root,\n        pr_number=state.pr_number,\n        title=pr_title,\n        body=BodyText(content=final_body),\n    )\n\n    # Publish draft PR if needed\n    pr_draft_check = ctx.github.get_pr(state.repo_root, state.pr_number)\n    if not isinstance(pr_draft_check, PRNotFound) and pr_draft_check.is_draft:\n        click.echo(click.style(\"   Publishing draft PR...\", dim=True))\n        ctx.github.mark_pr_ready(state.repo_root, state.pr_number)\n\n    # Add learn skip label if applicable\n    if is_learn_origin:\n        ctx.github.add_label_to_pr(state.repo_root, state.pr_number, ERK_SKIP_LEARN_LABEL)\n\n    # Amend local commit with title and body (without metadata footer)\n    commit_message = pr_title\n    if pr_body:\n        commit_message = f\"{pr_title}\\n\\n{pr_body}\"\n    ctx.git.commit.amend_commit(state.repo_root, commit_message)\n\n    # Fix Graphite tracking divergence caused by the amend\n    if ctx.graphite_branch_ops is not None:\n        ctx.graphite_branch_ops.retrack_branch(state.repo_root, state.branch_name)\n\n    # Clean up temp diff file\n    if state.diff_file is not None and state.diff_file.exists():\n        try:\n            state.diff_file.unlink()\n        except OSError as e:\n            if state.debug:\n                click.echo(click.style(f\"   Failed to clean up diff file: {e}\", dim=True))\n\n    click.echo(click.style(\"   PR metadata updated\", fg=\"green\"))\n    click.echo(\"\")\n\n    # Get final PR URL\n    pr_result = ctx.github.get_pr_for_branch(state.repo_root, state.branch_name)\n    pr_url = pr_result.url if not isinstance(pr_result, PRNotFound) else state.pr_url or \"\"\n\n    # Get Graphite URL if not already set\n    graphite_url = state.graphite_url\n    if graphite_url is None and state.use_graphite:\n        is_gt_authed, _, _ = ctx.graphite.check_auth_status()\n        if is_gt_authed:\n            remote_url = ctx.git.remote.get_remote_url(state.repo_root, \"origin\")\n            owner, repo_name = parse_git_remote_url(remote_url)\n            repo_id = GitHubRepoId(owner=owner, repo=repo_name)\n            graphite_url = ctx.graphite.get_graphite_url(repo_id, state.pr_number)\n\n    return dataclasses.replace(\n        state,\n        issue_number=issue_number,\n        pr_url=pr_url,\n        graphite_url=graphite_url,\n        title=pr_title,\n        body=pr_body,\n    )\n\n\n# ---------------------------------------------------------------------------\n# Helper\n# ---------------------------------------------------------------------------\n\n\ndef _extract_closing_ref_from_pr(\n    ctx: ErkContext,\n    cwd: Path,\n    pr_number: int,\n) -> ClosingReference | None:\n    \"\"\"Extract closing reference from an existing PR's footer.\"\"\"\n    repo_root = ctx.git.repo.get_repository_root(cwd)\n    current_pr = ctx.github.get_pr(repo_root, pr_number)\n    if isinstance(current_pr, PRNotFound) or not current_pr.body:\n        return None\n    existing_footer = extract_footer_from_body(current_pr.body)\n    if existing_footer is None:\n        return None\n    return extract_closing_reference(existing_footer)\n\n\n# ---------------------------------------------------------------------------\n# Pipeline Runner\n# ---------------------------------------------------------------------------\n\n\n@cache\ndef _submit_pipeline() -> tuple[SubmitStep, ...]:\n    return (\n        prepare_state,\n        commit_wip,\n        push_and_create_pr,\n        extract_diff,\n        fetch_plan_context,\n        generate_description,\n        enhance_with_graphite,\n        finalize_pr,\n    )\n\n\ndef run_submit_pipeline(ctx: ErkContext, state: SubmitState) -> SubmitState | SubmitError:\n    \"\"\"Run the submit pipeline, returning final state or first error.\"\"\"\n    for step in _submit_pipeline():\n        try:\n            result = step(ctx, state)\n        except Exception as e:\n            step_name = getattr(step, \"__name__\", repr(step))\n            return SubmitError(\n                phase=step_name,\n                error_type=\"unhandled_exception\",\n                message=f\"Unexpected error in {step_name}: {e}\",\n                details={},\n            )\n        if isinstance(result, SubmitError):\n            return result\n        state = result\n    return state\n\n\ndef make_initial_state(\n    *,\n    cwd: Path,\n    use_graphite: bool,\n    force: bool,\n    debug: bool,\n    session_id: str | None,\n) -> SubmitState:\n    \"\"\"Create initial SubmitState with only CLI-provided values.\n\n    All discovery fields start as empty/None and are populated by prepare_state().\n    \"\"\"\n    resolved_session_id = session_id if session_id is not None else str(uuid.uuid4())\n    return SubmitState(\n        cwd=cwd,\n        repo_root=cwd,\n        branch_name=\"\",\n        parent_branch=\"\",\n        trunk_branch=\"\",\n        use_graphite=use_graphite,\n        force=force,\n        debug=debug,\n        session_id=resolved_session_id,\n        issue_number=None,\n        pr_number=None,\n        pr_url=None,\n        was_created=False,\n        base_branch=None,\n        graphite_url=None,\n        diff_file=None,\n        plan_context=None,\n        title=None,\n        body=None,\n    )\n","structuredPatch":[{"oldStart":692,"oldLines":7,"newStart":692,"newLines":7,"lines":["                 issue_number = closing_ref.issue_number","                 effective_plans_repo = closing_ref.plans_repo"," ","-    # Add planned/ prefix for plan-linked PRs","+    # Add plnd/ prefix for plan-linked PRs","     if issue_number is not None:","         pr_title = _add_planned_prefix(pr_title)"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"3b3eb425-e3bf-4371-8d0f-f4a5e71b9c53","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01RhK9w3PZgxRX8X8pT3GVFr","type":"message","role":"assistant","content":[{"type":"text","text":"Good. Now let me also check for any other `planned/` references in the `.claude/` directory and other markdown docs:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":527,"cache_read_input_tokens":73808,"cache_creation":{"ephemeral_5m_input_tokens":527,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHd7edkQCoqtwxVw5V9","type":"assistant","uuid":"779f94dc-a53d-485f-83e5-1c202a0abebe","timestamp":"2026-02-22T14:45:17.712Z"}
{"parentUuid":"779f94dc-a53d-485f-83e5-1c202a0abebe","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01RhK9w3PZgxRX8X8pT3GVFr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q96bHwtp6z9oTT9boUfU1u","name":"Grep","input":{"pattern":"\"planned/\"","glob":"*.md","output_mode":"content","path":"/home/runner/work/erk/erk/.claude"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":527,"cache_read_input_tokens":73808,"cache_creation":{"ephemeral_5m_input_tokens":527,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHd7edkQCoqtwxVw5V9","type":"assistant","uuid":"e10f95b8-8dd7-4f47-a793-e63167068ee5","timestamp":"2026-02-22T14:45:18.604Z"}
{"parentUuid":"e10f95b8-8dd7-4f47-a793-e63167068ee5","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01RhK9w3PZgxRX8X8pT3GVFr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018SkqQdCbtWu3h6gbKGg1qb","name":"Grep","input":{"pattern":"planned/","glob":"*.md","output_mode":"content","path":"/home/runner/work/erk/erk/docs/learned"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":527,"cache_read_input_tokens":73808,"cache_creation":{"ephemeral_5m_input_tokens":527,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHd7edkQCoqtwxVw5V9","type":"assistant","uuid":"651f4788-9009-4c00-807e-d5e1cc65d1cd","timestamp":"2026-02-22T14:45:19.556Z"}
{"parentUuid":"651f4788-9009-4c00-807e-d5e1cc65d1cd","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q96bHwtp6z9oTT9boUfU1u","type":"tool_result","content":"No matches found"}]},"uuid":"1820267f-8cb6-4459-8b74-a5537ec0ef40","timestamp":"2026-02-22T14:45:20.074Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"parentUuid":"1820267f-8cb6-4459-8b74-a5537ec0ef40","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018SkqQdCbtWu3h6gbKGg1qb","type":"tool_result","content":"docs/learned/planning/index.md:50:- **[plan-title-prefix-system.md](plan-title-prefix-system.md)** — working with PR titles for plan implementations, understanding the planned/ prefix on PR titles, debugging why a PR title has or lacks the planned/ prefix\ndocs/learned/planning/tripwires.md:73:**changing branch naming convention (P{issue}- or planned/ prefix)** → Read [Branch Name Inference](branch-name-inference.md) first. The P{issue}- prefix (issue-based) and planned/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\ndocs/learned/planning/branch-name-inference.md:63:Branches for draft-PR plans start with `plnd/` and follow the pattern `plnd/{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone. Legacy branches may use `planned/` prefix.\ndocs/learned/planning/branch-name-inference.md:70:- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `plnd/` branches; `extract_objective_number()` handles `P{issue}-O{obj}-`, `plnd/O{obj}-`, and legacy `planned/O{obj}-` patterns\ndocs/learned/planning/draft-pr-plan-backend.md:75:- **Draft-PR**: `planned/{slug}-{MM-DD-HHMM}` or `planned/O{objective}-{slug}-{MM-DD-HHMM}` (draft-PR plans)"}]},"uuid":"eeb406c3-8e40-4dae-bcc9-ff8a12ce707b","timestamp":"2026-02-22T14:45:20.079Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"docs/learned/planning/index.md:50:- **[plan-title-prefix-system.md](plan-title-prefix-system.md)** — working with PR titles for plan implementations, understanding the planned/ prefix on PR titles, debugging why a PR title has or lacks the planned/ prefix\ndocs/learned/planning/tripwires.md:73:**changing branch naming convention (P{issue}- or planned/ prefix)** → Read [Branch Name Inference](branch-name-inference.md) first. The P{issue}- prefix (issue-based) and planned/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\ndocs/learned/planning/branch-name-inference.md:63:Branches for draft-PR plans start with `plnd/` and follow the pattern `plnd/{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone. Legacy branches may use `planned/` prefix.\ndocs/learned/planning/branch-name-inference.md:70:- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `plnd/` branches; `extract_objective_number()` handles `P{issue}-O{obj}-`, `plnd/O{obj}-`, and legacy `planned/O{obj}-` patterns\ndocs/learned/planning/draft-pr-plan-backend.md:75:- **Draft-PR**: `planned/{slug}-{MM-DD-HHMM}` or `planned/O{objective}-{slug}-{MM-DD-HHMM}` (draft-PR plans)","numLines":5}}
{"parentUuid":"eeb406c3-8e40-4dae-bcc9-ff8a12ce707b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_013dGeqEvdu6EZr21trfYhXj","type":"message","role":"assistant","content":[{"type":"text","text":"There are more doc files to update. Let me fix them:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1053,"cache_read_input_tokens":74335,"cache_creation":{"ephemeral_5m_input_tokens":1053,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHdUhASRvLNfLt7Lsnc","type":"assistant","uuid":"555b329b-bd71-42c1-aaf2-0356c19b5ae3","timestamp":"2026-02-22T14:45:22.524Z"}
{"parentUuid":"555b329b-bd71-42c1-aaf2-0356c19b5ae3","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_013dGeqEvdu6EZr21trfYhXj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Afx9UJzNtw37nttSJWd4V1","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/planning/index.md","offset":48,"limit":5},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1053,"cache_read_input_tokens":74335,"cache_creation":{"ephemeral_5m_input_tokens":1053,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHdUhASRvLNfLt7Lsnc","type":"assistant","uuid":"5c809dba-e40b-495d-98a5-218aa5e9e16b","timestamp":"2026-02-22T14:45:23.254Z"}
{"parentUuid":"5c809dba-e40b-495d-98a5-218aa5e9e16b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_013dGeqEvdu6EZr21trfYhXj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01R4LQh8364M1HfQLhepd9ew","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/planning/tripwires.md","offset":70,"limit":5},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1053,"cache_read_input_tokens":74335,"cache_creation":{"ephemeral_5m_input_tokens":1053,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHdUhASRvLNfLt7Lsnc","type":"assistant","uuid":"93f10613-890f-4142-8f8c-3792f6a82e78","timestamp":"2026-02-22T14:45:23.865Z"}
{"parentUuid":"93f10613-890f-4142-8f8c-3792f6a82e78","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_013dGeqEvdu6EZr21trfYhXj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JqcVq2rX2Ti5Qihn1frJHt","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/planning/draft-pr-plan-backend.md","offset":72,"limit":8},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1053,"cache_read_input_tokens":74335,"cache_creation":{"ephemeral_5m_input_tokens":1053,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHdUhASRvLNfLt7Lsnc","type":"assistant","uuid":"a1f95c3b-54bd-4716-9ad8-28a3e5577a0a","timestamp":"2026-02-22T14:45:24.643Z"}
{"parentUuid":"a1f95c3b-54bd-4716-9ad8-28a3e5577a0a","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Afx9UJzNtw37nttSJWd4V1","type":"tool_result","content":"    48→- **[plan-migrate-to-draft-pr.md](plan-migrate-to-draft-pr.md)** — migrating an issue-based plan to a draft PR, understanding two-phase metadata preservation during migration, debugging metadata loss after plan migration\n    49→- **[plan-schema.md](plan-schema.md)** — understanding plan issue structure, debugging plan validation errors, working with plan-header or plan-body blocks\n    50→- **[plan-title-prefix-system.md](plan-title-prefix-system.md)** — working with PR titles for plan implementations, understanding the planned/ prefix on PR titles, debugging why a PR title has or lacks the planned/ prefix\n    51→- **[planning-patterns.md](planning-patterns.md)** — preparing to enter plan mode, optimizing plan creation workflow, delegating tasks during planning\n    52→- **[pr-analysis-pattern.md](pr-analysis-pattern.md)** — analyzing PR changes for documentation, building workflows that inspect PRs\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3897d535-f70d-4053-8a2f-31c650404858","timestamp":"2026-02-22T14:45:24.671Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/docs/learned/planning/index.md","content":"- **[plan-migrate-to-draft-pr.md](plan-migrate-to-draft-pr.md)** — migrating an issue-based plan to a draft PR, understanding two-phase metadata preservation during migration, debugging metadata loss after plan migration\n- **[plan-schema.md](plan-schema.md)** — understanding plan issue structure, debugging plan validation errors, working with plan-header or plan-body blocks\n- **[plan-title-prefix-system.md](plan-title-prefix-system.md)** — working with PR titles for plan implementations, understanding the planned/ prefix on PR titles, debugging why a PR title has or lacks the planned/ prefix\n- **[planning-patterns.md](planning-patterns.md)** — preparing to enter plan mode, optimizing plan creation workflow, delegating tasks during planning\n- **[pr-analysis-pattern.md](pr-analysis-pattern.md)** — analyzing PR changes for documentation, building workflows that inspect PRs","numLines":5,"startLine":48,"totalLines":70}}}
{"parentUuid":"3897d535-f70d-4053-8a2f-31c650404858","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01R4LQh8364M1HfQLhepd9ew","type":"tool_result","content":"    70→\n    71→**catching PlanHeaderNotFoundError** → Read [PlanBackend Migration Guide](plan-backend-migration.md) first. PlanHeaderNotFoundError is an exception; PlanNotFound is a result type - use LBYL for the latter\n    72→\n    73→**changing branch naming convention (P{issue}- or planned/ prefix)** → Read [Branch Name Inference](branch-name-inference.md) first. The P{issue}- prefix (issue-based) and planned/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\n    74→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a1b70386-5c8a-4348-9704-1621d38e2c37","timestamp":"2026-02-22T14:45:24.671Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/docs/learned/planning/tripwires.md","content":"\n**catching PlanHeaderNotFoundError** → Read [PlanBackend Migration Guide](plan-backend-migration.md) first. PlanHeaderNotFoundError is an exception; PlanNotFound is a result type - use LBYL for the latter\n\n**changing branch naming convention (P{issue}- or planned/ prefix)** → Read [Branch Name Inference](branch-name-inference.md) first. The P{issue}- prefix (issue-based) and planned/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\n","numLines":5,"startLine":70,"totalLines":242}}}
{"parentUuid":"a1b70386-5c8a-4348-9704-1621d38e2c37","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JqcVq2rX2Ti5Qihn1frJHt","type":"tool_result","content":"    72→\n    73→- **P-prefix**: `P{number}-{slug}` (issue-based plan branches)\n    74→- **Objective format**: `P{number}-O{objective}-{slug}` (plans linked to objectives)\n    75→- **Draft-PR**: `planned/{slug}-{MM-DD-HHMM}` or `planned/O{objective}-{slug}-{MM-DD-HHMM}` (draft-PR plans)\n    76→\n    77→See [branch-plan-resolution.md](branch-plan-resolution.md) for how branches resolve to plans.\n    78→\n    79→## Land Pipeline Integration\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"8979dfdd-5b5b-432b-901f-6b0027a86bf2","timestamp":"2026-02-22T14:45:24.671Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/docs/learned/planning/draft-pr-plan-backend.md","content":"\n- **P-prefix**: `P{number}-{slug}` (issue-based plan branches)\n- **Objective format**: `P{number}-O{objective}-{slug}` (plans linked to objectives)\n- **Draft-PR**: `planned/{slug}-{MM-DD-HHMM}` or `planned/O{objective}-{slug}-{MM-DD-HHMM}` (draft-PR plans)\n\nSee [branch-plan-resolution.md](branch-plan-resolution.md) for how branches resolve to plans.\n\n## Land Pipeline Integration","numLines":8,"startLine":72,"totalLines":128}}}
{"parentUuid":"8979dfdd-5b5b-432b-901f-6b0027a86bf2","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01LZ9AxJ9JEergou9rJNzgFw","type":"message","role":"assistant","content":[{"type":"text","text":"These are auto-generated index/tripwire files. The index.md is auto-generated from frontmatter. Let me update the source frontmatter in plan-title-prefix-system.md (already done - I changed the `read_when` lines). The index and tripwires files are auto-generated. Let me update the draft-pr-plan-backend.md directly though:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1515,"cache_read_input_tokens":75388,"cache_creation":{"ephemeral_5m_input_tokens":1515,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHdpMMESXPwvxf3xiXE","type":"assistant","uuid":"f7bdb31b-3f38-4d3e-9575-16c9ad2840c7","timestamp":"2026-02-22T14:45:28.946Z"}
{"parentUuid":"f7bdb31b-3f38-4d3e-9575-16c9ad2840c7","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01LZ9AxJ9JEergou9rJNzgFw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Bvi24rwH15Sf2Z9o1y8Z5Z","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/planning/draft-pr-plan-backend.md","old_string":"- **Draft-PR**: `planned/{slug}-{MM-DD-HHMM}` or `planned/O{objective}-{slug}-{MM-DD-HHMM}` (draft-PR plans)","new_string":"- **Draft-PR**: `plnd/{slug}-{MM-DD-HHMM}` or `plnd/O{objective}-{slug}-{MM-DD-HHMM}` (draft-PR plans)"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1515,"cache_read_input_tokens":75388,"cache_creation":{"ephemeral_5m_input_tokens":1515,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHdpMMESXPwvxf3xiXE","type":"assistant","uuid":"e7060028-dc4f-4263-aecd-2868cb4bec6e","timestamp":"2026-02-22T14:45:30.487Z"}
{"parentUuid":"e7060028-dc4f-4263-aecd-2868cb4bec6e","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Bvi24rwH15Sf2Z9o1y8Z5Z","type":"tool_result","content":"The file /home/runner/work/erk/erk/docs/learned/planning/draft-pr-plan-backend.md has been updated successfully."}]},"uuid":"36a105c7-13d0-46aa-9ab8-d1f9c26d4f8d","timestamp":"2026-02-22T14:45:31.158Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/docs/learned/planning/draft-pr-plan-backend.md","oldString":"- **Draft-PR**: `planned/{slug}-{MM-DD-HHMM}` or `planned/O{objective}-{slug}-{MM-DD-HHMM}` (draft-PR plans)","newString":"- **Draft-PR**: `plnd/{slug}-{MM-DD-HHMM}` or `plnd/O{objective}-{slug}-{MM-DD-HHMM}` (draft-PR plans)","originalFile":"---\ntitle: Draft PR Plan Backend\nread_when:\n  - \"working with plan storage or plan backends\"\n  - \"adding plan storage behavior without checking plan backend type\"\n  - \"understanding how plans are stored as draft pull requests\"\n  - \"modifying plan-save or land pipeline for plan handling\"\ntripwires:\n  - action: \"adding plan storage behavior without checking plan backend type\"\n    warning: \"Two backends exist (github, draft_pr). Verify behavior works for both. See draft-pr-plan-backend.md.\"\n  - action: \"validating plan_id in exec scripts without checking provider type\"\n    warning: \"Draft-PR plan_id IS the PR number (not an issue number). Check provider type before assuming plan_id semantics. Issue-based plans use issue numbers; draft-PR plans use PR numbers.\"\n    score: 4\n  - action: \"reading ERK_PLAN_BACKEND env var inside inner functions when global_config is already in scope\"\n    warning: \"Backend detection precedence: when GlobalConfig.plan_backend is available via context, use it. Never fall back to re-reading env vars inside inner functions if global_config is already in scope — the context value takes precedence and re-reading env vars bypasses context overrides.\"\n    score: 8\n  - action: \"spawning a GitHub Actions workflow from erk without passing plan_backend as an explicit input\"\n    warning: \"Draft-PR backend propagation: GitHub Actions reusable workflows (workflow_call) do NOT inherit environment variables from the caller. ERK_PLAN_BACKEND must be declared as an explicit workflow input and passed by the caller. Ambient env vars are invisible to reusable workflows.\"\n    score: 9\n  - action: \"implementing RealPlanListService or DraftPRPlanListService without checking the other for parity\"\n    warning: \"Both plan list services must handle parameters identically. Interface contracts are not enforced by the type system — behavioral divergence between the two services causes subtle bugs when switching backends.\"\n    score: 6\n  - action: \"using gh issue view on a plan ID without checking plan backend type\"\n    warning: \"Draft-PR plan IDs are PR numbers. Using gh issue view on a draft-PR plan produces a confusing 404. Route to gh pr view based on backend type.\"\n    score: 7\n---\n\n# Draft PR Plan Backend\n\nDraftPRPlanBackend stores plans as GitHub draft pull requests instead of issues. It is an alternative to the default GitHubPlanStore (issue-based) backend.\n\n## Backend Selection\n\nBackend selection is controlled by the `ERK_PLAN_BACKEND` environment variable, read by `get_plan_backend()` in `packages/erk-shared/src/erk_shared/plan_store/__init__.py:19-24`:\n\n- `\"github\"` (default): Issue-based storage via GitHubPlanStore\n- `\"draft_pr\"`: Draft PR-based storage via DraftPRPlanBackend\n\nContext creation in `src/erk/core/context.py:604-609` uses this to select both the plan store and plan list service:\n\n<!-- Source: src/erk/core/context.py, create_context -->\n\nSee backend selection in `create_context()` in `src/erk/core/context.py` — dispatches on `get_plan_backend()` to select GitHubPlanStore or DraftPRPlanBackend.\n\n## Architecture\n\nDraftPRPlanBackend uses **composition** — it wraps the top-level GitHub gateway, not inheritance. The class is at `packages/erk-shared/src/erk_shared/plan_store/draft_pr.py`.\n\nKey design decisions:\n\n- **Lightweight init**: No I/O in `__init__`, dependencies injected (`github`, `time`)\n- **Provider name**: `\"github-draft-pr\"` (used for conditional dispatch elsewhere)\n- **Immutable metadata fields**: `schema_version`, `created_at`, `created_by` are protected from updates\n\n## PR Body Format\n\nPlan PRs use a structured body format: metadata block + separator + plan content.\n\n- **Separator**: `\"\\n\\n---\\n\\n\"`\n- **Label**: `\"erk-plan\"`\n- **Structure**: `<!-- plan-header metadata -->` + separator + `# Plan: Title` + content\n\nHelper functions `build_plan_stage_body()` and `extract_plan_content()` (public, in `draft_pr_lifecycle.py`) handle composition and extraction.\n\n## Plan File Commit\n\nPlans are committed to `.erk/plan/PLAN.md` on the draft PR branch. The `plan_save.py` script uses a try/finally pattern for branch restoration — see [plan-save-branch-restoration.md](../architecture/plan-save-branch-restoration.md).\n\n## Branch Naming\n\nThree branch name formats are supported:\n\n- **P-prefix**: `P{number}-{slug}` (issue-based plan branches)\n- **Objective format**: `P{number}-O{objective}-{slug}` (plans linked to objectives)\n- **Draft-PR**: `planned/{slug}-{MM-DD-HHMM}` or `planned/O{objective}-{slug}-{MM-DD-HHMM}` (draft-PR plans)\n\nSee [branch-plan-resolution.md](branch-plan-resolution.md) for how branches resolve to plans.\n\n## Land Pipeline Integration\n\nThe `close_review_pr()` function in `src/erk/cli/commands/land_pipeline.py:469-471` skips cleanup for draft-PR plans since they don't have separate review PRs:\n\n<!-- Source: src/erk/cli/commands/land_pipeline.py, close_review_pr -->\n\nSee `close_review_pr()` in `src/erk/cli/commands/land_pipeline.py` — skips cleanup for draft-PR plans.\n\n## Type Narrowing\n\nThe backend uses explicit `isinstance()` checks and conditional type conversion for metadata fields, following LBYL discipline rather than `cast()`.\n\n## Title Prefixing Behavior\n\nDraft PR titles (and issue-based plan titles) are prefixed with a label-based tag via `get_title_tag_from_labels()` in `packages/erk-shared/src/erk_shared/plan_utils.py:178-190`.\n\n<!-- Source: packages/erk-shared/src/erk_shared/plan_utils.py:178-190, get_title_tag_from_labels -->\n\nThe function returns `\"[erk-learn]\"` if `\"erk-learn\"` is in the labels list, otherwise `\"[erk-plan]\"`. The prefix is prepended to the plan title during PR creation (e.g., `[erk-plan] My Feature`). For erk-learn plans, the prefix becomes `[erk-learn]` to distinguish documentation/learning plans from implementation plans in the PR list.\n\n## GraphQL Refactor: `list_plan_prs_with_details()`\n\nThe plan data provider fetches PRs via a single GraphQL query (`list_plan_prs_with_details()`) instead of N+1 REST calls. This function lives in `packages/erk-shared/src/erk_shared/gateway/github/real.py:1588` and returns:\n\n- `list[PRDetails]` — for plan content extraction\n- `dict[int, list[PullRequestInfo]]` — for display metadata (checks, review threads, merge status)\n\nThe single query uses `GET_PLAN_PRS_WITH_DETAILS_QUERY` from `graphql_queries.py` and fetches review decision, conflict status, and CI checks in one round-trip, replacing the previous approach of fetching each PR individually.\n\n## Implementation Setup and .erk/impl-context/ Cleanup\n\nWhen implementing a draft-PR plan, the `.erk/impl-context/` staging directory must be cleaned up before implementation begins. This directory contains `plan.md` and `ref.json` committed during plan-save to give the draft PR a non-empty diff.\n\n**Cleanup pattern:**\n\n1. `setup_impl_from_issue.py` reads the files into `.impl/` but does NOT delete them (deferred cleanup)\n2. `plan-implement.md` Step 2d performs the actual `git rm -rf .erk/impl-context/ && git commit && git push`\n3. The step is **idempotent** — safe to run when the directory doesn't exist\n\n**Rebase conflict handling:** After cleanup commits on the plan branch, a `git pull --rebase` may be needed before pushing further implementation commits. Skipping this can cause non-fast-forward push failures when the remote branch has diverged.\n\nFor full details, see [Impl-Context Staging Directory](impl-context.md).\n\n## Related Topics\n\n- [Branch Plan Resolution](branch-plan-resolution.md) - How branches resolve to plans\n- [Plan Save Branch Restoration](../architecture/plan-save-branch-restoration.md) - Try/finally pattern for branch safety\n- [Dual Backend Testing](../testing/dual-backend-testing.md) - Testing across both backends\n- [Impl-Context Staging Directory](impl-context.md) - Staging directory lifecycle and cleanup\n","structuredPatch":[{"oldStart":72,"oldLines":7,"newStart":72,"newLines":7,"lines":[" "," - **P-prefix**: `P{number}-{slug}` (issue-based plan branches)"," - **Objective format**: `P{number}-O{objective}-{slug}` (plans linked to objectives)","-- **Draft-PR**: `planned/{slug}-{MM-DD-HHMM}` or `planned/O{objective}-{slug}-{MM-DD-HHMM}` (draft-PR plans)","+- **Draft-PR**: `plnd/{slug}-{MM-DD-HHMM}` or `plnd/O{objective}-{slug}-{MM-DD-HHMM}` (draft-PR plans)"," "," See [branch-plan-resolution.md](branch-plan-resolution.md) for how branches resolve to plans."," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"36a105c7-13d0-46aa-9ab8-d1f9c26d4f8d","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01XKfJuHG57oDDGf8w6HknZd","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the auto-generated index and tripwires files. These are auto-generated but I should still update them since `erk docs sync` may not be run immediately:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":348,"cache_read_input_tokens":76903,"cache_creation":{"ephemeral_5m_input_tokens":348,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHeJ5DbJmBmZMSgUJrT","type":"assistant","uuid":"bd15f038-f508-46a9-9bc7-a073ee320bb9","timestamp":"2026-02-22T14:45:34.235Z"}
{"parentUuid":"bd15f038-f508-46a9-9bc7-a073ee320bb9","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01XKfJuHG57oDDGf8w6HknZd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013oQDkRc8hQuMeRGFmjsGCU","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/planning/index.md","old_string":"- **[plan-title-prefix-system.md](plan-title-prefix-system.md)** — working with PR titles for plan implementations, understanding the planned/ prefix on PR titles, debugging why a PR title has or lacks the planned/ prefix","new_string":"- **[plan-title-prefix-system.md](plan-title-prefix-system.md)** — working with PR titles for plan implementations, understanding the plnd/ prefix on PR titles, debugging why a PR title has or lacks the plnd/ prefix"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":348,"cache_read_input_tokens":76903,"cache_creation":{"ephemeral_5m_input_tokens":348,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHeJ5DbJmBmZMSgUJrT","type":"assistant","uuid":"11fc0a95-69f5-49fd-a7ad-8c1395df272e","timestamp":"2026-02-22T14:45:35.959Z"}
{"parentUuid":"11fc0a95-69f5-49fd-a7ad-8c1395df272e","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013oQDkRc8hQuMeRGFmjsGCU","type":"tool_result","content":"The file /home/runner/work/erk/erk/docs/learned/planning/index.md has been updated successfully."}]},"uuid":"5fb6b195-7d0b-43f0-baf7-bc31c0eaa120","timestamp":"2026-02-22T14:45:36.639Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/docs/learned/planning/index.md","oldString":"- **[plan-title-prefix-system.md](plan-title-prefix-system.md)** — working with PR titles for plan implementations, understanding the planned/ prefix on PR titles, debugging why a PR title has or lacks the planned/ prefix","newString":"- **[plan-title-prefix-system.md](plan-title-prefix-system.md)** — working with PR titles for plan implementations, understanding the plnd/ prefix on PR titles, debugging why a PR title has or lacks the plnd/ prefix","originalFile":"<!-- AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY -->\n<!-- Edit source frontmatter, then run 'erk docs sync' to regenerate. -->\n\n# Planning Documentation\n\n- **[agent-delegation.md](agent-delegation.md)** — delegating to agents from commands, implementing command-agent pattern, workflow orchestration\n- **[agent-orchestration-safety.md](agent-orchestration-safety.md)** — passing data between agents via files or inline output, designing multi-agent workflows with parallel and sequential tiers, orchestrating subagents that produce markdown, XML, or other large outputs\n- **[agent-orchestration.md](agent-orchestration.md)** — designing agent workflows with parallel and sequential tiers, choosing between parallel and sequential agent execution, adding or modifying agents in the learn pipeline, deciding which model tier to assign an agent\n- **[agent-output-routing-strategies.md](agent-output-routing-strategies.md)** — deciding how agents should receive and produce outputs, designing multi-agent orchestration prompts, choosing between embedded-prompt and agent-file routing\n- **[async-learn-local-preprocessing.md](async-learn-local-preprocessing.md)** — modifying trigger-async-learn orchestration, debugging why learn materials are missing or malformed in CI, understanding the local-to-gist-to-codespace data flow\n- **[branch-name-inference.md](branch-name-inference.md)** — debugging missing branch_name in plan issues, implementing PR lookup from plan issues, modifying branch creation or naming conventions\n- **[branch-plan-resolution.md](branch-plan-resolution.md)** — resolving which plan a branch belongs to, working with branch naming conventions for plans, understanding how get_plan_for_branch works\n- **[complete-inventory-protocol.md](complete-inventory-protocol.md)** — estimating effort or remaining work for a plan or PR, closing a plan issue as complete, creating a consolidation plan from multiple PRs\n- **[consolidation-labels.md](consolidation-labels.md)** — consolidating multiple learn plans, working with erk-consolidated label, preventing re-consolidation of issues, modifying /local:replan-learn-plans or /erk:replan consolidation behavior\n- **[context-preservation-in-replan.md](context-preservation-in-replan.md)** — implementing or modifying replan workflow steps, debugging why a replanned issue produced a sparse plan, adding new plan-creation workflows that use EnterPlanMode\n- **[context-preservation-patterns.md](context-preservation-patterns.md)** — writing implementation plans (any workflow), reviewing plan content before saving to GitHub, creating consolidated plans from multiple sources, debugging why an implementing agent had to re-investigate\n- **[context-preservation-prompting.md](context-preservation-prompting.md)** — writing slash commands that create plans, designing any workflow that calls EnterPlanMode, understanding why plans lose investigation context\n- **[cornerstone-enforcement.md](cornerstone-enforcement.md)** — understanding SHOULD_BE_CODE filtering, working on learn pipeline classification, documentation items being classified as code, understanding cornerstone test rules\n- **[cross-artifact-analysis.md](cross-artifact-analysis.md)** — detecting PR and plan relationships, assessing if work supersedes a plan, analyzing overlap between artifacts\n- **[cross-repo-plans.md](cross-repo-plans.md)** — setting up plans in a separate repository, configuring [plans] repo in config.toml, understanding cross-repo issue closing syntax\n- **[debugging-patterns.md](debugging-patterns.md)** — Debugging validation failures after an initial fix attempt fails, Encountering errors where the required format is unclear from the error message alone, Deciding whether to guess at another fix or read the validator source\n- **[draft-pr-branch-sync.md](draft-pr-branch-sync.md)** — implementing or debugging draft-PR plan setup, understanding branch sync during plan implementation, working with setup_impl_from_issue for draft PR plans, debugging divergence between local and remote plan branches\n- **[draft-pr-learn-pipeline.md](draft-pr-learn-pipeline.md)** — debugging why erk learn fails for draft-PR-backed plans, understanding how trigger-async-learn discovers plan IDs for draft-PR plans, working on the learn pipeline for non-issue-based plans\n- **[draft-pr-lifecycle.md](draft-pr-lifecycle.md)** — working with draft-PR-backed plans, understanding PR body format for draft PR plans, debugging plan content extraction from PR bodies, building or modifying lifecycle stage transitions\n- **[draft-pr-plan-backend.md](draft-pr-plan-backend.md)** — working with plan storage or plan backends, adding plan storage behavior without checking plan backend type, understanding how plans are stored as draft pull requests, modifying plan-save or land pipeline for plan handling\n- **[exploration-strategies.md](exploration-strategies.md)** — deciding when to use Explore agents vs direct searches, planning a two-stage explore-then-plan workflow, gathering codebase context before entering plan mode\n- **[gateway-consolidation-checklist.md](gateway-consolidation-checklist.md)** — moving a gateway package into the gateway/ directory, extracting a new gateway from existing code, performing large-scale import refactoring across packages\n- **[impl-context.md](impl-context.md)** — working with .erk/impl-context/ files, debugging plan content missing from a draft-PR implementation, reviewing a PR that contains .erk/impl-context/ files, understanding how draft-PR plans transfer content to .impl/\n- **[learn-pipeline-workflow.md](learn-pipeline-workflow.md)** — debugging why learn materials are missing or malformed, understanding data flow from sessions to documentation plan, choosing between local learn and async learn modes, adding a new stage to the learn pipeline\n- **[learn-plan-metadata-fields.md](learn-plan-metadata-fields.md)** — working with learn plan metadata, troubleshooting null learn_status or learn_plan_issue, transforming Plan objects in pipelines, understanding created_from_workflow_run_url field, adding workflow run backlinks to plans\n- **[learn-plan-validation.md](learn-plan-validation.md)** — creating or modifying erk-learn plans, working on the learn workflow pipeline, debugging learn-on-learn cycle errors\n- **[learn-vs-implementation-plans.md](learn-vs-implementation-plans.md)** — choosing between plan types, creating erk-learn plans, understanding how learn plans relate to implementation plans, debugging learn plan base branch selection\n- **[learn-without-pr-context.md](learn-without-pr-context.md)** — debugging learn workflow failures where PR data is missing, implementing new learn pipeline steps that consume PR context, understanding why learn output lacks review feedback\n- **[learn-workflow.md](learn-workflow.md)** — using /erk:learn skill, understanding learn status tracking, auto-updating parent plans when learn plans land\n- **[lifecycle.md](lifecycle.md)** — creating a plan, closing a plan, understanding plan states\n- **[metadata-block-fallback.md](metadata-block-fallback.md)** — extracting plan content from GitHub issue comments, debugging 'no plan content found' errors in replan or plan-implement, working with older erk-plan issues that lack metadata blocks\n- **[metadata-field-workflow.md](metadata-field-workflow.md)** — adding a new field to plan-header metadata, extending plan issue schema, coordinating metadata changes across files\n- **[next-steps-output.md](next-steps-output.md)** — modifying next-steps output after plan save or submit, understanding IssueNextSteps vs DraftPRNextSteps, adding new next-steps commands to plan output\n- **[no-changes-handling.md](no-changes-handling.md)** — implementing erk-impl workflow, debugging no-changes scenarios, understanding erk-impl error handling\n- **[objective-update-after-land.md](objective-update-after-land.md)** — modifying the land pipeline's post-merge behavior, working with objective-update-after-land exec script, understanding fail-open patterns in erk\n- **[one-shot-workflow.md](one-shot-workflow.md)** — working with erk one-shot dispatch, understanding how plans are autonomously created and implemented, debugging one-shot workflow failures or skeleton plan issues, integrating objectives with one-shot dispatch\n- **[parallel-audit-pattern.md](parallel-audit-pattern.md)** — designing parallel agent workflows for bulk operations, implementing multi-agent batch processing, understanding how audit-scan or learn commands parallelize work\n- **[plan-backend-migration.md](plan-backend-migration.md)** — migrating exec scripts from direct GitHubIssues to PlanBackend, implementing LBYL pattern for plan existence checks, handling PlanNotFound vs PlanHeaderNotFoundError\n- **[plan-creation-pathways.md](plan-creation-pathways.md)** — understanding how plans are created in erk, adding a new plan creation entry point, debugging which code path created a plan\n- **[plan-execution-patterns.md](plan-execution-patterns.md)** — implementing a plan from a GitHub issue, understanding branch naming and worktree isolation, designing PR submission workflows for plans\n- **[plan-header-privatization.md](plan-header-privatization.md)** — migrating callers of plan_header.py functions, understanding why plan_header functions are being privatized, working with PlanBackend metadata operations\n- **[plan-lookup-strategy.md](plan-lookup-strategy.md)** — debugging plan lookup issues, understanding plan file discovery, troubleshooting wrong plan saved\n- **[plan-migrate-to-draft-pr.md](plan-migrate-to-draft-pr.md)** — migrating an issue-based plan to a draft PR, understanding two-phase metadata preservation during migration, debugging metadata loss after plan migration\n- **[plan-schema.md](plan-schema.md)** — understanding plan issue structure, debugging plan validation errors, working with plan-header or plan-body blocks\n- **[plan-title-prefix-system.md](plan-title-prefix-system.md)** — working with PR titles for plan implementations, understanding the planned/ prefix on PR titles, debugging why a PR title has or lacks the planned/ prefix\n- **[planning-patterns.md](planning-patterns.md)** — preparing to enter plan mode, optimizing plan creation workflow, delegating tasks during planning\n- **[pr-analysis-pattern.md](pr-analysis-pattern.md)** — analyzing PR changes for documentation, building workflows that inspect PRs\n- **[pr-discovery.md](pr-discovery.md)** — finding the PR associated with an erk plan issue, debugging why get-pr-for-plan returns no-branch-in-plan, understanding how erk learn finds PRs, working with plan-header branch_name field\n- **[pr-review-workflow.md](pr-review-workflow.md)** — creating or managing plan review PRs, addressing feedback on plan content via PR comments, understanding how review PRs relate to implementation PRs, closing or cleaning up plan review PRs\n- **[pr-submission-patterns.md](pr-submission-patterns.md)** — creating or updating PRs programmatically in erk, debugging why a duplicate PR or issue was created, fixing erk pr check validation failures, understanding the PR number vs issue number distinction\n- **[reliability-patterns.md](reliability-patterns.md)** — deciding whether an operation should be agent-driven or workflow-native, designing multi-layer resilience for critical automated operations, ordering git operations that mix cleanup with reset in CI workflows\n- **[remote-implementation-idempotency.md](remote-implementation-idempotency.md)** — implementing remote plan execution, debugging branch creation in remote workflows, working with worktree reuse patterns\n- **[schema-v3-migration.md](schema-v3-migration.md)** — working with plan metadata YAML keys, modifying roadmap parsing or rendering, encountering steps vs nodes naming in plan metadata\n- **[scratch-storage.md](scratch-storage.md)** — writing temp files for AI workflows, passing files between processes, understanding scratch directory location\n- **[session-deduplication.md](session-deduplication.md)** — understanding duplicate plan prevention, working with exit-plan-mode hook, debugging duplicate issue creation\n- **[session-preprocessing.md](session-preprocessing.md)** — modifying session preprocessing or compression pipeline, understanding why there are two preprocessing implementations, linking sessions to plans for learn workflow, debugging preprocessing failures or empty session output\n- **[sub-agent-context-limitations.md](sub-agent-context-limitations.md)** — delegating session-dependent commands to Task tool sub-agents, debugging impl-signal or plan-save-to-issue failures with empty session IDs, designing workflows that split work between root agent and sub-agents\n- **[submit-branch-reuse.md](submit-branch-reuse.md)** — implementing erk plan submit, handling duplicate branches, resubmitting a plan issue\n- **[token-optimization-patterns.md](token-optimization-patterns.md)** — designing multi-agent workflows that process multiple documents, experiencing context bloat from fetching large payloads into parent agent, choosing where to place content fetching in an orchestration pipeline, deciding which model tier to use for delegated work\n- **[tripwire-promotion-workflow.md](tripwire-promotion-workflow.md)** — implementing tripwire candidate extraction, promoting tripwire candidates to frontmatter, understanding the learn-to-tripwire pipeline\n- **[tripwire-worthiness-criteria.md](tripwire-worthiness-criteria.md)** — evaluating whether an insight deserves tripwire status, reviewing [TRIPWIRE-CANDIDATE] items from learn workflow, understanding what makes something tripwire-worthy\n- **[workflow-markers.md](workflow-markers.md)** — building multi-step workflows that need state persistence, using erk exec marker commands, implementing objective-to-plan workflows\n- **[workflow.md](workflow.md)** — using .impl/ folders, understanding plan file structure, implementing plans\n- **[worktree-cleanup.md](worktree-cleanup.md)** — cleaning up .worker-impl/ after plan implementation, debugging leftover .worker-impl/ artifacts in a PR, deciding whether to auto-remove an implementation folder\n","structuredPatch":[{"oldStart":47,"oldLines":7,"newStart":47,"newLines":7,"lines":[" - **[plan-lookup-strategy.md](plan-lookup-strategy.md)** — debugging plan lookup issues, understanding plan file discovery, troubleshooting wrong plan saved"," - **[plan-migrate-to-draft-pr.md](plan-migrate-to-draft-pr.md)** — migrating an issue-based plan to a draft PR, understanding two-phase metadata preservation during migration, debugging metadata loss after plan migration"," - **[plan-schema.md](plan-schema.md)** — understanding plan issue structure, debugging plan validation errors, working with plan-header or plan-body blocks","-- **[plan-title-prefix-system.md](plan-title-prefix-system.md)** — working with PR titles for plan implementations, understanding the planned/ prefix on PR titles, debugging why a PR title has or lacks the planned/ prefix","+- **[plan-title-prefix-system.md](plan-title-prefix-system.md)** — working with PR titles for plan implementations, understanding the plnd/ prefix on PR titles, debugging why a PR title has or lacks the plnd/ prefix"," - **[planning-patterns.md](planning-patterns.md)** — preparing to enter plan mode, optimizing plan creation workflow, delegating tasks during planning"," - **[pr-analysis-pattern.md](pr-analysis-pattern.md)** — analyzing PR changes for documentation, building workflows that inspect PRs"," - **[pr-discovery.md](pr-discovery.md)** — finding the PR associated with an erk plan issue, debugging why get-pr-for-plan returns no-branch-in-plan, understanding how erk learn finds PRs, working with plan-header branch_name field"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"5fb6b195-7d0b-43f0-baf7-bc31c0eaa120","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_016ospjYqL41926yb4C4QCCc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JpXmmdGgK6HHmZPaDad3S8","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/docs/learned/planning/tripwires.md","old_string":"**changing branch naming convention (P{issue}- or planned/ prefix)** → Read [Branch Name Inference](branch-name-inference.md) first. The P{issue}- prefix (issue-based) and planned/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.","new_string":"**changing branch naming convention (P{issue}- or plnd/ prefix)** → Read [Branch Name Inference](branch-name-inference.md) first. The P{issue}- prefix (issue-based) and plnd/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":636,"cache_read_input_tokens":77251,"cache_creation":{"ephemeral_5m_input_tokens":636,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHehVdSJtw2LC1DP7tP","type":"assistant","uuid":"83a010a9-3d18-4487-81c6-a273b170a898","timestamp":"2026-02-22T14:45:40.668Z"}
{"parentUuid":"83a010a9-3d18-4487-81c6-a273b170a898","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JpXmmdGgK6HHmZPaDad3S8","type":"tool_result","content":"The file /home/runner/work/erk/erk/docs/learned/planning/tripwires.md has been updated successfully."}]},"uuid":"b782bbbb-1c29-44cf-a379-5816807b6d25","timestamp":"2026-02-22T14:45:41.339Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/docs/learned/planning/tripwires.md","oldString":"**changing branch naming convention (P{issue}- or planned/ prefix)** → Read [Branch Name Inference](branch-name-inference.md) first. The P{issue}- prefix (issue-based) and planned/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.","newString":"**changing branch naming convention (P{issue}- or plnd/ prefix)** → Read [Branch Name Inference](branch-name-inference.md) first. The P{issue}- prefix (issue-based) and plnd/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.","originalFile":"---\ntitle: Planning Tripwires\nread_when:\n  - \"working on planning code\"\n---\n\n<!-- AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY -->\n<!-- Edit source frontmatter, then run 'erk docs sync' to regenerate. -->\n<!-- Generated from planning/*.md frontmatter -->\n\n# Planning Tripwires\n\nRules triggered by matching actions in code.\n\n**adding <code> inside <summary> elements in PR bodies** → Read [Draft PR Lifecycle](draft-pr-lifecycle.md) first. Graphite doesn't render <code> inside <summary> — use plain text instead. GitHub renders it but Graphite does not. The correct format is <summary>original-plan</summary> not <summary><code>original-plan</code></summary>.\n\n**adding Closes #N to a draft PR footer** → Read [Draft PR Lifecycle](draft-pr-lifecycle.md) first. Draft PR IS the plan. Self-referential close would close the plan itself. Use issue_number=None for draft-PR backend.\n\n**adding a new PR-dependent step to trigger-async-learn** → Read [Learn Without PR Context](learn-without-pr-context.md) first. Any new PR-dependent step must handle the None case from \\_get_pr_for_plan_direct. The entire PR comment block is gated on pr_result not being None.\n\n**adding a new filtering step to preprocess_session.py** → Read [Session Preprocessing Architecture](session-preprocessing.md) first. There are TWO preprocessing implementations: the exec script (preprocess_session.py) and erk-shared (session_preprocessing.py). The exec script has the full filtering pipeline; erk-shared has only Stage 1 mechanical reduction. New filters go in the exec script. Read this doc first.\n\n**adding a new pipeline stage to trigger-async-learn** → Read [Learn Pipeline Workflow](learn-pipeline-workflow.md) first. New stages must be direct Python function calls, not subprocess invocations. The orchestrator uses tight coupling for performance. See the Direct-Call Architecture section in async-learn-local-preprocessing.md.\n\n**adding a new setup path to plan-implement without routing through Step 2d** → Read [Impl-Context Staging Directory](impl-context.md) first. Impl-context cleanup routing: all code paths that set up an implementation context must route through Step 2d in plan-implement.md, which is the single convergence point for .erk/impl-context/ cleanup. Adding a new setup path that bypasses Step 2d will silently skip cleanup, leaving .erk/impl-context/ files in the final PR diff.\n\n**adding branch_name to plan-header at creation time** → Read [Branch Name Inference](branch-name-inference.md) first. branch_name is intentionally omitted at creation because the branch doesn't exist yet. The plan-save → branch-create → impl-signal lifecycle requires this gap. See the temporal gap section below.\n\n**adding dry-run support to one-shot commands** → Read [One-Shot Workflow](one-shot-workflow.md) first. One-shot dry-run mode must NOT create skeleton issues\n\n**adding erk-consolidated label to a single-issue replan** → Read [Consolidation Labels](consolidation-labels.md) first. Only multi-plan consolidation gets the erk-consolidated label. Single-issue replans are updates, not consolidations.\n\n**adding footer before PR creation** → Read [Draft PR Lifecycle](draft-pr-lifecycle.md) first. PR footer needs the PR number, which isn't known until after create_pr returns. Add footer AFTER PR creation.\n\n**adding new agents to learn workflow** → Read [Learn Workflow](learn-workflow.md) first. Document input/output format and test file passing. Learn workflow uses stateless agents with file-based composition.\n\n**adding plan storage behavior without checking plan backend type** → Read [Draft PR Plan Backend](draft-pr-plan-backend.md) first. Two backends exist (github, draft_pr). Verify behavior works for both. See draft-pr-plan-backend.md.\n\n**adding post-dispatch operations without matching submit.py pattern** → Read [One-Shot Workflow](one-shot-workflow.md) first. dispatch_one_shot() and \\_submit_single_issue() in submit.py must stay synchronized. Both use write_dispatch_metadata() + create_submission_queued_block(). Changes to one must be mirrored in the other.\n\n**adding subprocess calls to trigger-async-learn** → Read [Async Learn Local Preprocessing](async-learn-local-preprocessing.md) first. This command uses direct Python function calls, not subprocess invocations. This is intentional — see the direct-call architecture section below.\n\n**after plan-implement execution completes** → Read [Plan Lifecycle](lifecycle.md) first. Always clean .worker-impl/ with `git rm -rf .worker-impl/` and commit. Transient artifacts cause CI formatter failures (Prettier).\n\n**analyzing sessions larger than 100k characters** → Read [Scratch Storage](scratch-storage.md) first. Use `erk exec preprocess-session` first. Achieves ~99% token reduction (e.g., 6.2M -> 67k chars). Critical for fitting large sessions in agent context windows.\n\n**assigning opus to a mechanical extraction agent** → Read [Multi-Tier Agent Orchestration](agent-orchestration.md) first. Model escalation: haiku/sonnet for extraction and rule-based work, opus only for creative authoring. See the model escalation decision table.\n\n**assuming branch names always follow the P-prefix format** → Read [Branch Plan Resolution](branch-plan-resolution.md) first. Branch resolution supports multiple formats (P-prefix, objective). Use resolve_plan_id_for_branch() rather than manual parsing. See branch-plan-resolution.md.\n\n**assuming branch_name is always present in plan-header metadata** → Read [PR Discovery Strategies for Plans](pr-discovery.md) first. branch_name is null until Phase 2 (plan submit). Check the plan metadata field lifecycle in lifecycle.md.\n\n**assuming plan content is in the issue body** → Read [Plan Content Extraction Fallback](metadata-block-fallback.md) first. Schema v2 stores plan content in the FIRST COMMENT, not the issue body. The body contains only the plan-header metadata block. See extract_plan_from_comment() for the extraction logic.\n\n**assuming remote sessions skip local preprocessing** → Read [Async Learn Local Preprocessing](async-learn-local-preprocessing.md) first. Since PR #6974, remote sessions go through the same \\_preprocess_session_direct() pipeline as local sessions. They are downloaded first, then preprocessed identically.\n\n**automatically removing .impl/ folder** → Read [.worker-impl/ vs .impl/ Cleanup Discipline](worktree-cleanup.md) first. NEVER auto-delete .impl/. It belongs to the user for plan-vs-implementation review. Only .worker-impl/ is auto-cleaned.\n\n**blocking implementation on review PR feedback** → Read [PR-Based Plan Review Workflow](pr-review-workflow.md) first. Review PRs are advisory and non-blocking. Implementation can proceed regardless of review PR state.\n\n**calling `create_worker_impl_folder()` without checking `worker_impl_folder_exists()` first** → Read [Impl-Context Staging Directory](impl-context.md) first. Both submit paths use LBYL: `if worker_impl_folder_exists(): remove_worker_impl_folder()` before creating. Stale .worker-impl/ from a prior failed submission causes errors.\n\n**calling commands that depend on `.impl/plan-ref.json` metadata** → Read [Plan Lifecycle](lifecycle.md) first. Verify metadata file exists in worktree; if missing, operations silently return empty values. read_plan_ref() tries plan-ref.json first, falls back to legacy issue.json.\n\n**calling preprocess_session functions from trigger_async_learn** → Read [Session Preprocessing Architecture](session-preprocessing.md) first. trigger_async_learn duplicates the exec script's filtering pipeline as \\_preprocess_session_direct(). If you change the exec script's pipeline, update the direct function too.\n\n**calling update_metadata() on PlanBackend** → Read [PlanBackend Migration Guide](plan-backend-migration.md) first. Always check isinstance(result, PlanNotFound) before calling update_metadata()\n\n**capturing subagent output inline when it may exceed 1KB** → Read [Agent Orchestration Safety Patterns](agent-orchestration-safety.md) first. Bash tool truncates output at ~10KB with no error. Use Write tool to save agent output to scratch storage, then pass the file path to dependent agents.\n\n**catching PlanHeaderNotFoundError** → Read [PlanBackend Migration Guide](plan-backend-migration.md) first. PlanHeaderNotFoundError is an exception; PlanNotFound is a result type - use LBYL for the latter\n\n**changing branch naming convention (P{issue}- or planned/ prefix)** → Read [Branch Name Inference](branch-name-inference.md) first. The P{issue}- prefix (issue-based) and planned/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.\n\n**changing how sessions are classified as planning vs impl** → Read [Learn Pipeline Workflow](learn-pipeline-workflow.md) first. Classification uses planning_session_id from GitHub metadata. The resulting prefix (planning- vs impl-) propagates into XML filenames and is used by downstream learn agents to weight insights differently.\n\n**checking only one location when extracting plan content** → Read [Plan Content Extraction Fallback](metadata-block-fallback.md) first. Always check both the first comment (plan-body metadata block) and the issue body before reporting 'no plan content found'. The replan command documents this explicitly in Step 4a.\n\n**classifying a single-artifact API reference as NEW_DOC** → Read [Cornerstone Enforcement in Learn Pipeline](cornerstone-enforcement.md) first. Apply the three-rule SHOULD_BE_CODE test first. Single-artifact knowledge belongs in code (types, docstrings, or comments), not docs/learned/.\n\n**closing a plan issue without verifying all items were addressed** → Read [Complete File Inventory Protocol](complete-inventory-protocol.md) first. Compare the file inventory against the plan's items before closing. Silent omissions are the most common failure mode.\n\n**committing to draft-PR plan branches after checkout without pulling remote** → Read [Draft PR Branch Sync](draft-pr-branch-sync.md) first. Both setup_impl_from_issue.py and submit.py use the same three-step sync: fetch_branch -> checkout/create_tracking -> pull_rebase. Skipping pull_rebase causes non-fast-forward push failures.\n\n**consolidating issues that already have erk-consolidated label** → Read [Consolidation Labels](consolidation-labels.md) first. Filter out erk-consolidated issues before consolidation. These are outputs of previous consolidation and should not be re-consolidated.\n\n**constructing a PR footer manually instead of using build_pr_body_footer()** → Read [PR Submission Patterns](pr-submission-patterns.md) first. The footer format includes checkout commands and closing references with specific patterns. Use the builder function to ensure validation passes.\n\n**creating a PR without first checking if one already exists for the branch** → Read [PR Submission Patterns](pr-submission-patterns.md) first. The submit pipeline is idempotent — it checks for existing PRs before creating. If building PR creation outside the pipeline, replicate this check to prevent duplicates.\n\n**creating a learn plan without setting learned_from_issue** → Read [Learn Plans vs. Implementation Plans](learn-vs-implementation-plans.md) first. Learn plans MUST set learned_from_issue to their parent implementation plan's issue number. Without it, base branch auto-detection fails and the learn plan lands on trunk instead of stacking on the parent.\n\n**creating a new branch for a draft-PR plan** → Read [Draft PR Branch Sync](draft-pr-branch-sync.md) first. Draft-PR plans already have a branch created during plan-save. Reuse the existing branch, don't create a new one.\n\n**creating a new plan-generating command without a pre-plan gathering step** → Read [Context Preservation Prompting Patterns](context-preservation-prompting.md) first. Without explicit context materialization before EnterPlanMode, agents produce sparse plans. Apply the two-phase pattern from this document.\n\n**creating erk-learn plan for an issue that already has erk-learn label** → Read [Learn Plan Validation](learn-plan-validation.md) first. Validate target issue has erk-plan label, NOT erk-learn. Learn plans analyze implementation plans, not other learn plans (cycle prevention).\n\n**creating temp files for AI workflows** → Read [Scratch Storage](scratch-storage.md) first. Use worktree-scoped scratch storage for session-specific data.\n\n**delegating batch file renames from a plan** → Read [Plan Lifecycle](lifecycle.md) first. Verify each file path exists before delegating. Wrong paths cause silent coverage gaps in rename operations.\n\n**delegating judgment steps to Haiku subagents** → Read [Command-Agent Delegation](agent-delegation.md) first. Prose reconciliation, design analysis, and architectural comparison need Opus-level reasoning. Delegating to a Haiku subagent loses quality. Also avoid delegating steps that require direct user interaction.\n\n**designing output routing for a multi-agent workflow** → Read [Agent Output Routing Strategies](agent-output-routing-strategies.md) first. Choose between embedded-prompt routing (in orchestrator Task prompts) and agent-file routing (in agent definitions). See this doc for the decision framework.\n\n**detecting plan backend by checking backend type directly** → Read [Draft PR Branch Sync](draft-pr-branch-sync.md) first. Use plan.header_fields.get(BRANCH_NAME) to detect draft-PR plans. This is backend-agnostic and works across all backends.\n\n**editing plan body content in plan creation, replan, or one-shot dispatch** → Read [One-Shot Workflow](one-shot-workflow.md) first. One-shot metadata block preservation: the metadata block in the plan body (HTML comment with erk:metadata-block markers) must survive all edits. Never strip or overwrite HTML comment blocks that contain erk:metadata-block markers.\n\n**editing plan content only in the PR branch without syncing** → Read [PR-Based Plan Review Workflow](pr-review-workflow.md) first. Plan content lives in two places (PR branch + issue comment). Edit the local file, then sync to the issue with `erk exec plan-update-from-feedback`. See plan-file-sync-pattern.md.\n\n**entering Plan Mode in replan or consolidation workflow** → Read [Context Preservation in Replan Workflow](context-preservation-in-replan.md) first. Gather investigation context FIRST (Step 6a). Enter plan mode only after collecting file paths, evidence, and discoveries. Sparse plans are destructive to downstream implementation.\n\n**estimating effort for a plan without checking actual files changed** → Read [Complete File Inventory Protocol](complete-inventory-protocol.md) first. Run a file inventory first. Plans that skip inventory systematically undercount configuration, test, and documentation changes.\n\n**fetching N large documents into parent agent context** → Read [Token Optimization Patterns](token-optimization-patterns.md) first. Delegate content fetching to child agents. Parent receives only analysis summaries, not raw content. Achieves O(1) parent context instead of O(n). See token-optimization-patterns.md.\n\n**gathering sessions for preprocessing** → Read [Learn Workflow](learn-workflow.md) first. Sessions >100k characters MUST be preprocessed first. Use erk exec preprocess-session for ~99% token reduction.\n\n**grepping only for the error message text** → Read [Source Investigation Over Trial-and-Error](debugging-patterns.md) first. Also grep for function names extracted from the error (e.g., 'checkout_footer' from 'Missing checkout footer'). Validator function names are more stable search targets than error message strings.\n\n**hardcoding next-steps command strings instead of using the dataclass properties** → Read [Next Steps Output Formatting](next-steps-output.md) first. Use IssueNextSteps or DraftPRNextSteps dataclasses from erk_shared.output.next_steps. They are the single source of truth for command formatting.\n\n**implementing PR body generation with checkout footers** → Read [Plan Lifecycle](lifecycle.md) first. HTML `<details>` tags will fail `has_checkout_footer_for_pr()` validation. Use plain text backtick format: `` `gh pr checkout <number>` ``\n\n**implementing RealPlanListService or DraftPRPlanListService without checking the other for parity** → Read [Draft PR Plan Backend](draft-pr-plan-backend.md) first. Both plan list services must handle parameters identically. Interface contracts are not enforced by the type system — behavioral divergence between the two services causes subtle bugs when switching backends.\n\n**implementing custom PR/plan relevance assessment logic** → Read [Plan Lifecycle](lifecycle.md) first. Reference `/local:check-relevance` verdict classification system first. Use SUPERSEDED (80%+ overlap), PARTIALLY_IMPLEMENTED (30-80% overlap), DIFFERENT_APPROACH, STILL_RELEVANT, NEEDS_REVIEW categories for consistency.\n\n**implementing draft-PR plan without syncing with remote** → Read [Draft PR Branch Sync](draft-pr-branch-sync.md) first. Before implementing a draft-PR plan, always sync with remote: fetch_branch -> checkout/create_tracking -> pull_rebase\n\n**importing functions directly from plan_header.py** → Read [Plan Header Privatization](plan-header-privatization.md) first. plan_header.py functions are being privatized. Use PlanBackend methods instead for metadata operations.\n\n**including impl-signal or plan-save-to-issue in a Task tool sub-agent prompt** → Read [Sub-Agent Context Limitations](sub-agent-context-limitations.md) first. Sub-agents cannot access ${CLAUDE_SESSION_ID}. Session-dependent commands must run in the root agent context. See sub-agent-context-limitations.md.\n\n**launching a dependent agent that reads a file written by a prior agent** → Read [Agent Orchestration Safety Patterns](agent-orchestration-safety.md) first. Verify the file exists (ls) before launching. Write tool silently fails if the parent directory is missing, and the dependent agent wastes its entire context discovering the file isn't there.\n\n**launching parallel agents that return results inline instead of writing to files** → Read [Parallel Agent Orchestration for Bulk Operations](parallel-audit-pattern.md) first. Parallel agents must write results via Write tool to .erk/scratch/ files. Inline results can be truncated or lost. The parent agent reads files after completion.\n\n**making a third trial-and-error attempt at a validation fix** → Read [Source Investigation Over Trial-and-Error](debugging-patterns.md) first. After 2 failed attempts, stop guessing. Grep for the validator function and read the source to understand the exact requirement.\n\n**making objective-update-after-land exit non-zero** → Read [Objective Update After Land](objective-update-after-land.md) first. This script uses fail-open design. Failures must not block landing. See objective-update-after-land.md.\n\n**manually creating an erk-plan issue with gh issue create** → Read [Plan Lifecycle](lifecycle.md) first. Use `erk exec plan-save-to-issue --plan-file <path>` instead. Manual creation requires complex metadata block format (see Metadata Block Reference section).\n\n**manually setting the base branch for a learn plan submission** → Read [Learn Plans vs. Implementation Plans](learn-vs-implementation-plans.md) first. Learn plan base branch is auto-detected from learned_from_issue → parent branch. Only use --base to override if the parent branch is missing from the remote.\n\n**marking a draft-PR plan as 'implementation complete' and referencing itself as the implementing PR** → Read [Draft PR Lifecycle](draft-pr-lifecycle.md) first. Self-referential close prevention: when a draft PR IS the plan, it cannot close itself. The plan's implementation-complete event cannot reference the plan PR as the implementing PR. One-shot dispatch guards against this — do not remove the guard.\n\n**merging a plan review PR** → Read [PR-Based Plan Review Workflow](pr-review-workflow.md) first. Plan review PRs are NEVER merged. They exist only for inline review comments. Close without merging when review is complete.\n\n**migrating a plan without preserving operational metadata** → Read [Plan Migration to Draft PR](plan-migrate-to-draft-pr.md) first. create_plan() only sets a subset of fields. Use update_metadata() in a second phase to carry over operational fields like lifecycle_stage, last_dispatched_at, etc. See \\_FIELDS_HANDLED_BY_CREATE in plan_migrate_to_draft_pr.py.\n\n**modifying learn command to add/remove/reorder agents** → Read [Learn Workflow](learn-workflow.md) first. Verify tier placement before assigning model. Parallel extraction uses haiku, sequential synthesis may need opus for quality-critical output.\n\n**modifying marker deletion behavior in exit-plan-mode hook** → Read [Session-Based Plan Deduplication](session-deduplication.md) first. Reusable markers (plan-saved) must persist; one-time markers (implement-now, objective-context) are consumed. Deleting reusable markers breaks state machines and enables retry loops that create duplicates.\n\n**modifying one-shot dispatch or skeleton issue creation** → Read [One-Shot Workflow](one-shot-workflow.md) first. Skeleton plan issues must be created BEFORE generating branch names to get P<N>- prefix\n\n**modifying register-one-shot-plan exit behavior** → Read [One-Shot Workflow](one-shot-workflow.md) first. register-one-shot-plan uses best-effort: exit 0 if any operation succeeds\n\n**modifying the gist upload content format** → Read [Learn Pipeline Workflow](learn-pipeline-workflow.md) first. The download side (download-learn-materials) parses delimiters to split content back into files. Changes to the upload format must be mirrored in the download parser. See gist-materials-interchange.md.\n\n**moving gateway files without git mv** → Read [Gateway Consolidation Checklist](gateway-consolidation-checklist.md) first. Always use git mv to preserve file history. Plain mv + git add loses blame history, making future archaeology harder.\n\n**parsing plan content without backward compatibility** → Read [Draft PR Lifecycle](draft-pr-lifecycle.md) first. extract_plan_content() handles both details-wrapped and old flat format. Always use it instead of manual parsing.\n\n**passing ${CLAUDE_SESSION_ID} to a sub-agent via the prompt string** → Read [Sub-Agent Context Limitations](sub-agent-context-limitations.md) first. String substitution of ${CLAUDE_SESSION_ID} happens at the root agent level. By the time the sub-agent runs the bash command, the variable is not in its environment. The root agent must resolve the value and pass it as a literal.\n\n**passing session content to an analysis agent** → Read [Session Preprocessing Architecture](session-preprocessing.md) first. Raw JSONL sessions can be 6+ million characters. Always preprocess first. The learn workflow validates preprocessed output exists before spawning agents.\n\n**prompting an agent to 'include findings in the plan' without structuring them first** → Read [Context Preservation Prompting Patterns](context-preservation-prompting.md) first. Unstructured prompts don't work — agents summarize at too high a level. Use the four-category gathering step instead.\n\n**pushing implementation commits after impl-context cleanup without git pull --rebase** → Read [Impl-Context Staging Directory](impl-context.md) first. After git rm + commit + push of .erk/impl-context/, the local branch may diverge from remote if other commits were pushed. Run git pull --rebase before pushing further implementation commits to avoid non-fast-forward push failures.\n\n**reading ERK_PLAN_BACKEND env var inside inner functions when global_config is already in scope** → Read [Draft PR Plan Backend](draft-pr-plan-backend.md) first. Backend detection precedence: when GlobalConfig.plan_backend is available via context, use it. Never fall back to re-reading env vars inside inner functions if global_config is already in scope — the context value takes precedence and re-reading env vars bypasses context overrides.\n\n**reading learn_plan_issue or learn_status** → Read [Learn Plan Metadata Preservation](learn-plan-metadata-fields.md) first. Verify field came through full pipeline. If null, check if filtered out earlier. Use gateway abstractions; never hand-construct Plan objects.\n\n**reading parallel agent output without verifying files exist** → Read [Parallel Agent Orchestration for Bulk Operations](parallel-audit-pattern.md) first. Always verify output files exist (ls -la) before reading. Agent failures may produce empty or missing files.\n\n**relying on agent instructions as the sole enforcement for a critical operation** → Read [Workflow Reliability Patterns](reliability-patterns.md) first. Agent behavior is non-deterministic. Critical operations need a deterministic workflow step as the final safety net.\n\n**removing .worker-impl/ during implementation (before CI passes)** → Read [.worker-impl/ vs .impl/ Cleanup Discipline](worktree-cleanup.md) first. The folder is load-bearing during implementation — Claude reads from it (via copy to .impl/). Only remove after implementation succeeds and CI passes.\n\n**removing git-tracked temporary directories in setup scripts** → Read [Impl-Context Staging Directory](impl-context.md) first. Defer deletion to the git cleanup phase (git rm + commit + push), not shutil.rmtree(). setup_impl_from_issue.py reads the files but deliberately does NOT delete them — see the comment at line 202. Deletion is handled by plan-implement.md Step 2d.\n\n**renaming a lifecycle stage value** → Read [Plan Lifecycle](lifecycle.md) first. Update 3 locations: LifecycleStageValue type, valid_stages set, and color conditions in compute_lifecycle_display(). Missing any location causes silent validation failures or incorrect TUI colors.\n\n**renaming gateway files during a move without checking for non-standard naming** → Read [Gateway Consolidation Checklist](gateway-consolidation-checklist.md) first. Source files that don't follow standard naming (e.g., executor.py instead of abc.py) must be renamed to abc.py/real.py/fake.py during the move. The gateway directory convention requires standard file names.\n\n**reusing existing worktrees for remote implementation** → Read [Remote Implementation Idempotency](remote-implementation-idempotency.md) first. Check if worktree already has a branch before creating new one. Reusing worktrees without checking causes PR orphaning.\n\n**reviewing a PR that contains .erk/impl-context/ files** → Read [Impl-Context Staging Directory](impl-context.md) first. Leave a PR comment telling the author to remove .erk/impl-context/. This is an erk tooling error — the directory should have been cleaned up before implementation. Run: git rm -rf .erk/impl-context/ && git commit -m 'Remove leaked impl-context'\n\n**rewriting PR body without preserving metadata** → Read [Draft PR Lifecycle](draft-pr-lifecycle.md) first. Extract metadata prefix on every lifecycle transition via extract_metadata_prefix() to prevent metadata loss.\n\n**running /erk:learn in CI** → Read [Learn Workflow](learn-workflow.md) first. CI mode skips interactive prompts and auto-proceeds. Check CI/GITHUB_ACTIONS env vars. See CI Environment Behavior section.\n\n**running /erk:learn on an issue that already has the erk-learn label** → Read [Learn Plans vs. Implementation Plans](learn-vs-implementation-plans.md) first. Learn plans cannot generate additional learn plans — this creates documentation cycles. The learn command validates this upfront and rejects learn-on-learn.\n\n**running sequential analysis that could be parallelized** → Read [Multi-Tier Agent Orchestration](agent-orchestration.md) first. If agents analyze independent data sources, run them in parallel. Only use sequential execution when one agent's output is another's input.\n\n**saving a plan with --objective-issue flag** → Read [Plan Lifecycle](lifecycle.md) first. Always verify the link was saved correctly with `erk exec get-plan-metadata <issue> objective_issue`. Silent failures can leave plans unlinked from their objectives.\n\n**spawning a GitHub Actions workflow from erk without passing plan_backend as an explicit input** → Read [Draft PR Plan Backend](draft-pr-plan-backend.md) first. Draft-PR backend propagation: GitHub Actions reusable workflows (workflow_call) do NOT inherit environment variables from the caller. ERK_PLAN_BACKEND must be declared as an explicit workflow input and passed by the caller. Ambient env vars are invisible to reusable workflows.\n\n**staging .worker-impl/ deletion without an immediate commit** → Read [.worker-impl/ vs .impl/ Cleanup Discipline](worktree-cleanup.md) first. A downstream `git reset --hard` will silently discard staged-only deletions. Always commit+push cleanup atomically. See reliability-patterns.md.\n\n**staging git changes (git add/git rm) without an immediate commit before a git reset --hard** → Read [Workflow Reliability Patterns](reliability-patterns.md) first. git reset --hard silently discards staged changes. Commit and push cleanup BEFORE any reset step.\n\n**treating missing PR as an error in the learn pipeline** → Read [Learn Without PR Context](learn-without-pr-context.md) first. No-PR is a valid workflow state, not an error. The learn pipeline must degrade gracefully — sessions alone provide sufficient material for insight extraction.\n\n**updating imports one file at a time during gateway consolidation** → Read [Gateway Consolidation Checklist](gateway-consolidation-checklist.md) first. Use LibCST for systematic import updates. Manual editing misses call sites and creates partial migration states. See docs/learned/refactoring/libcst-systematic-imports.md.\n\n**using 'steps' instead of 'nodes' in new plan metadata code** → Read [Schema V3 Migration](schema-v3-migration.md) first. Schema v3 uses 'nodes' (not 'steps'). The parser accepts both for backward compatibility but the renderer always emits v3. See schema-v3-migration.md.\n\n**using `extract_metadata_prefix` or `extract_plan_content` without validating separator context** → Read [Draft PR Lifecycle](draft-pr-lifecycle.md) first. The content separator `\\n\\n---\\n\\n` can accidentally form from 'Remotely executed' notes + footer delimiter. extract_metadata_prefix() validates via `<!-- erk:metadata-block:` marker in the prefix. Never skip this validation.\n\n**using background agents without waiting for completion before dependent operations** → Read [Command-Agent Delegation](agent-delegation.md) first. Use TaskOutput with block=true to wait for all background agents to complete. Without synchronization, dependent agents may read incomplete outputs or missing files.\n\n**using gh issue view on a plan ID without checking plan backend type** → Read [Draft PR Plan Backend](draft-pr-plan-backend.md) first. Draft-PR plan IDs are PR numbers. Using gh issue view on a draft-PR plan produces a confusing 404. Route to gh pr view based on backend type.\n\n**using issue number from .impl/issue.json in a checkout footer** → Read [PR Submission Patterns](pr-submission-patterns.md) first. Checkout footers require the PR number, not the issue number. The issue is the plan; the PR is the implementation. See the PR Number vs Issue Number section.\n\n**using issue timeline API as the primary PR lookup path** → Read [PR Discovery Strategies for Plans](pr-discovery.md) first. The primary path is branch_name from plan-header → get_pr_for_branch(). Timeline API is a separate strategy for when branch_name is unavailable.\n\n**using opus/sonnet for mechanical data fetching or formatting tasks** → Read [Token Optimization Patterns](token-optimization-patterns.md) first. Use haiku for mechanical work (fetch, parse, format). Reserve expensive models for synthesis and reasoning.\n\n**using session-scoped markers in exec scripts** → Read [Session-Based Plan Deduplication](session-deduplication.md) first. Session markers enable idempotency in command retries. Always write markers AFTER successful operation completion, never before. Use triple-check guard on marker read: file exists AND content is valid AND expected type (numeric for issue numbers).\n\n**validating plan_id in exec scripts without checking provider type** → Read [Draft PR Plan Backend](draft-pr-plan-backend.md) first. Draft-PR plan_id IS the PR number (not an issue number). Check provider type before assuming plan_id semantics. Issue-based plans use issue numbers; draft-PR plans use PR numbers.\n\n**writing a plan step that says 'update X' without a file path** → Read [Context Preservation Patterns](context-preservation-patterns.md) first. Generic references force re-discovery. Include the full path, line numbers, and evidence. See the five dimensions below.\n\n**writing post-dispatch operations without try/except guards** → Read [One-Shot Workflow](one-shot-workflow.md) first. Post-dispatch operations (metadata write, queued comment) are best-effort. Wrap in try/except with user-visible warnings. See write_dispatch_metadata() and create_submission_queued_block() in one_shot_dispatch.py.\n\n**writing to /tmp/** → Read [Scratch Storage](scratch-storage.md) first. AI workflow files belong in .erk/scratch/<session-id>/, NOT /tmp/.\n\n**writing verification criteria like 'documentation is complete'** → Read [Context Preservation Patterns](context-preservation-patterns.md) first. Vague verification is unverifiable. Criteria must be testable with grep, file inspection, or running code.\n","structuredPatch":[{"oldStart":70,"oldLines":7,"newStart":70,"newLines":7,"lines":[" "," **catching PlanHeaderNotFoundError** → Read [PlanBackend Migration Guide](plan-backend-migration.md) first. PlanHeaderNotFoundError is an exception; PlanNotFound is a result type - use LBYL for the latter"," ","-**changing branch naming convention (P{issue}- or planned/ prefix)** → Read [Branch Name Inference](branch-name-inference.md) first. The P{issue}- prefix (issue-based) and planned/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers.","+**changing branch naming convention (P{issue}- or plnd/ prefix)** → Read [Branch Name Inference](branch-name-inference.md) first. The P{issue}- prefix (issue-based) and plnd/ prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers."," "," **changing how sessions are classified as planning vs impl** → Read [Learn Pipeline Workflow](learn-pipeline-workflow.md) first. Classification uses planning_session_id from GitHub metadata. The resulting prefix (planning- vs impl-) propagates into XML filenames and is used by downstream learn agents to weight insights differently."," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"b782bbbb-1c29-44cf-a379-5816807b6d25","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_012te8zhUn8fRGTnDgX2E2jK","type":"message","role":"assistant","content":[{"type":"text","text":"Let me also check if there are more `planned/` references in the draft-pr-plan-backend.md and other docs I might have missed:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":316,"cache_read_input_tokens":77887,"cache_creation":{"ephemeral_5m_input_tokens":316,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHf3Z8Tvmyw5DStK6yw","type":"assistant","uuid":"77118fbb-bb15-4ae7-a11c-70b30d1fd548","timestamp":"2026-02-22T14:45:44.102Z"}
{"parentUuid":"77118fbb-bb15-4ae7-a11c-70b30d1fd548","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_012te8zhUn8fRGTnDgX2E2jK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018snMvsQeDd8Z6fCCXyLavL","name":"Grep","input":{"pattern":"planned/","glob":"*.md","output_mode":"content","path":"/home/runner/work/erk/erk/docs/learned"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":316,"cache_read_input_tokens":77887,"cache_creation":{"ephemeral_5m_input_tokens":316,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHf3Z8Tvmyw5DStK6yw","type":"assistant","uuid":"12d136e7-517b-47cc-8182-9447e994486c","timestamp":"2026-02-22T14:45:45.013Z"}
{"parentUuid":"12d136e7-517b-47cc-8182-9447e994486c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018snMvsQeDd8Z6fCCXyLavL","type":"tool_result","content":"docs/learned/planning/branch-name-inference.md:63:Branches for draft-PR plans start with `plnd/` and follow the pattern `plnd/{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone. Legacy branches may use `planned/` prefix.\ndocs/learned/planning/branch-name-inference.md:70:- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `plnd/` branches; `extract_objective_number()` handles `P{issue}-O{obj}-`, `plnd/O{obj}-`, and legacy `planned/O{obj}-` patterns"}]},"uuid":"f65237b9-1196-44c0-9a7e-f524a8e1db34","timestamp":"2026-02-22T14:45:45.531Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"docs/learned/planning/branch-name-inference.md:63:Branches for draft-PR plans start with `plnd/` and follow the pattern `plnd/{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone. Legacy branches may use `planned/` prefix.\ndocs/learned/planning/branch-name-inference.md:70:- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `plnd/` branches; `extract_objective_number()` handles `P{issue}-O{obj}-`, `plnd/O{obj}-`, and legacy `planned/O{obj}-` patterns","numLines":2}}
{"parentUuid":"f65237b9-1196-44c0-9a7e-f524a8e1db34","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01PNHeAiiUoHde7r6MHASkbJ","type":"message","role":"assistant","content":[{"type":"text","text":"Good - remaining `planned/` references in docs are all in \"legacy\" context, which is correct. Now let me also check if there are any workflow files or other shell scripts:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":671,"cache_read_input_tokens":78203,"cache_creation":{"ephemeral_5m_input_tokens":671,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHfMY7K5C1ZBf87fMYT","type":"assistant","uuid":"aaf74694-46ae-4375-80f9-1ae77fcd3504","timestamp":"2026-02-22T14:45:51.575Z"}
{"parentUuid":"aaf74694-46ae-4375-80f9-1ae77fcd3504","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01PNHeAiiUoHde7r6MHASkbJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01T6oihJcx57wk8nvnTC1T6k","name":"Grep","input":{"pattern":"planned/","glob":"*.{yml,yaml,sh}","output_mode":"content","path":"/home/runner/work/erk/erk"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":671,"cache_read_input_tokens":78203,"cache_creation":{"ephemeral_5m_input_tokens":671,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHfMY7K5C1ZBf87fMYT","type":"assistant","uuid":"9098bd90-25dc-4556-8384-68ee73f221b6","timestamp":"2026-02-22T14:45:52.635Z"}
{"parentUuid":"9098bd90-25dc-4556-8384-68ee73f221b6","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01T6oihJcx57wk8nvnTC1T6k","type":"tool_result","content":"No matches found"}]},"uuid":"cae01cd0-41e0-4cb3-b5f4-78855ce7c94a","timestamp":"2026-02-22T14:45:53.150Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"parentUuid":"cae01cd0-41e0-4cb3-b5f4-78855ce7c94a","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01EmqoFYgwjApypgB37m84yp","type":"message","role":"assistant","content":[{"type":"text","text":"Good, no workflow files reference it. Now let me also check if `plan_save.py` or `plan_migrate_to_draft_pr.py` have references:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":177,"cache_read_input_tokens":78874,"cache_creation":{"ephemeral_5m_input_tokens":177,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHfv8v8vXaBYrSxyQDE","type":"assistant","uuid":"b080956e-2fa9-4203-b53c-00bb3ffa5294","timestamp":"2026-02-22T14:45:56.256Z"}
{"parentUuid":"b080956e-2fa9-4203-b53c-00bb3ffa5294","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01EmqoFYgwjApypgB37m84yp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MMs788CSfCnyvuSj41pGqJ","name":"Grep","input":{"pattern":"planned/","glob":"*.py","output_mode":"content","path":"/home/runner/work/erk/erk/src/erk/cli/commands/exec/scripts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":177,"cache_read_input_tokens":78874,"cache_creation":{"ephemeral_5m_input_tokens":177,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHfv8v8vXaBYrSxyQDE","type":"assistant","uuid":"a52424a7-1184-47e3-8c1b-269007347ea4","timestamp":"2026-02-22T14:45:57.399Z"}
{"parentUuid":"a52424a7-1184-47e3-8c1b-269007347ea4","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MMs788CSfCnyvuSj41pGqJ","type":"tool_result","content":"No matches found"}]},"uuid":"76cb4fde-8175-4fea-a942-f5d82fe5d246","timestamp":"2026-02-22T14:45:57.832Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"parentUuid":"76cb4fde-8175-4fea-a942-f5d82fe5d246","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Lr65ZD7ut8hYdmWtwCh83v","type":"message","role":"assistant","content":[{"type":"text","text":"All source code is clean. Now let me update the tests. Let me find all test files with `planned/` references:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":522,"cache_read_input_tokens":79051,"cache_creation":{"ephemeral_5m_input_tokens":522,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHgG6xZEBpwZvcFc4Jm","type":"assistant","uuid":"c0a96737-dd99-46f7-9b81-4fdd2f8aa66d","timestamp":"2026-02-22T14:46:01.269Z"}
{"parentUuid":"c0a96737-dd99-46f7-9b81-4fdd2f8aa66d","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Lr65ZD7ut8hYdmWtwCh83v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Fu5orRVMrCBMda6SkirdkV","name":"TodoWrite","input":{"todos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"completed","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"completed","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"completed","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"completed","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"completed","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"in_progress","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":522,"cache_read_input_tokens":79051,"cache_creation":{"ephemeral_5m_input_tokens":522,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHgG6xZEBpwZvcFc4Jm","type":"assistant","uuid":"e12c5a0d-810d-4e31-8e38-b46c0f84f0c1","timestamp":"2026-02-22T14:46:05.703Z"}
{"parentUuid":"e12c5a0d-810d-4e31-8e38-b46c0f84f0c1","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Fu5orRVMrCBMda6SkirdkV","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"23b0248b-244b-4ab7-93bd-7c4f8565c5d2","timestamp":"2026-02-22T14:46:05.717Z","toolUseResult":{"oldTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"completed","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"completed","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"completed","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"completed","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"in_progress","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"pending","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}],"newTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"completed","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"completed","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"completed","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"completed","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"completed","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"in_progress","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]}}
{"parentUuid":"23b0248b-244b-4ab7-93bd-7c4f8565c5d2","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_011u3kDbdo2cTwrWD3iEpEs9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PcCvu7Ne4X5xi8eYPohdoo","name":"Grep","input":{"pattern":"planned/","glob":"*.py","output_mode":"content","-n":true,"path":"/home/runner/work/erk/erk/tests"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":602,"cache_read_input_tokens":79573,"cache_creation":{"ephemeral_5m_input_tokens":602,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHgqqEWKMU1rXWeAhxx","type":"assistant","uuid":"0c3b5533-88ab-4582-bb4b-c5f709b15c5c","timestamp":"2026-02-22T14:46:09.048Z"}
{"parentUuid":"0c3b5533-88ab-4582-bb4b-c5f709b15c5c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PcCvu7Ne4X5xi8eYPohdoo","type":"tool_result","content":"tests/tui/data/test_provider.py:242:        \"\"\"Draft PR branch (planned/*) resolved via .impl/plan-ref.json.\ntests/tui/data/test_provider.py:244:        Branch name 'planned/fix-missing-data-02-19-1416' doesn't contain a\ntests/tui/data/test_provider.py:256:        branch_name = \"planned/fix-missing-data-02-19-1416\"\ntests/tui/data/test_provider.py:309:        \"\"\"Draft PR branch with planned/ prefix resolved via .impl/plan-ref.json.\ntests/tui/data/test_provider.py:311:        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\ntests/tui/data/test_provider.py:322:        branch_name = \"planned/fix-auth-bug-01-15-1430\"\ntests/tui/data/test_provider.py:377:        Only 'planned/' (forward slash) is valid. This test ensures the\ntests/tui/data/test_provider.py:434:        # planned- (hyphen) should NOT be recognized — only planned/ (slash) is valid\ntests/tui/data/test_provider.py:448:        branch_name = \"planned/fix-something-02-19-1416\"\ntests/tui/data/test_provider.py:482:        # No plan-ref.json, so planned/* branch should not produce an entry\ntests/unit/fakes/test_fake_git.py:509:        branch=\"planned/my-feature\",\ntests/unit/fakes/test_fake_git.py:517:    assert record.branch == \"planned/my-feature\"\ntests/commands/submit/test_pr_creation.py:28:    \"\"\"Test submit strips plan markers and adds planned/ prefix when creating PR.\"\"\"\ntests/commands/submit/test_pr_creation.py:38:    # Verify PR was created with stripped title and planned/ prefix\ntests/commands/submit/test_pr_creation.py:41:    assert title == \"planned/Implement feature X\"  # Stripped AND prefixed with planned/\ntests/commands/submit/test_pr_creation.py:88:    assert _add_planned_prefix(\"Implement feature X\") == \"planned/Implement feature X\"\ntests/commands/submit/test_pr_creation.py:94:    assert twice == \"planned/Implement feature X\"\ntests/commands/submit/test_pr_creation.py:95:    assert twice.count(\"planned/\") == 1  # Only one prefix\ntests/commands/submit/test_pr_creation.py:99:    \"\"\"Test planned/ prefix is added to PR titles from plan-originated submissions.\"\"\"\ntests/commands/submit/test_pr_creation.py:101:    assert _add_planned_prefix(\"Update docs\") == \"planned/Update docs\"\ntests/commands/submit/test_pr_creation.py:102:    assert _add_planned_prefix(\"Fix bug in authentication\") == \"planned/Fix bug in authentication\"\ntests/commands/submit/test_pr_creation.py:103:    assert _add_planned_prefix(\"\") == \"planned/\"  # Edge case: empty title\ntests/commands/submit/test_pr_creation.py:106:    assert _add_planned_prefix(\"planned/Already prefixed\") == \"planned/Already prefixed\"\ntests/commands/submit/test_basic_submission.py:58:    assert title == \"planned/Implement feature X\"\ntests/commands/land/test_get_objective_for_branch.py:109:    \"\"\"Branch with planned/ prefix and no plan found — extract from name.\"\"\"\ntests/commands/land/test_get_objective_for_branch.py:113:    result = get_objective_for_branch(ctx, tmp_path, \"planned/O456-fix-auth-01-15-1430\")\ntests/commands/one_shot/test_one_shot_dispatch.py:325:    \"\"\"Test full draft_pr dispatch: no skeleton issue, planned/ branch, PR with metadata block.\ntests/commands/one_shot/test_one_shot_dispatch.py:329:    - Use planned/ branch naming\ntests/commands/one_shot/test_one_shot_dispatch.py:369:        # Branch uses planned/ prefix (not P<N>-)\ntests/commands/one_shot/test_one_shot_dispatch.py:370:        assert result.branch_name.startswith(\"planned/\")\ntests/unit/cli/commands/exec/scripts/test_plan_save.py:67:    assert output[\"branch_name\"].startswith(\"planned/\")\ntests/unit/cli/commands/exec/scripts/test_plan_save.py:81:    assert \"Branch: planned/\" in result.output\ntests/unit/cli/commands/exec/scripts/test_plan_save.py:83:    assert \"planned/\" in result.output  # branch name appears in checkout command\ntests/unit/cli/commands/exec/scripts/test_plan_save.py:251:    assert branch_commit.branch.startswith(\"planned/\")\ntests/core/utils/test_naming.py:482:        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\ntests/core/utils/test_naming.py:483:        (\"planned/O1-add-tests-12-31-2359\", 1),\ntests/core/utils/test_naming.py:490:        (\"planned/fix-auth-bug-01-15-1430\", None),\ntests/core/utils/test_naming.py:514:        (\"planned/fix-auth-bug-01-15-1430\", None),\ntests/core/utils/test_naming.py:515:        (\"planned/O456-fix-auth-01-15-1430\", None),\ntests/core/utils/test_naming.py:532:        (\"planned/review-6214-01-15-1430\", 6214),\ntests/core/utils/test_naming.py:533:        (\"planned/review-42-01-28-0930\", 42),\ntests/core/utils/test_naming.py:534:        (\"planned/review-1-12-31-2359\", 1),\ntests/core/utils/test_naming.py:535:        (\"planned/review-99999-01-01-0000\", 99999),\ntests/core/utils/test_naming.py:541:        (\"planned/review\", None),  # Missing issue number\ntests/core/utils/test_naming.py:542:        (\"planned/review-\", None),  # Missing issue number\ntests/core/utils/test_naming.py:543:        (\"planned/review-abc-01-15-1430\", None),  # Non-numeric issue\ntests/core/utils/test_naming.py:559:            \"planned/fix-auth-bug-01-15-1430\",\ntests/core/utils/test_naming.py:566:            \"planned/my-feature-06-20-1000\",\ntests/core/utils/test_naming.py:573:            \"planned/update-docs-01-01-0000\",\ntests/core/utils/test_naming.py:580:            \"planned/O456-fix-auth-bug-01-15-1430\",\ntests/core/utils/test_naming.py:587:            \"planned/O1-add-tests-12-31-2359\",\ntests/core/utils/test_naming.py:594:    \"\"\"Branch name follows planned/{slug}-{timestamp} format.\"\"\"\ntests/core/utils/test_naming.py:608:    assert result.startswith(\"planned/\")\ntests/core/utils/test_naming.py:633:    assert result.startswith(\"planned/O456-\")\ntests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py:100:    assert output[\"branch_name\"].startswith(\"planned/\")\ntests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py:237:    assert \"planned/\" in output[\"branch_name\"]\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py:136:    expected_branch = f\"planned/review-{issue_number}-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py:366:    expected_branch = f\"planned/review-{issue_number}-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:86:    branch_name = \"planned/review-1234-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:147:    branch_name = \"planned/review-5678-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:180:    branch_name = \"planned/review-5679-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:213:    branch_name = \"planned/review-9999-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:255:    branch_name = \"planned/review-2222-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:288:    branch_name = \"planned/review-3333-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:324:    branch_name = \"planned/review-7777-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:393:    branch_name = \"planned/review-4444-01-15-1430\""}]},"uuid":"b93b3127-d7ac-4dd1-89c5-d86b203e0cc4","timestamp":"2026-02-22T14:46:09.507Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"tests/tui/data/test_provider.py:242:        \"\"\"Draft PR branch (planned/*) resolved via .impl/plan-ref.json.\ntests/tui/data/test_provider.py:244:        Branch name 'planned/fix-missing-data-02-19-1416' doesn't contain a\ntests/tui/data/test_provider.py:256:        branch_name = \"planned/fix-missing-data-02-19-1416\"\ntests/tui/data/test_provider.py:309:        \"\"\"Draft PR branch with planned/ prefix resolved via .impl/plan-ref.json.\ntests/tui/data/test_provider.py:311:        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\ntests/tui/data/test_provider.py:322:        branch_name = \"planned/fix-auth-bug-01-15-1430\"\ntests/tui/data/test_provider.py:377:        Only 'planned/' (forward slash) is valid. This test ensures the\ntests/tui/data/test_provider.py:434:        # planned- (hyphen) should NOT be recognized — only planned/ (slash) is valid\ntests/tui/data/test_provider.py:448:        branch_name = \"planned/fix-something-02-19-1416\"\ntests/tui/data/test_provider.py:482:        # No plan-ref.json, so planned/* branch should not produce an entry\ntests/unit/fakes/test_fake_git.py:509:        branch=\"planned/my-feature\",\ntests/unit/fakes/test_fake_git.py:517:    assert record.branch == \"planned/my-feature\"\ntests/commands/submit/test_pr_creation.py:28:    \"\"\"Test submit strips plan markers and adds planned/ prefix when creating PR.\"\"\"\ntests/commands/submit/test_pr_creation.py:38:    # Verify PR was created with stripped title and planned/ prefix\ntests/commands/submit/test_pr_creation.py:41:    assert title == \"planned/Implement feature X\"  # Stripped AND prefixed with planned/\ntests/commands/submit/test_pr_creation.py:88:    assert _add_planned_prefix(\"Implement feature X\") == \"planned/Implement feature X\"\ntests/commands/submit/test_pr_creation.py:94:    assert twice == \"planned/Implement feature X\"\ntests/commands/submit/test_pr_creation.py:95:    assert twice.count(\"planned/\") == 1  # Only one prefix\ntests/commands/submit/test_pr_creation.py:99:    \"\"\"Test planned/ prefix is added to PR titles from plan-originated submissions.\"\"\"\ntests/commands/submit/test_pr_creation.py:101:    assert _add_planned_prefix(\"Update docs\") == \"planned/Update docs\"\ntests/commands/submit/test_pr_creation.py:102:    assert _add_planned_prefix(\"Fix bug in authentication\") == \"planned/Fix bug in authentication\"\ntests/commands/submit/test_pr_creation.py:103:    assert _add_planned_prefix(\"\") == \"planned/\"  # Edge case: empty title\ntests/commands/submit/test_pr_creation.py:106:    assert _add_planned_prefix(\"planned/Already prefixed\") == \"planned/Already prefixed\"\ntests/commands/submit/test_basic_submission.py:58:    assert title == \"planned/Implement feature X\"\ntests/commands/land/test_get_objective_for_branch.py:109:    \"\"\"Branch with planned/ prefix and no plan found — extract from name.\"\"\"\ntests/commands/land/test_get_objective_for_branch.py:113:    result = get_objective_for_branch(ctx, tmp_path, \"planned/O456-fix-auth-01-15-1430\")\ntests/commands/one_shot/test_one_shot_dispatch.py:325:    \"\"\"Test full draft_pr dispatch: no skeleton issue, planned/ branch, PR with metadata block.\ntests/commands/one_shot/test_one_shot_dispatch.py:329:    - Use planned/ branch naming\ntests/commands/one_shot/test_one_shot_dispatch.py:369:        # Branch uses planned/ prefix (not P<N>-)\ntests/commands/one_shot/test_one_shot_dispatch.py:370:        assert result.branch_name.startswith(\"planned/\")\ntests/unit/cli/commands/exec/scripts/test_plan_save.py:67:    assert output[\"branch_name\"].startswith(\"planned/\")\ntests/unit/cli/commands/exec/scripts/test_plan_save.py:81:    assert \"Branch: planned/\" in result.output\ntests/unit/cli/commands/exec/scripts/test_plan_save.py:83:    assert \"planned/\" in result.output  # branch name appears in checkout command\ntests/unit/cli/commands/exec/scripts/test_plan_save.py:251:    assert branch_commit.branch.startswith(\"planned/\")\ntests/core/utils/test_naming.py:482:        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\ntests/core/utils/test_naming.py:483:        (\"planned/O1-add-tests-12-31-2359\", 1),\ntests/core/utils/test_naming.py:490:        (\"planned/fix-auth-bug-01-15-1430\", None),\ntests/core/utils/test_naming.py:514:        (\"planned/fix-auth-bug-01-15-1430\", None),\ntests/core/utils/test_naming.py:515:        (\"planned/O456-fix-auth-01-15-1430\", None),\ntests/core/utils/test_naming.py:532:        (\"planned/review-6214-01-15-1430\", 6214),\ntests/core/utils/test_naming.py:533:        (\"planned/review-42-01-28-0930\", 42),\ntests/core/utils/test_naming.py:534:        (\"planned/review-1-12-31-2359\", 1),\ntests/core/utils/test_naming.py:535:        (\"planned/review-99999-01-01-0000\", 99999),\ntests/core/utils/test_naming.py:541:        (\"planned/review\", None),  # Missing issue number\ntests/core/utils/test_naming.py:542:        (\"planned/review-\", None),  # Missing issue number\ntests/core/utils/test_naming.py:543:        (\"planned/review-abc-01-15-1430\", None),  # Non-numeric issue\ntests/core/utils/test_naming.py:559:            \"planned/fix-auth-bug-01-15-1430\",\ntests/core/utils/test_naming.py:566:            \"planned/my-feature-06-20-1000\",\ntests/core/utils/test_naming.py:573:            \"planned/update-docs-01-01-0000\",\ntests/core/utils/test_naming.py:580:            \"planned/O456-fix-auth-bug-01-15-1430\",\ntests/core/utils/test_naming.py:587:            \"planned/O1-add-tests-12-31-2359\",\ntests/core/utils/test_naming.py:594:    \"\"\"Branch name follows planned/{slug}-{timestamp} format.\"\"\"\ntests/core/utils/test_naming.py:608:    assert result.startswith(\"planned/\")\ntests/core/utils/test_naming.py:633:    assert result.startswith(\"planned/O456-\")\ntests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py:100:    assert output[\"branch_name\"].startswith(\"planned/\")\ntests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py:237:    assert \"planned/\" in output[\"branch_name\"]\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py:136:    expected_branch = f\"planned/review-{issue_number}-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py:366:    expected_branch = f\"planned/review-{issue_number}-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:86:    branch_name = \"planned/review-1234-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:147:    branch_name = \"planned/review-5678-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:180:    branch_name = \"planned/review-5679-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:213:    branch_name = \"planned/review-9999-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:255:    branch_name = \"planned/review-2222-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:288:    branch_name = \"planned/review-3333-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:324:    branch_name = \"planned/review-7777-01-15-1430\"\ntests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py:393:    branch_name = \"planned/review-4444-01-15-1430\"","numLines":66}}
{"parentUuid":"b93b3127-d7ac-4dd1-89c5-d86b203e0cc4","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01UoK7NkXbEWRPj6HrCySQmC","type":"message","role":"assistant","content":[{"type":"text","text":"There are many test files to update. Let me use a systematic approach with a libcst-refactor agent to handle the bulk replacements, or I can do targeted edits. Given these are mostly string literal changes, let me handle them file by file. Let me read and update each test file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2586,"cache_read_input_tokens":80175,"cache_creation":{"ephemeral_5m_input_tokens":2586,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHh83JfRjCSiuGsfuHS","type":"assistant","uuid":"39de61b1-752e-48a7-928d-0bf26b3e4ffd","timestamp":"2026-02-22T14:46:14.250Z"}
{"parentUuid":"39de61b1-752e-48a7-928d-0bf26b3e4ffd","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01UoK7NkXbEWRPj6HrCySQmC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SgPqdf4S7mcYQ7HpZqgBUY","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","offset":470,"limit":150},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2586,"cache_read_input_tokens":80175,"cache_creation":{"ephemeral_5m_input_tokens":2586,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHh83JfRjCSiuGsfuHS","type":"assistant","uuid":"a3764f27-4b12-46a6-a121-512a8ab96914","timestamp":"2026-02-22T14:46:15.296Z"}
{"parentUuid":"a3764f27-4b12-46a6-a121-512a8ab96914","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SgPqdf4S7mcYQ7HpZqgBUY","type":"tool_result","content":"   470→\n   471→@pytest.mark.parametrize(\n   472→    (\"branch_name\", \"expected\"),\n   473→    [\n   474→        # With objective ID\n   475→        (\"P123-O456-fix-auth-bug-01-15-1430\", 456),\n   476→        (\"P42-O789-my-feature-06-20-1000\", 789),\n   477→        (\"P100-O1-add-tests-12-31-2359\", 1),\n   478→        # Lowercase o prefix (case insensitive)\n   479→        (\"P123-o456-fix-bug\", 456),\n   480→        (\"p123-o789-feature\", 789),\n   481→        # Draft-PR branches with objective ID\n   482→        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\n   483→        (\"planned/O1-add-tests-12-31-2359\", 1),\n   484→        # Legacy plan/ prefix branches with objective ID\n   485→        (\"plan/O456-fix-auth-01-15-1430\", 456),\n   486→        (\"plan/O7709-plan-lazy-tip-sync-f-02-21-1116\", 7709),\n   487→        # Without objective ID\n   488→        (\"P123-fix-auth-bug-01-15-1430\", None),\n   489→        (\"P42-my-feature\", None),\n   490→        (\"planned/fix-auth-bug-01-15-1430\", None),\n   491→        (\"plan/fix-auth-bug-01-15-1430\", None),\n   492→        (\"feature-branch\", None),\n   493→        (\"master\", None),\n   494→    ],\n   495→)\n   496→def test_extract_objective_number(branch_name: str, expected: int | None) -> None:\n   497→    \"\"\"Extract objective ID from branch name.\"\"\"\n   498→    assert extract_objective_number(branch_name) == expected\n   499→\n   500→\n   501→@pytest.mark.parametrize(\n   502→    (\"branch_name\", \"expected\"),\n   503→    [\n   504→        # Standard format (still works with objective ID in branch)\n   505→        (\"P123-O456-fix-auth-bug-01-15-1430\", 123),\n   506→        (\"P42-O789-my-feature\", 42),\n   507→        # Without objective ID (existing behavior)\n   508→        (\"P2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n   509→        (\"P42-fix-bug\", 42),\n   510→        # Legacy format without P prefix\n   511→        (\"2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n   512→        (\"42-fix-bug\", 42),\n   513→        # Draft-PR branches return None (no extractable issue number)\n   514→        (\"planned/fix-auth-bug-01-15-1430\", None),\n   515→        (\"planned/O456-fix-auth-01-15-1430\", None),\n   516→        # Invalid formats\n   517→        (\"feature-branch\", None),\n   518→        (\"master\", None),\n   519→    ],\n   520→)\n   521→def test_extract_leading_issue_number_with_objective_format(\n   522→    branch_name: str, expected: int | None\n   523→) -> None:\n   524→    \"\"\"Extract leading issue number still works with objective ID in branch name.\"\"\"\n   525→    assert extract_leading_issue_number(branch_name) == expected\n   526→\n   527→\n   528→@pytest.mark.parametrize(\n   529→    (\"branch_name\", \"expected\"),\n   530→    [\n   531→        # Valid plan review branches\n   532→        (\"planned/review-6214-01-15-1430\", 6214),\n   533→        (\"planned/review-42-01-28-0930\", 42),\n   534→        (\"planned/review-1-12-31-2359\", 1),\n   535→        (\"planned/review-99999-01-01-0000\", 99999),\n   536→        # Not plan review branches\n   537→        (\"P2382-convert-erk-create-raw-ext\", None),\n   538→        (\"2382-convert-erk-create-raw-ext\", None),\n   539→        (\"feature-branch\", None),\n   540→        (\"master\", None),\n   541→        (\"planned/review\", None),  # Missing issue number\n   542→        (\"planned/review-\", None),  # Missing issue number\n   543→        (\"planned/review-abc-01-15-1430\", None),  # Non-numeric issue\n   544→    ],\n   545→)\n   546→def test_extract_plan_review_issue_number(branch_name: str, expected: int | None) -> None:\n   547→    assert extract_plan_review_issue_number(branch_name) == expected\n   548→\n   549→\n   550→# Tests for generate_draft_pr_branch_name\n   551→@pytest.mark.parametrize(\n   552→    (\"title\", \"timestamp\", \"objective_id\", \"expected\"),\n   553→    [\n   554→        # Standard case without objective\n   555→        (\n   556→            \"Fix Auth Bug\",\n   557→            datetime(2024, 1, 15, 14, 30),\n   558→            None,\n   559→            \"planned/fix-auth-bug-01-15-1430\",\n   560→        ),\n   561→        # Different timestamp\n   562→        (\n   563→            \"My Feature\",\n   564→            datetime(2024, 6, 20, 10, 0),\n   565→            None,\n   566→            \"planned/my-feature-06-20-1000\",\n   567→        ),\n   568→        # Midnight edge case\n   569→        (\n   570→            \"Update Docs\",\n   571→            datetime(2024, 1, 1, 0, 0),\n   572→            None,\n   573→            \"planned/update-docs-01-01-0000\",\n   574→        ),\n   575→        # With objective ID\n   576→        (\n   577→            \"Fix Auth Bug\",\n   578→            datetime(2024, 1, 15, 14, 30),\n   579→            456,\n   580→            \"planned/O456-fix-auth-bug-01-15-1430\",\n   581→        ),\n   582→        # Single digit objective\n   583→        (\n   584→            \"Add Tests\",\n   585→            datetime(2024, 12, 31, 23, 59),\n   586→            1,\n   587→            \"planned/O1-add-tests-12-31-2359\",\n   588→        ),\n   589→    ],\n   590→)\n   591→def test_generate_draft_pr_branch_name_format(\n   592→    title: str, timestamp: datetime, objective_id: int | None, expected: str\n   593→) -> None:\n   594→    \"\"\"Branch name follows planned/{slug}-{timestamp} format.\"\"\"\n   595→    assert generate_draft_pr_branch_name(title, timestamp, objective_id=objective_id) == expected\n   596→\n   597→\n   598→def test_generate_draft_pr_branch_name_truncates_long_title() -> None:\n   599→    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n   600→    long_title = \"This is a very long title that should be truncated before timestamp\"\n   601→    timestamp = datetime(2024, 1, 15, 14, 30)\n   602→\n   603→    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=None)\n   604→\n   605→    # Base (plan-...) should be truncated to 31 chars, then timestamp appended\n   606→    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n   607→    assert len(result) <= 42\n   608→    assert result.startswith(\"planned/\")\n   609→    assert result.endswith(\"-01-15-1430\")\n   610→    # No trailing hyphen before timestamp\n   611→    assert not result[:-11].endswith(\"-\")\n   612→\n   613→\n   614→def test_generate_draft_pr_branch_name_handles_special_chars() -> None:\n   615→    \"\"\"Special characters in titles are sanitized.\"\"\"\n   616→    result = generate_draft_pr_branch_name(\n   617→        \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n   618→    )\n   619→    assert \":\" not in result\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"cb81b84a-6d17-42b7-8a6d-5d32978ec5af","timestamp":"2026-02-22T14:46:15.366Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","content":"\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # With objective ID\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 456),\n        (\"P42-O789-my-feature-06-20-1000\", 789),\n        (\"P100-O1-add-tests-12-31-2359\", 1),\n        # Lowercase o prefix (case insensitive)\n        (\"P123-o456-fix-bug\", 456),\n        (\"p123-o789-feature\", 789),\n        # Draft-PR branches with objective ID\n        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"planned/O1-add-tests-12-31-2359\", 1),\n        # Legacy plan/ prefix branches with objective ID\n        (\"plan/O456-fix-auth-01-15-1430\", 456),\n        (\"plan/O7709-plan-lazy-tip-sync-f-02-21-1116\", 7709),\n        # Without objective ID\n        (\"P123-fix-auth-bug-01-15-1430\", None),\n        (\"P42-my-feature\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"plan/fix-auth-bug-01-15-1430\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_objective_number(branch_name: str, expected: int | None) -> None:\n    \"\"\"Extract objective ID from branch name.\"\"\"\n    assert extract_objective_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Standard format (still works with objective ID in branch)\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 123),\n        (\"P42-O789-my-feature\", 42),\n        # Without objective ID (existing behavior)\n        (\"P2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"P42-fix-bug\", 42),\n        # Legacy format without P prefix\n        (\"2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"42-fix-bug\", 42),\n        # Draft-PR branches return None (no extractable issue number)\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"planned/O456-fix-auth-01-15-1430\", None),\n        # Invalid formats\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_leading_issue_number_with_objective_format(\n    branch_name: str, expected: int | None\n) -> None:\n    \"\"\"Extract leading issue number still works with objective ID in branch name.\"\"\"\n    assert extract_leading_issue_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Valid plan review branches\n        (\"planned/review-6214-01-15-1430\", 6214),\n        (\"planned/review-42-01-28-0930\", 42),\n        (\"planned/review-1-12-31-2359\", 1),\n        (\"planned/review-99999-01-01-0000\", 99999),\n        # Not plan review branches\n        (\"P2382-convert-erk-create-raw-ext\", None),\n        (\"2382-convert-erk-create-raw-ext\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n        (\"planned/review\", None),  # Missing issue number\n        (\"planned/review-\", None),  # Missing issue number\n        (\"planned/review-abc-01-15-1430\", None),  # Non-numeric issue\n    ],\n)\ndef test_extract_plan_review_issue_number(branch_name: str, expected: int | None) -> None:\n    assert extract_plan_review_issue_number(branch_name) == expected\n\n\n# Tests for generate_draft_pr_branch_name\n@pytest.mark.parametrize(\n    (\"title\", \"timestamp\", \"objective_id\", \"expected\"),\n    [\n        # Standard case without objective\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            None,\n            \"planned/fix-auth-bug-01-15-1430\",\n        ),\n        # Different timestamp\n        (\n            \"My Feature\",\n            datetime(2024, 6, 20, 10, 0),\n            None,\n            \"planned/my-feature-06-20-1000\",\n        ),\n        # Midnight edge case\n        (\n            \"Update Docs\",\n            datetime(2024, 1, 1, 0, 0),\n            None,\n            \"planned/update-docs-01-01-0000\",\n        ),\n        # With objective ID\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            456,\n            \"planned/O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Single digit objective\n        (\n            \"Add Tests\",\n            datetime(2024, 12, 31, 23, 59),\n            1,\n            \"planned/O1-add-tests-12-31-2359\",\n        ),\n    ],\n)\ndef test_generate_draft_pr_branch_name_format(\n    title: str, timestamp: datetime, objective_id: int | None, expected: str\n) -> None:\n    \"\"\"Branch name follows planned/{slug}-{timestamp} format.\"\"\"\n    assert generate_draft_pr_branch_name(title, timestamp, objective_id=objective_id) == expected\n\n\ndef test_generate_draft_pr_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=None)\n\n    # Base (plan-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"planned/\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_draft_pr_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_draft_pr_branch_name(\n        \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    assert \":\" not in result","numLines":150,"startLine":470,"totalLines":765}}}
{"parentUuid":"cb81b84a-6d17-42b7-8a6d-5d32978ec5af","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01T8z8FhjyoqDd9NLLn4a37a","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UsaPpf1TErfvq5Lc2zFBFJ","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","offset":619,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2479,"cache_read_input_tokens":82761,"cache_creation":{"ephemeral_5m_input_tokens":2479,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHhZ5hC74FkoC6a8y8q","type":"assistant","uuid":"735689f3-fc45-4e04-8700-2e88b9079d23","timestamp":"2026-02-22T14:46:18.083Z"}
{"parentUuid":"735689f3-fc45-4e04-8700-2e88b9079d23","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UsaPpf1TErfvq5Lc2zFBFJ","type":"tool_result","content":"   619→    assert \":\" not in result\n   620→    assert \"#\" not in result\n   621→    assert \"!\" not in result\n   622→    assert \"--\" not in result\n   623→\n   624→\n   625→def test_generate_draft_pr_branch_name_with_objective_truncates() -> None:\n   626→    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n   627→    long_title = \"This is a very long title that should be truncated before timestamp\"\n   628→    timestamp = datetime(2024, 1, 15, 14, 30)\n   629→\n   630→    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=456)\n   631→\n   632→    assert len(result) <= 42\n   633→    assert result.startswith(\"planned/O456-\")\n   634→    assert result.endswith(\"-01-15-1430\")\n   635→    assert not result[:-11].endswith(\"-\")\n   636→\n   637→\n   638→# Tests for validate_objective_slug\n   639→@pytest.mark.parametrize(\n   640→    \"slug\",\n   641→    [\n   642→        \"build-auth-system\",\n   643→        \"refactor-gateway\",\n   644→        \"add-dark-mode\",\n   645→        \"simple\",\n   646→        \"abc\",\n   647→        \"a\" * 40,\n   648→        \"fix-tui-layout\",\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"1c1e95c3-c639-4ba3-b0f2-ad6e43a574c6","timestamp":"2026-02-22T14:46:18.107Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","content":"    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\ndef test_generate_draft_pr_branch_name_with_objective_truncates() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=456)\n\n    assert len(result) <= 42\n    assert result.startswith(\"planned/O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    assert not result[:-11].endswith(\"-\")\n\n\n# Tests for validate_objective_slug\n@pytest.mark.parametrize(\n    \"slug\",\n    [\n        \"build-auth-system\",\n        \"refactor-gateway\",\n        \"add-dark-mode\",\n        \"simple\",\n        \"abc\",\n        \"a\" * 40,\n        \"fix-tui-layout\",","numLines":30,"startLine":619,"totalLines":765}}}
{"parentUuid":"1c1e95c3-c639-4ba3-b0f2-ad6e43a574c6","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01QAUYxs6D5SemnSUrZ4ZVba","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update test_naming.py. I need to change `planned/` to `plnd/` in the new branch generation tests, but keep `planned/` in backward-compat tests. For `extract_objective_number` and `extract_plan_review_issue_number`, I should update the primary test cases to use `plnd/` and also add `planned/` as legacy test cases."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":569,"cache_read_input_tokens":85240,"cache_creation":{"ephemeral_5m_input_tokens":569,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHhko9Xn9tqgrwWFKNZ","type":"assistant","uuid":"9eb92684-986b-4df9-aaa7-9d2342f66946","timestamp":"2026-02-22T14:46:22.712Z"}
{"parentUuid":"9eb92684-986b-4df9-aaa7-9d2342f66946","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01QAUYxs6D5SemnSUrZ4ZVba","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012VLpHRbE7kufACkswE298d","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","old_string":"        # Draft-PR branches with objective ID\n        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"planned/O1-add-tests-12-31-2359\", 1),\n        # Legacy plan/ prefix branches with objective ID","new_string":"        # Draft-PR branches with objective ID (current prefix)\n        (\"plnd/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"plnd/O1-add-tests-12-31-2359\", 1),\n        # Legacy planned/ prefix branches with objective ID\n        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"planned/O1-add-tests-12-31-2359\", 1),\n        # Legacy plan/ prefix branches with objective ID"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":569,"cache_read_input_tokens":85240,"cache_creation":{"ephemeral_5m_input_tokens":569,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHhko9Xn9tqgrwWFKNZ","type":"assistant","uuid":"fe9548b8-00f2-4887-8961-8bf7fc4cae15","timestamp":"2026-02-22T14:46:25.114Z"}
{"parentUuid":"fe9548b8-00f2-4887-8961-8bf7fc4cae15","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012VLpHRbE7kufACkswE298d","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/core/utils/test_naming.py has been updated successfully."}]},"uuid":"97484caa-9c39-4198-a6bd-eb3478e51a64","timestamp":"2026-02-22T14:46:25.792Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","oldString":"        # Draft-PR branches with objective ID\n        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"planned/O1-add-tests-12-31-2359\", 1),\n        # Legacy plan/ prefix branches with objective ID","newString":"        # Draft-PR branches with objective ID (current prefix)\n        (\"plnd/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"plnd/O1-add-tests-12-31-2359\", 1),\n        # Legacy planned/ prefix branches with objective ID\n        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"planned/O1-add-tests-12-31-2359\", 1),\n        # Legacy plan/ prefix branches with objective ID","originalFile":"from datetime import datetime\nfrom pathlib import Path\n\nimport pytest\n\nfrom erk_shared.naming import (\n    WORKTREE_DATE_SUFFIX_FORMAT,\n    InvalidObjectiveSlug,\n    InvalidPlanTitle,\n    ValidObjectiveSlug,\n    ValidPlanTitle,\n    default_branch_for_worktree,\n    derive_branch_name_from_title,\n    ensure_unique_worktree_name,\n    extract_leading_issue_number,\n    extract_objective_number,\n    extract_plan_review_issue_number,\n    extract_trailing_number,\n    generate_draft_pr_branch_name,\n    generate_issue_branch_name,\n    sanitize_branch_component,\n    sanitize_worktree_name,\n    strip_plan_from_filename,\n    validate_objective_slug,\n    validate_plan_title,\n)\n\n\ndef _get_current_date_suffix() -> str:\n    \"\"\"Get the current date suffix for plan-derived worktrees.\"\"\"\n    return datetime.now().strftime(WORKTREE_DATE_SUFFIX_FORMAT)\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\" Foo Bar \", \"foo-bar\"),\n        (\"A/B C\", \"a/b-c\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-branch-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-branch-name\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        (\"short\", \"short\"),\n        # Test long names with trailing hyphens are stripped\n        (\n            \"branch-name-with-dash-at-position-31-\",\n            \"branch-name-with-dash-at-positi\",\n        ),\n        # Test very long names truncate to 31\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".hidden-file\", \"hidden-file\"),\n        (\"file.extension\", \"file-extension\"),\n    ],\n)\ndef test_sanitize_branch_component(value: str, expected: str) -> None:\n    assert sanitize_branch_component(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"feature X\", \"feature-x\"),\n        (\"/ / \", \"work\"),\n    ],\n)\ndef test_default_branch_for_worktree(value: str, expected: str) -> None:\n    assert default_branch_for_worktree(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\"Add_Auth_Feature\", \"add-auth-feature\"),\n        (\"My_Cool_Plan\", \"my-cool-plan\"),\n        (\"FOO_BAR_BAZ\", \"foo-bar-baz\"),\n        (\"feature__with___multiple___underscores\", \"feature-with-multiple-underscor\"),\n        (\"name-with-hyphens\", \"name-with-hyphens\"),\n        (\"Mixed_Case-Hyphen_Underscore\", \"mixed-case-hyphen-underscore\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        (\"   spaces   \", \"spaces\"),\n        (\"---\", \"work\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-worktree-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-worktree-na\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        # Test truncation with trailing hyphen removal\n        (\n            \"worktree-name-with-dash-at-position-31-\",\n            \"worktree-name-with-dash-at-posi\",\n        ),\n        # Test truncation that ends with hyphen is stripped\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".worker-impl\", \"worker-impl\"),\n        (\"fix-.worker\", \"fix-worker\"),\n        (\"name.with.dots\", \"name-with-dots\"),\n    ],\n)\ndef test_sanitize_worktree_name(value: str, expected: str) -> None:\n    assert sanitize_worktree_name(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"devclikit-extraction-plan\", \"devclikit-extraction\"),\n        (\"my-feature-plan\", \"my-feature\"),\n        (\"plan-for-auth\", \"for-auth\"),\n        (\"plan-something\", \"something\"),\n        (\"something-plan\", \"something\"),\n        (\"something-plan-else\", \"something-else\"),\n        (\"plan-my-plan-feature\", \"my-feature\"),\n        (\"my-plan-feature-plan\", \"my-feature\"),\n        (\"plan\", \"plan\"),\n        (\"my_feature_plan\", \"my_feature\"),\n        (\"my feature plan\", \"my feature\"),\n        (\"my-feature_plan\", \"my-feature\"),\n        (\"MY-FEATURE-PLAN\", \"MY-FEATURE\"),\n        (\"My-Feature-Plan\", \"My-Feature\"),\n        (\"my-feature-PLAN\", \"my-feature\"),\n        (\"airplane-feature\", \"airplane-feature\"),\n        (\"explain-system\", \"explain-system\"),\n        (\"planted-tree\", \"planted-tree\"),\n        (\"planning-session\", \"planning-session\"),\n        (\"plans-document\", \"plans-document\"),\n        (\"-plan-feature\", \"feature\"),\n        (\"feature-plan-\", \"feature\"),\n        (\"my-feature-implementation-plan\", \"my-feature\"),\n        (\"implementation-plan-for-auth\", \"for-auth\"),\n        (\"implementation_plan_feature\", \"feature\"),\n        (\"feature implementation plan\", \"feature\"),\n        (\"my-feature_implementation-plan\", \"my-feature\"),\n        (\"implementation_plan-for-auth\", \"for-auth\"),\n        (\"IMPLEMENTATION-PLAN-FEATURE\", \"FEATURE\"),\n        (\"Implementation-Plan-Feature\", \"Feature\"),\n        (\"my-IMPLEMENTATION-plan\", \"my\"),\n        (\"my-implementation-plan-feature\", \"my-feature\"),\n        (\"plan-implementation-plan\", \"implementation\"),\n        (\"plan implementation plan\", \"implementation\"),\n        (\"implementation-plan\", \"implementation\"),\n        (\"implementation_plan\", \"implementation\"),\n        (\"IMPLEMENTATION-PLAN\", \"IMPLEMENTATION\"),\n        (\"reimplementation-feature\", \"reimplementation-feature\"),\n        (\"implantation-system\", \"implantation-system\"),\n    ],\n)\ndef test_strip_plan_from_filename(value: str, expected: str) -> None:\n    assert strip_plan_from_filename(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"name\", \"expected_base\", \"expected_number\"),\n    [\n        (\"my-feature\", \"my-feature\", None),\n        (\"my-feature-2\", \"my-feature\", 2),\n        (\"fix-42\", \"fix\", 42),\n        (\"feature-3-test\", \"feature-3-test\", None),  # Number in middle, not trailing\n        (\"test-123\", \"test\", 123),\n        (\"no-number\", \"no-number\", None),\n        (\"v2-feature-10\", \"v2-feature\", 10),\n    ],\n)\ndef test_extract_trailing_number(\n    name: str, expected_base: str, expected_number: int | None\n) -> None:\n    \"\"\"Test extracting trailing numbers from worktree names.\"\"\"\n    base, number = extract_trailing_number(name)\n    assert base == expected_base\n    assert number == expected_number\n\n\ndef test_ensure_unique_worktree_name_first_time(tmp_path: Path) -> None:\n    \"\"\"Test first-time worktree creation gets only datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    # Should have datetime suffix in format -YY-MM-DD-HHMM\n    date_suffix = _get_current_date_suffix()\n    assert result == f\"my-feature-{date_suffix}\"\n    assert not (repo_dir / result).exists()\n\n\ndef test_ensure_unique_worktree_name_duplicate_same_minute(tmp_path: Path) -> None:\n    \"\"\"Test duplicate worktree in same minute adds -2 after datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    existing_name = f\"my-feature-{date_suffix}\"\n    (repo_dir / existing_name).mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-2\"\n    assert not (repo_dir / result).exists()\n    assert (repo_dir / existing_name).exists()\n\n\ndef test_ensure_unique_worktree_name_multiple_duplicates(tmp_path: Path) -> None:\n    \"\"\"Test multiple duplicates increment correctly.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    (repo_dir / f\"my-feature-{date_suffix}\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-2\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-3\").mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-4\"\n\n\ndef test_ensure_unique_worktree_name_with_existing_number(tmp_path: Path) -> None:\n    \"\"\"Test name with existing number in base preserves it.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    date_suffix = _get_current_date_suffix()\n    result = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    # Base name has number, should preserve it in datetime-suffixed name\n    assert result == f\"fix-v3-{date_suffix}\"\n\n    # Create it and try again\n    (repo_dir / result).mkdir()\n    result2 = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    assert result2 == f\"fix-v3-{date_suffix}-2\"\n\n\ndef test_sanitize_branch_component_truncates_at_31_chars() -> None:\n    \"\"\"Branch names should truncate to 31 characters maximum.\"\"\"\n    # Exactly 31 characters\n    assert len(sanitize_branch_component(\"a\" * 31)) == 31\n\n    # 32 characters truncates to 31\n    assert len(sanitize_branch_component(\"a\" * 32)) == 31\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = sanitize_branch_component(long_name)\n    assert len(result) == 31\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\ndef test_sanitize_branch_component_matches_worktree_length() -> None:\n    \"\"\"Branch and worktree names should have same length for same input.\"\"\"\n    test_name = \"very-long-feature-name-that-exceeds-thirty-characters-easily\"\n    branch = sanitize_branch_component(test_name)\n    worktree = sanitize_worktree_name(test_name)\n    assert len(branch) == len(worktree)\n    assert len(branch) == 31\n\n\ndef test_very_long_title_truncates_to_45_chars_total() -> None:\n    \"\"\"Regression test: 99-char title should truncate to max 45 chars total with datetime suffix.\n\n    This tests the bug fix where `erk implement` created excessively long branch names.\n    Example: \"refactor erk implement command to support interactive and\n    non-interactive execution modes\"\n\n    Note: The 31-char limit includes rstrip(\"-\") after truncation,\n    so actual length may be <= 31.\n    \"\"\"\n    # 89-character title that caused the original bug\n    long_title = (\n        \"refactor erk implement command to support interactive and non-interactive execution modes\"\n    )\n\n    # Sanitize the worktree name (should be <= 31 chars max, trailing hyphens stripped)\n    base_name = sanitize_worktree_name(long_title)\n    assert len(base_name) <= 31\n\n    # With datetime suffix (-YY-MM-DD-HHMM = 14 chars including hyphen), total should be <= 45 chars\n    date_suffix = \"25-11-23-1430\"\n    name_with_date = f\"{base_name}-{date_suffix}\"\n    assert len(name_with_date) <= 45\n\n    # Verify the base name is correctly truncated (30 chars after rstrip of trailing hyphen)\n    assert base_name == \"refactor-erk-implement-command\"\n    assert len(base_name) == 30  # 31 chars truncated, then trailing hyphen stripped\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"expected\"),\n    [\n        (\"My Feature\", \"my-feature\"),\n        (\"Fix Bug #123!\", \"fix-bug-123\"),\n        (\"Simple\", \"simple\"),\n        (\"With_Underscores\", \"with-underscores\"),\n        (\"UPPERCASE\", \"uppercase\"),\n        (\"spaces  multiple   here\", \"spaces-multiple-here\"),\n        (\"leading---hyphens\", \"leading-hyphens\"),\n        (\"trailing---\", \"trailing\"),\n        (\"---both---\", \"both\"),\n        # Test 30-char truncation (different from sanitize_branch_component's 31)\n        (\"a\" * 40, \"a\" * 30),\n        (\"abcdefghijklmnopqrstuvwxyz-1234567890\", \"abcdefghijklmnopqrstuvwxyz-123\"),\n        # Trailing hyphen after truncation is removed\n        (\"this-is-thirty-chars-exact-yes\", \"this-is-thirty-chars-exact-yes\"),  # Exactly 30\n        (\"this-is-thirty-one-chars-exact\", \"this-is-thirty-one-chars-exact\"),  # 31 chars -> 30\n        # Test non-alphanumeric characters\n        (\"feat: add something\", \"feat-add-something\"),\n        (\"feat/add/something\", \"feat-add-something\"),\n        (\"feat(scope): message\", \"feat-scope-message\"),\n    ],\n)\ndef test_derive_branch_name_from_title(title: str, expected: str) -> None:\n    \"\"\"Test derive_branch_name_from_title matches workflow logic.\"\"\"\n    assert derive_branch_name_from_title(title) == expected\n\n\ndef test_derive_branch_name_truncates_to_30_chars() -> None:\n    \"\"\"Branch names from titles should truncate to 30 characters maximum.\n\n    This matches the workflow logic in plan-implement.yml which uses:\n    BRANCH_NAME=\"${BRANCH_NAME:0:30}\"\n    \"\"\"\n    # Exactly 30 characters\n    assert len(derive_branch_name_from_title(\"a\" * 30)) == 30\n\n    # 31 characters truncates to 30\n    assert len(derive_branch_name_from_title(\"a\" * 31)) == 30\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = derive_branch_name_from_title(long_name)\n    assert len(result) == 30\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\n# Tests for generate_issue_branch_name\n@pytest.mark.parametrize(\n    (\"issue_number\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # Standard case\n        (123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), \"P123-fix-auth-bug-01-15-1430\"),\n        # Integer issue number\n        (42, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-my-feature-06-20-1000\"),\n        # String issue number\n        (\"456\", \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P456-add-tests-12-31-2359\"),\n        # Midnight edge case\n        (789, \"Update Docs\", datetime(2024, 1, 1, 0, 0), \"P789-update-docs-01-01-0000\"),\n    ],\n)\ndef test_generate_issue_branch_name_format(\n    issue_number: int | str, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name follows P{num}-{slug}-{timestamp} format.\"\"\"\n    assert generate_issue_branch_name(issue_number, title, timestamp, objective_id=None) == expected\n\n\ndef test_generate_issue_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    # Very long title that would exceed 31 chars for base name\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=None)\n\n    # Base (P123-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"P123-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_issue_branch_name_preserves_hyphens_in_title() -> None:\n    \"\"\"Hyphens in titles are preserved (not doubled).\"\"\"\n    result = generate_issue_branch_name(\n        123, \"fix-auth-bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Should be P123-fix-auth-bug-..., not P123--fix-auth-bug-...\n    assert \"P123-fix-auth-bug-\" in result\n    assert \"--\" not in result\n\n\ndef test_generate_issue_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_issue_branch_name(\n        123, \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Special chars should be replaced with hyphens, then collapsed\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\n@pytest.mark.parametrize(\n    (\"issue_number\", \"objective_id\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # With objective ID\n        (\n            123,\n            456,\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            \"P123-O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Different objective ID\n        (42, 789, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-O789-my-feature-06-20-1000\"),\n        # Single digit objective\n        (100, 1, \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P100-O1-add-tests-12-31-2359\"),\n    ],\n)\ndef test_generate_issue_branch_name_with_objective(\n    issue_number: int, objective_id: int, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name includes objective ID when provided.\"\"\"\n    result = generate_issue_branch_name(issue_number, title, timestamp, objective_id=objective_id)\n    assert result == expected\n\n\ndef test_generate_issue_branch_name_with_objective_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=456)\n\n    # Base (P123-O456-...) should be truncated to 31 chars, then timestamp appended\n    assert len(result) <= 42\n    assert result.startswith(\"P123-O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # With objective ID\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 456),\n        (\"P42-O789-my-feature-06-20-1000\", 789),\n        (\"P100-O1-add-tests-12-31-2359\", 1),\n        # Lowercase o prefix (case insensitive)\n        (\"P123-o456-fix-bug\", 456),\n        (\"p123-o789-feature\", 789),\n        # Draft-PR branches with objective ID\n        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"planned/O1-add-tests-12-31-2359\", 1),\n        # Legacy plan/ prefix branches with objective ID\n        (\"plan/O456-fix-auth-01-15-1430\", 456),\n        (\"plan/O7709-plan-lazy-tip-sync-f-02-21-1116\", 7709),\n        # Without objective ID\n        (\"P123-fix-auth-bug-01-15-1430\", None),\n        (\"P42-my-feature\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"plan/fix-auth-bug-01-15-1430\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_objective_number(branch_name: str, expected: int | None) -> None:\n    \"\"\"Extract objective ID from branch name.\"\"\"\n    assert extract_objective_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Standard format (still works with objective ID in branch)\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 123),\n        (\"P42-O789-my-feature\", 42),\n        # Without objective ID (existing behavior)\n        (\"P2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"P42-fix-bug\", 42),\n        # Legacy format without P prefix\n        (\"2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"42-fix-bug\", 42),\n        # Draft-PR branches return None (no extractable issue number)\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"planned/O456-fix-auth-01-15-1430\", None),\n        # Invalid formats\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_leading_issue_number_with_objective_format(\n    branch_name: str, expected: int | None\n) -> None:\n    \"\"\"Extract leading issue number still works with objective ID in branch name.\"\"\"\n    assert extract_leading_issue_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Valid plan review branches\n        (\"planned/review-6214-01-15-1430\", 6214),\n        (\"planned/review-42-01-28-0930\", 42),\n        (\"planned/review-1-12-31-2359\", 1),\n        (\"planned/review-99999-01-01-0000\", 99999),\n        # Not plan review branches\n        (\"P2382-convert-erk-create-raw-ext\", None),\n        (\"2382-convert-erk-create-raw-ext\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n        (\"planned/review\", None),  # Missing issue number\n        (\"planned/review-\", None),  # Missing issue number\n        (\"planned/review-abc-01-15-1430\", None),  # Non-numeric issue\n    ],\n)\ndef test_extract_plan_review_issue_number(branch_name: str, expected: int | None) -> None:\n    assert extract_plan_review_issue_number(branch_name) == expected\n\n\n# Tests for generate_draft_pr_branch_name\n@pytest.mark.parametrize(\n    (\"title\", \"timestamp\", \"objective_id\", \"expected\"),\n    [\n        # Standard case without objective\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            None,\n            \"planned/fix-auth-bug-01-15-1430\",\n        ),\n        # Different timestamp\n        (\n            \"My Feature\",\n            datetime(2024, 6, 20, 10, 0),\n            None,\n            \"planned/my-feature-06-20-1000\",\n        ),\n        # Midnight edge case\n        (\n            \"Update Docs\",\n            datetime(2024, 1, 1, 0, 0),\n            None,\n            \"planned/update-docs-01-01-0000\",\n        ),\n        # With objective ID\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            456,\n            \"planned/O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Single digit objective\n        (\n            \"Add Tests\",\n            datetime(2024, 12, 31, 23, 59),\n            1,\n            \"planned/O1-add-tests-12-31-2359\",\n        ),\n    ],\n)\ndef test_generate_draft_pr_branch_name_format(\n    title: str, timestamp: datetime, objective_id: int | None, expected: str\n) -> None:\n    \"\"\"Branch name follows planned/{slug}-{timestamp} format.\"\"\"\n    assert generate_draft_pr_branch_name(title, timestamp, objective_id=objective_id) == expected\n\n\ndef test_generate_draft_pr_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=None)\n\n    # Base (plan-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"planned/\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_draft_pr_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_draft_pr_branch_name(\n        \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\ndef test_generate_draft_pr_branch_name_with_objective_truncates() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=456)\n\n    assert len(result) <= 42\n    assert result.startswith(\"planned/O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    assert not result[:-11].endswith(\"-\")\n\n\n# Tests for validate_objective_slug\n@pytest.mark.parametrize(\n    \"slug\",\n    [\n        \"build-auth-system\",\n        \"refactor-gateway\",\n        \"add-dark-mode\",\n        \"simple\",\n        \"abc\",\n        \"a\" * 40,\n        \"fix-tui-layout\",\n        \"add-v2-support\",\n        \"feature123\",\n    ],\n)\ndef test_validate_objective_slug_valid(slug: str) -> None:\n    \"\"\"Valid slugs return ValidObjectiveSlug.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, ValidObjectiveSlug)\n    assert result.slug == slug\n\n\n@pytest.mark.parametrize(\n    (\"slug\", \"reason_fragment\"),\n    [\n        (\"ab\", \"Too short\"),\n        (\"a\" * 41, \"Too long\"),\n        (\"Build-Auth\", \"Does not match\"),\n        (\"UPPERCASE\", \"Does not match\"),\n        (\"123-start\", \"Does not match\"),\n        (\"my--slug\", \"Does not match\"),\n        (\"has spaces\", \"Does not match\"),\n        (\"with_underscores\", \"Does not match\"),\n        (\"has.dots\", \"Does not match\"),\n        (\"-leading-hyphen\", \"Does not match\"),\n        (\"trailing-hyphen-\", \"Does not match\"),\n    ],\n)\ndef test_validate_objective_slug_invalid(slug: str, reason_fragment: str) -> None:\n    \"\"\"Invalid slugs return InvalidObjectiveSlug with matching reason.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_objective_slug_error_message_includes_pattern() -> None:\n    \"\"\"Error message includes the regex pattern for agent self-correction.\"\"\"\n    result = validate_objective_slug(\"INVALID\")\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert \"^[a-z][a-z0-9]*(-[a-z0-9]+)*$\" in result.message\n    assert \"INVALID\" in result.message\n\n\n# Tests for validate_plan_title\n@pytest.mark.parametrize(\n    \"title\",\n    [\n        \"Add User Authentication\",\n        \"Refactor Gateway Layer\",\n        \"Fix CLI Argument Parsing\",\n        \"hello\",\n        \"a\" * 100,\n        \"Fix Bug #123 in Auth Module\",\n        \"café au lait feature\",\n        \"Update the README file\",\n        \"Add v2 API support for external clients\",\n    ],\n)\ndef test_validate_plan_title_valid(title: str) -> None:\n    \"\"\"Valid titles return ValidPlanTitle.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == title.strip()\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"reason_fragment\"),\n    [\n        (\"\", \"empty\"),\n        (\"   \", \"empty\"),\n        (\"\\t\\n\", \"empty\"),\n        (\"Plan\", \"Too short\"),\n        (\"ab\", \"Too short\"),\n        (\"a\" * 101, \"Too long\"),\n        (\"12345\", \"at least one alphabetic\"),\n        (\"12345 67890\", \"at least one alphabetic\"),\n        (\"!@#$%^&*()\", \"at least one alphabetic\"),\n        (\"\\U0001f680\\U0001f389\\U0001f525\\U0001f4a5\\U0001f31f\", \"at least one alphabetic\"),\n        (\"\\u4f60\\u597d\\u4e16\\u754c\\u7684\\u8ba1\\u5212\", \"No usable content\"),\n    ],\n)\ndef test_validate_plan_title_invalid(title: str, reason_fragment: str) -> None:\n    \"\"\"Invalid titles return InvalidPlanTitle with matching reason.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, InvalidPlanTitle)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_plan_title_error_message_includes_rules() -> None:\n    \"\"\"Error message includes rules for agent self-correction.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert \"5-100 characters\" in result.message\n    assert \"at least one alphabetic\" in result.message\n    assert \"Valid examples\" in result.message\n    assert \"Invalid examples\" in result.message\n\n\ndef test_validate_plan_title_error_type() -> None:\n    \"\"\"Error type is machine-readable.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.error_type == \"invalid-plan-title\"\n\n\ndef test_validate_plan_title_strips_whitespace() -> None:\n    \"\"\"Leading/trailing whitespace is stripped before validation.\"\"\"\n    result = validate_plan_title(\"  Add Feature  \")\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == \"Add Feature\"\n\n\ndef test_validate_plan_title_preserves_original_in_error() -> None:\n    \"\"\"Error includes the original unmodified title.\"\"\"\n    result = validate_plan_title(\"   ab   \")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.raw_title == \"   ab   \"\n","structuredPatch":[{"oldStart":478,"oldLines":7,"newStart":478,"newLines":10,"lines":["         # Lowercase o prefix (case insensitive)","         (\"P123-o456-fix-bug\", 456),","         (\"p123-o789-feature\", 789),","-        # Draft-PR branches with objective ID","+        # Draft-PR branches with objective ID (current prefix)","+        (\"plnd/O456-fix-auth-bug-01-15-1430\", 456),","+        (\"plnd/O1-add-tests-12-31-2359\", 1),","+        # Legacy planned/ prefix branches with objective ID","         (\"planned/O456-fix-auth-bug-01-15-1430\", 456),","         (\"planned/O1-add-tests-12-31-2359\", 1),","         # Legacy plan/ prefix branches with objective ID"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"97484caa-9c39-4198-a6bd-eb3478e51a64","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01889QVUYvL5KStjp3z1rDDf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0158UWZLFkj8DNfzFE79eVnh","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","old_string":"        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"plan/fix-auth-bug-01-15-1430\", None),\n        (\"feature-branch\", None),","new_string":"        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"plan/fix-auth-bug-01-15-1430\", None),\n        (\"feature-branch\", None),"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":778,"cache_read_input_tokens":85809,"cache_creation":{"ephemeral_5m_input_tokens":778,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHiKg58bxtEcCwUVuaE","type":"assistant","uuid":"f34b1396-cd3b-4f96-ae38-28d0cd2ea415","timestamp":"2026-02-22T14:46:30.370Z"}
{"parentUuid":"f34b1396-cd3b-4f96-ae38-28d0cd2ea415","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0158UWZLFkj8DNfzFE79eVnh","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/core/utils/test_naming.py has been updated successfully."}]},"uuid":"30f225f6-b4ba-4f3f-aaea-778c2cb79ad4","timestamp":"2026-02-22T14:46:31.042Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","oldString":"        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"plan/fix-auth-bug-01-15-1430\", None),\n        (\"feature-branch\", None),","newString":"        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"plan/fix-auth-bug-01-15-1430\", None),\n        (\"feature-branch\", None),","originalFile":"from datetime import datetime\nfrom pathlib import Path\n\nimport pytest\n\nfrom erk_shared.naming import (\n    WORKTREE_DATE_SUFFIX_FORMAT,\n    InvalidObjectiveSlug,\n    InvalidPlanTitle,\n    ValidObjectiveSlug,\n    ValidPlanTitle,\n    default_branch_for_worktree,\n    derive_branch_name_from_title,\n    ensure_unique_worktree_name,\n    extract_leading_issue_number,\n    extract_objective_number,\n    extract_plan_review_issue_number,\n    extract_trailing_number,\n    generate_draft_pr_branch_name,\n    generate_issue_branch_name,\n    sanitize_branch_component,\n    sanitize_worktree_name,\n    strip_plan_from_filename,\n    validate_objective_slug,\n    validate_plan_title,\n)\n\n\ndef _get_current_date_suffix() -> str:\n    \"\"\"Get the current date suffix for plan-derived worktrees.\"\"\"\n    return datetime.now().strftime(WORKTREE_DATE_SUFFIX_FORMAT)\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\" Foo Bar \", \"foo-bar\"),\n        (\"A/B C\", \"a/b-c\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-branch-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-branch-name\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        (\"short\", \"short\"),\n        # Test long names with trailing hyphens are stripped\n        (\n            \"branch-name-with-dash-at-position-31-\",\n            \"branch-name-with-dash-at-positi\",\n        ),\n        # Test very long names truncate to 31\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".hidden-file\", \"hidden-file\"),\n        (\"file.extension\", \"file-extension\"),\n    ],\n)\ndef test_sanitize_branch_component(value: str, expected: str) -> None:\n    assert sanitize_branch_component(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"feature X\", \"feature-x\"),\n        (\"/ / \", \"work\"),\n    ],\n)\ndef test_default_branch_for_worktree(value: str, expected: str) -> None:\n    assert default_branch_for_worktree(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\"Add_Auth_Feature\", \"add-auth-feature\"),\n        (\"My_Cool_Plan\", \"my-cool-plan\"),\n        (\"FOO_BAR_BAZ\", \"foo-bar-baz\"),\n        (\"feature__with___multiple___underscores\", \"feature-with-multiple-underscor\"),\n        (\"name-with-hyphens\", \"name-with-hyphens\"),\n        (\"Mixed_Case-Hyphen_Underscore\", \"mixed-case-hyphen-underscore\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        (\"   spaces   \", \"spaces\"),\n        (\"---\", \"work\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-worktree-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-worktree-na\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        # Test truncation with trailing hyphen removal\n        (\n            \"worktree-name-with-dash-at-position-31-\",\n            \"worktree-name-with-dash-at-posi\",\n        ),\n        # Test truncation that ends with hyphen is stripped\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".worker-impl\", \"worker-impl\"),\n        (\"fix-.worker\", \"fix-worker\"),\n        (\"name.with.dots\", \"name-with-dots\"),\n    ],\n)\ndef test_sanitize_worktree_name(value: str, expected: str) -> None:\n    assert sanitize_worktree_name(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"devclikit-extraction-plan\", \"devclikit-extraction\"),\n        (\"my-feature-plan\", \"my-feature\"),\n        (\"plan-for-auth\", \"for-auth\"),\n        (\"plan-something\", \"something\"),\n        (\"something-plan\", \"something\"),\n        (\"something-plan-else\", \"something-else\"),\n        (\"plan-my-plan-feature\", \"my-feature\"),\n        (\"my-plan-feature-plan\", \"my-feature\"),\n        (\"plan\", \"plan\"),\n        (\"my_feature_plan\", \"my_feature\"),\n        (\"my feature plan\", \"my feature\"),\n        (\"my-feature_plan\", \"my-feature\"),\n        (\"MY-FEATURE-PLAN\", \"MY-FEATURE\"),\n        (\"My-Feature-Plan\", \"My-Feature\"),\n        (\"my-feature-PLAN\", \"my-feature\"),\n        (\"airplane-feature\", \"airplane-feature\"),\n        (\"explain-system\", \"explain-system\"),\n        (\"planted-tree\", \"planted-tree\"),\n        (\"planning-session\", \"planning-session\"),\n        (\"plans-document\", \"plans-document\"),\n        (\"-plan-feature\", \"feature\"),\n        (\"feature-plan-\", \"feature\"),\n        (\"my-feature-implementation-plan\", \"my-feature\"),\n        (\"implementation-plan-for-auth\", \"for-auth\"),\n        (\"implementation_plan_feature\", \"feature\"),\n        (\"feature implementation plan\", \"feature\"),\n        (\"my-feature_implementation-plan\", \"my-feature\"),\n        (\"implementation_plan-for-auth\", \"for-auth\"),\n        (\"IMPLEMENTATION-PLAN-FEATURE\", \"FEATURE\"),\n        (\"Implementation-Plan-Feature\", \"Feature\"),\n        (\"my-IMPLEMENTATION-plan\", \"my\"),\n        (\"my-implementation-plan-feature\", \"my-feature\"),\n        (\"plan-implementation-plan\", \"implementation\"),\n        (\"plan implementation plan\", \"implementation\"),\n        (\"implementation-plan\", \"implementation\"),\n        (\"implementation_plan\", \"implementation\"),\n        (\"IMPLEMENTATION-PLAN\", \"IMPLEMENTATION\"),\n        (\"reimplementation-feature\", \"reimplementation-feature\"),\n        (\"implantation-system\", \"implantation-system\"),\n    ],\n)\ndef test_strip_plan_from_filename(value: str, expected: str) -> None:\n    assert strip_plan_from_filename(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"name\", \"expected_base\", \"expected_number\"),\n    [\n        (\"my-feature\", \"my-feature\", None),\n        (\"my-feature-2\", \"my-feature\", 2),\n        (\"fix-42\", \"fix\", 42),\n        (\"feature-3-test\", \"feature-3-test\", None),  # Number in middle, not trailing\n        (\"test-123\", \"test\", 123),\n        (\"no-number\", \"no-number\", None),\n        (\"v2-feature-10\", \"v2-feature\", 10),\n    ],\n)\ndef test_extract_trailing_number(\n    name: str, expected_base: str, expected_number: int | None\n) -> None:\n    \"\"\"Test extracting trailing numbers from worktree names.\"\"\"\n    base, number = extract_trailing_number(name)\n    assert base == expected_base\n    assert number == expected_number\n\n\ndef test_ensure_unique_worktree_name_first_time(tmp_path: Path) -> None:\n    \"\"\"Test first-time worktree creation gets only datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    # Should have datetime suffix in format -YY-MM-DD-HHMM\n    date_suffix = _get_current_date_suffix()\n    assert result == f\"my-feature-{date_suffix}\"\n    assert not (repo_dir / result).exists()\n\n\ndef test_ensure_unique_worktree_name_duplicate_same_minute(tmp_path: Path) -> None:\n    \"\"\"Test duplicate worktree in same minute adds -2 after datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    existing_name = f\"my-feature-{date_suffix}\"\n    (repo_dir / existing_name).mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-2\"\n    assert not (repo_dir / result).exists()\n    assert (repo_dir / existing_name).exists()\n\n\ndef test_ensure_unique_worktree_name_multiple_duplicates(tmp_path: Path) -> None:\n    \"\"\"Test multiple duplicates increment correctly.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    (repo_dir / f\"my-feature-{date_suffix}\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-2\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-3\").mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-4\"\n\n\ndef test_ensure_unique_worktree_name_with_existing_number(tmp_path: Path) -> None:\n    \"\"\"Test name with existing number in base preserves it.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    date_suffix = _get_current_date_suffix()\n    result = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    # Base name has number, should preserve it in datetime-suffixed name\n    assert result == f\"fix-v3-{date_suffix}\"\n\n    # Create it and try again\n    (repo_dir / result).mkdir()\n    result2 = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    assert result2 == f\"fix-v3-{date_suffix}-2\"\n\n\ndef test_sanitize_branch_component_truncates_at_31_chars() -> None:\n    \"\"\"Branch names should truncate to 31 characters maximum.\"\"\"\n    # Exactly 31 characters\n    assert len(sanitize_branch_component(\"a\" * 31)) == 31\n\n    # 32 characters truncates to 31\n    assert len(sanitize_branch_component(\"a\" * 32)) == 31\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = sanitize_branch_component(long_name)\n    assert len(result) == 31\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\ndef test_sanitize_branch_component_matches_worktree_length() -> None:\n    \"\"\"Branch and worktree names should have same length for same input.\"\"\"\n    test_name = \"very-long-feature-name-that-exceeds-thirty-characters-easily\"\n    branch = sanitize_branch_component(test_name)\n    worktree = sanitize_worktree_name(test_name)\n    assert len(branch) == len(worktree)\n    assert len(branch) == 31\n\n\ndef test_very_long_title_truncates_to_45_chars_total() -> None:\n    \"\"\"Regression test: 99-char title should truncate to max 45 chars total with datetime suffix.\n\n    This tests the bug fix where `erk implement` created excessively long branch names.\n    Example: \"refactor erk implement command to support interactive and\n    non-interactive execution modes\"\n\n    Note: The 31-char limit includes rstrip(\"-\") after truncation,\n    so actual length may be <= 31.\n    \"\"\"\n    # 89-character title that caused the original bug\n    long_title = (\n        \"refactor erk implement command to support interactive and non-interactive execution modes\"\n    )\n\n    # Sanitize the worktree name (should be <= 31 chars max, trailing hyphens stripped)\n    base_name = sanitize_worktree_name(long_title)\n    assert len(base_name) <= 31\n\n    # With datetime suffix (-YY-MM-DD-HHMM = 14 chars including hyphen), total should be <= 45 chars\n    date_suffix = \"25-11-23-1430\"\n    name_with_date = f\"{base_name}-{date_suffix}\"\n    assert len(name_with_date) <= 45\n\n    # Verify the base name is correctly truncated (30 chars after rstrip of trailing hyphen)\n    assert base_name == \"refactor-erk-implement-command\"\n    assert len(base_name) == 30  # 31 chars truncated, then trailing hyphen stripped\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"expected\"),\n    [\n        (\"My Feature\", \"my-feature\"),\n        (\"Fix Bug #123!\", \"fix-bug-123\"),\n        (\"Simple\", \"simple\"),\n        (\"With_Underscores\", \"with-underscores\"),\n        (\"UPPERCASE\", \"uppercase\"),\n        (\"spaces  multiple   here\", \"spaces-multiple-here\"),\n        (\"leading---hyphens\", \"leading-hyphens\"),\n        (\"trailing---\", \"trailing\"),\n        (\"---both---\", \"both\"),\n        # Test 30-char truncation (different from sanitize_branch_component's 31)\n        (\"a\" * 40, \"a\" * 30),\n        (\"abcdefghijklmnopqrstuvwxyz-1234567890\", \"abcdefghijklmnopqrstuvwxyz-123\"),\n        # Trailing hyphen after truncation is removed\n        (\"this-is-thirty-chars-exact-yes\", \"this-is-thirty-chars-exact-yes\"),  # Exactly 30\n        (\"this-is-thirty-one-chars-exact\", \"this-is-thirty-one-chars-exact\"),  # 31 chars -> 30\n        # Test non-alphanumeric characters\n        (\"feat: add something\", \"feat-add-something\"),\n        (\"feat/add/something\", \"feat-add-something\"),\n        (\"feat(scope): message\", \"feat-scope-message\"),\n    ],\n)\ndef test_derive_branch_name_from_title(title: str, expected: str) -> None:\n    \"\"\"Test derive_branch_name_from_title matches workflow logic.\"\"\"\n    assert derive_branch_name_from_title(title) == expected\n\n\ndef test_derive_branch_name_truncates_to_30_chars() -> None:\n    \"\"\"Branch names from titles should truncate to 30 characters maximum.\n\n    This matches the workflow logic in plan-implement.yml which uses:\n    BRANCH_NAME=\"${BRANCH_NAME:0:30}\"\n    \"\"\"\n    # Exactly 30 characters\n    assert len(derive_branch_name_from_title(\"a\" * 30)) == 30\n\n    # 31 characters truncates to 30\n    assert len(derive_branch_name_from_title(\"a\" * 31)) == 30\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = derive_branch_name_from_title(long_name)\n    assert len(result) == 30\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\n# Tests for generate_issue_branch_name\n@pytest.mark.parametrize(\n    (\"issue_number\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # Standard case\n        (123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), \"P123-fix-auth-bug-01-15-1430\"),\n        # Integer issue number\n        (42, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-my-feature-06-20-1000\"),\n        # String issue number\n        (\"456\", \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P456-add-tests-12-31-2359\"),\n        # Midnight edge case\n        (789, \"Update Docs\", datetime(2024, 1, 1, 0, 0), \"P789-update-docs-01-01-0000\"),\n    ],\n)\ndef test_generate_issue_branch_name_format(\n    issue_number: int | str, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name follows P{num}-{slug}-{timestamp} format.\"\"\"\n    assert generate_issue_branch_name(issue_number, title, timestamp, objective_id=None) == expected\n\n\ndef test_generate_issue_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    # Very long title that would exceed 31 chars for base name\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=None)\n\n    # Base (P123-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"P123-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_issue_branch_name_preserves_hyphens_in_title() -> None:\n    \"\"\"Hyphens in titles are preserved (not doubled).\"\"\"\n    result = generate_issue_branch_name(\n        123, \"fix-auth-bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Should be P123-fix-auth-bug-..., not P123--fix-auth-bug-...\n    assert \"P123-fix-auth-bug-\" in result\n    assert \"--\" not in result\n\n\ndef test_generate_issue_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_issue_branch_name(\n        123, \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Special chars should be replaced with hyphens, then collapsed\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\n@pytest.mark.parametrize(\n    (\"issue_number\", \"objective_id\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # With objective ID\n        (\n            123,\n            456,\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            \"P123-O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Different objective ID\n        (42, 789, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-O789-my-feature-06-20-1000\"),\n        # Single digit objective\n        (100, 1, \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P100-O1-add-tests-12-31-2359\"),\n    ],\n)\ndef test_generate_issue_branch_name_with_objective(\n    issue_number: int, objective_id: int, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name includes objective ID when provided.\"\"\"\n    result = generate_issue_branch_name(issue_number, title, timestamp, objective_id=objective_id)\n    assert result == expected\n\n\ndef test_generate_issue_branch_name_with_objective_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=456)\n\n    # Base (P123-O456-...) should be truncated to 31 chars, then timestamp appended\n    assert len(result) <= 42\n    assert result.startswith(\"P123-O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # With objective ID\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 456),\n        (\"P42-O789-my-feature-06-20-1000\", 789),\n        (\"P100-O1-add-tests-12-31-2359\", 1),\n        # Lowercase o prefix (case insensitive)\n        (\"P123-o456-fix-bug\", 456),\n        (\"p123-o789-feature\", 789),\n        # Draft-PR branches with objective ID (current prefix)\n        (\"plnd/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"plnd/O1-add-tests-12-31-2359\", 1),\n        # Legacy planned/ prefix branches with objective ID\n        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"planned/O1-add-tests-12-31-2359\", 1),\n        # Legacy plan/ prefix branches with objective ID\n        (\"plan/O456-fix-auth-01-15-1430\", 456),\n        (\"plan/O7709-plan-lazy-tip-sync-f-02-21-1116\", 7709),\n        # Without objective ID\n        (\"P123-fix-auth-bug-01-15-1430\", None),\n        (\"P42-my-feature\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"plan/fix-auth-bug-01-15-1430\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_objective_number(branch_name: str, expected: int | None) -> None:\n    \"\"\"Extract objective ID from branch name.\"\"\"\n    assert extract_objective_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Standard format (still works with objective ID in branch)\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 123),\n        (\"P42-O789-my-feature\", 42),\n        # Without objective ID (existing behavior)\n        (\"P2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"P42-fix-bug\", 42),\n        # Legacy format without P prefix\n        (\"2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"42-fix-bug\", 42),\n        # Draft-PR branches return None (no extractable issue number)\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"planned/O456-fix-auth-01-15-1430\", None),\n        # Invalid formats\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_leading_issue_number_with_objective_format(\n    branch_name: str, expected: int | None\n) -> None:\n    \"\"\"Extract leading issue number still works with objective ID in branch name.\"\"\"\n    assert extract_leading_issue_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Valid plan review branches\n        (\"planned/review-6214-01-15-1430\", 6214),\n        (\"planned/review-42-01-28-0930\", 42),\n        (\"planned/review-1-12-31-2359\", 1),\n        (\"planned/review-99999-01-01-0000\", 99999),\n        # Not plan review branches\n        (\"P2382-convert-erk-create-raw-ext\", None),\n        (\"2382-convert-erk-create-raw-ext\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n        (\"planned/review\", None),  # Missing issue number\n        (\"planned/review-\", None),  # Missing issue number\n        (\"planned/review-abc-01-15-1430\", None),  # Non-numeric issue\n    ],\n)\ndef test_extract_plan_review_issue_number(branch_name: str, expected: int | None) -> None:\n    assert extract_plan_review_issue_number(branch_name) == expected\n\n\n# Tests for generate_draft_pr_branch_name\n@pytest.mark.parametrize(\n    (\"title\", \"timestamp\", \"objective_id\", \"expected\"),\n    [\n        # Standard case without objective\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            None,\n            \"planned/fix-auth-bug-01-15-1430\",\n        ),\n        # Different timestamp\n        (\n            \"My Feature\",\n            datetime(2024, 6, 20, 10, 0),\n            None,\n            \"planned/my-feature-06-20-1000\",\n        ),\n        # Midnight edge case\n        (\n            \"Update Docs\",\n            datetime(2024, 1, 1, 0, 0),\n            None,\n            \"planned/update-docs-01-01-0000\",\n        ),\n        # With objective ID\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            456,\n            \"planned/O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Single digit objective\n        (\n            \"Add Tests\",\n            datetime(2024, 12, 31, 23, 59),\n            1,\n            \"planned/O1-add-tests-12-31-2359\",\n        ),\n    ],\n)\ndef test_generate_draft_pr_branch_name_format(\n    title: str, timestamp: datetime, objective_id: int | None, expected: str\n) -> None:\n    \"\"\"Branch name follows planned/{slug}-{timestamp} format.\"\"\"\n    assert generate_draft_pr_branch_name(title, timestamp, objective_id=objective_id) == expected\n\n\ndef test_generate_draft_pr_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=None)\n\n    # Base (plan-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"planned/\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_draft_pr_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_draft_pr_branch_name(\n        \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\ndef test_generate_draft_pr_branch_name_with_objective_truncates() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=456)\n\n    assert len(result) <= 42\n    assert result.startswith(\"planned/O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    assert not result[:-11].endswith(\"-\")\n\n\n# Tests for validate_objective_slug\n@pytest.mark.parametrize(\n    \"slug\",\n    [\n        \"build-auth-system\",\n        \"refactor-gateway\",\n        \"add-dark-mode\",\n        \"simple\",\n        \"abc\",\n        \"a\" * 40,\n        \"fix-tui-layout\",\n        \"add-v2-support\",\n        \"feature123\",\n    ],\n)\ndef test_validate_objective_slug_valid(slug: str) -> None:\n    \"\"\"Valid slugs return ValidObjectiveSlug.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, ValidObjectiveSlug)\n    assert result.slug == slug\n\n\n@pytest.mark.parametrize(\n    (\"slug\", \"reason_fragment\"),\n    [\n        (\"ab\", \"Too short\"),\n        (\"a\" * 41, \"Too long\"),\n        (\"Build-Auth\", \"Does not match\"),\n        (\"UPPERCASE\", \"Does not match\"),\n        (\"123-start\", \"Does not match\"),\n        (\"my--slug\", \"Does not match\"),\n        (\"has spaces\", \"Does not match\"),\n        (\"with_underscores\", \"Does not match\"),\n        (\"has.dots\", \"Does not match\"),\n        (\"-leading-hyphen\", \"Does not match\"),\n        (\"trailing-hyphen-\", \"Does not match\"),\n    ],\n)\ndef test_validate_objective_slug_invalid(slug: str, reason_fragment: str) -> None:\n    \"\"\"Invalid slugs return InvalidObjectiveSlug with matching reason.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_objective_slug_error_message_includes_pattern() -> None:\n    \"\"\"Error message includes the regex pattern for agent self-correction.\"\"\"\n    result = validate_objective_slug(\"INVALID\")\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert \"^[a-z][a-z0-9]*(-[a-z0-9]+)*$\" in result.message\n    assert \"INVALID\" in result.message\n\n\n# Tests for validate_plan_title\n@pytest.mark.parametrize(\n    \"title\",\n    [\n        \"Add User Authentication\",\n        \"Refactor Gateway Layer\",\n        \"Fix CLI Argument Parsing\",\n        \"hello\",\n        \"a\" * 100,\n        \"Fix Bug #123 in Auth Module\",\n        \"café au lait feature\",\n        \"Update the README file\",\n        \"Add v2 API support for external clients\",\n    ],\n)\ndef test_validate_plan_title_valid(title: str) -> None:\n    \"\"\"Valid titles return ValidPlanTitle.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == title.strip()\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"reason_fragment\"),\n    [\n        (\"\", \"empty\"),\n        (\"   \", \"empty\"),\n        (\"\\t\\n\", \"empty\"),\n        (\"Plan\", \"Too short\"),\n        (\"ab\", \"Too short\"),\n        (\"a\" * 101, \"Too long\"),\n        (\"12345\", \"at least one alphabetic\"),\n        (\"12345 67890\", \"at least one alphabetic\"),\n        (\"!@#$%^&*()\", \"at least one alphabetic\"),\n        (\"\\U0001f680\\U0001f389\\U0001f525\\U0001f4a5\\U0001f31f\", \"at least one alphabetic\"),\n        (\"\\u4f60\\u597d\\u4e16\\u754c\\u7684\\u8ba1\\u5212\", \"No usable content\"),\n    ],\n)\ndef test_validate_plan_title_invalid(title: str, reason_fragment: str) -> None:\n    \"\"\"Invalid titles return InvalidPlanTitle with matching reason.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, InvalidPlanTitle)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_plan_title_error_message_includes_rules() -> None:\n    \"\"\"Error message includes rules for agent self-correction.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert \"5-100 characters\" in result.message\n    assert \"at least one alphabetic\" in result.message\n    assert \"Valid examples\" in result.message\n    assert \"Invalid examples\" in result.message\n\n\ndef test_validate_plan_title_error_type() -> None:\n    \"\"\"Error type is machine-readable.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.error_type == \"invalid-plan-title\"\n\n\ndef test_validate_plan_title_strips_whitespace() -> None:\n    \"\"\"Leading/trailing whitespace is stripped before validation.\"\"\"\n    result = validate_plan_title(\"  Add Feature  \")\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == \"Add Feature\"\n\n\ndef test_validate_plan_title_preserves_original_in_error() -> None:\n    \"\"\"Error includes the original unmodified title.\"\"\"\n    result = validate_plan_title(\"   ab   \")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.raw_title == \"   ab   \"\n","structuredPatch":[{"oldStart":490,"oldLines":6,"newStart":490,"newLines":7,"lines":["         # Without objective ID","         (\"P123-fix-auth-bug-01-15-1430\", None),","         (\"P42-my-feature\", None),","+        (\"plnd/fix-auth-bug-01-15-1430\", None),","         (\"planned/fix-auth-bug-01-15-1430\", None),","         (\"plan/fix-auth-bug-01-15-1430\", None),","         (\"feature-branch\", None),"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"30f225f6-b4ba-4f3f-aaea-778c2cb79ad4","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01UvFHWeBccYN61sFcfv1TRT","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `extract_leading_issue_number` tests - these should also add `plnd/` cases:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":271,"cache_read_input_tokens":86587,"cache_creation":{"ephemeral_5m_input_tokens":271,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHiiL6UBR6M39gWBNpB","type":"assistant","uuid":"fe8593f9-e638-410b-a8fe-12fc0a8ed724","timestamp":"2026-02-22T14:46:34.515Z"}
{"parentUuid":"fe8593f9-e638-410b-a8fe-12fc0a8ed724","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01UvFHWeBccYN61sFcfv1TRT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JvK1mHaBDrym6qDPcpCLtm","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","old_string":"        # Draft-PR branches return None (no extractable issue number)\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"planned/O456-fix-auth-01-15-1430\", None),","new_string":"        # Draft-PR branches return None (no extractable issue number)\n        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"plnd/O456-fix-auth-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"planned/O456-fix-auth-01-15-1430\", None),"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":271,"cache_read_input_tokens":86587,"cache_creation":{"ephemeral_5m_input_tokens":271,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHiiL6UBR6M39gWBNpB","type":"assistant","uuid":"0b393b2d-9d38-4a36-aced-5cc32c8d553a","timestamp":"2026-02-22T14:46:36.645Z"}
{"parentUuid":"0b393b2d-9d38-4a36-aced-5cc32c8d553a","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JvK1mHaBDrym6qDPcpCLtm","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/core/utils/test_naming.py has been updated successfully."}]},"uuid":"6e974328-b8c9-4d20-b478-2f4818e607f9","timestamp":"2026-02-22T14:46:37.339Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","oldString":"        # Draft-PR branches return None (no extractable issue number)\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"planned/O456-fix-auth-01-15-1430\", None),","newString":"        # Draft-PR branches return None (no extractable issue number)\n        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"plnd/O456-fix-auth-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"planned/O456-fix-auth-01-15-1430\", None),","originalFile":"from datetime import datetime\nfrom pathlib import Path\n\nimport pytest\n\nfrom erk_shared.naming import (\n    WORKTREE_DATE_SUFFIX_FORMAT,\n    InvalidObjectiveSlug,\n    InvalidPlanTitle,\n    ValidObjectiveSlug,\n    ValidPlanTitle,\n    default_branch_for_worktree,\n    derive_branch_name_from_title,\n    ensure_unique_worktree_name,\n    extract_leading_issue_number,\n    extract_objective_number,\n    extract_plan_review_issue_number,\n    extract_trailing_number,\n    generate_draft_pr_branch_name,\n    generate_issue_branch_name,\n    sanitize_branch_component,\n    sanitize_worktree_name,\n    strip_plan_from_filename,\n    validate_objective_slug,\n    validate_plan_title,\n)\n\n\ndef _get_current_date_suffix() -> str:\n    \"\"\"Get the current date suffix for plan-derived worktrees.\"\"\"\n    return datetime.now().strftime(WORKTREE_DATE_SUFFIX_FORMAT)\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\" Foo Bar \", \"foo-bar\"),\n        (\"A/B C\", \"a/b-c\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-branch-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-branch-name\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        (\"short\", \"short\"),\n        # Test long names with trailing hyphens are stripped\n        (\n            \"branch-name-with-dash-at-position-31-\",\n            \"branch-name-with-dash-at-positi\",\n        ),\n        # Test very long names truncate to 31\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".hidden-file\", \"hidden-file\"),\n        (\"file.extension\", \"file-extension\"),\n    ],\n)\ndef test_sanitize_branch_component(value: str, expected: str) -> None:\n    assert sanitize_branch_component(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"feature X\", \"feature-x\"),\n        (\"/ / \", \"work\"),\n    ],\n)\ndef test_default_branch_for_worktree(value: str, expected: str) -> None:\n    assert default_branch_for_worktree(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\"Add_Auth_Feature\", \"add-auth-feature\"),\n        (\"My_Cool_Plan\", \"my-cool-plan\"),\n        (\"FOO_BAR_BAZ\", \"foo-bar-baz\"),\n        (\"feature__with___multiple___underscores\", \"feature-with-multiple-underscor\"),\n        (\"name-with-hyphens\", \"name-with-hyphens\"),\n        (\"Mixed_Case-Hyphen_Underscore\", \"mixed-case-hyphen-underscore\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        (\"   spaces   \", \"spaces\"),\n        (\"---\", \"work\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-worktree-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-worktree-na\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        # Test truncation with trailing hyphen removal\n        (\n            \"worktree-name-with-dash-at-position-31-\",\n            \"worktree-name-with-dash-at-posi\",\n        ),\n        # Test truncation that ends with hyphen is stripped\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".worker-impl\", \"worker-impl\"),\n        (\"fix-.worker\", \"fix-worker\"),\n        (\"name.with.dots\", \"name-with-dots\"),\n    ],\n)\ndef test_sanitize_worktree_name(value: str, expected: str) -> None:\n    assert sanitize_worktree_name(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"devclikit-extraction-plan\", \"devclikit-extraction\"),\n        (\"my-feature-plan\", \"my-feature\"),\n        (\"plan-for-auth\", \"for-auth\"),\n        (\"plan-something\", \"something\"),\n        (\"something-plan\", \"something\"),\n        (\"something-plan-else\", \"something-else\"),\n        (\"plan-my-plan-feature\", \"my-feature\"),\n        (\"my-plan-feature-plan\", \"my-feature\"),\n        (\"plan\", \"plan\"),\n        (\"my_feature_plan\", \"my_feature\"),\n        (\"my feature plan\", \"my feature\"),\n        (\"my-feature_plan\", \"my-feature\"),\n        (\"MY-FEATURE-PLAN\", \"MY-FEATURE\"),\n        (\"My-Feature-Plan\", \"My-Feature\"),\n        (\"my-feature-PLAN\", \"my-feature\"),\n        (\"airplane-feature\", \"airplane-feature\"),\n        (\"explain-system\", \"explain-system\"),\n        (\"planted-tree\", \"planted-tree\"),\n        (\"planning-session\", \"planning-session\"),\n        (\"plans-document\", \"plans-document\"),\n        (\"-plan-feature\", \"feature\"),\n        (\"feature-plan-\", \"feature\"),\n        (\"my-feature-implementation-plan\", \"my-feature\"),\n        (\"implementation-plan-for-auth\", \"for-auth\"),\n        (\"implementation_plan_feature\", \"feature\"),\n        (\"feature implementation plan\", \"feature\"),\n        (\"my-feature_implementation-plan\", \"my-feature\"),\n        (\"implementation_plan-for-auth\", \"for-auth\"),\n        (\"IMPLEMENTATION-PLAN-FEATURE\", \"FEATURE\"),\n        (\"Implementation-Plan-Feature\", \"Feature\"),\n        (\"my-IMPLEMENTATION-plan\", \"my\"),\n        (\"my-implementation-plan-feature\", \"my-feature\"),\n        (\"plan-implementation-plan\", \"implementation\"),\n        (\"plan implementation plan\", \"implementation\"),\n        (\"implementation-plan\", \"implementation\"),\n        (\"implementation_plan\", \"implementation\"),\n        (\"IMPLEMENTATION-PLAN\", \"IMPLEMENTATION\"),\n        (\"reimplementation-feature\", \"reimplementation-feature\"),\n        (\"implantation-system\", \"implantation-system\"),\n    ],\n)\ndef test_strip_plan_from_filename(value: str, expected: str) -> None:\n    assert strip_plan_from_filename(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"name\", \"expected_base\", \"expected_number\"),\n    [\n        (\"my-feature\", \"my-feature\", None),\n        (\"my-feature-2\", \"my-feature\", 2),\n        (\"fix-42\", \"fix\", 42),\n        (\"feature-3-test\", \"feature-3-test\", None),  # Number in middle, not trailing\n        (\"test-123\", \"test\", 123),\n        (\"no-number\", \"no-number\", None),\n        (\"v2-feature-10\", \"v2-feature\", 10),\n    ],\n)\ndef test_extract_trailing_number(\n    name: str, expected_base: str, expected_number: int | None\n) -> None:\n    \"\"\"Test extracting trailing numbers from worktree names.\"\"\"\n    base, number = extract_trailing_number(name)\n    assert base == expected_base\n    assert number == expected_number\n\n\ndef test_ensure_unique_worktree_name_first_time(tmp_path: Path) -> None:\n    \"\"\"Test first-time worktree creation gets only datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    # Should have datetime suffix in format -YY-MM-DD-HHMM\n    date_suffix = _get_current_date_suffix()\n    assert result == f\"my-feature-{date_suffix}\"\n    assert not (repo_dir / result).exists()\n\n\ndef test_ensure_unique_worktree_name_duplicate_same_minute(tmp_path: Path) -> None:\n    \"\"\"Test duplicate worktree in same minute adds -2 after datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    existing_name = f\"my-feature-{date_suffix}\"\n    (repo_dir / existing_name).mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-2\"\n    assert not (repo_dir / result).exists()\n    assert (repo_dir / existing_name).exists()\n\n\ndef test_ensure_unique_worktree_name_multiple_duplicates(tmp_path: Path) -> None:\n    \"\"\"Test multiple duplicates increment correctly.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    (repo_dir / f\"my-feature-{date_suffix}\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-2\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-3\").mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-4\"\n\n\ndef test_ensure_unique_worktree_name_with_existing_number(tmp_path: Path) -> None:\n    \"\"\"Test name with existing number in base preserves it.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    date_suffix = _get_current_date_suffix()\n    result = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    # Base name has number, should preserve it in datetime-suffixed name\n    assert result == f\"fix-v3-{date_suffix}\"\n\n    # Create it and try again\n    (repo_dir / result).mkdir()\n    result2 = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    assert result2 == f\"fix-v3-{date_suffix}-2\"\n\n\ndef test_sanitize_branch_component_truncates_at_31_chars() -> None:\n    \"\"\"Branch names should truncate to 31 characters maximum.\"\"\"\n    # Exactly 31 characters\n    assert len(sanitize_branch_component(\"a\" * 31)) == 31\n\n    # 32 characters truncates to 31\n    assert len(sanitize_branch_component(\"a\" * 32)) == 31\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = sanitize_branch_component(long_name)\n    assert len(result) == 31\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\ndef test_sanitize_branch_component_matches_worktree_length() -> None:\n    \"\"\"Branch and worktree names should have same length for same input.\"\"\"\n    test_name = \"very-long-feature-name-that-exceeds-thirty-characters-easily\"\n    branch = sanitize_branch_component(test_name)\n    worktree = sanitize_worktree_name(test_name)\n    assert len(branch) == len(worktree)\n    assert len(branch) == 31\n\n\ndef test_very_long_title_truncates_to_45_chars_total() -> None:\n    \"\"\"Regression test: 99-char title should truncate to max 45 chars total with datetime suffix.\n\n    This tests the bug fix where `erk implement` created excessively long branch names.\n    Example: \"refactor erk implement command to support interactive and\n    non-interactive execution modes\"\n\n    Note: The 31-char limit includes rstrip(\"-\") after truncation,\n    so actual length may be <= 31.\n    \"\"\"\n    # 89-character title that caused the original bug\n    long_title = (\n        \"refactor erk implement command to support interactive and non-interactive execution modes\"\n    )\n\n    # Sanitize the worktree name (should be <= 31 chars max, trailing hyphens stripped)\n    base_name = sanitize_worktree_name(long_title)\n    assert len(base_name) <= 31\n\n    # With datetime suffix (-YY-MM-DD-HHMM = 14 chars including hyphen), total should be <= 45 chars\n    date_suffix = \"25-11-23-1430\"\n    name_with_date = f\"{base_name}-{date_suffix}\"\n    assert len(name_with_date) <= 45\n\n    # Verify the base name is correctly truncated (30 chars after rstrip of trailing hyphen)\n    assert base_name == \"refactor-erk-implement-command\"\n    assert len(base_name) == 30  # 31 chars truncated, then trailing hyphen stripped\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"expected\"),\n    [\n        (\"My Feature\", \"my-feature\"),\n        (\"Fix Bug #123!\", \"fix-bug-123\"),\n        (\"Simple\", \"simple\"),\n        (\"With_Underscores\", \"with-underscores\"),\n        (\"UPPERCASE\", \"uppercase\"),\n        (\"spaces  multiple   here\", \"spaces-multiple-here\"),\n        (\"leading---hyphens\", \"leading-hyphens\"),\n        (\"trailing---\", \"trailing\"),\n        (\"---both---\", \"both\"),\n        # Test 30-char truncation (different from sanitize_branch_component's 31)\n        (\"a\" * 40, \"a\" * 30),\n        (\"abcdefghijklmnopqrstuvwxyz-1234567890\", \"abcdefghijklmnopqrstuvwxyz-123\"),\n        # Trailing hyphen after truncation is removed\n        (\"this-is-thirty-chars-exact-yes\", \"this-is-thirty-chars-exact-yes\"),  # Exactly 30\n        (\"this-is-thirty-one-chars-exact\", \"this-is-thirty-one-chars-exact\"),  # 31 chars -> 30\n        # Test non-alphanumeric characters\n        (\"feat: add something\", \"feat-add-something\"),\n        (\"feat/add/something\", \"feat-add-something\"),\n        (\"feat(scope): message\", \"feat-scope-message\"),\n    ],\n)\ndef test_derive_branch_name_from_title(title: str, expected: str) -> None:\n    \"\"\"Test derive_branch_name_from_title matches workflow logic.\"\"\"\n    assert derive_branch_name_from_title(title) == expected\n\n\ndef test_derive_branch_name_truncates_to_30_chars() -> None:\n    \"\"\"Branch names from titles should truncate to 30 characters maximum.\n\n    This matches the workflow logic in plan-implement.yml which uses:\n    BRANCH_NAME=\"${BRANCH_NAME:0:30}\"\n    \"\"\"\n    # Exactly 30 characters\n    assert len(derive_branch_name_from_title(\"a\" * 30)) == 30\n\n    # 31 characters truncates to 30\n    assert len(derive_branch_name_from_title(\"a\" * 31)) == 30\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = derive_branch_name_from_title(long_name)\n    assert len(result) == 30\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\n# Tests for generate_issue_branch_name\n@pytest.mark.parametrize(\n    (\"issue_number\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # Standard case\n        (123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), \"P123-fix-auth-bug-01-15-1430\"),\n        # Integer issue number\n        (42, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-my-feature-06-20-1000\"),\n        # String issue number\n        (\"456\", \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P456-add-tests-12-31-2359\"),\n        # Midnight edge case\n        (789, \"Update Docs\", datetime(2024, 1, 1, 0, 0), \"P789-update-docs-01-01-0000\"),\n    ],\n)\ndef test_generate_issue_branch_name_format(\n    issue_number: int | str, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name follows P{num}-{slug}-{timestamp} format.\"\"\"\n    assert generate_issue_branch_name(issue_number, title, timestamp, objective_id=None) == expected\n\n\ndef test_generate_issue_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    # Very long title that would exceed 31 chars for base name\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=None)\n\n    # Base (P123-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"P123-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_issue_branch_name_preserves_hyphens_in_title() -> None:\n    \"\"\"Hyphens in titles are preserved (not doubled).\"\"\"\n    result = generate_issue_branch_name(\n        123, \"fix-auth-bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Should be P123-fix-auth-bug-..., not P123--fix-auth-bug-...\n    assert \"P123-fix-auth-bug-\" in result\n    assert \"--\" not in result\n\n\ndef test_generate_issue_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_issue_branch_name(\n        123, \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Special chars should be replaced with hyphens, then collapsed\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\n@pytest.mark.parametrize(\n    (\"issue_number\", \"objective_id\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # With objective ID\n        (\n            123,\n            456,\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            \"P123-O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Different objective ID\n        (42, 789, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-O789-my-feature-06-20-1000\"),\n        # Single digit objective\n        (100, 1, \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P100-O1-add-tests-12-31-2359\"),\n    ],\n)\ndef test_generate_issue_branch_name_with_objective(\n    issue_number: int, objective_id: int, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name includes objective ID when provided.\"\"\"\n    result = generate_issue_branch_name(issue_number, title, timestamp, objective_id=objective_id)\n    assert result == expected\n\n\ndef test_generate_issue_branch_name_with_objective_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=456)\n\n    # Base (P123-O456-...) should be truncated to 31 chars, then timestamp appended\n    assert len(result) <= 42\n    assert result.startswith(\"P123-O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # With objective ID\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 456),\n        (\"P42-O789-my-feature-06-20-1000\", 789),\n        (\"P100-O1-add-tests-12-31-2359\", 1),\n        # Lowercase o prefix (case insensitive)\n        (\"P123-o456-fix-bug\", 456),\n        (\"p123-o789-feature\", 789),\n        # Draft-PR branches with objective ID (current prefix)\n        (\"plnd/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"plnd/O1-add-tests-12-31-2359\", 1),\n        # Legacy planned/ prefix branches with objective ID\n        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"planned/O1-add-tests-12-31-2359\", 1),\n        # Legacy plan/ prefix branches with objective ID\n        (\"plan/O456-fix-auth-01-15-1430\", 456),\n        (\"plan/O7709-plan-lazy-tip-sync-f-02-21-1116\", 7709),\n        # Without objective ID\n        (\"P123-fix-auth-bug-01-15-1430\", None),\n        (\"P42-my-feature\", None),\n        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"plan/fix-auth-bug-01-15-1430\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_objective_number(branch_name: str, expected: int | None) -> None:\n    \"\"\"Extract objective ID from branch name.\"\"\"\n    assert extract_objective_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Standard format (still works with objective ID in branch)\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 123),\n        (\"P42-O789-my-feature\", 42),\n        # Without objective ID (existing behavior)\n        (\"P2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"P42-fix-bug\", 42),\n        # Legacy format without P prefix\n        (\"2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"42-fix-bug\", 42),\n        # Draft-PR branches return None (no extractable issue number)\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"planned/O456-fix-auth-01-15-1430\", None),\n        # Invalid formats\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_leading_issue_number_with_objective_format(\n    branch_name: str, expected: int | None\n) -> None:\n    \"\"\"Extract leading issue number still works with objective ID in branch name.\"\"\"\n    assert extract_leading_issue_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Valid plan review branches\n        (\"planned/review-6214-01-15-1430\", 6214),\n        (\"planned/review-42-01-28-0930\", 42),\n        (\"planned/review-1-12-31-2359\", 1),\n        (\"planned/review-99999-01-01-0000\", 99999),\n        # Not plan review branches\n        (\"P2382-convert-erk-create-raw-ext\", None),\n        (\"2382-convert-erk-create-raw-ext\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n        (\"planned/review\", None),  # Missing issue number\n        (\"planned/review-\", None),  # Missing issue number\n        (\"planned/review-abc-01-15-1430\", None),  # Non-numeric issue\n    ],\n)\ndef test_extract_plan_review_issue_number(branch_name: str, expected: int | None) -> None:\n    assert extract_plan_review_issue_number(branch_name) == expected\n\n\n# Tests for generate_draft_pr_branch_name\n@pytest.mark.parametrize(\n    (\"title\", \"timestamp\", \"objective_id\", \"expected\"),\n    [\n        # Standard case without objective\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            None,\n            \"planned/fix-auth-bug-01-15-1430\",\n        ),\n        # Different timestamp\n        (\n            \"My Feature\",\n            datetime(2024, 6, 20, 10, 0),\n            None,\n            \"planned/my-feature-06-20-1000\",\n        ),\n        # Midnight edge case\n        (\n            \"Update Docs\",\n            datetime(2024, 1, 1, 0, 0),\n            None,\n            \"planned/update-docs-01-01-0000\",\n        ),\n        # With objective ID\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            456,\n            \"planned/O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Single digit objective\n        (\n            \"Add Tests\",\n            datetime(2024, 12, 31, 23, 59),\n            1,\n            \"planned/O1-add-tests-12-31-2359\",\n        ),\n    ],\n)\ndef test_generate_draft_pr_branch_name_format(\n    title: str, timestamp: datetime, objective_id: int | None, expected: str\n) -> None:\n    \"\"\"Branch name follows planned/{slug}-{timestamp} format.\"\"\"\n    assert generate_draft_pr_branch_name(title, timestamp, objective_id=objective_id) == expected\n\n\ndef test_generate_draft_pr_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=None)\n\n    # Base (plan-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"planned/\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_draft_pr_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_draft_pr_branch_name(\n        \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\ndef test_generate_draft_pr_branch_name_with_objective_truncates() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=456)\n\n    assert len(result) <= 42\n    assert result.startswith(\"planned/O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    assert not result[:-11].endswith(\"-\")\n\n\n# Tests for validate_objective_slug\n@pytest.mark.parametrize(\n    \"slug\",\n    [\n        \"build-auth-system\",\n        \"refactor-gateway\",\n        \"add-dark-mode\",\n        \"simple\",\n        \"abc\",\n        \"a\" * 40,\n        \"fix-tui-layout\",\n        \"add-v2-support\",\n        \"feature123\",\n    ],\n)\ndef test_validate_objective_slug_valid(slug: str) -> None:\n    \"\"\"Valid slugs return ValidObjectiveSlug.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, ValidObjectiveSlug)\n    assert result.slug == slug\n\n\n@pytest.mark.parametrize(\n    (\"slug\", \"reason_fragment\"),\n    [\n        (\"ab\", \"Too short\"),\n        (\"a\" * 41, \"Too long\"),\n        (\"Build-Auth\", \"Does not match\"),\n        (\"UPPERCASE\", \"Does not match\"),\n        (\"123-start\", \"Does not match\"),\n        (\"my--slug\", \"Does not match\"),\n        (\"has spaces\", \"Does not match\"),\n        (\"with_underscores\", \"Does not match\"),\n        (\"has.dots\", \"Does not match\"),\n        (\"-leading-hyphen\", \"Does not match\"),\n        (\"trailing-hyphen-\", \"Does not match\"),\n    ],\n)\ndef test_validate_objective_slug_invalid(slug: str, reason_fragment: str) -> None:\n    \"\"\"Invalid slugs return InvalidObjectiveSlug with matching reason.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_objective_slug_error_message_includes_pattern() -> None:\n    \"\"\"Error message includes the regex pattern for agent self-correction.\"\"\"\n    result = validate_objective_slug(\"INVALID\")\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert \"^[a-z][a-z0-9]*(-[a-z0-9]+)*$\" in result.message\n    assert \"INVALID\" in result.message\n\n\n# Tests for validate_plan_title\n@pytest.mark.parametrize(\n    \"title\",\n    [\n        \"Add User Authentication\",\n        \"Refactor Gateway Layer\",\n        \"Fix CLI Argument Parsing\",\n        \"hello\",\n        \"a\" * 100,\n        \"Fix Bug #123 in Auth Module\",\n        \"café au lait feature\",\n        \"Update the README file\",\n        \"Add v2 API support for external clients\",\n    ],\n)\ndef test_validate_plan_title_valid(title: str) -> None:\n    \"\"\"Valid titles return ValidPlanTitle.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == title.strip()\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"reason_fragment\"),\n    [\n        (\"\", \"empty\"),\n        (\"   \", \"empty\"),\n        (\"\\t\\n\", \"empty\"),\n        (\"Plan\", \"Too short\"),\n        (\"ab\", \"Too short\"),\n        (\"a\" * 101, \"Too long\"),\n        (\"12345\", \"at least one alphabetic\"),\n        (\"12345 67890\", \"at least one alphabetic\"),\n        (\"!@#$%^&*()\", \"at least one alphabetic\"),\n        (\"\\U0001f680\\U0001f389\\U0001f525\\U0001f4a5\\U0001f31f\", \"at least one alphabetic\"),\n        (\"\\u4f60\\u597d\\u4e16\\u754c\\u7684\\u8ba1\\u5212\", \"No usable content\"),\n    ],\n)\ndef test_validate_plan_title_invalid(title: str, reason_fragment: str) -> None:\n    \"\"\"Invalid titles return InvalidPlanTitle with matching reason.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, InvalidPlanTitle)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_plan_title_error_message_includes_rules() -> None:\n    \"\"\"Error message includes rules for agent self-correction.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert \"5-100 characters\" in result.message\n    assert \"at least one alphabetic\" in result.message\n    assert \"Valid examples\" in result.message\n    assert \"Invalid examples\" in result.message\n\n\ndef test_validate_plan_title_error_type() -> None:\n    \"\"\"Error type is machine-readable.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.error_type == \"invalid-plan-title\"\n\n\ndef test_validate_plan_title_strips_whitespace() -> None:\n    \"\"\"Leading/trailing whitespace is stripped before validation.\"\"\"\n    result = validate_plan_title(\"  Add Feature  \")\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == \"Add Feature\"\n\n\ndef test_validate_plan_title_preserves_original_in_error() -> None:\n    \"\"\"Error includes the original unmodified title.\"\"\"\n    result = validate_plan_title(\"   ab   \")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.raw_title == \"   ab   \"\n","structuredPatch":[{"oldStart":515,"oldLines":6,"newStart":515,"newLines":8,"lines":["         (\"2382-convert-erk-create-raw-ext-12-05-2359\", 2382),","         (\"42-fix-bug\", 42),","         # Draft-PR branches return None (no extractable issue number)","+        (\"plnd/fix-auth-bug-01-15-1430\", None),","+        (\"plnd/O456-fix-auth-01-15-1430\", None),","         (\"planned/fix-auth-bug-01-15-1430\", None),","         (\"planned/O456-fix-auth-01-15-1430\", None),","         # Invalid formats"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"6e974328-b8c9-4d20-b478-2f4818e607f9","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Paf9Sufr4jBshn6f5T41T6","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `test_extract_plan_review_issue_number` - add `plnd/` test cases and keep `planned/` as legacy:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":672,"cache_read_input_tokens":86858,"cache_creation":{"ephemeral_5m_input_tokens":672,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHjB5B3RyHiM6y4KTUE","type":"assistant","uuid":"86a8b95b-a7c4-4ece-8ea8-208b83c4a625","timestamp":"2026-02-22T14:46:40.665Z"}
{"parentUuid":"86a8b95b-a7c4-4ece-8ea8-208b83c4a625","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Paf9Sufr4jBshn6f5T41T6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TgYBjdxggw9dQVcAupDwpx","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","old_string":"        # Valid plan review branches\n        (\"planned/review-6214-01-15-1430\", 6214),\n        (\"planned/review-42-01-28-0930\", 42),\n        (\"planned/review-1-12-31-2359\", 1),\n        (\"planned/review-99999-01-01-0000\", 99999),\n        # Not plan review branches\n        (\"P2382-convert-erk-create-raw-ext\", None),\n        (\"2382-convert-erk-create-raw-ext\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n        (\"planned/review\", None),  # Missing issue number\n        (\"planned/review-\", None),  # Missing issue number\n        (\"planned/review-abc-01-15-1430\", None),  # Non-numeric issue","new_string":"        # Valid plan review branches (current prefix)\n        (\"plnd/review-6214-01-15-1430\", 6214),\n        (\"plnd/review-42-01-28-0930\", 42),\n        (\"plnd/review-1-12-31-2359\", 1),\n        (\"plnd/review-99999-01-01-0000\", 99999),\n        # Legacy planned/ prefix still works\n        (\"planned/review-6214-01-15-1430\", 6214),\n        (\"planned/review-42-01-28-0930\", 42),\n        (\"planned/review-1-12-31-2359\", 1),\n        (\"planned/review-99999-01-01-0000\", 99999),\n        # Not plan review branches\n        (\"P2382-convert-erk-create-raw-ext\", None),\n        (\"2382-convert-erk-create-raw-ext\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n        (\"plnd/review\", None),  # Missing issue number\n        (\"plnd/review-\", None),  # Missing issue number\n        (\"plnd/review-abc-01-15-1430\", None),  # Non-numeric issue"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":672,"cache_read_input_tokens":86858,"cache_creation":{"ephemeral_5m_input_tokens":672,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHjB5B3RyHiM6y4KTUE","type":"assistant","uuid":"8f0b7f54-7ced-4b06-873c-9bdab8f848ad","timestamp":"2026-02-22T14:46:45.542Z"}
{"parentUuid":"8f0b7f54-7ced-4b06-873c-9bdab8f848ad","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TgYBjdxggw9dQVcAupDwpx","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/core/utils/test_naming.py has been updated successfully."}]},"uuid":"df4381d9-a47d-4a17-8e2c-657d707054c9","timestamp":"2026-02-22T14:46:46.236Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","oldString":"        # Valid plan review branches\n        (\"planned/review-6214-01-15-1430\", 6214),\n        (\"planned/review-42-01-28-0930\", 42),\n        (\"planned/review-1-12-31-2359\", 1),\n        (\"planned/review-99999-01-01-0000\", 99999),\n        # Not plan review branches\n        (\"P2382-convert-erk-create-raw-ext\", None),\n        (\"2382-convert-erk-create-raw-ext\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n        (\"planned/review\", None),  # Missing issue number\n        (\"planned/review-\", None),  # Missing issue number\n        (\"planned/review-abc-01-15-1430\", None),  # Non-numeric issue","newString":"        # Valid plan review branches (current prefix)\n        (\"plnd/review-6214-01-15-1430\", 6214),\n        (\"plnd/review-42-01-28-0930\", 42),\n        (\"plnd/review-1-12-31-2359\", 1),\n        (\"plnd/review-99999-01-01-0000\", 99999),\n        # Legacy planned/ prefix still works\n        (\"planned/review-6214-01-15-1430\", 6214),\n        (\"planned/review-42-01-28-0930\", 42),\n        (\"planned/review-1-12-31-2359\", 1),\n        (\"planned/review-99999-01-01-0000\", 99999),\n        # Not plan review branches\n        (\"P2382-convert-erk-create-raw-ext\", None),\n        (\"2382-convert-erk-create-raw-ext\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n        (\"plnd/review\", None),  # Missing issue number\n        (\"plnd/review-\", None),  # Missing issue number\n        (\"plnd/review-abc-01-15-1430\", None),  # Non-numeric issue","originalFile":"from datetime import datetime\nfrom pathlib import Path\n\nimport pytest\n\nfrom erk_shared.naming import (\n    WORKTREE_DATE_SUFFIX_FORMAT,\n    InvalidObjectiveSlug,\n    InvalidPlanTitle,\n    ValidObjectiveSlug,\n    ValidPlanTitle,\n    default_branch_for_worktree,\n    derive_branch_name_from_title,\n    ensure_unique_worktree_name,\n    extract_leading_issue_number,\n    extract_objective_number,\n    extract_plan_review_issue_number,\n    extract_trailing_number,\n    generate_draft_pr_branch_name,\n    generate_issue_branch_name,\n    sanitize_branch_component,\n    sanitize_worktree_name,\n    strip_plan_from_filename,\n    validate_objective_slug,\n    validate_plan_title,\n)\n\n\ndef _get_current_date_suffix() -> str:\n    \"\"\"Get the current date suffix for plan-derived worktrees.\"\"\"\n    return datetime.now().strftime(WORKTREE_DATE_SUFFIX_FORMAT)\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\" Foo Bar \", \"foo-bar\"),\n        (\"A/B C\", \"a/b-c\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-branch-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-branch-name\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        (\"short\", \"short\"),\n        # Test long names with trailing hyphens are stripped\n        (\n            \"branch-name-with-dash-at-position-31-\",\n            \"branch-name-with-dash-at-positi\",\n        ),\n        # Test very long names truncate to 31\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".hidden-file\", \"hidden-file\"),\n        (\"file.extension\", \"file-extension\"),\n    ],\n)\ndef test_sanitize_branch_component(value: str, expected: str) -> None:\n    assert sanitize_branch_component(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"feature X\", \"feature-x\"),\n        (\"/ / \", \"work\"),\n    ],\n)\ndef test_default_branch_for_worktree(value: str, expected: str) -> None:\n    assert default_branch_for_worktree(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\"Add_Auth_Feature\", \"add-auth-feature\"),\n        (\"My_Cool_Plan\", \"my-cool-plan\"),\n        (\"FOO_BAR_BAZ\", \"foo-bar-baz\"),\n        (\"feature__with___multiple___underscores\", \"feature-with-multiple-underscor\"),\n        (\"name-with-hyphens\", \"name-with-hyphens\"),\n        (\"Mixed_Case-Hyphen_Underscore\", \"mixed-case-hyphen-underscore\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        (\"   spaces   \", \"spaces\"),\n        (\"---\", \"work\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-worktree-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-worktree-na\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        # Test truncation with trailing hyphen removal\n        (\n            \"worktree-name-with-dash-at-position-31-\",\n            \"worktree-name-with-dash-at-posi\",\n        ),\n        # Test truncation that ends with hyphen is stripped\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".worker-impl\", \"worker-impl\"),\n        (\"fix-.worker\", \"fix-worker\"),\n        (\"name.with.dots\", \"name-with-dots\"),\n    ],\n)\ndef test_sanitize_worktree_name(value: str, expected: str) -> None:\n    assert sanitize_worktree_name(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"devclikit-extraction-plan\", \"devclikit-extraction\"),\n        (\"my-feature-plan\", \"my-feature\"),\n        (\"plan-for-auth\", \"for-auth\"),\n        (\"plan-something\", \"something\"),\n        (\"something-plan\", \"something\"),\n        (\"something-plan-else\", \"something-else\"),\n        (\"plan-my-plan-feature\", \"my-feature\"),\n        (\"my-plan-feature-plan\", \"my-feature\"),\n        (\"plan\", \"plan\"),\n        (\"my_feature_plan\", \"my_feature\"),\n        (\"my feature plan\", \"my feature\"),\n        (\"my-feature_plan\", \"my-feature\"),\n        (\"MY-FEATURE-PLAN\", \"MY-FEATURE\"),\n        (\"My-Feature-Plan\", \"My-Feature\"),\n        (\"my-feature-PLAN\", \"my-feature\"),\n        (\"airplane-feature\", \"airplane-feature\"),\n        (\"explain-system\", \"explain-system\"),\n        (\"planted-tree\", \"planted-tree\"),\n        (\"planning-session\", \"planning-session\"),\n        (\"plans-document\", \"plans-document\"),\n        (\"-plan-feature\", \"feature\"),\n        (\"feature-plan-\", \"feature\"),\n        (\"my-feature-implementation-plan\", \"my-feature\"),\n        (\"implementation-plan-for-auth\", \"for-auth\"),\n        (\"implementation_plan_feature\", \"feature\"),\n        (\"feature implementation plan\", \"feature\"),\n        (\"my-feature_implementation-plan\", \"my-feature\"),\n        (\"implementation_plan-for-auth\", \"for-auth\"),\n        (\"IMPLEMENTATION-PLAN-FEATURE\", \"FEATURE\"),\n        (\"Implementation-Plan-Feature\", \"Feature\"),\n        (\"my-IMPLEMENTATION-plan\", \"my\"),\n        (\"my-implementation-plan-feature\", \"my-feature\"),\n        (\"plan-implementation-plan\", \"implementation\"),\n        (\"plan implementation plan\", \"implementation\"),\n        (\"implementation-plan\", \"implementation\"),\n        (\"implementation_plan\", \"implementation\"),\n        (\"IMPLEMENTATION-PLAN\", \"IMPLEMENTATION\"),\n        (\"reimplementation-feature\", \"reimplementation-feature\"),\n        (\"implantation-system\", \"implantation-system\"),\n    ],\n)\ndef test_strip_plan_from_filename(value: str, expected: str) -> None:\n    assert strip_plan_from_filename(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"name\", \"expected_base\", \"expected_number\"),\n    [\n        (\"my-feature\", \"my-feature\", None),\n        (\"my-feature-2\", \"my-feature\", 2),\n        (\"fix-42\", \"fix\", 42),\n        (\"feature-3-test\", \"feature-3-test\", None),  # Number in middle, not trailing\n        (\"test-123\", \"test\", 123),\n        (\"no-number\", \"no-number\", None),\n        (\"v2-feature-10\", \"v2-feature\", 10),\n    ],\n)\ndef test_extract_trailing_number(\n    name: str, expected_base: str, expected_number: int | None\n) -> None:\n    \"\"\"Test extracting trailing numbers from worktree names.\"\"\"\n    base, number = extract_trailing_number(name)\n    assert base == expected_base\n    assert number == expected_number\n\n\ndef test_ensure_unique_worktree_name_first_time(tmp_path: Path) -> None:\n    \"\"\"Test first-time worktree creation gets only datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    # Should have datetime suffix in format -YY-MM-DD-HHMM\n    date_suffix = _get_current_date_suffix()\n    assert result == f\"my-feature-{date_suffix}\"\n    assert not (repo_dir / result).exists()\n\n\ndef test_ensure_unique_worktree_name_duplicate_same_minute(tmp_path: Path) -> None:\n    \"\"\"Test duplicate worktree in same minute adds -2 after datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    existing_name = f\"my-feature-{date_suffix}\"\n    (repo_dir / existing_name).mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-2\"\n    assert not (repo_dir / result).exists()\n    assert (repo_dir / existing_name).exists()\n\n\ndef test_ensure_unique_worktree_name_multiple_duplicates(tmp_path: Path) -> None:\n    \"\"\"Test multiple duplicates increment correctly.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    (repo_dir / f\"my-feature-{date_suffix}\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-2\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-3\").mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-4\"\n\n\ndef test_ensure_unique_worktree_name_with_existing_number(tmp_path: Path) -> None:\n    \"\"\"Test name with existing number in base preserves it.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    date_suffix = _get_current_date_suffix()\n    result = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    # Base name has number, should preserve it in datetime-suffixed name\n    assert result == f\"fix-v3-{date_suffix}\"\n\n    # Create it and try again\n    (repo_dir / result).mkdir()\n    result2 = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    assert result2 == f\"fix-v3-{date_suffix}-2\"\n\n\ndef test_sanitize_branch_component_truncates_at_31_chars() -> None:\n    \"\"\"Branch names should truncate to 31 characters maximum.\"\"\"\n    # Exactly 31 characters\n    assert len(sanitize_branch_component(\"a\" * 31)) == 31\n\n    # 32 characters truncates to 31\n    assert len(sanitize_branch_component(\"a\" * 32)) == 31\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = sanitize_branch_component(long_name)\n    assert len(result) == 31\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\ndef test_sanitize_branch_component_matches_worktree_length() -> None:\n    \"\"\"Branch and worktree names should have same length for same input.\"\"\"\n    test_name = \"very-long-feature-name-that-exceeds-thirty-characters-easily\"\n    branch = sanitize_branch_component(test_name)\n    worktree = sanitize_worktree_name(test_name)\n    assert len(branch) == len(worktree)\n    assert len(branch) == 31\n\n\ndef test_very_long_title_truncates_to_45_chars_total() -> None:\n    \"\"\"Regression test: 99-char title should truncate to max 45 chars total with datetime suffix.\n\n    This tests the bug fix where `erk implement` created excessively long branch names.\n    Example: \"refactor erk implement command to support interactive and\n    non-interactive execution modes\"\n\n    Note: The 31-char limit includes rstrip(\"-\") after truncation,\n    so actual length may be <= 31.\n    \"\"\"\n    # 89-character title that caused the original bug\n    long_title = (\n        \"refactor erk implement command to support interactive and non-interactive execution modes\"\n    )\n\n    # Sanitize the worktree name (should be <= 31 chars max, trailing hyphens stripped)\n    base_name = sanitize_worktree_name(long_title)\n    assert len(base_name) <= 31\n\n    # With datetime suffix (-YY-MM-DD-HHMM = 14 chars including hyphen), total should be <= 45 chars\n    date_suffix = \"25-11-23-1430\"\n    name_with_date = f\"{base_name}-{date_suffix}\"\n    assert len(name_with_date) <= 45\n\n    # Verify the base name is correctly truncated (30 chars after rstrip of trailing hyphen)\n    assert base_name == \"refactor-erk-implement-command\"\n    assert len(base_name) == 30  # 31 chars truncated, then trailing hyphen stripped\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"expected\"),\n    [\n        (\"My Feature\", \"my-feature\"),\n        (\"Fix Bug #123!\", \"fix-bug-123\"),\n        (\"Simple\", \"simple\"),\n        (\"With_Underscores\", \"with-underscores\"),\n        (\"UPPERCASE\", \"uppercase\"),\n        (\"spaces  multiple   here\", \"spaces-multiple-here\"),\n        (\"leading---hyphens\", \"leading-hyphens\"),\n        (\"trailing---\", \"trailing\"),\n        (\"---both---\", \"both\"),\n        # Test 30-char truncation (different from sanitize_branch_component's 31)\n        (\"a\" * 40, \"a\" * 30),\n        (\"abcdefghijklmnopqrstuvwxyz-1234567890\", \"abcdefghijklmnopqrstuvwxyz-123\"),\n        # Trailing hyphen after truncation is removed\n        (\"this-is-thirty-chars-exact-yes\", \"this-is-thirty-chars-exact-yes\"),  # Exactly 30\n        (\"this-is-thirty-one-chars-exact\", \"this-is-thirty-one-chars-exact\"),  # 31 chars -> 30\n        # Test non-alphanumeric characters\n        (\"feat: add something\", \"feat-add-something\"),\n        (\"feat/add/something\", \"feat-add-something\"),\n        (\"feat(scope): message\", \"feat-scope-message\"),\n    ],\n)\ndef test_derive_branch_name_from_title(title: str, expected: str) -> None:\n    \"\"\"Test derive_branch_name_from_title matches workflow logic.\"\"\"\n    assert derive_branch_name_from_title(title) == expected\n\n\ndef test_derive_branch_name_truncates_to_30_chars() -> None:\n    \"\"\"Branch names from titles should truncate to 30 characters maximum.\n\n    This matches the workflow logic in plan-implement.yml which uses:\n    BRANCH_NAME=\"${BRANCH_NAME:0:30}\"\n    \"\"\"\n    # Exactly 30 characters\n    assert len(derive_branch_name_from_title(\"a\" * 30)) == 30\n\n    # 31 characters truncates to 30\n    assert len(derive_branch_name_from_title(\"a\" * 31)) == 30\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = derive_branch_name_from_title(long_name)\n    assert len(result) == 30\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\n# Tests for generate_issue_branch_name\n@pytest.mark.parametrize(\n    (\"issue_number\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # Standard case\n        (123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), \"P123-fix-auth-bug-01-15-1430\"),\n        # Integer issue number\n        (42, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-my-feature-06-20-1000\"),\n        # String issue number\n        (\"456\", \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P456-add-tests-12-31-2359\"),\n        # Midnight edge case\n        (789, \"Update Docs\", datetime(2024, 1, 1, 0, 0), \"P789-update-docs-01-01-0000\"),\n    ],\n)\ndef test_generate_issue_branch_name_format(\n    issue_number: int | str, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name follows P{num}-{slug}-{timestamp} format.\"\"\"\n    assert generate_issue_branch_name(issue_number, title, timestamp, objective_id=None) == expected\n\n\ndef test_generate_issue_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    # Very long title that would exceed 31 chars for base name\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=None)\n\n    # Base (P123-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"P123-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_issue_branch_name_preserves_hyphens_in_title() -> None:\n    \"\"\"Hyphens in titles are preserved (not doubled).\"\"\"\n    result = generate_issue_branch_name(\n        123, \"fix-auth-bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Should be P123-fix-auth-bug-..., not P123--fix-auth-bug-...\n    assert \"P123-fix-auth-bug-\" in result\n    assert \"--\" not in result\n\n\ndef test_generate_issue_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_issue_branch_name(\n        123, \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Special chars should be replaced with hyphens, then collapsed\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\n@pytest.mark.parametrize(\n    (\"issue_number\", \"objective_id\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # With objective ID\n        (\n            123,\n            456,\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            \"P123-O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Different objective ID\n        (42, 789, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-O789-my-feature-06-20-1000\"),\n        # Single digit objective\n        (100, 1, \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P100-O1-add-tests-12-31-2359\"),\n    ],\n)\ndef test_generate_issue_branch_name_with_objective(\n    issue_number: int, objective_id: int, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name includes objective ID when provided.\"\"\"\n    result = generate_issue_branch_name(issue_number, title, timestamp, objective_id=objective_id)\n    assert result == expected\n\n\ndef test_generate_issue_branch_name_with_objective_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=456)\n\n    # Base (P123-O456-...) should be truncated to 31 chars, then timestamp appended\n    assert len(result) <= 42\n    assert result.startswith(\"P123-O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # With objective ID\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 456),\n        (\"P42-O789-my-feature-06-20-1000\", 789),\n        (\"P100-O1-add-tests-12-31-2359\", 1),\n        # Lowercase o prefix (case insensitive)\n        (\"P123-o456-fix-bug\", 456),\n        (\"p123-o789-feature\", 789),\n        # Draft-PR branches with objective ID (current prefix)\n        (\"plnd/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"plnd/O1-add-tests-12-31-2359\", 1),\n        # Legacy planned/ prefix branches with objective ID\n        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"planned/O1-add-tests-12-31-2359\", 1),\n        # Legacy plan/ prefix branches with objective ID\n        (\"plan/O456-fix-auth-01-15-1430\", 456),\n        (\"plan/O7709-plan-lazy-tip-sync-f-02-21-1116\", 7709),\n        # Without objective ID\n        (\"P123-fix-auth-bug-01-15-1430\", None),\n        (\"P42-my-feature\", None),\n        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"plan/fix-auth-bug-01-15-1430\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_objective_number(branch_name: str, expected: int | None) -> None:\n    \"\"\"Extract objective ID from branch name.\"\"\"\n    assert extract_objective_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Standard format (still works with objective ID in branch)\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 123),\n        (\"P42-O789-my-feature\", 42),\n        # Without objective ID (existing behavior)\n        (\"P2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"P42-fix-bug\", 42),\n        # Legacy format without P prefix\n        (\"2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"42-fix-bug\", 42),\n        # Draft-PR branches return None (no extractable issue number)\n        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"plnd/O456-fix-auth-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"planned/O456-fix-auth-01-15-1430\", None),\n        # Invalid formats\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_leading_issue_number_with_objective_format(\n    branch_name: str, expected: int | None\n) -> None:\n    \"\"\"Extract leading issue number still works with objective ID in branch name.\"\"\"\n    assert extract_leading_issue_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Valid plan review branches\n        (\"planned/review-6214-01-15-1430\", 6214),\n        (\"planned/review-42-01-28-0930\", 42),\n        (\"planned/review-1-12-31-2359\", 1),\n        (\"planned/review-99999-01-01-0000\", 99999),\n        # Not plan review branches\n        (\"P2382-convert-erk-create-raw-ext\", None),\n        (\"2382-convert-erk-create-raw-ext\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n        (\"planned/review\", None),  # Missing issue number\n        (\"planned/review-\", None),  # Missing issue number\n        (\"planned/review-abc-01-15-1430\", None),  # Non-numeric issue\n    ],\n)\ndef test_extract_plan_review_issue_number(branch_name: str, expected: int | None) -> None:\n    assert extract_plan_review_issue_number(branch_name) == expected\n\n\n# Tests for generate_draft_pr_branch_name\n@pytest.mark.parametrize(\n    (\"title\", \"timestamp\", \"objective_id\", \"expected\"),\n    [\n        # Standard case without objective\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            None,\n            \"planned/fix-auth-bug-01-15-1430\",\n        ),\n        # Different timestamp\n        (\n            \"My Feature\",\n            datetime(2024, 6, 20, 10, 0),\n            None,\n            \"planned/my-feature-06-20-1000\",\n        ),\n        # Midnight edge case\n        (\n            \"Update Docs\",\n            datetime(2024, 1, 1, 0, 0),\n            None,\n            \"planned/update-docs-01-01-0000\",\n        ),\n        # With objective ID\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            456,\n            \"planned/O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Single digit objective\n        (\n            \"Add Tests\",\n            datetime(2024, 12, 31, 23, 59),\n            1,\n            \"planned/O1-add-tests-12-31-2359\",\n        ),\n    ],\n)\ndef test_generate_draft_pr_branch_name_format(\n    title: str, timestamp: datetime, objective_id: int | None, expected: str\n) -> None:\n    \"\"\"Branch name follows planned/{slug}-{timestamp} format.\"\"\"\n    assert generate_draft_pr_branch_name(title, timestamp, objective_id=objective_id) == expected\n\n\ndef test_generate_draft_pr_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=None)\n\n    # Base (plan-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"planned/\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_draft_pr_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_draft_pr_branch_name(\n        \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\ndef test_generate_draft_pr_branch_name_with_objective_truncates() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=456)\n\n    assert len(result) <= 42\n    assert result.startswith(\"planned/O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    assert not result[:-11].endswith(\"-\")\n\n\n# Tests for validate_objective_slug\n@pytest.mark.parametrize(\n    \"slug\",\n    [\n        \"build-auth-system\",\n        \"refactor-gateway\",\n        \"add-dark-mode\",\n        \"simple\",\n        \"abc\",\n        \"a\" * 40,\n        \"fix-tui-layout\",\n        \"add-v2-support\",\n        \"feature123\",\n    ],\n)\ndef test_validate_objective_slug_valid(slug: str) -> None:\n    \"\"\"Valid slugs return ValidObjectiveSlug.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, ValidObjectiveSlug)\n    assert result.slug == slug\n\n\n@pytest.mark.parametrize(\n    (\"slug\", \"reason_fragment\"),\n    [\n        (\"ab\", \"Too short\"),\n        (\"a\" * 41, \"Too long\"),\n        (\"Build-Auth\", \"Does not match\"),\n        (\"UPPERCASE\", \"Does not match\"),\n        (\"123-start\", \"Does not match\"),\n        (\"my--slug\", \"Does not match\"),\n        (\"has spaces\", \"Does not match\"),\n        (\"with_underscores\", \"Does not match\"),\n        (\"has.dots\", \"Does not match\"),\n        (\"-leading-hyphen\", \"Does not match\"),\n        (\"trailing-hyphen-\", \"Does not match\"),\n    ],\n)\ndef test_validate_objective_slug_invalid(slug: str, reason_fragment: str) -> None:\n    \"\"\"Invalid slugs return InvalidObjectiveSlug with matching reason.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_objective_slug_error_message_includes_pattern() -> None:\n    \"\"\"Error message includes the regex pattern for agent self-correction.\"\"\"\n    result = validate_objective_slug(\"INVALID\")\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert \"^[a-z][a-z0-9]*(-[a-z0-9]+)*$\" in result.message\n    assert \"INVALID\" in result.message\n\n\n# Tests for validate_plan_title\n@pytest.mark.parametrize(\n    \"title\",\n    [\n        \"Add User Authentication\",\n        \"Refactor Gateway Layer\",\n        \"Fix CLI Argument Parsing\",\n        \"hello\",\n        \"a\" * 100,\n        \"Fix Bug #123 in Auth Module\",\n        \"café au lait feature\",\n        \"Update the README file\",\n        \"Add v2 API support for external clients\",\n    ],\n)\ndef test_validate_plan_title_valid(title: str) -> None:\n    \"\"\"Valid titles return ValidPlanTitle.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == title.strip()\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"reason_fragment\"),\n    [\n        (\"\", \"empty\"),\n        (\"   \", \"empty\"),\n        (\"\\t\\n\", \"empty\"),\n        (\"Plan\", \"Too short\"),\n        (\"ab\", \"Too short\"),\n        (\"a\" * 101, \"Too long\"),\n        (\"12345\", \"at least one alphabetic\"),\n        (\"12345 67890\", \"at least one alphabetic\"),\n        (\"!@#$%^&*()\", \"at least one alphabetic\"),\n        (\"\\U0001f680\\U0001f389\\U0001f525\\U0001f4a5\\U0001f31f\", \"at least one alphabetic\"),\n        (\"\\u4f60\\u597d\\u4e16\\u754c\\u7684\\u8ba1\\u5212\", \"No usable content\"),\n    ],\n)\ndef test_validate_plan_title_invalid(title: str, reason_fragment: str) -> None:\n    \"\"\"Invalid titles return InvalidPlanTitle with matching reason.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, InvalidPlanTitle)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_plan_title_error_message_includes_rules() -> None:\n    \"\"\"Error message includes rules for agent self-correction.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert \"5-100 characters\" in result.message\n    assert \"at least one alphabetic\" in result.message\n    assert \"Valid examples\" in result.message\n    assert \"Invalid examples\" in result.message\n\n\ndef test_validate_plan_title_error_type() -> None:\n    \"\"\"Error type is machine-readable.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.error_type == \"invalid-plan-title\"\n\n\ndef test_validate_plan_title_strips_whitespace() -> None:\n    \"\"\"Leading/trailing whitespace is stripped before validation.\"\"\"\n    result = validate_plan_title(\"  Add Feature  \")\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == \"Add Feature\"\n\n\ndef test_validate_plan_title_preserves_original_in_error() -> None:\n    \"\"\"Error includes the original unmodified title.\"\"\"\n    result = validate_plan_title(\"   ab   \")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.raw_title == \"   ab   \"\n","structuredPatch":[{"oldStart":534,"oldLines":7,"newStart":534,"newLines":12,"lines":[" @pytest.mark.parametrize(","     (\"branch_name\", \"expected\"),","     [","-        # Valid plan review branches","+        # Valid plan review branches (current prefix)","+        (\"plnd/review-6214-01-15-1430\", 6214),","+        (\"plnd/review-42-01-28-0930\", 42),","+        (\"plnd/review-1-12-31-2359\", 1),","+        (\"plnd/review-99999-01-01-0000\", 99999),","+        # Legacy planned/ prefix still works","         (\"planned/review-6214-01-15-1430\", 6214),","         (\"planned/review-42-01-28-0930\", 42),","         (\"planned/review-1-12-31-2359\", 1),"]},{"oldStart":544,"oldLines":9,"newStart":549,"newLines":9,"lines":["         (\"2382-convert-erk-create-raw-ext\", None),","         (\"feature-branch\", None),","         (\"master\", None),","-        (\"planned/review\", None),  # Missing issue number","-        (\"planned/review-\", None),  # Missing issue number","-        (\"planned/review-abc-01-15-1430\", None),  # Non-numeric issue","+        (\"plnd/review\", None),  # Missing issue number","+        (\"plnd/review-\", None),  # Missing issue number","+        (\"plnd/review-abc-01-15-1430\", None),  # Non-numeric issue","     ],"," )"," def test_extract_plan_review_issue_number(branch_name: str, expected: int | None) -> None:"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"df4381d9-a47d-4a17-8e2c-657d707054c9","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_011CBrj6yyJvh8FVkofLSCHU","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `test_generate_draft_pr_branch_name_format` - these should all use `plnd/`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":690,"cache_read_input_tokens":87530,"cache_creation":{"ephemeral_5m_input_tokens":690,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHjq5vaJkoXZxCqZM33","type":"assistant","uuid":"fbad20bd-6234-464f-b485-90ecb3d2d927","timestamp":"2026-02-22T14:46:49.026Z"}
{"parentUuid":"fbad20bd-6234-464f-b485-90ecb3d2d927","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_011CBrj6yyJvh8FVkofLSCHU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018iBNCXUtF4gWE7vNZwTksC","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","old_string":"            \"planned/fix-auth-bug-01-15-1430\",\n        ),\n        # Different timestamp\n        (\n            \"My Feature\",\n            datetime(2024, 6, 20, 10, 0),\n            None,\n            \"planned/my-feature-06-20-1000\",\n        ),\n        # Midnight edge case\n        (\n            \"Update Docs\",\n            datetime(2024, 1, 1, 0, 0),\n            None,\n            \"planned/update-docs-01-01-0000\",\n        ),\n        # With objective ID\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            456,\n            \"planned/O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Single digit objective\n        (\n            \"Add Tests\",\n            datetime(2024, 12, 31, 23, 59),\n            1,\n            \"planned/O1-add-tests-12-31-2359\",","new_string":"            \"plnd/fix-auth-bug-01-15-1430\",\n        ),\n        # Different timestamp\n        (\n            \"My Feature\",\n            datetime(2024, 6, 20, 10, 0),\n            None,\n            \"plnd/my-feature-06-20-1000\",\n        ),\n        # Midnight edge case\n        (\n            \"Update Docs\",\n            datetime(2024, 1, 1, 0, 0),\n            None,\n            \"plnd/update-docs-01-01-0000\",\n        ),\n        # With objective ID\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            456,\n            \"plnd/O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Single digit objective\n        (\n            \"Add Tests\",\n            datetime(2024, 12, 31, 23, 59),\n            1,\n            \"plnd/O1-add-tests-12-31-2359\","},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":690,"cache_read_input_tokens":87530,"cache_creation":{"ephemeral_5m_input_tokens":690,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHjq5vaJkoXZxCqZM33","type":"assistant","uuid":"31571986-a417-44a7-859e-18ca1c16af36","timestamp":"2026-02-22T14:46:53.542Z"}
{"parentUuid":"31571986-a417-44a7-859e-18ca1c16af36","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018iBNCXUtF4gWE7vNZwTksC","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/core/utils/test_naming.py has been updated successfully."}]},"uuid":"ed1361d6-06a1-4f3c-895a-2817a4ba0bd3","timestamp":"2026-02-22T14:46:54.245Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","oldString":"            \"planned/fix-auth-bug-01-15-1430\",\n        ),\n        # Different timestamp\n        (\n            \"My Feature\",\n            datetime(2024, 6, 20, 10, 0),\n            None,\n            \"planned/my-feature-06-20-1000\",\n        ),\n        # Midnight edge case\n        (\n            \"Update Docs\",\n            datetime(2024, 1, 1, 0, 0),\n            None,\n            \"planned/update-docs-01-01-0000\",\n        ),\n        # With objective ID\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            456,\n            \"planned/O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Single digit objective\n        (\n            \"Add Tests\",\n            datetime(2024, 12, 31, 23, 59),\n            1,\n            \"planned/O1-add-tests-12-31-2359\",","newString":"            \"plnd/fix-auth-bug-01-15-1430\",\n        ),\n        # Different timestamp\n        (\n            \"My Feature\",\n            datetime(2024, 6, 20, 10, 0),\n            None,\n            \"plnd/my-feature-06-20-1000\",\n        ),\n        # Midnight edge case\n        (\n            \"Update Docs\",\n            datetime(2024, 1, 1, 0, 0),\n            None,\n            \"plnd/update-docs-01-01-0000\",\n        ),\n        # With objective ID\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            456,\n            \"plnd/O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Single digit objective\n        (\n            \"Add Tests\",\n            datetime(2024, 12, 31, 23, 59),\n            1,\n            \"plnd/O1-add-tests-12-31-2359\",","originalFile":"from datetime import datetime\nfrom pathlib import Path\n\nimport pytest\n\nfrom erk_shared.naming import (\n    WORKTREE_DATE_SUFFIX_FORMAT,\n    InvalidObjectiveSlug,\n    InvalidPlanTitle,\n    ValidObjectiveSlug,\n    ValidPlanTitle,\n    default_branch_for_worktree,\n    derive_branch_name_from_title,\n    ensure_unique_worktree_name,\n    extract_leading_issue_number,\n    extract_objective_number,\n    extract_plan_review_issue_number,\n    extract_trailing_number,\n    generate_draft_pr_branch_name,\n    generate_issue_branch_name,\n    sanitize_branch_component,\n    sanitize_worktree_name,\n    strip_plan_from_filename,\n    validate_objective_slug,\n    validate_plan_title,\n)\n\n\ndef _get_current_date_suffix() -> str:\n    \"\"\"Get the current date suffix for plan-derived worktrees.\"\"\"\n    return datetime.now().strftime(WORKTREE_DATE_SUFFIX_FORMAT)\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\" Foo Bar \", \"foo-bar\"),\n        (\"A/B C\", \"a/b-c\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-branch-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-branch-name\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        (\"short\", \"short\"),\n        # Test long names with trailing hyphens are stripped\n        (\n            \"branch-name-with-dash-at-position-31-\",\n            \"branch-name-with-dash-at-positi\",\n        ),\n        # Test very long names truncate to 31\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".hidden-file\", \"hidden-file\"),\n        (\"file.extension\", \"file-extension\"),\n    ],\n)\ndef test_sanitize_branch_component(value: str, expected: str) -> None:\n    assert sanitize_branch_component(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"feature X\", \"feature-x\"),\n        (\"/ / \", \"work\"),\n    ],\n)\ndef test_default_branch_for_worktree(value: str, expected: str) -> None:\n    assert default_branch_for_worktree(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\"Add_Auth_Feature\", \"add-auth-feature\"),\n        (\"My_Cool_Plan\", \"my-cool-plan\"),\n        (\"FOO_BAR_BAZ\", \"foo-bar-baz\"),\n        (\"feature__with___multiple___underscores\", \"feature-with-multiple-underscor\"),\n        (\"name-with-hyphens\", \"name-with-hyphens\"),\n        (\"Mixed_Case-Hyphen_Underscore\", \"mixed-case-hyphen-underscore\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        (\"   spaces   \", \"spaces\"),\n        (\"---\", \"work\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-worktree-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-worktree-na\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        # Test truncation with trailing hyphen removal\n        (\n            \"worktree-name-with-dash-at-position-31-\",\n            \"worktree-name-with-dash-at-posi\",\n        ),\n        # Test truncation that ends with hyphen is stripped\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".worker-impl\", \"worker-impl\"),\n        (\"fix-.worker\", \"fix-worker\"),\n        (\"name.with.dots\", \"name-with-dots\"),\n    ],\n)\ndef test_sanitize_worktree_name(value: str, expected: str) -> None:\n    assert sanitize_worktree_name(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"devclikit-extraction-plan\", \"devclikit-extraction\"),\n        (\"my-feature-plan\", \"my-feature\"),\n        (\"plan-for-auth\", \"for-auth\"),\n        (\"plan-something\", \"something\"),\n        (\"something-plan\", \"something\"),\n        (\"something-plan-else\", \"something-else\"),\n        (\"plan-my-plan-feature\", \"my-feature\"),\n        (\"my-plan-feature-plan\", \"my-feature\"),\n        (\"plan\", \"plan\"),\n        (\"my_feature_plan\", \"my_feature\"),\n        (\"my feature plan\", \"my feature\"),\n        (\"my-feature_plan\", \"my-feature\"),\n        (\"MY-FEATURE-PLAN\", \"MY-FEATURE\"),\n        (\"My-Feature-Plan\", \"My-Feature\"),\n        (\"my-feature-PLAN\", \"my-feature\"),\n        (\"airplane-feature\", \"airplane-feature\"),\n        (\"explain-system\", \"explain-system\"),\n        (\"planted-tree\", \"planted-tree\"),\n        (\"planning-session\", \"planning-session\"),\n        (\"plans-document\", \"plans-document\"),\n        (\"-plan-feature\", \"feature\"),\n        (\"feature-plan-\", \"feature\"),\n        (\"my-feature-implementation-plan\", \"my-feature\"),\n        (\"implementation-plan-for-auth\", \"for-auth\"),\n        (\"implementation_plan_feature\", \"feature\"),\n        (\"feature implementation plan\", \"feature\"),\n        (\"my-feature_implementation-plan\", \"my-feature\"),\n        (\"implementation_plan-for-auth\", \"for-auth\"),\n        (\"IMPLEMENTATION-PLAN-FEATURE\", \"FEATURE\"),\n        (\"Implementation-Plan-Feature\", \"Feature\"),\n        (\"my-IMPLEMENTATION-plan\", \"my\"),\n        (\"my-implementation-plan-feature\", \"my-feature\"),\n        (\"plan-implementation-plan\", \"implementation\"),\n        (\"plan implementation plan\", \"implementation\"),\n        (\"implementation-plan\", \"implementation\"),\n        (\"implementation_plan\", \"implementation\"),\n        (\"IMPLEMENTATION-PLAN\", \"IMPLEMENTATION\"),\n        (\"reimplementation-feature\", \"reimplementation-feature\"),\n        (\"implantation-system\", \"implantation-system\"),\n    ],\n)\ndef test_strip_plan_from_filename(value: str, expected: str) -> None:\n    assert strip_plan_from_filename(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"name\", \"expected_base\", \"expected_number\"),\n    [\n        (\"my-feature\", \"my-feature\", None),\n        (\"my-feature-2\", \"my-feature\", 2),\n        (\"fix-42\", \"fix\", 42),\n        (\"feature-3-test\", \"feature-3-test\", None),  # Number in middle, not trailing\n        (\"test-123\", \"test\", 123),\n        (\"no-number\", \"no-number\", None),\n        (\"v2-feature-10\", \"v2-feature\", 10),\n    ],\n)\ndef test_extract_trailing_number(\n    name: str, expected_base: str, expected_number: int | None\n) -> None:\n    \"\"\"Test extracting trailing numbers from worktree names.\"\"\"\n    base, number = extract_trailing_number(name)\n    assert base == expected_base\n    assert number == expected_number\n\n\ndef test_ensure_unique_worktree_name_first_time(tmp_path: Path) -> None:\n    \"\"\"Test first-time worktree creation gets only datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    # Should have datetime suffix in format -YY-MM-DD-HHMM\n    date_suffix = _get_current_date_suffix()\n    assert result == f\"my-feature-{date_suffix}\"\n    assert not (repo_dir / result).exists()\n\n\ndef test_ensure_unique_worktree_name_duplicate_same_minute(tmp_path: Path) -> None:\n    \"\"\"Test duplicate worktree in same minute adds -2 after datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    existing_name = f\"my-feature-{date_suffix}\"\n    (repo_dir / existing_name).mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-2\"\n    assert not (repo_dir / result).exists()\n    assert (repo_dir / existing_name).exists()\n\n\ndef test_ensure_unique_worktree_name_multiple_duplicates(tmp_path: Path) -> None:\n    \"\"\"Test multiple duplicates increment correctly.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    (repo_dir / f\"my-feature-{date_suffix}\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-2\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-3\").mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-4\"\n\n\ndef test_ensure_unique_worktree_name_with_existing_number(tmp_path: Path) -> None:\n    \"\"\"Test name with existing number in base preserves it.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    date_suffix = _get_current_date_suffix()\n    result = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    # Base name has number, should preserve it in datetime-suffixed name\n    assert result == f\"fix-v3-{date_suffix}\"\n\n    # Create it and try again\n    (repo_dir / result).mkdir()\n    result2 = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    assert result2 == f\"fix-v3-{date_suffix}-2\"\n\n\ndef test_sanitize_branch_component_truncates_at_31_chars() -> None:\n    \"\"\"Branch names should truncate to 31 characters maximum.\"\"\"\n    # Exactly 31 characters\n    assert len(sanitize_branch_component(\"a\" * 31)) == 31\n\n    # 32 characters truncates to 31\n    assert len(sanitize_branch_component(\"a\" * 32)) == 31\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = sanitize_branch_component(long_name)\n    assert len(result) == 31\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\ndef test_sanitize_branch_component_matches_worktree_length() -> None:\n    \"\"\"Branch and worktree names should have same length for same input.\"\"\"\n    test_name = \"very-long-feature-name-that-exceeds-thirty-characters-easily\"\n    branch = sanitize_branch_component(test_name)\n    worktree = sanitize_worktree_name(test_name)\n    assert len(branch) == len(worktree)\n    assert len(branch) == 31\n\n\ndef test_very_long_title_truncates_to_45_chars_total() -> None:\n    \"\"\"Regression test: 99-char title should truncate to max 45 chars total with datetime suffix.\n\n    This tests the bug fix where `erk implement` created excessively long branch names.\n    Example: \"refactor erk implement command to support interactive and\n    non-interactive execution modes\"\n\n    Note: The 31-char limit includes rstrip(\"-\") after truncation,\n    so actual length may be <= 31.\n    \"\"\"\n    # 89-character title that caused the original bug\n    long_title = (\n        \"refactor erk implement command to support interactive and non-interactive execution modes\"\n    )\n\n    # Sanitize the worktree name (should be <= 31 chars max, trailing hyphens stripped)\n    base_name = sanitize_worktree_name(long_title)\n    assert len(base_name) <= 31\n\n    # With datetime suffix (-YY-MM-DD-HHMM = 14 chars including hyphen), total should be <= 45 chars\n    date_suffix = \"25-11-23-1430\"\n    name_with_date = f\"{base_name}-{date_suffix}\"\n    assert len(name_with_date) <= 45\n\n    # Verify the base name is correctly truncated (30 chars after rstrip of trailing hyphen)\n    assert base_name == \"refactor-erk-implement-command\"\n    assert len(base_name) == 30  # 31 chars truncated, then trailing hyphen stripped\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"expected\"),\n    [\n        (\"My Feature\", \"my-feature\"),\n        (\"Fix Bug #123!\", \"fix-bug-123\"),\n        (\"Simple\", \"simple\"),\n        (\"With_Underscores\", \"with-underscores\"),\n        (\"UPPERCASE\", \"uppercase\"),\n        (\"spaces  multiple   here\", \"spaces-multiple-here\"),\n        (\"leading---hyphens\", \"leading-hyphens\"),\n        (\"trailing---\", \"trailing\"),\n        (\"---both---\", \"both\"),\n        # Test 30-char truncation (different from sanitize_branch_component's 31)\n        (\"a\" * 40, \"a\" * 30),\n        (\"abcdefghijklmnopqrstuvwxyz-1234567890\", \"abcdefghijklmnopqrstuvwxyz-123\"),\n        # Trailing hyphen after truncation is removed\n        (\"this-is-thirty-chars-exact-yes\", \"this-is-thirty-chars-exact-yes\"),  # Exactly 30\n        (\"this-is-thirty-one-chars-exact\", \"this-is-thirty-one-chars-exact\"),  # 31 chars -> 30\n        # Test non-alphanumeric characters\n        (\"feat: add something\", \"feat-add-something\"),\n        (\"feat/add/something\", \"feat-add-something\"),\n        (\"feat(scope): message\", \"feat-scope-message\"),\n    ],\n)\ndef test_derive_branch_name_from_title(title: str, expected: str) -> None:\n    \"\"\"Test derive_branch_name_from_title matches workflow logic.\"\"\"\n    assert derive_branch_name_from_title(title) == expected\n\n\ndef test_derive_branch_name_truncates_to_30_chars() -> None:\n    \"\"\"Branch names from titles should truncate to 30 characters maximum.\n\n    This matches the workflow logic in plan-implement.yml which uses:\n    BRANCH_NAME=\"${BRANCH_NAME:0:30}\"\n    \"\"\"\n    # Exactly 30 characters\n    assert len(derive_branch_name_from_title(\"a\" * 30)) == 30\n\n    # 31 characters truncates to 30\n    assert len(derive_branch_name_from_title(\"a\" * 31)) == 30\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = derive_branch_name_from_title(long_name)\n    assert len(result) == 30\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\n# Tests for generate_issue_branch_name\n@pytest.mark.parametrize(\n    (\"issue_number\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # Standard case\n        (123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), \"P123-fix-auth-bug-01-15-1430\"),\n        # Integer issue number\n        (42, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-my-feature-06-20-1000\"),\n        # String issue number\n        (\"456\", \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P456-add-tests-12-31-2359\"),\n        # Midnight edge case\n        (789, \"Update Docs\", datetime(2024, 1, 1, 0, 0), \"P789-update-docs-01-01-0000\"),\n    ],\n)\ndef test_generate_issue_branch_name_format(\n    issue_number: int | str, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name follows P{num}-{slug}-{timestamp} format.\"\"\"\n    assert generate_issue_branch_name(issue_number, title, timestamp, objective_id=None) == expected\n\n\ndef test_generate_issue_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    # Very long title that would exceed 31 chars for base name\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=None)\n\n    # Base (P123-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"P123-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_issue_branch_name_preserves_hyphens_in_title() -> None:\n    \"\"\"Hyphens in titles are preserved (not doubled).\"\"\"\n    result = generate_issue_branch_name(\n        123, \"fix-auth-bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Should be P123-fix-auth-bug-..., not P123--fix-auth-bug-...\n    assert \"P123-fix-auth-bug-\" in result\n    assert \"--\" not in result\n\n\ndef test_generate_issue_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_issue_branch_name(\n        123, \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Special chars should be replaced with hyphens, then collapsed\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\n@pytest.mark.parametrize(\n    (\"issue_number\", \"objective_id\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # With objective ID\n        (\n            123,\n            456,\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            \"P123-O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Different objective ID\n        (42, 789, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-O789-my-feature-06-20-1000\"),\n        # Single digit objective\n        (100, 1, \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P100-O1-add-tests-12-31-2359\"),\n    ],\n)\ndef test_generate_issue_branch_name_with_objective(\n    issue_number: int, objective_id: int, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name includes objective ID when provided.\"\"\"\n    result = generate_issue_branch_name(issue_number, title, timestamp, objective_id=objective_id)\n    assert result == expected\n\n\ndef test_generate_issue_branch_name_with_objective_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=456)\n\n    # Base (P123-O456-...) should be truncated to 31 chars, then timestamp appended\n    assert len(result) <= 42\n    assert result.startswith(\"P123-O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # With objective ID\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 456),\n        (\"P42-O789-my-feature-06-20-1000\", 789),\n        (\"P100-O1-add-tests-12-31-2359\", 1),\n        # Lowercase o prefix (case insensitive)\n        (\"P123-o456-fix-bug\", 456),\n        (\"p123-o789-feature\", 789),\n        # Draft-PR branches with objective ID (current prefix)\n        (\"plnd/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"plnd/O1-add-tests-12-31-2359\", 1),\n        # Legacy planned/ prefix branches with objective ID\n        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"planned/O1-add-tests-12-31-2359\", 1),\n        # Legacy plan/ prefix branches with objective ID\n        (\"plan/O456-fix-auth-01-15-1430\", 456),\n        (\"plan/O7709-plan-lazy-tip-sync-f-02-21-1116\", 7709),\n        # Without objective ID\n        (\"P123-fix-auth-bug-01-15-1430\", None),\n        (\"P42-my-feature\", None),\n        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"plan/fix-auth-bug-01-15-1430\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_objective_number(branch_name: str, expected: int | None) -> None:\n    \"\"\"Extract objective ID from branch name.\"\"\"\n    assert extract_objective_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Standard format (still works with objective ID in branch)\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 123),\n        (\"P42-O789-my-feature\", 42),\n        # Without objective ID (existing behavior)\n        (\"P2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"P42-fix-bug\", 42),\n        # Legacy format without P prefix\n        (\"2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"42-fix-bug\", 42),\n        # Draft-PR branches return None (no extractable issue number)\n        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"plnd/O456-fix-auth-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"planned/O456-fix-auth-01-15-1430\", None),\n        # Invalid formats\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_leading_issue_number_with_objective_format(\n    branch_name: str, expected: int | None\n) -> None:\n    \"\"\"Extract leading issue number still works with objective ID in branch name.\"\"\"\n    assert extract_leading_issue_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Valid plan review branches (current prefix)\n        (\"plnd/review-6214-01-15-1430\", 6214),\n        (\"plnd/review-42-01-28-0930\", 42),\n        (\"plnd/review-1-12-31-2359\", 1),\n        (\"plnd/review-99999-01-01-0000\", 99999),\n        # Legacy planned/ prefix still works\n        (\"planned/review-6214-01-15-1430\", 6214),\n        (\"planned/review-42-01-28-0930\", 42),\n        (\"planned/review-1-12-31-2359\", 1),\n        (\"planned/review-99999-01-01-0000\", 99999),\n        # Not plan review branches\n        (\"P2382-convert-erk-create-raw-ext\", None),\n        (\"2382-convert-erk-create-raw-ext\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n        (\"plnd/review\", None),  # Missing issue number\n        (\"plnd/review-\", None),  # Missing issue number\n        (\"plnd/review-abc-01-15-1430\", None),  # Non-numeric issue\n    ],\n)\ndef test_extract_plan_review_issue_number(branch_name: str, expected: int | None) -> None:\n    assert extract_plan_review_issue_number(branch_name) == expected\n\n\n# Tests for generate_draft_pr_branch_name\n@pytest.mark.parametrize(\n    (\"title\", \"timestamp\", \"objective_id\", \"expected\"),\n    [\n        # Standard case without objective\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            None,\n            \"planned/fix-auth-bug-01-15-1430\",\n        ),\n        # Different timestamp\n        (\n            \"My Feature\",\n            datetime(2024, 6, 20, 10, 0),\n            None,\n            \"planned/my-feature-06-20-1000\",\n        ),\n        # Midnight edge case\n        (\n            \"Update Docs\",\n            datetime(2024, 1, 1, 0, 0),\n            None,\n            \"planned/update-docs-01-01-0000\",\n        ),\n        # With objective ID\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            456,\n            \"planned/O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Single digit objective\n        (\n            \"Add Tests\",\n            datetime(2024, 12, 31, 23, 59),\n            1,\n            \"planned/O1-add-tests-12-31-2359\",\n        ),\n    ],\n)\ndef test_generate_draft_pr_branch_name_format(\n    title: str, timestamp: datetime, objective_id: int | None, expected: str\n) -> None:\n    \"\"\"Branch name follows planned/{slug}-{timestamp} format.\"\"\"\n    assert generate_draft_pr_branch_name(title, timestamp, objective_id=objective_id) == expected\n\n\ndef test_generate_draft_pr_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=None)\n\n    # Base (plan-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"planned/\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_draft_pr_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_draft_pr_branch_name(\n        \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\ndef test_generate_draft_pr_branch_name_with_objective_truncates() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=456)\n\n    assert len(result) <= 42\n    assert result.startswith(\"planned/O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    assert not result[:-11].endswith(\"-\")\n\n\n# Tests for validate_objective_slug\n@pytest.mark.parametrize(\n    \"slug\",\n    [\n        \"build-auth-system\",\n        \"refactor-gateway\",\n        \"add-dark-mode\",\n        \"simple\",\n        \"abc\",\n        \"a\" * 40,\n        \"fix-tui-layout\",\n        \"add-v2-support\",\n        \"feature123\",\n    ],\n)\ndef test_validate_objective_slug_valid(slug: str) -> None:\n    \"\"\"Valid slugs return ValidObjectiveSlug.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, ValidObjectiveSlug)\n    assert result.slug == slug\n\n\n@pytest.mark.parametrize(\n    (\"slug\", \"reason_fragment\"),\n    [\n        (\"ab\", \"Too short\"),\n        (\"a\" * 41, \"Too long\"),\n        (\"Build-Auth\", \"Does not match\"),\n        (\"UPPERCASE\", \"Does not match\"),\n        (\"123-start\", \"Does not match\"),\n        (\"my--slug\", \"Does not match\"),\n        (\"has spaces\", \"Does not match\"),\n        (\"with_underscores\", \"Does not match\"),\n        (\"has.dots\", \"Does not match\"),\n        (\"-leading-hyphen\", \"Does not match\"),\n        (\"trailing-hyphen-\", \"Does not match\"),\n    ],\n)\ndef test_validate_objective_slug_invalid(slug: str, reason_fragment: str) -> None:\n    \"\"\"Invalid slugs return InvalidObjectiveSlug with matching reason.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_objective_slug_error_message_includes_pattern() -> None:\n    \"\"\"Error message includes the regex pattern for agent self-correction.\"\"\"\n    result = validate_objective_slug(\"INVALID\")\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert \"^[a-z][a-z0-9]*(-[a-z0-9]+)*$\" in result.message\n    assert \"INVALID\" in result.message\n\n\n# Tests for validate_plan_title\n@pytest.mark.parametrize(\n    \"title\",\n    [\n        \"Add User Authentication\",\n        \"Refactor Gateway Layer\",\n        \"Fix CLI Argument Parsing\",\n        \"hello\",\n        \"a\" * 100,\n        \"Fix Bug #123 in Auth Module\",\n        \"café au lait feature\",\n        \"Update the README file\",\n        \"Add v2 API support for external clients\",\n    ],\n)\ndef test_validate_plan_title_valid(title: str) -> None:\n    \"\"\"Valid titles return ValidPlanTitle.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == title.strip()\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"reason_fragment\"),\n    [\n        (\"\", \"empty\"),\n        (\"   \", \"empty\"),\n        (\"\\t\\n\", \"empty\"),\n        (\"Plan\", \"Too short\"),\n        (\"ab\", \"Too short\"),\n        (\"a\" * 101, \"Too long\"),\n        (\"12345\", \"at least one alphabetic\"),\n        (\"12345 67890\", \"at least one alphabetic\"),\n        (\"!@#$%^&*()\", \"at least one alphabetic\"),\n        (\"\\U0001f680\\U0001f389\\U0001f525\\U0001f4a5\\U0001f31f\", \"at least one alphabetic\"),\n        (\"\\u4f60\\u597d\\u4e16\\u754c\\u7684\\u8ba1\\u5212\", \"No usable content\"),\n    ],\n)\ndef test_validate_plan_title_invalid(title: str, reason_fragment: str) -> None:\n    \"\"\"Invalid titles return InvalidPlanTitle with matching reason.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, InvalidPlanTitle)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_plan_title_error_message_includes_rules() -> None:\n    \"\"\"Error message includes rules for agent self-correction.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert \"5-100 characters\" in result.message\n    assert \"at least one alphabetic\" in result.message\n    assert \"Valid examples\" in result.message\n    assert \"Invalid examples\" in result.message\n\n\ndef test_validate_plan_title_error_type() -> None:\n    \"\"\"Error type is machine-readable.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.error_type == \"invalid-plan-title\"\n\n\ndef test_validate_plan_title_strips_whitespace() -> None:\n    \"\"\"Leading/trailing whitespace is stripped before validation.\"\"\"\n    result = validate_plan_title(\"  Add Feature  \")\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == \"Add Feature\"\n\n\ndef test_validate_plan_title_preserves_original_in_error() -> None:\n    \"\"\"Error includes the original unmodified title.\"\"\"\n    result = validate_plan_title(\"   ab   \")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.raw_title == \"   ab   \"\n","structuredPatch":[{"oldStart":567,"oldLines":35,"newStart":567,"newLines":35,"lines":["             \"Fix Auth Bug\",","             datetime(2024, 1, 15, 14, 30),","             None,","-            \"planned/fix-auth-bug-01-15-1430\",","+            \"plnd/fix-auth-bug-01-15-1430\",","         ),","         # Different timestamp","         (","             \"My Feature\",","             datetime(2024, 6, 20, 10, 0),","             None,","-            \"planned/my-feature-06-20-1000\",","+            \"plnd/my-feature-06-20-1000\",","         ),","         # Midnight edge case","         (","             \"Update Docs\",","             datetime(2024, 1, 1, 0, 0),","             None,","-            \"planned/update-docs-01-01-0000\",","+            \"plnd/update-docs-01-01-0000\",","         ),","         # With objective ID","         (","             \"Fix Auth Bug\",","             datetime(2024, 1, 15, 14, 30),","             456,","-            \"planned/O456-fix-auth-bug-01-15-1430\",","+            \"plnd/O456-fix-auth-bug-01-15-1430\",","         ),","         # Single digit objective","         (","             \"Add Tests\",","             datetime(2024, 12, 31, 23, 59),","             1,","-            \"planned/O1-add-tests-12-31-2359\",","+            \"plnd/O1-add-tests-12-31-2359\",","         ),","     ],"," )"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"ed1361d6-06a1-4f3c-895a-2817a4ba0bd3","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Y71jUStUWHdxjs4cbsCAJi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011Qfnf1Kp6BxZAvnHN8a6HS","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","old_string":"    \"\"\"Branch name follows planned/{slug}-{timestamp} format.\"\"\"","new_string":"    \"\"\"Branch name follows plnd/{slug}-{timestamp} format.\"\"\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1035,"cache_read_input_tokens":88220,"cache_creation":{"ephemeral_5m_input_tokens":1035,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHkRKDJ89jaSuR6WzHs","type":"assistant","uuid":"b7b95044-205e-485b-8579-16e1320724b3","timestamp":"2026-02-22T14:46:57.653Z"}
{"parentUuid":"b7b95044-205e-485b-8579-16e1320724b3","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011Qfnf1Kp6BxZAvnHN8a6HS","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/core/utils/test_naming.py has been updated successfully."}]},"uuid":"0bf63b80-f9a4-4cda-bdc0-dd97748d188c","timestamp":"2026-02-22T14:46:58.338Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","oldString":"    \"\"\"Branch name follows planned/{slug}-{timestamp} format.\"\"\"","newString":"    \"\"\"Branch name follows plnd/{slug}-{timestamp} format.\"\"\"","originalFile":"from datetime import datetime\nfrom pathlib import Path\n\nimport pytest\n\nfrom erk_shared.naming import (\n    WORKTREE_DATE_SUFFIX_FORMAT,\n    InvalidObjectiveSlug,\n    InvalidPlanTitle,\n    ValidObjectiveSlug,\n    ValidPlanTitle,\n    default_branch_for_worktree,\n    derive_branch_name_from_title,\n    ensure_unique_worktree_name,\n    extract_leading_issue_number,\n    extract_objective_number,\n    extract_plan_review_issue_number,\n    extract_trailing_number,\n    generate_draft_pr_branch_name,\n    generate_issue_branch_name,\n    sanitize_branch_component,\n    sanitize_worktree_name,\n    strip_plan_from_filename,\n    validate_objective_slug,\n    validate_plan_title,\n)\n\n\ndef _get_current_date_suffix() -> str:\n    \"\"\"Get the current date suffix for plan-derived worktrees.\"\"\"\n    return datetime.now().strftime(WORKTREE_DATE_SUFFIX_FORMAT)\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\" Foo Bar \", \"foo-bar\"),\n        (\"A/B C\", \"a/b-c\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-branch-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-branch-name\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        (\"short\", \"short\"),\n        # Test long names with trailing hyphens are stripped\n        (\n            \"branch-name-with-dash-at-position-31-\",\n            \"branch-name-with-dash-at-positi\",\n        ),\n        # Test very long names truncate to 31\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".hidden-file\", \"hidden-file\"),\n        (\"file.extension\", \"file-extension\"),\n    ],\n)\ndef test_sanitize_branch_component(value: str, expected: str) -> None:\n    assert sanitize_branch_component(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"feature X\", \"feature-x\"),\n        (\"/ / \", \"work\"),\n    ],\n)\ndef test_default_branch_for_worktree(value: str, expected: str) -> None:\n    assert default_branch_for_worktree(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\"Add_Auth_Feature\", \"add-auth-feature\"),\n        (\"My_Cool_Plan\", \"my-cool-plan\"),\n        (\"FOO_BAR_BAZ\", \"foo-bar-baz\"),\n        (\"feature__with___multiple___underscores\", \"feature-with-multiple-underscor\"),\n        (\"name-with-hyphens\", \"name-with-hyphens\"),\n        (\"Mixed_Case-Hyphen_Underscore\", \"mixed-case-hyphen-underscore\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        (\"   spaces   \", \"spaces\"),\n        (\"---\", \"work\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-worktree-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-worktree-na\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        # Test truncation with trailing hyphen removal\n        (\n            \"worktree-name-with-dash-at-position-31-\",\n            \"worktree-name-with-dash-at-posi\",\n        ),\n        # Test truncation that ends with hyphen is stripped\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".worker-impl\", \"worker-impl\"),\n        (\"fix-.worker\", \"fix-worker\"),\n        (\"name.with.dots\", \"name-with-dots\"),\n    ],\n)\ndef test_sanitize_worktree_name(value: str, expected: str) -> None:\n    assert sanitize_worktree_name(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"devclikit-extraction-plan\", \"devclikit-extraction\"),\n        (\"my-feature-plan\", \"my-feature\"),\n        (\"plan-for-auth\", \"for-auth\"),\n        (\"plan-something\", \"something\"),\n        (\"something-plan\", \"something\"),\n        (\"something-plan-else\", \"something-else\"),\n        (\"plan-my-plan-feature\", \"my-feature\"),\n        (\"my-plan-feature-plan\", \"my-feature\"),\n        (\"plan\", \"plan\"),\n        (\"my_feature_plan\", \"my_feature\"),\n        (\"my feature plan\", \"my feature\"),\n        (\"my-feature_plan\", \"my-feature\"),\n        (\"MY-FEATURE-PLAN\", \"MY-FEATURE\"),\n        (\"My-Feature-Plan\", \"My-Feature\"),\n        (\"my-feature-PLAN\", \"my-feature\"),\n        (\"airplane-feature\", \"airplane-feature\"),\n        (\"explain-system\", \"explain-system\"),\n        (\"planted-tree\", \"planted-tree\"),\n        (\"planning-session\", \"planning-session\"),\n        (\"plans-document\", \"plans-document\"),\n        (\"-plan-feature\", \"feature\"),\n        (\"feature-plan-\", \"feature\"),\n        (\"my-feature-implementation-plan\", \"my-feature\"),\n        (\"implementation-plan-for-auth\", \"for-auth\"),\n        (\"implementation_plan_feature\", \"feature\"),\n        (\"feature implementation plan\", \"feature\"),\n        (\"my-feature_implementation-plan\", \"my-feature\"),\n        (\"implementation_plan-for-auth\", \"for-auth\"),\n        (\"IMPLEMENTATION-PLAN-FEATURE\", \"FEATURE\"),\n        (\"Implementation-Plan-Feature\", \"Feature\"),\n        (\"my-IMPLEMENTATION-plan\", \"my\"),\n        (\"my-implementation-plan-feature\", \"my-feature\"),\n        (\"plan-implementation-plan\", \"implementation\"),\n        (\"plan implementation plan\", \"implementation\"),\n        (\"implementation-plan\", \"implementation\"),\n        (\"implementation_plan\", \"implementation\"),\n        (\"IMPLEMENTATION-PLAN\", \"IMPLEMENTATION\"),\n        (\"reimplementation-feature\", \"reimplementation-feature\"),\n        (\"implantation-system\", \"implantation-system\"),\n    ],\n)\ndef test_strip_plan_from_filename(value: str, expected: str) -> None:\n    assert strip_plan_from_filename(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"name\", \"expected_base\", \"expected_number\"),\n    [\n        (\"my-feature\", \"my-feature\", None),\n        (\"my-feature-2\", \"my-feature\", 2),\n        (\"fix-42\", \"fix\", 42),\n        (\"feature-3-test\", \"feature-3-test\", None),  # Number in middle, not trailing\n        (\"test-123\", \"test\", 123),\n        (\"no-number\", \"no-number\", None),\n        (\"v2-feature-10\", \"v2-feature\", 10),\n    ],\n)\ndef test_extract_trailing_number(\n    name: str, expected_base: str, expected_number: int | None\n) -> None:\n    \"\"\"Test extracting trailing numbers from worktree names.\"\"\"\n    base, number = extract_trailing_number(name)\n    assert base == expected_base\n    assert number == expected_number\n\n\ndef test_ensure_unique_worktree_name_first_time(tmp_path: Path) -> None:\n    \"\"\"Test first-time worktree creation gets only datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    # Should have datetime suffix in format -YY-MM-DD-HHMM\n    date_suffix = _get_current_date_suffix()\n    assert result == f\"my-feature-{date_suffix}\"\n    assert not (repo_dir / result).exists()\n\n\ndef test_ensure_unique_worktree_name_duplicate_same_minute(tmp_path: Path) -> None:\n    \"\"\"Test duplicate worktree in same minute adds -2 after datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    existing_name = f\"my-feature-{date_suffix}\"\n    (repo_dir / existing_name).mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-2\"\n    assert not (repo_dir / result).exists()\n    assert (repo_dir / existing_name).exists()\n\n\ndef test_ensure_unique_worktree_name_multiple_duplicates(tmp_path: Path) -> None:\n    \"\"\"Test multiple duplicates increment correctly.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    (repo_dir / f\"my-feature-{date_suffix}\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-2\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-3\").mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-4\"\n\n\ndef test_ensure_unique_worktree_name_with_existing_number(tmp_path: Path) -> None:\n    \"\"\"Test name with existing number in base preserves it.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    date_suffix = _get_current_date_suffix()\n    result = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    # Base name has number, should preserve it in datetime-suffixed name\n    assert result == f\"fix-v3-{date_suffix}\"\n\n    # Create it and try again\n    (repo_dir / result).mkdir()\n    result2 = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    assert result2 == f\"fix-v3-{date_suffix}-2\"\n\n\ndef test_sanitize_branch_component_truncates_at_31_chars() -> None:\n    \"\"\"Branch names should truncate to 31 characters maximum.\"\"\"\n    # Exactly 31 characters\n    assert len(sanitize_branch_component(\"a\" * 31)) == 31\n\n    # 32 characters truncates to 31\n    assert len(sanitize_branch_component(\"a\" * 32)) == 31\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = sanitize_branch_component(long_name)\n    assert len(result) == 31\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\ndef test_sanitize_branch_component_matches_worktree_length() -> None:\n    \"\"\"Branch and worktree names should have same length for same input.\"\"\"\n    test_name = \"very-long-feature-name-that-exceeds-thirty-characters-easily\"\n    branch = sanitize_branch_component(test_name)\n    worktree = sanitize_worktree_name(test_name)\n    assert len(branch) == len(worktree)\n    assert len(branch) == 31\n\n\ndef test_very_long_title_truncates_to_45_chars_total() -> None:\n    \"\"\"Regression test: 99-char title should truncate to max 45 chars total with datetime suffix.\n\n    This tests the bug fix where `erk implement` created excessively long branch names.\n    Example: \"refactor erk implement command to support interactive and\n    non-interactive execution modes\"\n\n    Note: The 31-char limit includes rstrip(\"-\") after truncation,\n    so actual length may be <= 31.\n    \"\"\"\n    # 89-character title that caused the original bug\n    long_title = (\n        \"refactor erk implement command to support interactive and non-interactive execution modes\"\n    )\n\n    # Sanitize the worktree name (should be <= 31 chars max, trailing hyphens stripped)\n    base_name = sanitize_worktree_name(long_title)\n    assert len(base_name) <= 31\n\n    # With datetime suffix (-YY-MM-DD-HHMM = 14 chars including hyphen), total should be <= 45 chars\n    date_suffix = \"25-11-23-1430\"\n    name_with_date = f\"{base_name}-{date_suffix}\"\n    assert len(name_with_date) <= 45\n\n    # Verify the base name is correctly truncated (30 chars after rstrip of trailing hyphen)\n    assert base_name == \"refactor-erk-implement-command\"\n    assert len(base_name) == 30  # 31 chars truncated, then trailing hyphen stripped\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"expected\"),\n    [\n        (\"My Feature\", \"my-feature\"),\n        (\"Fix Bug #123!\", \"fix-bug-123\"),\n        (\"Simple\", \"simple\"),\n        (\"With_Underscores\", \"with-underscores\"),\n        (\"UPPERCASE\", \"uppercase\"),\n        (\"spaces  multiple   here\", \"spaces-multiple-here\"),\n        (\"leading---hyphens\", \"leading-hyphens\"),\n        (\"trailing---\", \"trailing\"),\n        (\"---both---\", \"both\"),\n        # Test 30-char truncation (different from sanitize_branch_component's 31)\n        (\"a\" * 40, \"a\" * 30),\n        (\"abcdefghijklmnopqrstuvwxyz-1234567890\", \"abcdefghijklmnopqrstuvwxyz-123\"),\n        # Trailing hyphen after truncation is removed\n        (\"this-is-thirty-chars-exact-yes\", \"this-is-thirty-chars-exact-yes\"),  # Exactly 30\n        (\"this-is-thirty-one-chars-exact\", \"this-is-thirty-one-chars-exact\"),  # 31 chars -> 30\n        # Test non-alphanumeric characters\n        (\"feat: add something\", \"feat-add-something\"),\n        (\"feat/add/something\", \"feat-add-something\"),\n        (\"feat(scope): message\", \"feat-scope-message\"),\n    ],\n)\ndef test_derive_branch_name_from_title(title: str, expected: str) -> None:\n    \"\"\"Test derive_branch_name_from_title matches workflow logic.\"\"\"\n    assert derive_branch_name_from_title(title) == expected\n\n\ndef test_derive_branch_name_truncates_to_30_chars() -> None:\n    \"\"\"Branch names from titles should truncate to 30 characters maximum.\n\n    This matches the workflow logic in plan-implement.yml which uses:\n    BRANCH_NAME=\"${BRANCH_NAME:0:30}\"\n    \"\"\"\n    # Exactly 30 characters\n    assert len(derive_branch_name_from_title(\"a\" * 30)) == 30\n\n    # 31 characters truncates to 30\n    assert len(derive_branch_name_from_title(\"a\" * 31)) == 30\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = derive_branch_name_from_title(long_name)\n    assert len(result) == 30\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\n# Tests for generate_issue_branch_name\n@pytest.mark.parametrize(\n    (\"issue_number\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # Standard case\n        (123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), \"P123-fix-auth-bug-01-15-1430\"),\n        # Integer issue number\n        (42, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-my-feature-06-20-1000\"),\n        # String issue number\n        (\"456\", \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P456-add-tests-12-31-2359\"),\n        # Midnight edge case\n        (789, \"Update Docs\", datetime(2024, 1, 1, 0, 0), \"P789-update-docs-01-01-0000\"),\n    ],\n)\ndef test_generate_issue_branch_name_format(\n    issue_number: int | str, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name follows P{num}-{slug}-{timestamp} format.\"\"\"\n    assert generate_issue_branch_name(issue_number, title, timestamp, objective_id=None) == expected\n\n\ndef test_generate_issue_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    # Very long title that would exceed 31 chars for base name\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=None)\n\n    # Base (P123-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"P123-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_issue_branch_name_preserves_hyphens_in_title() -> None:\n    \"\"\"Hyphens in titles are preserved (not doubled).\"\"\"\n    result = generate_issue_branch_name(\n        123, \"fix-auth-bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Should be P123-fix-auth-bug-..., not P123--fix-auth-bug-...\n    assert \"P123-fix-auth-bug-\" in result\n    assert \"--\" not in result\n\n\ndef test_generate_issue_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_issue_branch_name(\n        123, \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Special chars should be replaced with hyphens, then collapsed\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\n@pytest.mark.parametrize(\n    (\"issue_number\", \"objective_id\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # With objective ID\n        (\n            123,\n            456,\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            \"P123-O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Different objective ID\n        (42, 789, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-O789-my-feature-06-20-1000\"),\n        # Single digit objective\n        (100, 1, \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P100-O1-add-tests-12-31-2359\"),\n    ],\n)\ndef test_generate_issue_branch_name_with_objective(\n    issue_number: int, objective_id: int, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name includes objective ID when provided.\"\"\"\n    result = generate_issue_branch_name(issue_number, title, timestamp, objective_id=objective_id)\n    assert result == expected\n\n\ndef test_generate_issue_branch_name_with_objective_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=456)\n\n    # Base (P123-O456-...) should be truncated to 31 chars, then timestamp appended\n    assert len(result) <= 42\n    assert result.startswith(\"P123-O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # With objective ID\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 456),\n        (\"P42-O789-my-feature-06-20-1000\", 789),\n        (\"P100-O1-add-tests-12-31-2359\", 1),\n        # Lowercase o prefix (case insensitive)\n        (\"P123-o456-fix-bug\", 456),\n        (\"p123-o789-feature\", 789),\n        # Draft-PR branches with objective ID (current prefix)\n        (\"plnd/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"plnd/O1-add-tests-12-31-2359\", 1),\n        # Legacy planned/ prefix branches with objective ID\n        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"planned/O1-add-tests-12-31-2359\", 1),\n        # Legacy plan/ prefix branches with objective ID\n        (\"plan/O456-fix-auth-01-15-1430\", 456),\n        (\"plan/O7709-plan-lazy-tip-sync-f-02-21-1116\", 7709),\n        # Without objective ID\n        (\"P123-fix-auth-bug-01-15-1430\", None),\n        (\"P42-my-feature\", None),\n        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"plan/fix-auth-bug-01-15-1430\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_objective_number(branch_name: str, expected: int | None) -> None:\n    \"\"\"Extract objective ID from branch name.\"\"\"\n    assert extract_objective_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Standard format (still works with objective ID in branch)\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 123),\n        (\"P42-O789-my-feature\", 42),\n        # Without objective ID (existing behavior)\n        (\"P2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"P42-fix-bug\", 42),\n        # Legacy format without P prefix\n        (\"2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"42-fix-bug\", 42),\n        # Draft-PR branches return None (no extractable issue number)\n        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"plnd/O456-fix-auth-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"planned/O456-fix-auth-01-15-1430\", None),\n        # Invalid formats\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_leading_issue_number_with_objective_format(\n    branch_name: str, expected: int | None\n) -> None:\n    \"\"\"Extract leading issue number still works with objective ID in branch name.\"\"\"\n    assert extract_leading_issue_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Valid plan review branches (current prefix)\n        (\"plnd/review-6214-01-15-1430\", 6214),\n        (\"plnd/review-42-01-28-0930\", 42),\n        (\"plnd/review-1-12-31-2359\", 1),\n        (\"plnd/review-99999-01-01-0000\", 99999),\n        # Legacy planned/ prefix still works\n        (\"planned/review-6214-01-15-1430\", 6214),\n        (\"planned/review-42-01-28-0930\", 42),\n        (\"planned/review-1-12-31-2359\", 1),\n        (\"planned/review-99999-01-01-0000\", 99999),\n        # Not plan review branches\n        (\"P2382-convert-erk-create-raw-ext\", None),\n        (\"2382-convert-erk-create-raw-ext\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n        (\"plnd/review\", None),  # Missing issue number\n        (\"plnd/review-\", None),  # Missing issue number\n        (\"plnd/review-abc-01-15-1430\", None),  # Non-numeric issue\n    ],\n)\ndef test_extract_plan_review_issue_number(branch_name: str, expected: int | None) -> None:\n    assert extract_plan_review_issue_number(branch_name) == expected\n\n\n# Tests for generate_draft_pr_branch_name\n@pytest.mark.parametrize(\n    (\"title\", \"timestamp\", \"objective_id\", \"expected\"),\n    [\n        # Standard case without objective\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            None,\n            \"plnd/fix-auth-bug-01-15-1430\",\n        ),\n        # Different timestamp\n        (\n            \"My Feature\",\n            datetime(2024, 6, 20, 10, 0),\n            None,\n            \"plnd/my-feature-06-20-1000\",\n        ),\n        # Midnight edge case\n        (\n            \"Update Docs\",\n            datetime(2024, 1, 1, 0, 0),\n            None,\n            \"plnd/update-docs-01-01-0000\",\n        ),\n        # With objective ID\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            456,\n            \"plnd/O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Single digit objective\n        (\n            \"Add Tests\",\n            datetime(2024, 12, 31, 23, 59),\n            1,\n            \"plnd/O1-add-tests-12-31-2359\",\n        ),\n    ],\n)\ndef test_generate_draft_pr_branch_name_format(\n    title: str, timestamp: datetime, objective_id: int | None, expected: str\n) -> None:\n    \"\"\"Branch name follows planned/{slug}-{timestamp} format.\"\"\"\n    assert generate_draft_pr_branch_name(title, timestamp, objective_id=objective_id) == expected\n\n\ndef test_generate_draft_pr_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=None)\n\n    # Base (plan-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"planned/\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_draft_pr_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_draft_pr_branch_name(\n        \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\ndef test_generate_draft_pr_branch_name_with_objective_truncates() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=456)\n\n    assert len(result) <= 42\n    assert result.startswith(\"planned/O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    assert not result[:-11].endswith(\"-\")\n\n\n# Tests for validate_objective_slug\n@pytest.mark.parametrize(\n    \"slug\",\n    [\n        \"build-auth-system\",\n        \"refactor-gateway\",\n        \"add-dark-mode\",\n        \"simple\",\n        \"abc\",\n        \"a\" * 40,\n        \"fix-tui-layout\",\n        \"add-v2-support\",\n        \"feature123\",\n    ],\n)\ndef test_validate_objective_slug_valid(slug: str) -> None:\n    \"\"\"Valid slugs return ValidObjectiveSlug.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, ValidObjectiveSlug)\n    assert result.slug == slug\n\n\n@pytest.mark.parametrize(\n    (\"slug\", \"reason_fragment\"),\n    [\n        (\"ab\", \"Too short\"),\n        (\"a\" * 41, \"Too long\"),\n        (\"Build-Auth\", \"Does not match\"),\n        (\"UPPERCASE\", \"Does not match\"),\n        (\"123-start\", \"Does not match\"),\n        (\"my--slug\", \"Does not match\"),\n        (\"has spaces\", \"Does not match\"),\n        (\"with_underscores\", \"Does not match\"),\n        (\"has.dots\", \"Does not match\"),\n        (\"-leading-hyphen\", \"Does not match\"),\n        (\"trailing-hyphen-\", \"Does not match\"),\n    ],\n)\ndef test_validate_objective_slug_invalid(slug: str, reason_fragment: str) -> None:\n    \"\"\"Invalid slugs return InvalidObjectiveSlug with matching reason.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_objective_slug_error_message_includes_pattern() -> None:\n    \"\"\"Error message includes the regex pattern for agent self-correction.\"\"\"\n    result = validate_objective_slug(\"INVALID\")\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert \"^[a-z][a-z0-9]*(-[a-z0-9]+)*$\" in result.message\n    assert \"INVALID\" in result.message\n\n\n# Tests for validate_plan_title\n@pytest.mark.parametrize(\n    \"title\",\n    [\n        \"Add User Authentication\",\n        \"Refactor Gateway Layer\",\n        \"Fix CLI Argument Parsing\",\n        \"hello\",\n        \"a\" * 100,\n        \"Fix Bug #123 in Auth Module\",\n        \"café au lait feature\",\n        \"Update the README file\",\n        \"Add v2 API support for external clients\",\n    ],\n)\ndef test_validate_plan_title_valid(title: str) -> None:\n    \"\"\"Valid titles return ValidPlanTitle.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == title.strip()\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"reason_fragment\"),\n    [\n        (\"\", \"empty\"),\n        (\"   \", \"empty\"),\n        (\"\\t\\n\", \"empty\"),\n        (\"Plan\", \"Too short\"),\n        (\"ab\", \"Too short\"),\n        (\"a\" * 101, \"Too long\"),\n        (\"12345\", \"at least one alphabetic\"),\n        (\"12345 67890\", \"at least one alphabetic\"),\n        (\"!@#$%^&*()\", \"at least one alphabetic\"),\n        (\"\\U0001f680\\U0001f389\\U0001f525\\U0001f4a5\\U0001f31f\", \"at least one alphabetic\"),\n        (\"\\u4f60\\u597d\\u4e16\\u754c\\u7684\\u8ba1\\u5212\", \"No usable content\"),\n    ],\n)\ndef test_validate_plan_title_invalid(title: str, reason_fragment: str) -> None:\n    \"\"\"Invalid titles return InvalidPlanTitle with matching reason.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, InvalidPlanTitle)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_plan_title_error_message_includes_rules() -> None:\n    \"\"\"Error message includes rules for agent self-correction.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert \"5-100 characters\" in result.message\n    assert \"at least one alphabetic\" in result.message\n    assert \"Valid examples\" in result.message\n    assert \"Invalid examples\" in result.message\n\n\ndef test_validate_plan_title_error_type() -> None:\n    \"\"\"Error type is machine-readable.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.error_type == \"invalid-plan-title\"\n\n\ndef test_validate_plan_title_strips_whitespace() -> None:\n    \"\"\"Leading/trailing whitespace is stripped before validation.\"\"\"\n    result = validate_plan_title(\"  Add Feature  \")\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == \"Add Feature\"\n\n\ndef test_validate_plan_title_preserves_original_in_error() -> None:\n    \"\"\"Error includes the original unmodified title.\"\"\"\n    result = validate_plan_title(\"   ab   \")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.raw_title == \"   ab   \"\n","structuredPatch":[{"oldStart":602,"oldLines":7,"newStart":602,"newLines":7,"lines":[" def test_generate_draft_pr_branch_name_format(","     title: str, timestamp: datetime, objective_id: int | None, expected: str"," ) -> None:","-    \"\"\"Branch name follows planned/{slug}-{timestamp} format.\"\"\"","+    \"\"\"Branch name follows plnd/{slug}-{timestamp} format.\"\"\"","     assert generate_draft_pr_branch_name(title, timestamp, objective_id=objective_id) == expected"," "," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"0bf63b80-f9a4-4cda-bdc0-dd97748d188c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01VWonkTzeuuiZEnDEoiS5tc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01X1xXUmCj9RGw6rXjuPMaoW","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","old_string":"    assert result.startswith(\"planned/\")\n    assert result.endswith(\"-01-15-1430\")","new_string":"    assert result.startswith(\"plnd/\")\n    assert result.endswith(\"-01-15-1430\")"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":183,"cache_read_input_tokens":89255,"cache_creation":{"ephemeral_5m_input_tokens":183,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHkiqQexqsqQtpnfAfy","type":"assistant","uuid":"a601d59c-2d9e-499c-8415-b30b5e54956e","timestamp":"2026-02-22T14:47:01.921Z"}
{"parentUuid":"a601d59c-2d9e-499c-8415-b30b5e54956e","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01X1xXUmCj9RGw6rXjuPMaoW","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/core/utils/test_naming.py has been updated successfully."}]},"uuid":"0b9f4be7-739f-42e2-bb0b-bcd3920e273f","timestamp":"2026-02-22T14:47:02.597Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","oldString":"    assert result.startswith(\"planned/\")\n    assert result.endswith(\"-01-15-1430\")","newString":"    assert result.startswith(\"plnd/\")\n    assert result.endswith(\"-01-15-1430\")","originalFile":"from datetime import datetime\nfrom pathlib import Path\n\nimport pytest\n\nfrom erk_shared.naming import (\n    WORKTREE_DATE_SUFFIX_FORMAT,\n    InvalidObjectiveSlug,\n    InvalidPlanTitle,\n    ValidObjectiveSlug,\n    ValidPlanTitle,\n    default_branch_for_worktree,\n    derive_branch_name_from_title,\n    ensure_unique_worktree_name,\n    extract_leading_issue_number,\n    extract_objective_number,\n    extract_plan_review_issue_number,\n    extract_trailing_number,\n    generate_draft_pr_branch_name,\n    generate_issue_branch_name,\n    sanitize_branch_component,\n    sanitize_worktree_name,\n    strip_plan_from_filename,\n    validate_objective_slug,\n    validate_plan_title,\n)\n\n\ndef _get_current_date_suffix() -> str:\n    \"\"\"Get the current date suffix for plan-derived worktrees.\"\"\"\n    return datetime.now().strftime(WORKTREE_DATE_SUFFIX_FORMAT)\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\" Foo Bar \", \"foo-bar\"),\n        (\"A/B C\", \"a/b-c\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-branch-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-branch-name\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        (\"short\", \"short\"),\n        # Test long names with trailing hyphens are stripped\n        (\n            \"branch-name-with-dash-at-position-31-\",\n            \"branch-name-with-dash-at-positi\",\n        ),\n        # Test very long names truncate to 31\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".hidden-file\", \"hidden-file\"),\n        (\"file.extension\", \"file-extension\"),\n    ],\n)\ndef test_sanitize_branch_component(value: str, expected: str) -> None:\n    assert sanitize_branch_component(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"feature X\", \"feature-x\"),\n        (\"/ / \", \"work\"),\n    ],\n)\ndef test_default_branch_for_worktree(value: str, expected: str) -> None:\n    assert default_branch_for_worktree(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\"Add_Auth_Feature\", \"add-auth-feature\"),\n        (\"My_Cool_Plan\", \"my-cool-plan\"),\n        (\"FOO_BAR_BAZ\", \"foo-bar-baz\"),\n        (\"feature__with___multiple___underscores\", \"feature-with-multiple-underscor\"),\n        (\"name-with-hyphens\", \"name-with-hyphens\"),\n        (\"Mixed_Case-Hyphen_Underscore\", \"mixed-case-hyphen-underscore\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        (\"   spaces   \", \"spaces\"),\n        (\"---\", \"work\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-worktree-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-worktree-na\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        # Test truncation with trailing hyphen removal\n        (\n            \"worktree-name-with-dash-at-position-31-\",\n            \"worktree-name-with-dash-at-posi\",\n        ),\n        # Test truncation that ends with hyphen is stripped\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".worker-impl\", \"worker-impl\"),\n        (\"fix-.worker\", \"fix-worker\"),\n        (\"name.with.dots\", \"name-with-dots\"),\n    ],\n)\ndef test_sanitize_worktree_name(value: str, expected: str) -> None:\n    assert sanitize_worktree_name(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"devclikit-extraction-plan\", \"devclikit-extraction\"),\n        (\"my-feature-plan\", \"my-feature\"),\n        (\"plan-for-auth\", \"for-auth\"),\n        (\"plan-something\", \"something\"),\n        (\"something-plan\", \"something\"),\n        (\"something-plan-else\", \"something-else\"),\n        (\"plan-my-plan-feature\", \"my-feature\"),\n        (\"my-plan-feature-plan\", \"my-feature\"),\n        (\"plan\", \"plan\"),\n        (\"my_feature_plan\", \"my_feature\"),\n        (\"my feature plan\", \"my feature\"),\n        (\"my-feature_plan\", \"my-feature\"),\n        (\"MY-FEATURE-PLAN\", \"MY-FEATURE\"),\n        (\"My-Feature-Plan\", \"My-Feature\"),\n        (\"my-feature-PLAN\", \"my-feature\"),\n        (\"airplane-feature\", \"airplane-feature\"),\n        (\"explain-system\", \"explain-system\"),\n        (\"planted-tree\", \"planted-tree\"),\n        (\"planning-session\", \"planning-session\"),\n        (\"plans-document\", \"plans-document\"),\n        (\"-plan-feature\", \"feature\"),\n        (\"feature-plan-\", \"feature\"),\n        (\"my-feature-implementation-plan\", \"my-feature\"),\n        (\"implementation-plan-for-auth\", \"for-auth\"),\n        (\"implementation_plan_feature\", \"feature\"),\n        (\"feature implementation plan\", \"feature\"),\n        (\"my-feature_implementation-plan\", \"my-feature\"),\n        (\"implementation_plan-for-auth\", \"for-auth\"),\n        (\"IMPLEMENTATION-PLAN-FEATURE\", \"FEATURE\"),\n        (\"Implementation-Plan-Feature\", \"Feature\"),\n        (\"my-IMPLEMENTATION-plan\", \"my\"),\n        (\"my-implementation-plan-feature\", \"my-feature\"),\n        (\"plan-implementation-plan\", \"implementation\"),\n        (\"plan implementation plan\", \"implementation\"),\n        (\"implementation-plan\", \"implementation\"),\n        (\"implementation_plan\", \"implementation\"),\n        (\"IMPLEMENTATION-PLAN\", \"IMPLEMENTATION\"),\n        (\"reimplementation-feature\", \"reimplementation-feature\"),\n        (\"implantation-system\", \"implantation-system\"),\n    ],\n)\ndef test_strip_plan_from_filename(value: str, expected: str) -> None:\n    assert strip_plan_from_filename(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"name\", \"expected_base\", \"expected_number\"),\n    [\n        (\"my-feature\", \"my-feature\", None),\n        (\"my-feature-2\", \"my-feature\", 2),\n        (\"fix-42\", \"fix\", 42),\n        (\"feature-3-test\", \"feature-3-test\", None),  # Number in middle, not trailing\n        (\"test-123\", \"test\", 123),\n        (\"no-number\", \"no-number\", None),\n        (\"v2-feature-10\", \"v2-feature\", 10),\n    ],\n)\ndef test_extract_trailing_number(\n    name: str, expected_base: str, expected_number: int | None\n) -> None:\n    \"\"\"Test extracting trailing numbers from worktree names.\"\"\"\n    base, number = extract_trailing_number(name)\n    assert base == expected_base\n    assert number == expected_number\n\n\ndef test_ensure_unique_worktree_name_first_time(tmp_path: Path) -> None:\n    \"\"\"Test first-time worktree creation gets only datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    # Should have datetime suffix in format -YY-MM-DD-HHMM\n    date_suffix = _get_current_date_suffix()\n    assert result == f\"my-feature-{date_suffix}\"\n    assert not (repo_dir / result).exists()\n\n\ndef test_ensure_unique_worktree_name_duplicate_same_minute(tmp_path: Path) -> None:\n    \"\"\"Test duplicate worktree in same minute adds -2 after datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    existing_name = f\"my-feature-{date_suffix}\"\n    (repo_dir / existing_name).mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-2\"\n    assert not (repo_dir / result).exists()\n    assert (repo_dir / existing_name).exists()\n\n\ndef test_ensure_unique_worktree_name_multiple_duplicates(tmp_path: Path) -> None:\n    \"\"\"Test multiple duplicates increment correctly.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    (repo_dir / f\"my-feature-{date_suffix}\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-2\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-3\").mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-4\"\n\n\ndef test_ensure_unique_worktree_name_with_existing_number(tmp_path: Path) -> None:\n    \"\"\"Test name with existing number in base preserves it.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    date_suffix = _get_current_date_suffix()\n    result = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    # Base name has number, should preserve it in datetime-suffixed name\n    assert result == f\"fix-v3-{date_suffix}\"\n\n    # Create it and try again\n    (repo_dir / result).mkdir()\n    result2 = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    assert result2 == f\"fix-v3-{date_suffix}-2\"\n\n\ndef test_sanitize_branch_component_truncates_at_31_chars() -> None:\n    \"\"\"Branch names should truncate to 31 characters maximum.\"\"\"\n    # Exactly 31 characters\n    assert len(sanitize_branch_component(\"a\" * 31)) == 31\n\n    # 32 characters truncates to 31\n    assert len(sanitize_branch_component(\"a\" * 32)) == 31\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = sanitize_branch_component(long_name)\n    assert len(result) == 31\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\ndef test_sanitize_branch_component_matches_worktree_length() -> None:\n    \"\"\"Branch and worktree names should have same length for same input.\"\"\"\n    test_name = \"very-long-feature-name-that-exceeds-thirty-characters-easily\"\n    branch = sanitize_branch_component(test_name)\n    worktree = sanitize_worktree_name(test_name)\n    assert len(branch) == len(worktree)\n    assert len(branch) == 31\n\n\ndef test_very_long_title_truncates_to_45_chars_total() -> None:\n    \"\"\"Regression test: 99-char title should truncate to max 45 chars total with datetime suffix.\n\n    This tests the bug fix where `erk implement` created excessively long branch names.\n    Example: \"refactor erk implement command to support interactive and\n    non-interactive execution modes\"\n\n    Note: The 31-char limit includes rstrip(\"-\") after truncation,\n    so actual length may be <= 31.\n    \"\"\"\n    # 89-character title that caused the original bug\n    long_title = (\n        \"refactor erk implement command to support interactive and non-interactive execution modes\"\n    )\n\n    # Sanitize the worktree name (should be <= 31 chars max, trailing hyphens stripped)\n    base_name = sanitize_worktree_name(long_title)\n    assert len(base_name) <= 31\n\n    # With datetime suffix (-YY-MM-DD-HHMM = 14 chars including hyphen), total should be <= 45 chars\n    date_suffix = \"25-11-23-1430\"\n    name_with_date = f\"{base_name}-{date_suffix}\"\n    assert len(name_with_date) <= 45\n\n    # Verify the base name is correctly truncated (30 chars after rstrip of trailing hyphen)\n    assert base_name == \"refactor-erk-implement-command\"\n    assert len(base_name) == 30  # 31 chars truncated, then trailing hyphen stripped\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"expected\"),\n    [\n        (\"My Feature\", \"my-feature\"),\n        (\"Fix Bug #123!\", \"fix-bug-123\"),\n        (\"Simple\", \"simple\"),\n        (\"With_Underscores\", \"with-underscores\"),\n        (\"UPPERCASE\", \"uppercase\"),\n        (\"spaces  multiple   here\", \"spaces-multiple-here\"),\n        (\"leading---hyphens\", \"leading-hyphens\"),\n        (\"trailing---\", \"trailing\"),\n        (\"---both---\", \"both\"),\n        # Test 30-char truncation (different from sanitize_branch_component's 31)\n        (\"a\" * 40, \"a\" * 30),\n        (\"abcdefghijklmnopqrstuvwxyz-1234567890\", \"abcdefghijklmnopqrstuvwxyz-123\"),\n        # Trailing hyphen after truncation is removed\n        (\"this-is-thirty-chars-exact-yes\", \"this-is-thirty-chars-exact-yes\"),  # Exactly 30\n        (\"this-is-thirty-one-chars-exact\", \"this-is-thirty-one-chars-exact\"),  # 31 chars -> 30\n        # Test non-alphanumeric characters\n        (\"feat: add something\", \"feat-add-something\"),\n        (\"feat/add/something\", \"feat-add-something\"),\n        (\"feat(scope): message\", \"feat-scope-message\"),\n    ],\n)\ndef test_derive_branch_name_from_title(title: str, expected: str) -> None:\n    \"\"\"Test derive_branch_name_from_title matches workflow logic.\"\"\"\n    assert derive_branch_name_from_title(title) == expected\n\n\ndef test_derive_branch_name_truncates_to_30_chars() -> None:\n    \"\"\"Branch names from titles should truncate to 30 characters maximum.\n\n    This matches the workflow logic in plan-implement.yml which uses:\n    BRANCH_NAME=\"${BRANCH_NAME:0:30}\"\n    \"\"\"\n    # Exactly 30 characters\n    assert len(derive_branch_name_from_title(\"a\" * 30)) == 30\n\n    # 31 characters truncates to 30\n    assert len(derive_branch_name_from_title(\"a\" * 31)) == 30\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = derive_branch_name_from_title(long_name)\n    assert len(result) == 30\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\n# Tests for generate_issue_branch_name\n@pytest.mark.parametrize(\n    (\"issue_number\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # Standard case\n        (123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), \"P123-fix-auth-bug-01-15-1430\"),\n        # Integer issue number\n        (42, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-my-feature-06-20-1000\"),\n        # String issue number\n        (\"456\", \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P456-add-tests-12-31-2359\"),\n        # Midnight edge case\n        (789, \"Update Docs\", datetime(2024, 1, 1, 0, 0), \"P789-update-docs-01-01-0000\"),\n    ],\n)\ndef test_generate_issue_branch_name_format(\n    issue_number: int | str, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name follows P{num}-{slug}-{timestamp} format.\"\"\"\n    assert generate_issue_branch_name(issue_number, title, timestamp, objective_id=None) == expected\n\n\ndef test_generate_issue_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    # Very long title that would exceed 31 chars for base name\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=None)\n\n    # Base (P123-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"P123-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_issue_branch_name_preserves_hyphens_in_title() -> None:\n    \"\"\"Hyphens in titles are preserved (not doubled).\"\"\"\n    result = generate_issue_branch_name(\n        123, \"fix-auth-bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Should be P123-fix-auth-bug-..., not P123--fix-auth-bug-...\n    assert \"P123-fix-auth-bug-\" in result\n    assert \"--\" not in result\n\n\ndef test_generate_issue_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_issue_branch_name(\n        123, \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Special chars should be replaced with hyphens, then collapsed\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\n@pytest.mark.parametrize(\n    (\"issue_number\", \"objective_id\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # With objective ID\n        (\n            123,\n            456,\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            \"P123-O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Different objective ID\n        (42, 789, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-O789-my-feature-06-20-1000\"),\n        # Single digit objective\n        (100, 1, \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P100-O1-add-tests-12-31-2359\"),\n    ],\n)\ndef test_generate_issue_branch_name_with_objective(\n    issue_number: int, objective_id: int, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name includes objective ID when provided.\"\"\"\n    result = generate_issue_branch_name(issue_number, title, timestamp, objective_id=objective_id)\n    assert result == expected\n\n\ndef test_generate_issue_branch_name_with_objective_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=456)\n\n    # Base (P123-O456-...) should be truncated to 31 chars, then timestamp appended\n    assert len(result) <= 42\n    assert result.startswith(\"P123-O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # With objective ID\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 456),\n        (\"P42-O789-my-feature-06-20-1000\", 789),\n        (\"P100-O1-add-tests-12-31-2359\", 1),\n        # Lowercase o prefix (case insensitive)\n        (\"P123-o456-fix-bug\", 456),\n        (\"p123-o789-feature\", 789),\n        # Draft-PR branches with objective ID (current prefix)\n        (\"plnd/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"plnd/O1-add-tests-12-31-2359\", 1),\n        # Legacy planned/ prefix branches with objective ID\n        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"planned/O1-add-tests-12-31-2359\", 1),\n        # Legacy plan/ prefix branches with objective ID\n        (\"plan/O456-fix-auth-01-15-1430\", 456),\n        (\"plan/O7709-plan-lazy-tip-sync-f-02-21-1116\", 7709),\n        # Without objective ID\n        (\"P123-fix-auth-bug-01-15-1430\", None),\n        (\"P42-my-feature\", None),\n        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"plan/fix-auth-bug-01-15-1430\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_objective_number(branch_name: str, expected: int | None) -> None:\n    \"\"\"Extract objective ID from branch name.\"\"\"\n    assert extract_objective_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Standard format (still works with objective ID in branch)\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 123),\n        (\"P42-O789-my-feature\", 42),\n        # Without objective ID (existing behavior)\n        (\"P2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"P42-fix-bug\", 42),\n        # Legacy format without P prefix\n        (\"2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"42-fix-bug\", 42),\n        # Draft-PR branches return None (no extractable issue number)\n        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"plnd/O456-fix-auth-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"planned/O456-fix-auth-01-15-1430\", None),\n        # Invalid formats\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_leading_issue_number_with_objective_format(\n    branch_name: str, expected: int | None\n) -> None:\n    \"\"\"Extract leading issue number still works with objective ID in branch name.\"\"\"\n    assert extract_leading_issue_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Valid plan review branches (current prefix)\n        (\"plnd/review-6214-01-15-1430\", 6214),\n        (\"plnd/review-42-01-28-0930\", 42),\n        (\"plnd/review-1-12-31-2359\", 1),\n        (\"plnd/review-99999-01-01-0000\", 99999),\n        # Legacy planned/ prefix still works\n        (\"planned/review-6214-01-15-1430\", 6214),\n        (\"planned/review-42-01-28-0930\", 42),\n        (\"planned/review-1-12-31-2359\", 1),\n        (\"planned/review-99999-01-01-0000\", 99999),\n        # Not plan review branches\n        (\"P2382-convert-erk-create-raw-ext\", None),\n        (\"2382-convert-erk-create-raw-ext\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n        (\"plnd/review\", None),  # Missing issue number\n        (\"plnd/review-\", None),  # Missing issue number\n        (\"plnd/review-abc-01-15-1430\", None),  # Non-numeric issue\n    ],\n)\ndef test_extract_plan_review_issue_number(branch_name: str, expected: int | None) -> None:\n    assert extract_plan_review_issue_number(branch_name) == expected\n\n\n# Tests for generate_draft_pr_branch_name\n@pytest.mark.parametrize(\n    (\"title\", \"timestamp\", \"objective_id\", \"expected\"),\n    [\n        # Standard case without objective\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            None,\n            \"plnd/fix-auth-bug-01-15-1430\",\n        ),\n        # Different timestamp\n        (\n            \"My Feature\",\n            datetime(2024, 6, 20, 10, 0),\n            None,\n            \"plnd/my-feature-06-20-1000\",\n        ),\n        # Midnight edge case\n        (\n            \"Update Docs\",\n            datetime(2024, 1, 1, 0, 0),\n            None,\n            \"plnd/update-docs-01-01-0000\",\n        ),\n        # With objective ID\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            456,\n            \"plnd/O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Single digit objective\n        (\n            \"Add Tests\",\n            datetime(2024, 12, 31, 23, 59),\n            1,\n            \"plnd/O1-add-tests-12-31-2359\",\n        ),\n    ],\n)\ndef test_generate_draft_pr_branch_name_format(\n    title: str, timestamp: datetime, objective_id: int | None, expected: str\n) -> None:\n    \"\"\"Branch name follows plnd/{slug}-{timestamp} format.\"\"\"\n    assert generate_draft_pr_branch_name(title, timestamp, objective_id=objective_id) == expected\n\n\ndef test_generate_draft_pr_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=None)\n\n    # Base (plan-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"planned/\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_draft_pr_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_draft_pr_branch_name(\n        \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\ndef test_generate_draft_pr_branch_name_with_objective_truncates() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=456)\n\n    assert len(result) <= 42\n    assert result.startswith(\"planned/O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    assert not result[:-11].endswith(\"-\")\n\n\n# Tests for validate_objective_slug\n@pytest.mark.parametrize(\n    \"slug\",\n    [\n        \"build-auth-system\",\n        \"refactor-gateway\",\n        \"add-dark-mode\",\n        \"simple\",\n        \"abc\",\n        \"a\" * 40,\n        \"fix-tui-layout\",\n        \"add-v2-support\",\n        \"feature123\",\n    ],\n)\ndef test_validate_objective_slug_valid(slug: str) -> None:\n    \"\"\"Valid slugs return ValidObjectiveSlug.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, ValidObjectiveSlug)\n    assert result.slug == slug\n\n\n@pytest.mark.parametrize(\n    (\"slug\", \"reason_fragment\"),\n    [\n        (\"ab\", \"Too short\"),\n        (\"a\" * 41, \"Too long\"),\n        (\"Build-Auth\", \"Does not match\"),\n        (\"UPPERCASE\", \"Does not match\"),\n        (\"123-start\", \"Does not match\"),\n        (\"my--slug\", \"Does not match\"),\n        (\"has spaces\", \"Does not match\"),\n        (\"with_underscores\", \"Does not match\"),\n        (\"has.dots\", \"Does not match\"),\n        (\"-leading-hyphen\", \"Does not match\"),\n        (\"trailing-hyphen-\", \"Does not match\"),\n    ],\n)\ndef test_validate_objective_slug_invalid(slug: str, reason_fragment: str) -> None:\n    \"\"\"Invalid slugs return InvalidObjectiveSlug with matching reason.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_objective_slug_error_message_includes_pattern() -> None:\n    \"\"\"Error message includes the regex pattern for agent self-correction.\"\"\"\n    result = validate_objective_slug(\"INVALID\")\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert \"^[a-z][a-z0-9]*(-[a-z0-9]+)*$\" in result.message\n    assert \"INVALID\" in result.message\n\n\n# Tests for validate_plan_title\n@pytest.mark.parametrize(\n    \"title\",\n    [\n        \"Add User Authentication\",\n        \"Refactor Gateway Layer\",\n        \"Fix CLI Argument Parsing\",\n        \"hello\",\n        \"a\" * 100,\n        \"Fix Bug #123 in Auth Module\",\n        \"café au lait feature\",\n        \"Update the README file\",\n        \"Add v2 API support for external clients\",\n    ],\n)\ndef test_validate_plan_title_valid(title: str) -> None:\n    \"\"\"Valid titles return ValidPlanTitle.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == title.strip()\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"reason_fragment\"),\n    [\n        (\"\", \"empty\"),\n        (\"   \", \"empty\"),\n        (\"\\t\\n\", \"empty\"),\n        (\"Plan\", \"Too short\"),\n        (\"ab\", \"Too short\"),\n        (\"a\" * 101, \"Too long\"),\n        (\"12345\", \"at least one alphabetic\"),\n        (\"12345 67890\", \"at least one alphabetic\"),\n        (\"!@#$%^&*()\", \"at least one alphabetic\"),\n        (\"\\U0001f680\\U0001f389\\U0001f525\\U0001f4a5\\U0001f31f\", \"at least one alphabetic\"),\n        (\"\\u4f60\\u597d\\u4e16\\u754c\\u7684\\u8ba1\\u5212\", \"No usable content\"),\n    ],\n)\ndef test_validate_plan_title_invalid(title: str, reason_fragment: str) -> None:\n    \"\"\"Invalid titles return InvalidPlanTitle with matching reason.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, InvalidPlanTitle)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_plan_title_error_message_includes_rules() -> None:\n    \"\"\"Error message includes rules for agent self-correction.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert \"5-100 characters\" in result.message\n    assert \"at least one alphabetic\" in result.message\n    assert \"Valid examples\" in result.message\n    assert \"Invalid examples\" in result.message\n\n\ndef test_validate_plan_title_error_type() -> None:\n    \"\"\"Error type is machine-readable.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.error_type == \"invalid-plan-title\"\n\n\ndef test_validate_plan_title_strips_whitespace() -> None:\n    \"\"\"Leading/trailing whitespace is stripped before validation.\"\"\"\n    result = validate_plan_title(\"  Add Feature  \")\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == \"Add Feature\"\n\n\ndef test_validate_plan_title_preserves_original_in_error() -> None:\n    \"\"\"Error includes the original unmodified title.\"\"\"\n    result = validate_plan_title(\"   ab   \")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.raw_title == \"   ab   \"\n","structuredPatch":[{"oldStart":616,"oldLines":7,"newStart":616,"newLines":7,"lines":["     # Base (plan-...) should be truncated to 31 chars, then timestamp appended","     # Total = 31 + 11 (timestamp with hyphen) = 42 chars max","     assert len(result) <= 42","-    assert result.startswith(\"planned/\")","+    assert result.startswith(\"plnd/\")","     assert result.endswith(\"-01-15-1430\")","     # No trailing hyphen before timestamp","     assert not result[:-11].endswith(\"-\")"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"0b9f4be7-739f-42e2-bb0b-bcd3920e273f","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Dne7W5iJLtzsDsVVxey6R7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HZzoKaptQPhpGiDdhanctN","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","old_string":"    assert result.startswith(\"planned/O456-\")","new_string":"    assert result.startswith(\"plnd/O456-\")"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":205,"cache_read_input_tokens":89438,"cache_creation":{"ephemeral_5m_input_tokens":205,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHm32J6VZA2ra4bmv3s","type":"assistant","uuid":"3c005f1a-2ea1-4938-b635-fdd679048934","timestamp":"2026-02-22T14:47:05.465Z"}
{"parentUuid":"3c005f1a-2ea1-4938-b635-fdd679048934","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HZzoKaptQPhpGiDdhanctN","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/core/utils/test_naming.py has been updated successfully."}]},"uuid":"5f79baae-72ab-471b-b43b-478e96b3dcc4","timestamp":"2026-02-22T14:47:06.146Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/core/utils/test_naming.py","oldString":"    assert result.startswith(\"planned/O456-\")","newString":"    assert result.startswith(\"plnd/O456-\")","originalFile":"from datetime import datetime\nfrom pathlib import Path\n\nimport pytest\n\nfrom erk_shared.naming import (\n    WORKTREE_DATE_SUFFIX_FORMAT,\n    InvalidObjectiveSlug,\n    InvalidPlanTitle,\n    ValidObjectiveSlug,\n    ValidPlanTitle,\n    default_branch_for_worktree,\n    derive_branch_name_from_title,\n    ensure_unique_worktree_name,\n    extract_leading_issue_number,\n    extract_objective_number,\n    extract_plan_review_issue_number,\n    extract_trailing_number,\n    generate_draft_pr_branch_name,\n    generate_issue_branch_name,\n    sanitize_branch_component,\n    sanitize_worktree_name,\n    strip_plan_from_filename,\n    validate_objective_slug,\n    validate_plan_title,\n)\n\n\ndef _get_current_date_suffix() -> str:\n    \"\"\"Get the current date suffix for plan-derived worktrees.\"\"\"\n    return datetime.now().strftime(WORKTREE_DATE_SUFFIX_FORMAT)\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\" Foo Bar \", \"foo-bar\"),\n        (\"A/B C\", \"a/b-c\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-branch-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-branch-name\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        (\"short\", \"short\"),\n        # Test long names with trailing hyphens are stripped\n        (\n            \"branch-name-with-dash-at-position-31-\",\n            \"branch-name-with-dash-at-positi\",\n        ),\n        # Test very long names truncate to 31\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".hidden-file\", \"hidden-file\"),\n        (\"file.extension\", \"file-extension\"),\n    ],\n)\ndef test_sanitize_branch_component(value: str, expected: str) -> None:\n    assert sanitize_branch_component(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"feature X\", \"feature-x\"),\n        (\"/ / \", \"work\"),\n    ],\n)\ndef test_default_branch_for_worktree(value: str, expected: str) -> None:\n    assert default_branch_for_worktree(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"Foo\", \"foo\"),\n        (\"Add_Auth_Feature\", \"add-auth-feature\"),\n        (\"My_Cool_Plan\", \"my-cool-plan\"),\n        (\"FOO_BAR_BAZ\", \"foo-bar-baz\"),\n        (\"feature__with___multiple___underscores\", \"feature-with-multiple-underscor\"),\n        (\"name-with-hyphens\", \"name-with-hyphens\"),\n        (\"Mixed_Case-Hyphen_Underscore\", \"mixed-case-hyphen-underscore\"),\n        (\"@@weird!!name??\", \"weird-name\"),\n        (\"   spaces   \", \"spaces\"),\n        (\"---\", \"work\"),\n        # Test truncation to 31 characters\n        (\"a\" * 35, \"a\" * 31),\n        (\n            \"this-is-a-very-long-worktree-name-that-exceeds-thirty-characters\",\n            \"this-is-a-very-long-worktree-na\",\n        ),\n        (\"exactly-31-characters-long-oka\", \"exactly-31-characters-long-oka\"),\n        (\n            \"32-characters-long-should-be-abc\",\n            \"32-characters-long-should-be-ab\",\n        ),  # Truncates to 31\n        # Test truncation with trailing hyphen removal\n        (\n            \"worktree-name-with-dash-at-position-31-\",\n            \"worktree-name-with-dash-at-posi\",\n        ),\n        # Test truncation that ends with hyphen is stripped\n        (\n            \"1234567890123456789012345678901-extra\",\n            \"1234567890123456789012345678901\",\n        ),  # Hyphen at position 31 stripped\n        # Test dot handling - dots should be replaced with hyphens\n        (\".worker-impl\", \"worker-impl\"),\n        (\"fix-.worker\", \"fix-worker\"),\n        (\"name.with.dots\", \"name-with-dots\"),\n    ],\n)\ndef test_sanitize_worktree_name(value: str, expected: str) -> None:\n    assert sanitize_worktree_name(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        (\"devclikit-extraction-plan\", \"devclikit-extraction\"),\n        (\"my-feature-plan\", \"my-feature\"),\n        (\"plan-for-auth\", \"for-auth\"),\n        (\"plan-something\", \"something\"),\n        (\"something-plan\", \"something\"),\n        (\"something-plan-else\", \"something-else\"),\n        (\"plan-my-plan-feature\", \"my-feature\"),\n        (\"my-plan-feature-plan\", \"my-feature\"),\n        (\"plan\", \"plan\"),\n        (\"my_feature_plan\", \"my_feature\"),\n        (\"my feature plan\", \"my feature\"),\n        (\"my-feature_plan\", \"my-feature\"),\n        (\"MY-FEATURE-PLAN\", \"MY-FEATURE\"),\n        (\"My-Feature-Plan\", \"My-Feature\"),\n        (\"my-feature-PLAN\", \"my-feature\"),\n        (\"airplane-feature\", \"airplane-feature\"),\n        (\"explain-system\", \"explain-system\"),\n        (\"planted-tree\", \"planted-tree\"),\n        (\"planning-session\", \"planning-session\"),\n        (\"plans-document\", \"plans-document\"),\n        (\"-plan-feature\", \"feature\"),\n        (\"feature-plan-\", \"feature\"),\n        (\"my-feature-implementation-plan\", \"my-feature\"),\n        (\"implementation-plan-for-auth\", \"for-auth\"),\n        (\"implementation_plan_feature\", \"feature\"),\n        (\"feature implementation plan\", \"feature\"),\n        (\"my-feature_implementation-plan\", \"my-feature\"),\n        (\"implementation_plan-for-auth\", \"for-auth\"),\n        (\"IMPLEMENTATION-PLAN-FEATURE\", \"FEATURE\"),\n        (\"Implementation-Plan-Feature\", \"Feature\"),\n        (\"my-IMPLEMENTATION-plan\", \"my\"),\n        (\"my-implementation-plan-feature\", \"my-feature\"),\n        (\"plan-implementation-plan\", \"implementation\"),\n        (\"plan implementation plan\", \"implementation\"),\n        (\"implementation-plan\", \"implementation\"),\n        (\"implementation_plan\", \"implementation\"),\n        (\"IMPLEMENTATION-PLAN\", \"IMPLEMENTATION\"),\n        (\"reimplementation-feature\", \"reimplementation-feature\"),\n        (\"implantation-system\", \"implantation-system\"),\n    ],\n)\ndef test_strip_plan_from_filename(value: str, expected: str) -> None:\n    assert strip_plan_from_filename(value) == expected\n\n\n@pytest.mark.parametrize(\n    (\"name\", \"expected_base\", \"expected_number\"),\n    [\n        (\"my-feature\", \"my-feature\", None),\n        (\"my-feature-2\", \"my-feature\", 2),\n        (\"fix-42\", \"fix\", 42),\n        (\"feature-3-test\", \"feature-3-test\", None),  # Number in middle, not trailing\n        (\"test-123\", \"test\", 123),\n        (\"no-number\", \"no-number\", None),\n        (\"v2-feature-10\", \"v2-feature\", 10),\n    ],\n)\ndef test_extract_trailing_number(\n    name: str, expected_base: str, expected_number: int | None\n) -> None:\n    \"\"\"Test extracting trailing numbers from worktree names.\"\"\"\n    base, number = extract_trailing_number(name)\n    assert base == expected_base\n    assert number == expected_number\n\n\ndef test_ensure_unique_worktree_name_first_time(tmp_path: Path) -> None:\n    \"\"\"Test first-time worktree creation gets only datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    # Should have datetime suffix in format -YY-MM-DD-HHMM\n    date_suffix = _get_current_date_suffix()\n    assert result == f\"my-feature-{date_suffix}\"\n    assert not (repo_dir / result).exists()\n\n\ndef test_ensure_unique_worktree_name_duplicate_same_minute(tmp_path: Path) -> None:\n    \"\"\"Test duplicate worktree in same minute adds -2 after datetime suffix.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    existing_name = f\"my-feature-{date_suffix}\"\n    (repo_dir / existing_name).mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-2\"\n    assert not (repo_dir / result).exists()\n    assert (repo_dir / existing_name).exists()\n\n\ndef test_ensure_unique_worktree_name_multiple_duplicates(tmp_path: Path) -> None:\n    \"\"\"Test multiple duplicates increment correctly.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    date_suffix = _get_current_date_suffix()\n    (repo_dir / f\"my-feature-{date_suffix}\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-2\").mkdir()\n    (repo_dir / f\"my-feature-{date_suffix}-3\").mkdir()\n\n    git_ops = RealGit()\n    result = ensure_unique_worktree_name(\"my-feature\", repo_dir, git_ops)\n\n    assert result == f\"my-feature-{date_suffix}-4\"\n\n\ndef test_ensure_unique_worktree_name_with_existing_number(tmp_path: Path) -> None:\n    \"\"\"Test name with existing number in base preserves it.\"\"\"\n    from erk_shared.gateway.git.real import RealGit\n\n    repo_dir = tmp_path / \"erks\"\n    repo_dir.mkdir()\n\n    git_ops = RealGit()\n    date_suffix = _get_current_date_suffix()\n    result = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    # Base name has number, should preserve it in datetime-suffixed name\n    assert result == f\"fix-v3-{date_suffix}\"\n\n    # Create it and try again\n    (repo_dir / result).mkdir()\n    result2 = ensure_unique_worktree_name(\"fix-v3\", repo_dir, git_ops)\n\n    assert result2 == f\"fix-v3-{date_suffix}-2\"\n\n\ndef test_sanitize_branch_component_truncates_at_31_chars() -> None:\n    \"\"\"Branch names should truncate to 31 characters maximum.\"\"\"\n    # Exactly 31 characters\n    assert len(sanitize_branch_component(\"a\" * 31)) == 31\n\n    # 32 characters truncates to 31\n    assert len(sanitize_branch_component(\"a\" * 32)) == 31\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = sanitize_branch_component(long_name)\n    assert len(result) == 31\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\ndef test_sanitize_branch_component_matches_worktree_length() -> None:\n    \"\"\"Branch and worktree names should have same length for same input.\"\"\"\n    test_name = \"very-long-feature-name-that-exceeds-thirty-characters-easily\"\n    branch = sanitize_branch_component(test_name)\n    worktree = sanitize_worktree_name(test_name)\n    assert len(branch) == len(worktree)\n    assert len(branch) == 31\n\n\ndef test_very_long_title_truncates_to_45_chars_total() -> None:\n    \"\"\"Regression test: 99-char title should truncate to max 45 chars total with datetime suffix.\n\n    This tests the bug fix where `erk implement` created excessively long branch names.\n    Example: \"refactor erk implement command to support interactive and\n    non-interactive execution modes\"\n\n    Note: The 31-char limit includes rstrip(\"-\") after truncation,\n    so actual length may be <= 31.\n    \"\"\"\n    # 89-character title that caused the original bug\n    long_title = (\n        \"refactor erk implement command to support interactive and non-interactive execution modes\"\n    )\n\n    # Sanitize the worktree name (should be <= 31 chars max, trailing hyphens stripped)\n    base_name = sanitize_worktree_name(long_title)\n    assert len(base_name) <= 31\n\n    # With datetime suffix (-YY-MM-DD-HHMM = 14 chars including hyphen), total should be <= 45 chars\n    date_suffix = \"25-11-23-1430\"\n    name_with_date = f\"{base_name}-{date_suffix}\"\n    assert len(name_with_date) <= 45\n\n    # Verify the base name is correctly truncated (30 chars after rstrip of trailing hyphen)\n    assert base_name == \"refactor-erk-implement-command\"\n    assert len(base_name) == 30  # 31 chars truncated, then trailing hyphen stripped\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"expected\"),\n    [\n        (\"My Feature\", \"my-feature\"),\n        (\"Fix Bug #123!\", \"fix-bug-123\"),\n        (\"Simple\", \"simple\"),\n        (\"With_Underscores\", \"with-underscores\"),\n        (\"UPPERCASE\", \"uppercase\"),\n        (\"spaces  multiple   here\", \"spaces-multiple-here\"),\n        (\"leading---hyphens\", \"leading-hyphens\"),\n        (\"trailing---\", \"trailing\"),\n        (\"---both---\", \"both\"),\n        # Test 30-char truncation (different from sanitize_branch_component's 31)\n        (\"a\" * 40, \"a\" * 30),\n        (\"abcdefghijklmnopqrstuvwxyz-1234567890\", \"abcdefghijklmnopqrstuvwxyz-123\"),\n        # Trailing hyphen after truncation is removed\n        (\"this-is-thirty-chars-exact-yes\", \"this-is-thirty-chars-exact-yes\"),  # Exactly 30\n        (\"this-is-thirty-one-chars-exact\", \"this-is-thirty-one-chars-exact\"),  # 31 chars -> 30\n        # Test non-alphanumeric characters\n        (\"feat: add something\", \"feat-add-something\"),\n        (\"feat/add/something\", \"feat-add-something\"),\n        (\"feat(scope): message\", \"feat-scope-message\"),\n    ],\n)\ndef test_derive_branch_name_from_title(title: str, expected: str) -> None:\n    \"\"\"Test derive_branch_name_from_title matches workflow logic.\"\"\"\n    assert derive_branch_name_from_title(title) == expected\n\n\ndef test_derive_branch_name_truncates_to_30_chars() -> None:\n    \"\"\"Branch names from titles should truncate to 30 characters maximum.\n\n    This matches the workflow logic in plan-implement.yml which uses:\n    BRANCH_NAME=\"${BRANCH_NAME:0:30}\"\n    \"\"\"\n    # Exactly 30 characters\n    assert len(derive_branch_name_from_title(\"a\" * 30)) == 30\n\n    # 31 characters truncates to 30\n    assert len(derive_branch_name_from_title(\"a\" * 31)) == 30\n\n    # Long descriptive name gets truncated\n    long_name = \"fix-dependency-injection-in-simplesubmitpy-to-eliminate-test-mocking\"\n    result = derive_branch_name_from_title(long_name)\n    assert len(result) == 30\n    assert not result.endswith(\"-\")  # No trailing hyphens after truncation\n\n\n# Tests for generate_issue_branch_name\n@pytest.mark.parametrize(\n    (\"issue_number\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # Standard case\n        (123, \"Fix Auth Bug\", datetime(2024, 1, 15, 14, 30), \"P123-fix-auth-bug-01-15-1430\"),\n        # Integer issue number\n        (42, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-my-feature-06-20-1000\"),\n        # String issue number\n        (\"456\", \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P456-add-tests-12-31-2359\"),\n        # Midnight edge case\n        (789, \"Update Docs\", datetime(2024, 1, 1, 0, 0), \"P789-update-docs-01-01-0000\"),\n    ],\n)\ndef test_generate_issue_branch_name_format(\n    issue_number: int | str, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name follows P{num}-{slug}-{timestamp} format.\"\"\"\n    assert generate_issue_branch_name(issue_number, title, timestamp, objective_id=None) == expected\n\n\ndef test_generate_issue_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    # Very long title that would exceed 31 chars for base name\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=None)\n\n    # Base (P123-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"P123-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_issue_branch_name_preserves_hyphens_in_title() -> None:\n    \"\"\"Hyphens in titles are preserved (not doubled).\"\"\"\n    result = generate_issue_branch_name(\n        123, \"fix-auth-bug\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Should be P123-fix-auth-bug-..., not P123--fix-auth-bug-...\n    assert \"P123-fix-auth-bug-\" in result\n    assert \"--\" not in result\n\n\ndef test_generate_issue_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_issue_branch_name(\n        123, \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    # Special chars should be replaced with hyphens, then collapsed\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\n@pytest.mark.parametrize(\n    (\"issue_number\", \"objective_id\", \"title\", \"timestamp\", \"expected\"),\n    [\n        # With objective ID\n        (\n            123,\n            456,\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            \"P123-O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Different objective ID\n        (42, 789, \"My Feature\", datetime(2024, 6, 20, 10, 0), \"P42-O789-my-feature-06-20-1000\"),\n        # Single digit objective\n        (100, 1, \"Add Tests\", datetime(2024, 12, 31, 23, 59), \"P100-O1-add-tests-12-31-2359\"),\n    ],\n)\ndef test_generate_issue_branch_name_with_objective(\n    issue_number: int, objective_id: int, title: str, timestamp: datetime, expected: str\n) -> None:\n    \"\"\"Branch name includes objective ID when provided.\"\"\"\n    result = generate_issue_branch_name(issue_number, title, timestamp, objective_id=objective_id)\n    assert result == expected\n\n\ndef test_generate_issue_branch_name_with_objective_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_issue_branch_name(123, long_title, timestamp, objective_id=456)\n\n    # Base (P123-O456-...) should be truncated to 31 chars, then timestamp appended\n    assert len(result) <= 42\n    assert result.startswith(\"P123-O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # With objective ID\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 456),\n        (\"P42-O789-my-feature-06-20-1000\", 789),\n        (\"P100-O1-add-tests-12-31-2359\", 1),\n        # Lowercase o prefix (case insensitive)\n        (\"P123-o456-fix-bug\", 456),\n        (\"p123-o789-feature\", 789),\n        # Draft-PR branches with objective ID (current prefix)\n        (\"plnd/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"plnd/O1-add-tests-12-31-2359\", 1),\n        # Legacy planned/ prefix branches with objective ID\n        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\n        (\"planned/O1-add-tests-12-31-2359\", 1),\n        # Legacy plan/ prefix branches with objective ID\n        (\"plan/O456-fix-auth-01-15-1430\", 456),\n        (\"plan/O7709-plan-lazy-tip-sync-f-02-21-1116\", 7709),\n        # Without objective ID\n        (\"P123-fix-auth-bug-01-15-1430\", None),\n        (\"P42-my-feature\", None),\n        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"plan/fix-auth-bug-01-15-1430\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_objective_number(branch_name: str, expected: int | None) -> None:\n    \"\"\"Extract objective ID from branch name.\"\"\"\n    assert extract_objective_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Standard format (still works with objective ID in branch)\n        (\"P123-O456-fix-auth-bug-01-15-1430\", 123),\n        (\"P42-O789-my-feature\", 42),\n        # Without objective ID (existing behavior)\n        (\"P2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"P42-fix-bug\", 42),\n        # Legacy format without P prefix\n        (\"2382-convert-erk-create-raw-ext-12-05-2359\", 2382),\n        (\"42-fix-bug\", 42),\n        # Draft-PR branches return None (no extractable issue number)\n        (\"plnd/fix-auth-bug-01-15-1430\", None),\n        (\"plnd/O456-fix-auth-01-15-1430\", None),\n        (\"planned/fix-auth-bug-01-15-1430\", None),\n        (\"planned/O456-fix-auth-01-15-1430\", None),\n        # Invalid formats\n        (\"feature-branch\", None),\n        (\"master\", None),\n    ],\n)\ndef test_extract_leading_issue_number_with_objective_format(\n    branch_name: str, expected: int | None\n) -> None:\n    \"\"\"Extract leading issue number still works with objective ID in branch name.\"\"\"\n    assert extract_leading_issue_number(branch_name) == expected\n\n\n@pytest.mark.parametrize(\n    (\"branch_name\", \"expected\"),\n    [\n        # Valid plan review branches (current prefix)\n        (\"plnd/review-6214-01-15-1430\", 6214),\n        (\"plnd/review-42-01-28-0930\", 42),\n        (\"plnd/review-1-12-31-2359\", 1),\n        (\"plnd/review-99999-01-01-0000\", 99999),\n        # Legacy planned/ prefix still works\n        (\"planned/review-6214-01-15-1430\", 6214),\n        (\"planned/review-42-01-28-0930\", 42),\n        (\"planned/review-1-12-31-2359\", 1),\n        (\"planned/review-99999-01-01-0000\", 99999),\n        # Not plan review branches\n        (\"P2382-convert-erk-create-raw-ext\", None),\n        (\"2382-convert-erk-create-raw-ext\", None),\n        (\"feature-branch\", None),\n        (\"master\", None),\n        (\"plnd/review\", None),  # Missing issue number\n        (\"plnd/review-\", None),  # Missing issue number\n        (\"plnd/review-abc-01-15-1430\", None),  # Non-numeric issue\n    ],\n)\ndef test_extract_plan_review_issue_number(branch_name: str, expected: int | None) -> None:\n    assert extract_plan_review_issue_number(branch_name) == expected\n\n\n# Tests for generate_draft_pr_branch_name\n@pytest.mark.parametrize(\n    (\"title\", \"timestamp\", \"objective_id\", \"expected\"),\n    [\n        # Standard case without objective\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            None,\n            \"plnd/fix-auth-bug-01-15-1430\",\n        ),\n        # Different timestamp\n        (\n            \"My Feature\",\n            datetime(2024, 6, 20, 10, 0),\n            None,\n            \"plnd/my-feature-06-20-1000\",\n        ),\n        # Midnight edge case\n        (\n            \"Update Docs\",\n            datetime(2024, 1, 1, 0, 0),\n            None,\n            \"plnd/update-docs-01-01-0000\",\n        ),\n        # With objective ID\n        (\n            \"Fix Auth Bug\",\n            datetime(2024, 1, 15, 14, 30),\n            456,\n            \"plnd/O456-fix-auth-bug-01-15-1430\",\n        ),\n        # Single digit objective\n        (\n            \"Add Tests\",\n            datetime(2024, 12, 31, 23, 59),\n            1,\n            \"plnd/O1-add-tests-12-31-2359\",\n        ),\n    ],\n)\ndef test_generate_draft_pr_branch_name_format(\n    title: str, timestamp: datetime, objective_id: int | None, expected: str\n) -> None:\n    \"\"\"Branch name follows plnd/{slug}-{timestamp} format.\"\"\"\n    assert generate_draft_pr_branch_name(title, timestamp, objective_id=objective_id) == expected\n\n\ndef test_generate_draft_pr_branch_name_truncates_long_title() -> None:\n    \"\"\"Long titles are truncated before timestamp is appended.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=None)\n\n    # Base (plan-...) should be truncated to 31 chars, then timestamp appended\n    # Total = 31 + 11 (timestamp with hyphen) = 42 chars max\n    assert len(result) <= 42\n    assert result.startswith(\"plnd/\")\n    assert result.endswith(\"-01-15-1430\")\n    # No trailing hyphen before timestamp\n    assert not result[:-11].endswith(\"-\")\n\n\ndef test_generate_draft_pr_branch_name_handles_special_chars() -> None:\n    \"\"\"Special characters in titles are sanitized.\"\"\"\n    result = generate_draft_pr_branch_name(\n        \"Fix: Bug #456!\", datetime(2024, 1, 15, 14, 30), objective_id=None\n    )\n    assert \":\" not in result\n    assert \"#\" not in result\n    assert \"!\" not in result\n    assert \"--\" not in result\n\n\ndef test_generate_draft_pr_branch_name_with_objective_truncates() -> None:\n    \"\"\"Long titles are truncated with objective ID prefix included.\"\"\"\n    long_title = \"This is a very long title that should be truncated before timestamp\"\n    timestamp = datetime(2024, 1, 15, 14, 30)\n\n    result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=456)\n\n    assert len(result) <= 42\n    assert result.startswith(\"planned/O456-\")\n    assert result.endswith(\"-01-15-1430\")\n    assert not result[:-11].endswith(\"-\")\n\n\n# Tests for validate_objective_slug\n@pytest.mark.parametrize(\n    \"slug\",\n    [\n        \"build-auth-system\",\n        \"refactor-gateway\",\n        \"add-dark-mode\",\n        \"simple\",\n        \"abc\",\n        \"a\" * 40,\n        \"fix-tui-layout\",\n        \"add-v2-support\",\n        \"feature123\",\n    ],\n)\ndef test_validate_objective_slug_valid(slug: str) -> None:\n    \"\"\"Valid slugs return ValidObjectiveSlug.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, ValidObjectiveSlug)\n    assert result.slug == slug\n\n\n@pytest.mark.parametrize(\n    (\"slug\", \"reason_fragment\"),\n    [\n        (\"ab\", \"Too short\"),\n        (\"a\" * 41, \"Too long\"),\n        (\"Build-Auth\", \"Does not match\"),\n        (\"UPPERCASE\", \"Does not match\"),\n        (\"123-start\", \"Does not match\"),\n        (\"my--slug\", \"Does not match\"),\n        (\"has spaces\", \"Does not match\"),\n        (\"with_underscores\", \"Does not match\"),\n        (\"has.dots\", \"Does not match\"),\n        (\"-leading-hyphen\", \"Does not match\"),\n        (\"trailing-hyphen-\", \"Does not match\"),\n    ],\n)\ndef test_validate_objective_slug_invalid(slug: str, reason_fragment: str) -> None:\n    \"\"\"Invalid slugs return InvalidObjectiveSlug with matching reason.\"\"\"\n    result = validate_objective_slug(slug)\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_objective_slug_error_message_includes_pattern() -> None:\n    \"\"\"Error message includes the regex pattern for agent self-correction.\"\"\"\n    result = validate_objective_slug(\"INVALID\")\n    assert isinstance(result, InvalidObjectiveSlug)\n    assert \"^[a-z][a-z0-9]*(-[a-z0-9]+)*$\" in result.message\n    assert \"INVALID\" in result.message\n\n\n# Tests for validate_plan_title\n@pytest.mark.parametrize(\n    \"title\",\n    [\n        \"Add User Authentication\",\n        \"Refactor Gateway Layer\",\n        \"Fix CLI Argument Parsing\",\n        \"hello\",\n        \"a\" * 100,\n        \"Fix Bug #123 in Auth Module\",\n        \"café au lait feature\",\n        \"Update the README file\",\n        \"Add v2 API support for external clients\",\n    ],\n)\ndef test_validate_plan_title_valid(title: str) -> None:\n    \"\"\"Valid titles return ValidPlanTitle.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == title.strip()\n\n\n@pytest.mark.parametrize(\n    (\"title\", \"reason_fragment\"),\n    [\n        (\"\", \"empty\"),\n        (\"   \", \"empty\"),\n        (\"\\t\\n\", \"empty\"),\n        (\"Plan\", \"Too short\"),\n        (\"ab\", \"Too short\"),\n        (\"a\" * 101, \"Too long\"),\n        (\"12345\", \"at least one alphabetic\"),\n        (\"12345 67890\", \"at least one alphabetic\"),\n        (\"!@#$%^&*()\", \"at least one alphabetic\"),\n        (\"\\U0001f680\\U0001f389\\U0001f525\\U0001f4a5\\U0001f31f\", \"at least one alphabetic\"),\n        (\"\\u4f60\\u597d\\u4e16\\u754c\\u7684\\u8ba1\\u5212\", \"No usable content\"),\n    ],\n)\ndef test_validate_plan_title_invalid(title: str, reason_fragment: str) -> None:\n    \"\"\"Invalid titles return InvalidPlanTitle with matching reason.\"\"\"\n    result = validate_plan_title(title)\n    assert isinstance(result, InvalidPlanTitle)\n    assert reason_fragment in result.reason\n\n\ndef test_validate_plan_title_error_message_includes_rules() -> None:\n    \"\"\"Error message includes rules for agent self-correction.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert \"5-100 characters\" in result.message\n    assert \"at least one alphabetic\" in result.message\n    assert \"Valid examples\" in result.message\n    assert \"Invalid examples\" in result.message\n\n\ndef test_validate_plan_title_error_type() -> None:\n    \"\"\"Error type is machine-readable.\"\"\"\n    result = validate_plan_title(\"\")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.error_type == \"invalid-plan-title\"\n\n\ndef test_validate_plan_title_strips_whitespace() -> None:\n    \"\"\"Leading/trailing whitespace is stripped before validation.\"\"\"\n    result = validate_plan_title(\"  Add Feature  \")\n    assert isinstance(result, ValidPlanTitle)\n    assert result.title == \"Add Feature\"\n\n\ndef test_validate_plan_title_preserves_original_in_error() -> None:\n    \"\"\"Error includes the original unmodified title.\"\"\"\n    result = validate_plan_title(\"   ab   \")\n    assert isinstance(result, InvalidPlanTitle)\n    assert result.raw_title == \"   ab   \"\n","structuredPatch":[{"oldStart":641,"oldLines":7,"newStart":641,"newLines":7,"lines":["     result = generate_draft_pr_branch_name(long_title, timestamp, objective_id=456)"," ","     assert len(result) <= 42","-    assert result.startswith(\"planned/O456-\")","+    assert result.startswith(\"plnd/O456-\")","     assert result.endswith(\"-01-15-1430\")","     assert not result[:-11].endswith(\"-\")"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"5f79baae-72ab-471b-b43b-478e96b3dcc4","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_017y4S9d8Y3wSXLuvYg5MAAY","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the submit test files:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":519,"cache_read_input_tokens":89643,"cache_creation":{"ephemeral_5m_input_tokens":519,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHmJC7Z1VGPdc5N9SjA","type":"assistant","uuid":"59cd7220-bb17-4a1d-9f6d-1c300f8244bc","timestamp":"2026-02-22T14:47:09.002Z"}
{"parentUuid":"59cd7220-bb17-4a1d-9f6d-1c300f8244bc","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_017y4S9d8Y3wSXLuvYg5MAAY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014nu4LNRnhYcqyr4NaAvdks","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/commands/submit/test_pr_creation.py"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":519,"cache_read_input_tokens":89643,"cache_creation":{"ephemeral_5m_input_tokens":519,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHmJC7Z1VGPdc5N9SjA","type":"assistant","uuid":"8df16d96-9cea-4ede-afda-47d5f36d3504","timestamp":"2026-02-22T14:47:09.529Z"}
{"parentUuid":"8df16d96-9cea-4ede-afda-47d5f36d3504","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014nu4LNRnhYcqyr4NaAvdks","type":"tool_result","content":"     1→\"\"\"Tests for PR creation during submit.\"\"\"\n     2→\n     3→from pathlib import Path\n     4→\n     5→from click.testing import CliRunner\n     6→\n     7→from erk.cli.commands.submit import _add_planned_prefix, _strip_plan_markers, submit_cmd\n     8→from tests.commands.submit.conftest import create_plan, setup_submit_context\n     9→\n    10→\n    11→def test_strip_plan_markers() -> None:\n    12→    \"\"\"Test _strip_plan_markers removes '[erk-plan]' prefix and 'Plan:' prefix from titles.\"\"\"\n    13→    # Strip [erk-plan] prefix only\n    14→    assert _strip_plan_markers(\"[erk-plan] Implement feature X\") == \"Implement feature X\"\n    15→    assert _strip_plan_markers(\"Implement feature X\") == \"Implement feature X\"\n    16→    assert _strip_plan_markers(\"[erk-plan] \") == \"\"\n    17→    assert _strip_plan_markers(\"Planning [erk-plan] ahead\") == \"Planning [erk-plan] ahead\"\n    18→    # Strip Plan: prefix only\n    19→    assert _strip_plan_markers(\"Plan: Implement feature X\") == \"Implement feature X\"\n    20→    assert _strip_plan_markers(\"Plan: Already has prefix\") == \"Already has prefix\"\n    21→    # Strip both [erk-plan] prefix and Plan: prefix\n    22→    assert _strip_plan_markers(\"[erk-plan] Plan: Implement feature X\") == \"Implement feature X\"\n    23→    # No stripping needed\n    24→    assert _strip_plan_markers(\"Regular title\") == \"Regular title\"\n    25→\n    26→\n    27→def test_submit_strips_plan_markers_from_pr_title(tmp_path: Path) -> None:\n    28→    \"\"\"Test submit strips plan markers and adds planned/ prefix when creating PR.\"\"\"\n    29→    # Plan with \"[erk-plan]\" prefix (standard format for erk-plan issues)\n    30→    plan = create_plan(\"123\", \"[erk-plan] Implement feature X\")\n    31→    ctx, _, fake_github, _, _, _ = setup_submit_context(tmp_path, {\"123\": plan})\n    32→\n    33→    runner = CliRunner()\n    34→    result = runner.invoke(submit_cmd, [\"123\"], obj=ctx)\n    35→\n    36→    assert result.exit_code == 0, result.output\n    37→\n    38→    # Verify PR was created with stripped title and planned/ prefix\n    39→    assert len(fake_github.created_prs) == 1\n    40→    branch_name, title, body, base, draft = fake_github.created_prs[0]\n    41→    assert title == \"planned/Implement feature X\"  # Stripped AND prefixed with planned/\n    42→\n    43→    # Verify PR body was updated: first with checkout footer, then with workflow run link\n    44→    assert len(fake_github.updated_pr_bodies) == 2\n    45→    pr_number, updated_body = fake_github.updated_pr_bodies[0]\n    46→    assert pr_number == 999  # FakeGitHub returns 999 for created PRs\n    47→    assert 'source \"$(erk pr checkout 999 --script)\" && erk pr sync --dangerous' in updated_body\n    48→    _, workflow_body = fake_github.updated_pr_bodies[1]\n    49→    assert \"Workflow run:\" in workflow_body\n    50→\n    51→\n    52→def test_submit_includes_closes_issue_in_pr_body(tmp_path: Path) -> None:\n    53→    \"\"\"Test submit includes 'Closes #N' in INITIAL PR body to enable willCloseTarget.\n    54→\n    55→    GitHub's willCloseTarget API field is set at PR creation time and is NOT updated\n    56→    when the PR body is edited afterward. This test verifies that 'Closes #N' is\n    57→    included in the body passed to create_pr(), not just added via update_pr_body().\n    58→    \"\"\"\n    59→    plan = create_plan(\"123\", \"Implement feature X\")\n    60→    ctx, _, fake_github, _, _, _ = setup_submit_context(tmp_path, {\"123\": plan})\n    61→\n    62→    runner = CliRunner()\n    63→    result = runner.invoke(submit_cmd, [\"123\"], obj=ctx)\n    64→\n    65→    assert result.exit_code == 0, result.output\n    66→\n    67→    # CRITICAL: Verify \"Closes #123\" is in the INITIAL body passed to create_pr()\n    68→    # GitHub's willCloseTarget API field is set at creation time and NOT updated afterward\n    69→    assert len(fake_github.created_prs) == 1\n    70→    branch, title, initial_body, base, draft = fake_github.created_prs[0]\n    71→    assert \"Closes #123\" in initial_body, (\n    72→        \"Closes #123 must be in initial PR body for GitHub's willCloseTarget to work\"\n    73→    )\n    74→\n    75→    # Verify PR body was updated: first with checkout footer, then with workflow run link\n    76→    assert len(fake_github.updated_pr_bodies) == 2\n    77→    pr_number, updated_body = fake_github.updated_pr_bodies[0]\n    78→    assert pr_number == 999  # FakeGitHub returns 999 for created PRs\n    79→    assert \"Closes #123\" in updated_body\n    80→    assert 'source \"$(erk pr checkout 999 --script)\" && erk pr sync --dangerous' in updated_body\n    81→    _, workflow_body = fake_github.updated_pr_bodies[1]\n    82→    assert \"Workflow run:\" in workflow_body\n    83→\n    84→\n    85→def test_planned_prefix_idempotent() -> None:\n    86→    \"\"\"Test _add_planned_prefix is idempotent and doesn't double-prefix.\"\"\"\n    87→    # Single application\n    88→    assert _add_planned_prefix(\"Implement feature X\") == \"planned/Implement feature X\"\n    89→\n    90→    # Double application should not double-prefix\n    91→    once = _add_planned_prefix(\"Implement feature X\")\n    92→    twice = _add_planned_prefix(once)\n    93→    assert once == twice\n    94→    assert twice == \"planned/Implement feature X\"\n    95→    assert twice.count(\"planned/\") == 1  # Only one prefix\n    96→\n    97→\n    98→def test_planned_prefix_added_to_pr_title() -> None:\n    99→    \"\"\"Test planned/ prefix is added to PR titles from plan-originated submissions.\"\"\"\n   100→    # Test various title formats\n   101→    assert _add_planned_prefix(\"Update docs\") == \"planned/Update docs\"\n   102→    assert _add_planned_prefix(\"Fix bug in authentication\") == \"planned/Fix bug in authentication\"\n   103→    assert _add_planned_prefix(\"\") == \"planned/\"  # Edge case: empty title\n   104→\n   105→    # Verify it's idempotent for already-prefixed titles\n   106→    assert _add_planned_prefix(\"planned/Already prefixed\") == \"planned/Already prefixed\"\n   107→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"9762ec2c-e718-4de9-abe6-094ec3825a59","timestamp":"2026-02-22T14:47:09.547Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/commands/submit/test_pr_creation.py","content":"\"\"\"Tests for PR creation during submit.\"\"\"\n\nfrom pathlib import Path\n\nfrom click.testing import CliRunner\n\nfrom erk.cli.commands.submit import _add_planned_prefix, _strip_plan_markers, submit_cmd\nfrom tests.commands.submit.conftest import create_plan, setup_submit_context\n\n\ndef test_strip_plan_markers() -> None:\n    \"\"\"Test _strip_plan_markers removes '[erk-plan]' prefix and 'Plan:' prefix from titles.\"\"\"\n    # Strip [erk-plan] prefix only\n    assert _strip_plan_markers(\"[erk-plan] Implement feature X\") == \"Implement feature X\"\n    assert _strip_plan_markers(\"Implement feature X\") == \"Implement feature X\"\n    assert _strip_plan_markers(\"[erk-plan] \") == \"\"\n    assert _strip_plan_markers(\"Planning [erk-plan] ahead\") == \"Planning [erk-plan] ahead\"\n    # Strip Plan: prefix only\n    assert _strip_plan_markers(\"Plan: Implement feature X\") == \"Implement feature X\"\n    assert _strip_plan_markers(\"Plan: Already has prefix\") == \"Already has prefix\"\n    # Strip both [erk-plan] prefix and Plan: prefix\n    assert _strip_plan_markers(\"[erk-plan] Plan: Implement feature X\") == \"Implement feature X\"\n    # No stripping needed\n    assert _strip_plan_markers(\"Regular title\") == \"Regular title\"\n\n\ndef test_submit_strips_plan_markers_from_pr_title(tmp_path: Path) -> None:\n    \"\"\"Test submit strips plan markers and adds planned/ prefix when creating PR.\"\"\"\n    # Plan with \"[erk-plan]\" prefix (standard format for erk-plan issues)\n    plan = create_plan(\"123\", \"[erk-plan] Implement feature X\")\n    ctx, _, fake_github, _, _, _ = setup_submit_context(tmp_path, {\"123\": plan})\n\n    runner = CliRunner()\n    result = runner.invoke(submit_cmd, [\"123\"], obj=ctx)\n\n    assert result.exit_code == 0, result.output\n\n    # Verify PR was created with stripped title and planned/ prefix\n    assert len(fake_github.created_prs) == 1\n    branch_name, title, body, base, draft = fake_github.created_prs[0]\n    assert title == \"planned/Implement feature X\"  # Stripped AND prefixed with planned/\n\n    # Verify PR body was updated: first with checkout footer, then with workflow run link\n    assert len(fake_github.updated_pr_bodies) == 2\n    pr_number, updated_body = fake_github.updated_pr_bodies[0]\n    assert pr_number == 999  # FakeGitHub returns 999 for created PRs\n    assert 'source \"$(erk pr checkout 999 --script)\" && erk pr sync --dangerous' in updated_body\n    _, workflow_body = fake_github.updated_pr_bodies[1]\n    assert \"Workflow run:\" in workflow_body\n\n\ndef test_submit_includes_closes_issue_in_pr_body(tmp_path: Path) -> None:\n    \"\"\"Test submit includes 'Closes #N' in INITIAL PR body to enable willCloseTarget.\n\n    GitHub's willCloseTarget API field is set at PR creation time and is NOT updated\n    when the PR body is edited afterward. This test verifies that 'Closes #N' is\n    included in the body passed to create_pr(), not just added via update_pr_body().\n    \"\"\"\n    plan = create_plan(\"123\", \"Implement feature X\")\n    ctx, _, fake_github, _, _, _ = setup_submit_context(tmp_path, {\"123\": plan})\n\n    runner = CliRunner()\n    result = runner.invoke(submit_cmd, [\"123\"], obj=ctx)\n\n    assert result.exit_code == 0, result.output\n\n    # CRITICAL: Verify \"Closes #123\" is in the INITIAL body passed to create_pr()\n    # GitHub's willCloseTarget API field is set at creation time and NOT updated afterward\n    assert len(fake_github.created_prs) == 1\n    branch, title, initial_body, base, draft = fake_github.created_prs[0]\n    assert \"Closes #123\" in initial_body, (\n        \"Closes #123 must be in initial PR body for GitHub's willCloseTarget to work\"\n    )\n\n    # Verify PR body was updated: first with checkout footer, then with workflow run link\n    assert len(fake_github.updated_pr_bodies) == 2\n    pr_number, updated_body = fake_github.updated_pr_bodies[0]\n    assert pr_number == 999  # FakeGitHub returns 999 for created PRs\n    assert \"Closes #123\" in updated_body\n    assert 'source \"$(erk pr checkout 999 --script)\" && erk pr sync --dangerous' in updated_body\n    _, workflow_body = fake_github.updated_pr_bodies[1]\n    assert \"Workflow run:\" in workflow_body\n\n\ndef test_planned_prefix_idempotent() -> None:\n    \"\"\"Test _add_planned_prefix is idempotent and doesn't double-prefix.\"\"\"\n    # Single application\n    assert _add_planned_prefix(\"Implement feature X\") == \"planned/Implement feature X\"\n\n    # Double application should not double-prefix\n    once = _add_planned_prefix(\"Implement feature X\")\n    twice = _add_planned_prefix(once)\n    assert once == twice\n    assert twice == \"planned/Implement feature X\"\n    assert twice.count(\"planned/\") == 1  # Only one prefix\n\n\ndef test_planned_prefix_added_to_pr_title() -> None:\n    \"\"\"Test planned/ prefix is added to PR titles from plan-originated submissions.\"\"\"\n    # Test various title formats\n    assert _add_planned_prefix(\"Update docs\") == \"planned/Update docs\"\n    assert _add_planned_prefix(\"Fix bug in authentication\") == \"planned/Fix bug in authentication\"\n    assert _add_planned_prefix(\"\") == \"planned/\"  # Edge case: empty title\n\n    # Verify it's idempotent for already-prefixed titles\n    assert _add_planned_prefix(\"planned/Already prefixed\") == \"planned/Already prefixed\"\n","numLines":107,"startLine":1,"totalLines":107}}}
{"parentUuid":"9762ec2c-e718-4de9-abe6-094ec3825a59","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01XVLMBDUAEYi5ceiXHGBRrD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016qoeyTYB3x8cTM6qXprfxq","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/commands/submit/test_pr_creation.py","old_string":"    \"\"\"Test submit strips plan markers and adds planned/ prefix when creating PR.\"\"\"","new_string":"    \"\"\"Test submit strips plan markers and adds plnd/ prefix when creating PR.\"\"\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2044,"cache_read_input_tokens":90162,"cache_creation":{"ephemeral_5m_input_tokens":2044,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHmYhExZzjB37UCqtjK","type":"assistant","uuid":"666d498a-e31b-4fb2-bcb1-7d8c484ad1f7","timestamp":"2026-02-22T14:47:12.610Z"}
{"parentUuid":"666d498a-e31b-4fb2-bcb1-7d8c484ad1f7","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016qoeyTYB3x8cTM6qXprfxq","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/commands/submit/test_pr_creation.py has been updated successfully."}]},"uuid":"d16658be-876e-4e41-8c29-4bc45b6f11f9","timestamp":"2026-02-22T14:47:13.279Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/commands/submit/test_pr_creation.py","oldString":"    \"\"\"Test submit strips plan markers and adds planned/ prefix when creating PR.\"\"\"","newString":"    \"\"\"Test submit strips plan markers and adds plnd/ prefix when creating PR.\"\"\"","originalFile":"\"\"\"Tests for PR creation during submit.\"\"\"\n\nfrom pathlib import Path\n\nfrom click.testing import CliRunner\n\nfrom erk.cli.commands.submit import _add_planned_prefix, _strip_plan_markers, submit_cmd\nfrom tests.commands.submit.conftest import create_plan, setup_submit_context\n\n\ndef test_strip_plan_markers() -> None:\n    \"\"\"Test _strip_plan_markers removes '[erk-plan]' prefix and 'Plan:' prefix from titles.\"\"\"\n    # Strip [erk-plan] prefix only\n    assert _strip_plan_markers(\"[erk-plan] Implement feature X\") == \"Implement feature X\"\n    assert _strip_plan_markers(\"Implement feature X\") == \"Implement feature X\"\n    assert _strip_plan_markers(\"[erk-plan] \") == \"\"\n    assert _strip_plan_markers(\"Planning [erk-plan] ahead\") == \"Planning [erk-plan] ahead\"\n    # Strip Plan: prefix only\n    assert _strip_plan_markers(\"Plan: Implement feature X\") == \"Implement feature X\"\n    assert _strip_plan_markers(\"Plan: Already has prefix\") == \"Already has prefix\"\n    # Strip both [erk-plan] prefix and Plan: prefix\n    assert _strip_plan_markers(\"[erk-plan] Plan: Implement feature X\") == \"Implement feature X\"\n    # No stripping needed\n    assert _strip_plan_markers(\"Regular title\") == \"Regular title\"\n\n\ndef test_submit_strips_plan_markers_from_pr_title(tmp_path: Path) -> None:\n    \"\"\"Test submit strips plan markers and adds planned/ prefix when creating PR.\"\"\"\n    # Plan with \"[erk-plan]\" prefix (standard format for erk-plan issues)\n    plan = create_plan(\"123\", \"[erk-plan] Implement feature X\")\n    ctx, _, fake_github, _, _, _ = setup_submit_context(tmp_path, {\"123\": plan})\n\n    runner = CliRunner()\n    result = runner.invoke(submit_cmd, [\"123\"], obj=ctx)\n\n    assert result.exit_code == 0, result.output\n\n    # Verify PR was created with stripped title and planned/ prefix\n    assert len(fake_github.created_prs) == 1\n    branch_name, title, body, base, draft = fake_github.created_prs[0]\n    assert title == \"planned/Implement feature X\"  # Stripped AND prefixed with planned/\n\n    # Verify PR body was updated: first with checkout footer, then with workflow run link\n    assert len(fake_github.updated_pr_bodies) == 2\n    pr_number, updated_body = fake_github.updated_pr_bodies[0]\n    assert pr_number == 999  # FakeGitHub returns 999 for created PRs\n    assert 'source \"$(erk pr checkout 999 --script)\" && erk pr sync --dangerous' in updated_body\n    _, workflow_body = fake_github.updated_pr_bodies[1]\n    assert \"Workflow run:\" in workflow_body\n\n\ndef test_submit_includes_closes_issue_in_pr_body(tmp_path: Path) -> None:\n    \"\"\"Test submit includes 'Closes #N' in INITIAL PR body to enable willCloseTarget.\n\n    GitHub's willCloseTarget API field is set at PR creation time and is NOT updated\n    when the PR body is edited afterward. This test verifies that 'Closes #N' is\n    included in the body passed to create_pr(), not just added via update_pr_body().\n    \"\"\"\n    plan = create_plan(\"123\", \"Implement feature X\")\n    ctx, _, fake_github, _, _, _ = setup_submit_context(tmp_path, {\"123\": plan})\n\n    runner = CliRunner()\n    result = runner.invoke(submit_cmd, [\"123\"], obj=ctx)\n\n    assert result.exit_code == 0, result.output\n\n    # CRITICAL: Verify \"Closes #123\" is in the INITIAL body passed to create_pr()\n    # GitHub's willCloseTarget API field is set at creation time and NOT updated afterward\n    assert len(fake_github.created_prs) == 1\n    branch, title, initial_body, base, draft = fake_github.created_prs[0]\n    assert \"Closes #123\" in initial_body, (\n        \"Closes #123 must be in initial PR body for GitHub's willCloseTarget to work\"\n    )\n\n    # Verify PR body was updated: first with checkout footer, then with workflow run link\n    assert len(fake_github.updated_pr_bodies) == 2\n    pr_number, updated_body = fake_github.updated_pr_bodies[0]\n    assert pr_number == 999  # FakeGitHub returns 999 for created PRs\n    assert \"Closes #123\" in updated_body\n    assert 'source \"$(erk pr checkout 999 --script)\" && erk pr sync --dangerous' in updated_body\n    _, workflow_body = fake_github.updated_pr_bodies[1]\n    assert \"Workflow run:\" in workflow_body\n\n\ndef test_planned_prefix_idempotent() -> None:\n    \"\"\"Test _add_planned_prefix is idempotent and doesn't double-prefix.\"\"\"\n    # Single application\n    assert _add_planned_prefix(\"Implement feature X\") == \"planned/Implement feature X\"\n\n    # Double application should not double-prefix\n    once = _add_planned_prefix(\"Implement feature X\")\n    twice = _add_planned_prefix(once)\n    assert once == twice\n    assert twice == \"planned/Implement feature X\"\n    assert twice.count(\"planned/\") == 1  # Only one prefix\n\n\ndef test_planned_prefix_added_to_pr_title() -> None:\n    \"\"\"Test planned/ prefix is added to PR titles from plan-originated submissions.\"\"\"\n    # Test various title formats\n    assert _add_planned_prefix(\"Update docs\") == \"planned/Update docs\"\n    assert _add_planned_prefix(\"Fix bug in authentication\") == \"planned/Fix bug in authentication\"\n    assert _add_planned_prefix(\"\") == \"planned/\"  # Edge case: empty title\n\n    # Verify it's idempotent for already-prefixed titles\n    assert _add_planned_prefix(\"planned/Already prefixed\") == \"planned/Already prefixed\"\n","structuredPatch":[{"oldStart":25,"oldLines":7,"newStart":25,"newLines":7,"lines":[" "," "," def test_submit_strips_plan_markers_from_pr_title(tmp_path: Path) -> None:","-    \"\"\"Test submit strips plan markers and adds planned/ prefix when creating PR.\"\"\"","+    \"\"\"Test submit strips plan markers and adds plnd/ prefix when creating PR.\"\"\"","     # Plan with \"[erk-plan]\" prefix (standard format for erk-plan issues)","     plan = create_plan(\"123\", \"[erk-plan] Implement feature X\")","     ctx, _, fake_github, _, _, _ = setup_submit_context(tmp_path, {\"123\": plan})"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"d16658be-876e-4e41-8c29-4bc45b6f11f9","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01JSNtvjPg8wPk44K8sLwtCh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DDtoY36TdwWpNKhLLKKZN9","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/commands/submit/test_pr_creation.py","old_string":"    # Verify PR was created with stripped title and planned/ prefix\n    assert len(fake_github.created_prs) == 1\n    branch_name, title, body, base, draft = fake_github.created_prs[0]\n    assert title == \"planned/Implement feature X\"  # Stripped AND prefixed with planned/","new_string":"    # Verify PR was created with stripped title and plnd/ prefix\n    assert len(fake_github.created_prs) == 1\n    branch_name, title, body, base, draft = fake_github.created_prs[0]\n    assert title == \"plnd/Implement feature X\"  # Stripped AND prefixed with plnd/"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":529,"cache_read_input_tokens":92206,"cache_creation":{"ephemeral_5m_input_tokens":529,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHmpmNwWQoHjbJUy1WU","type":"assistant","uuid":"4b57b0ef-1a0d-4315-b6dd-bfdb7d39f9a0","timestamp":"2026-02-22T14:47:18.791Z"}
{"parentUuid":"4b57b0ef-1a0d-4315-b6dd-bfdb7d39f9a0","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DDtoY36TdwWpNKhLLKKZN9","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/commands/submit/test_pr_creation.py has been updated successfully."}]},"uuid":"d94c4d12-ce47-43aa-ba7d-5dbcbd95e90b","timestamp":"2026-02-22T14:47:19.526Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/commands/submit/test_pr_creation.py","oldString":"    # Verify PR was created with stripped title and planned/ prefix\n    assert len(fake_github.created_prs) == 1\n    branch_name, title, body, base, draft = fake_github.created_prs[0]\n    assert title == \"planned/Implement feature X\"  # Stripped AND prefixed with planned/","newString":"    # Verify PR was created with stripped title and plnd/ prefix\n    assert len(fake_github.created_prs) == 1\n    branch_name, title, body, base, draft = fake_github.created_prs[0]\n    assert title == \"plnd/Implement feature X\"  # Stripped AND prefixed with plnd/","originalFile":"\"\"\"Tests for PR creation during submit.\"\"\"\n\nfrom pathlib import Path\n\nfrom click.testing import CliRunner\n\nfrom erk.cli.commands.submit import _add_planned_prefix, _strip_plan_markers, submit_cmd\nfrom tests.commands.submit.conftest import create_plan, setup_submit_context\n\n\ndef test_strip_plan_markers() -> None:\n    \"\"\"Test _strip_plan_markers removes '[erk-plan]' prefix and 'Plan:' prefix from titles.\"\"\"\n    # Strip [erk-plan] prefix only\n    assert _strip_plan_markers(\"[erk-plan] Implement feature X\") == \"Implement feature X\"\n    assert _strip_plan_markers(\"Implement feature X\") == \"Implement feature X\"\n    assert _strip_plan_markers(\"[erk-plan] \") == \"\"\n    assert _strip_plan_markers(\"Planning [erk-plan] ahead\") == \"Planning [erk-plan] ahead\"\n    # Strip Plan: prefix only\n    assert _strip_plan_markers(\"Plan: Implement feature X\") == \"Implement feature X\"\n    assert _strip_plan_markers(\"Plan: Already has prefix\") == \"Already has prefix\"\n    # Strip both [erk-plan] prefix and Plan: prefix\n    assert _strip_plan_markers(\"[erk-plan] Plan: Implement feature X\") == \"Implement feature X\"\n    # No stripping needed\n    assert _strip_plan_markers(\"Regular title\") == \"Regular title\"\n\n\ndef test_submit_strips_plan_markers_from_pr_title(tmp_path: Path) -> None:\n    \"\"\"Test submit strips plan markers and adds plnd/ prefix when creating PR.\"\"\"\n    # Plan with \"[erk-plan]\" prefix (standard format for erk-plan issues)\n    plan = create_plan(\"123\", \"[erk-plan] Implement feature X\")\n    ctx, _, fake_github, _, _, _ = setup_submit_context(tmp_path, {\"123\": plan})\n\n    runner = CliRunner()\n    result = runner.invoke(submit_cmd, [\"123\"], obj=ctx)\n\n    assert result.exit_code == 0, result.output\n\n    # Verify PR was created with stripped title and planned/ prefix\n    assert len(fake_github.created_prs) == 1\n    branch_name, title, body, base, draft = fake_github.created_prs[0]\n    assert title == \"planned/Implement feature X\"  # Stripped AND prefixed with planned/\n\n    # Verify PR body was updated: first with checkout footer, then with workflow run link\n    assert len(fake_github.updated_pr_bodies) == 2\n    pr_number, updated_body = fake_github.updated_pr_bodies[0]\n    assert pr_number == 999  # FakeGitHub returns 999 for created PRs\n    assert 'source \"$(erk pr checkout 999 --script)\" && erk pr sync --dangerous' in updated_body\n    _, workflow_body = fake_github.updated_pr_bodies[1]\n    assert \"Workflow run:\" in workflow_body\n\n\ndef test_submit_includes_closes_issue_in_pr_body(tmp_path: Path) -> None:\n    \"\"\"Test submit includes 'Closes #N' in INITIAL PR body to enable willCloseTarget.\n\n    GitHub's willCloseTarget API field is set at PR creation time and is NOT updated\n    when the PR body is edited afterward. This test verifies that 'Closes #N' is\n    included in the body passed to create_pr(), not just added via update_pr_body().\n    \"\"\"\n    plan = create_plan(\"123\", \"Implement feature X\")\n    ctx, _, fake_github, _, _, _ = setup_submit_context(tmp_path, {\"123\": plan})\n\n    runner = CliRunner()\n    result = runner.invoke(submit_cmd, [\"123\"], obj=ctx)\n\n    assert result.exit_code == 0, result.output\n\n    # CRITICAL: Verify \"Closes #123\" is in the INITIAL body passed to create_pr()\n    # GitHub's willCloseTarget API field is set at creation time and NOT updated afterward\n    assert len(fake_github.created_prs) == 1\n    branch, title, initial_body, base, draft = fake_github.created_prs[0]\n    assert \"Closes #123\" in initial_body, (\n        \"Closes #123 must be in initial PR body for GitHub's willCloseTarget to work\"\n    )\n\n    # Verify PR body was updated: first with checkout footer, then with workflow run link\n    assert len(fake_github.updated_pr_bodies) == 2\n    pr_number, updated_body = fake_github.updated_pr_bodies[0]\n    assert pr_number == 999  # FakeGitHub returns 999 for created PRs\n    assert \"Closes #123\" in updated_body\n    assert 'source \"$(erk pr checkout 999 --script)\" && erk pr sync --dangerous' in updated_body\n    _, workflow_body = fake_github.updated_pr_bodies[1]\n    assert \"Workflow run:\" in workflow_body\n\n\ndef test_planned_prefix_idempotent() -> None:\n    \"\"\"Test _add_planned_prefix is idempotent and doesn't double-prefix.\"\"\"\n    # Single application\n    assert _add_planned_prefix(\"Implement feature X\") == \"planned/Implement feature X\"\n\n    # Double application should not double-prefix\n    once = _add_planned_prefix(\"Implement feature X\")\n    twice = _add_planned_prefix(once)\n    assert once == twice\n    assert twice == \"planned/Implement feature X\"\n    assert twice.count(\"planned/\") == 1  # Only one prefix\n\n\ndef test_planned_prefix_added_to_pr_title() -> None:\n    \"\"\"Test planned/ prefix is added to PR titles from plan-originated submissions.\"\"\"\n    # Test various title formats\n    assert _add_planned_prefix(\"Update docs\") == \"planned/Update docs\"\n    assert _add_planned_prefix(\"Fix bug in authentication\") == \"planned/Fix bug in authentication\"\n    assert _add_planned_prefix(\"\") == \"planned/\"  # Edge case: empty title\n\n    # Verify it's idempotent for already-prefixed titles\n    assert _add_planned_prefix(\"planned/Already prefixed\") == \"planned/Already prefixed\"\n","structuredPatch":[{"oldStart":35,"oldLines":10,"newStart":35,"newLines":10,"lines":[" ","     assert result.exit_code == 0, result.output"," ","-    # Verify PR was created with stripped title and planned/ prefix","+    # Verify PR was created with stripped title and plnd/ prefix","     assert len(fake_github.created_prs) == 1","     branch_name, title, body, base, draft = fake_github.created_prs[0]","-    assert title == \"planned/Implement feature X\"  # Stripped AND prefixed with planned/","+    assert title == \"plnd/Implement feature X\"  # Stripped AND prefixed with plnd/"," ","     # Verify PR body was updated: first with checkout footer, then with workflow run link","     assert len(fake_github.updated_pr_bodies) == 2"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"d94c4d12-ce47-43aa-ba7d-5dbcbd95e90b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01LatrUneQpdBrtW8HAPAjg7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019FX2tSVqXSUHZsR3AZqqXT","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/commands/submit/test_pr_creation.py","old_string":"def test_planned_prefix_idempotent() -> None:\n    \"\"\"Test _add_planned_prefix is idempotent and doesn't double-prefix.\"\"\"\n    # Single application\n    assert _add_planned_prefix(\"Implement feature X\") == \"planned/Implement feature X\"\n\n    # Double application should not double-prefix\n    once = _add_planned_prefix(\"Implement feature X\")\n    twice = _add_planned_prefix(once)\n    assert once == twice\n    assert twice == \"planned/Implement feature X\"\n    assert twice.count(\"planned/\") == 1  # Only one prefix\n\n\ndef test_planned_prefix_added_to_pr_title() -> None:\n    \"\"\"Test planned/ prefix is added to PR titles from plan-originated submissions.\"\"\"\n    # Test various title formats\n    assert _add_planned_prefix(\"Update docs\") == \"planned/Update docs\"\n    assert _add_planned_prefix(\"Fix bug in authentication\") == \"planned/Fix bug in authentication\"\n    assert _add_planned_prefix(\"\") == \"planned/\"  # Edge case: empty title\n\n    # Verify it's idempotent for already-prefixed titles\n    assert _add_planned_prefix(\"planned/Already prefixed\") == \"planned/Already prefixed\"","new_string":"def test_planned_prefix_idempotent() -> None:\n    \"\"\"Test _add_planned_prefix is idempotent and doesn't double-prefix.\"\"\"\n    # Single application\n    assert _add_planned_prefix(\"Implement feature X\") == \"plnd/Implement feature X\"\n\n    # Double application should not double-prefix\n    once = _add_planned_prefix(\"Implement feature X\")\n    twice = _add_planned_prefix(once)\n    assert once == twice\n    assert twice == \"plnd/Implement feature X\"\n    assert twice.count(\"plnd/\") == 1  # Only one prefix\n\n\ndef test_planned_prefix_added_to_pr_title() -> None:\n    \"\"\"Test plnd/ prefix is added to PR titles from plan-originated submissions.\"\"\"\n    # Test various title formats\n    assert _add_planned_prefix(\"Update docs\") == \"plnd/Update docs\"\n    assert _add_planned_prefix(\"Fix bug in authentication\") == \"plnd/Fix bug in authentication\"\n    assert _add_planned_prefix(\"\") == \"plnd/\"  # Edge case: empty title\n\n    # Verify it's idempotent for already-prefixed titles\n    assert _add_planned_prefix(\"plnd/Already prefixed\") == \"plnd/Already prefixed\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":319,"cache_read_input_tokens":92735,"cache_creation":{"ephemeral_5m_input_tokens":319,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHnHRzmT6aYz3xSmWyq","type":"assistant","uuid":"122204c6-c175-4ca7-93ae-d108d28b5bf5","timestamp":"2026-02-22T14:47:26.914Z"}
{"parentUuid":"122204c6-c175-4ca7-93ae-d108d28b5bf5","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019FX2tSVqXSUHZsR3AZqqXT","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/commands/submit/test_pr_creation.py has been updated successfully."}]},"uuid":"c37aa830-b659-4544-afc5-9eae9aedd2e7","timestamp":"2026-02-22T14:47:27.597Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/commands/submit/test_pr_creation.py","oldString":"def test_planned_prefix_idempotent() -> None:\n    \"\"\"Test _add_planned_prefix is idempotent and doesn't double-prefix.\"\"\"\n    # Single application\n    assert _add_planned_prefix(\"Implement feature X\") == \"planned/Implement feature X\"\n\n    # Double application should not double-prefix\n    once = _add_planned_prefix(\"Implement feature X\")\n    twice = _add_planned_prefix(once)\n    assert once == twice\n    assert twice == \"planned/Implement feature X\"\n    assert twice.count(\"planned/\") == 1  # Only one prefix\n\n\ndef test_planned_prefix_added_to_pr_title() -> None:\n    \"\"\"Test planned/ prefix is added to PR titles from plan-originated submissions.\"\"\"\n    # Test various title formats\n    assert _add_planned_prefix(\"Update docs\") == \"planned/Update docs\"\n    assert _add_planned_prefix(\"Fix bug in authentication\") == \"planned/Fix bug in authentication\"\n    assert _add_planned_prefix(\"\") == \"planned/\"  # Edge case: empty title\n\n    # Verify it's idempotent for already-prefixed titles\n    assert _add_planned_prefix(\"planned/Already prefixed\") == \"planned/Already prefixed\"","newString":"def test_planned_prefix_idempotent() -> None:\n    \"\"\"Test _add_planned_prefix is idempotent and doesn't double-prefix.\"\"\"\n    # Single application\n    assert _add_planned_prefix(\"Implement feature X\") == \"plnd/Implement feature X\"\n\n    # Double application should not double-prefix\n    once = _add_planned_prefix(\"Implement feature X\")\n    twice = _add_planned_prefix(once)\n    assert once == twice\n    assert twice == \"plnd/Implement feature X\"\n    assert twice.count(\"plnd/\") == 1  # Only one prefix\n\n\ndef test_planned_prefix_added_to_pr_title() -> None:\n    \"\"\"Test plnd/ prefix is added to PR titles from plan-originated submissions.\"\"\"\n    # Test various title formats\n    assert _add_planned_prefix(\"Update docs\") == \"plnd/Update docs\"\n    assert _add_planned_prefix(\"Fix bug in authentication\") == \"plnd/Fix bug in authentication\"\n    assert _add_planned_prefix(\"\") == \"plnd/\"  # Edge case: empty title\n\n    # Verify it's idempotent for already-prefixed titles\n    assert _add_planned_prefix(\"plnd/Already prefixed\") == \"plnd/Already prefixed\"","originalFile":"\"\"\"Tests for PR creation during submit.\"\"\"\n\nfrom pathlib import Path\n\nfrom click.testing import CliRunner\n\nfrom erk.cli.commands.submit import _add_planned_prefix, _strip_plan_markers, submit_cmd\nfrom tests.commands.submit.conftest import create_plan, setup_submit_context\n\n\ndef test_strip_plan_markers() -> None:\n    \"\"\"Test _strip_plan_markers removes '[erk-plan]' prefix and 'Plan:' prefix from titles.\"\"\"\n    # Strip [erk-plan] prefix only\n    assert _strip_plan_markers(\"[erk-plan] Implement feature X\") == \"Implement feature X\"\n    assert _strip_plan_markers(\"Implement feature X\") == \"Implement feature X\"\n    assert _strip_plan_markers(\"[erk-plan] \") == \"\"\n    assert _strip_plan_markers(\"Planning [erk-plan] ahead\") == \"Planning [erk-plan] ahead\"\n    # Strip Plan: prefix only\n    assert _strip_plan_markers(\"Plan: Implement feature X\") == \"Implement feature X\"\n    assert _strip_plan_markers(\"Plan: Already has prefix\") == \"Already has prefix\"\n    # Strip both [erk-plan] prefix and Plan: prefix\n    assert _strip_plan_markers(\"[erk-plan] Plan: Implement feature X\") == \"Implement feature X\"\n    # No stripping needed\n    assert _strip_plan_markers(\"Regular title\") == \"Regular title\"\n\n\ndef test_submit_strips_plan_markers_from_pr_title(tmp_path: Path) -> None:\n    \"\"\"Test submit strips plan markers and adds plnd/ prefix when creating PR.\"\"\"\n    # Plan with \"[erk-plan]\" prefix (standard format for erk-plan issues)\n    plan = create_plan(\"123\", \"[erk-plan] Implement feature X\")\n    ctx, _, fake_github, _, _, _ = setup_submit_context(tmp_path, {\"123\": plan})\n\n    runner = CliRunner()\n    result = runner.invoke(submit_cmd, [\"123\"], obj=ctx)\n\n    assert result.exit_code == 0, result.output\n\n    # Verify PR was created with stripped title and plnd/ prefix\n    assert len(fake_github.created_prs) == 1\n    branch_name, title, body, base, draft = fake_github.created_prs[0]\n    assert title == \"plnd/Implement feature X\"  # Stripped AND prefixed with plnd/\n\n    # Verify PR body was updated: first with checkout footer, then with workflow run link\n    assert len(fake_github.updated_pr_bodies) == 2\n    pr_number, updated_body = fake_github.updated_pr_bodies[0]\n    assert pr_number == 999  # FakeGitHub returns 999 for created PRs\n    assert 'source \"$(erk pr checkout 999 --script)\" && erk pr sync --dangerous' in updated_body\n    _, workflow_body = fake_github.updated_pr_bodies[1]\n    assert \"Workflow run:\" in workflow_body\n\n\ndef test_submit_includes_closes_issue_in_pr_body(tmp_path: Path) -> None:\n    \"\"\"Test submit includes 'Closes #N' in INITIAL PR body to enable willCloseTarget.\n\n    GitHub's willCloseTarget API field is set at PR creation time and is NOT updated\n    when the PR body is edited afterward. This test verifies that 'Closes #N' is\n    included in the body passed to create_pr(), not just added via update_pr_body().\n    \"\"\"\n    plan = create_plan(\"123\", \"Implement feature X\")\n    ctx, _, fake_github, _, _, _ = setup_submit_context(tmp_path, {\"123\": plan})\n\n    runner = CliRunner()\n    result = runner.invoke(submit_cmd, [\"123\"], obj=ctx)\n\n    assert result.exit_code == 0, result.output\n\n    # CRITICAL: Verify \"Closes #123\" is in the INITIAL body passed to create_pr()\n    # GitHub's willCloseTarget API field is set at creation time and NOT updated afterward\n    assert len(fake_github.created_prs) == 1\n    branch, title, initial_body, base, draft = fake_github.created_prs[0]\n    assert \"Closes #123\" in initial_body, (\n        \"Closes #123 must be in initial PR body for GitHub's willCloseTarget to work\"\n    )\n\n    # Verify PR body was updated: first with checkout footer, then with workflow run link\n    assert len(fake_github.updated_pr_bodies) == 2\n    pr_number, updated_body = fake_github.updated_pr_bodies[0]\n    assert pr_number == 999  # FakeGitHub returns 999 for created PRs\n    assert \"Closes #123\" in updated_body\n    assert 'source \"$(erk pr checkout 999 --script)\" && erk pr sync --dangerous' in updated_body\n    _, workflow_body = fake_github.updated_pr_bodies[1]\n    assert \"Workflow run:\" in workflow_body\n\n\ndef test_planned_prefix_idempotent() -> None:\n    \"\"\"Test _add_planned_prefix is idempotent and doesn't double-prefix.\"\"\"\n    # Single application\n    assert _add_planned_prefix(\"Implement feature X\") == \"planned/Implement feature X\"\n\n    # Double application should not double-prefix\n    once = _add_planned_prefix(\"Implement feature X\")\n    twice = _add_planned_prefix(once)\n    assert once == twice\n    assert twice == \"planned/Implement feature X\"\n    assert twice.count(\"planned/\") == 1  # Only one prefix\n\n\ndef test_planned_prefix_added_to_pr_title() -> None:\n    \"\"\"Test planned/ prefix is added to PR titles from plan-originated submissions.\"\"\"\n    # Test various title formats\n    assert _add_planned_prefix(\"Update docs\") == \"planned/Update docs\"\n    assert _add_planned_prefix(\"Fix bug in authentication\") == \"planned/Fix bug in authentication\"\n    assert _add_planned_prefix(\"\") == \"planned/\"  # Edge case: empty title\n\n    # Verify it's idempotent for already-prefixed titles\n    assert _add_planned_prefix(\"planned/Already prefixed\") == \"planned/Already prefixed\"\n","structuredPatch":[{"oldStart":85,"oldLines":22,"newStart":85,"newLines":22,"lines":[" def test_planned_prefix_idempotent() -> None:","     \"\"\"Test _add_planned_prefix is idempotent and doesn't double-prefix.\"\"\"","     # Single application","-    assert _add_planned_prefix(\"Implement feature X\") == \"planned/Implement feature X\"","+    assert _add_planned_prefix(\"Implement feature X\") == \"plnd/Implement feature X\""," ","     # Double application should not double-prefix","     once = _add_planned_prefix(\"Implement feature X\")","     twice = _add_planned_prefix(once)","     assert once == twice","-    assert twice == \"planned/Implement feature X\"","-    assert twice.count(\"planned/\") == 1  # Only one prefix","+    assert twice == \"plnd/Implement feature X\"","+    assert twice.count(\"plnd/\") == 1  # Only one prefix"," "," "," def test_planned_prefix_added_to_pr_title() -> None:","-    \"\"\"Test planned/ prefix is added to PR titles from plan-originated submissions.\"\"\"","+    \"\"\"Test plnd/ prefix is added to PR titles from plan-originated submissions.\"\"\"","     # Test various title formats","-    assert _add_planned_prefix(\"Update docs\") == \"planned/Update docs\"","-    assert _add_planned_prefix(\"Fix bug in authentication\") == \"planned/Fix bug in authentication\"","-    assert _add_planned_prefix(\"\") == \"planned/\"  # Edge case: empty title","+    assert _add_planned_prefix(\"Update docs\") == \"plnd/Update docs\"","+    assert _add_planned_prefix(\"Fix bug in authentication\") == \"plnd/Fix bug in authentication\"","+    assert _add_planned_prefix(\"\") == \"plnd/\"  # Edge case: empty title"," ","     # Verify it's idempotent for already-prefixed titles","-    assert _add_planned_prefix(\"planned/Already prefixed\") == \"planned/Already prefixed\"","+    assert _add_planned_prefix(\"plnd/Already prefixed\") == \"plnd/Already prefixed\""]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"c37aa830-b659-4544-afc5-9eae9aedd2e7","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_016N2BndPoRCY63bGFm7pvyT","type":"message","role":"assistant","content":[{"type":"text","text":"Now update test_basic_submission.py:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":753,"cache_read_input_tokens":93054,"cache_creation":{"ephemeral_5m_input_tokens":753,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHnsuRXoAStpFZXWYE2","type":"assistant","uuid":"dff39949-a044-427e-84d0-caa190db2962","timestamp":"2026-02-22T14:47:30.105Z"}
{"parentUuid":"dff39949-a044-427e-84d0-caa190db2962","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_016N2BndPoRCY63bGFm7pvyT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SNj6bJKBPNPVjwy9Uzxui2","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/commands/submit/test_basic_submission.py","offset":50,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":753,"cache_read_input_tokens":93054,"cache_creation":{"ephemeral_5m_input_tokens":753,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHnsuRXoAStpFZXWYE2","type":"assistant","uuid":"e6f2097d-051e-414b-8f1f-a67280da6621","timestamp":"2026-02-22T14:47:30.838Z"}
{"parentUuid":"e6f2097d-051e-414b-8f1f-a67280da6621","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SNj6bJKBPNPVjwy9Uzxui2","type":"tool_result","content":"    50→    assert branch == expected_branch\n    51→    assert set_upstream is True\n    52→    assert force is False\n    53→\n    54→    # Verify draft PR was created\n    55→    assert len(fake_github.created_prs) == 1\n    56→    branch_name, title, body, base, draft = fake_github.created_prs[0]\n    57→    assert branch_name == expected_branch\n    58→    assert title == \"planned/Implement feature X\"\n    59→    assert draft is True\n    60→    # PR body contains plan reference\n    61→    assert \"**Plan:** #123\" in body\n    62→\n    63→    # Verify workflow was triggered\n    64→    assert len(fake_github.triggered_workflows) == 1\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a768ae41-12b7-419e-950e-41b32ae87e26","timestamp":"2026-02-22T14:47:30.907Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/commands/submit/test_basic_submission.py","content":"    assert branch == expected_branch\n    assert set_upstream is True\n    assert force is False\n\n    # Verify draft PR was created\n    assert len(fake_github.created_prs) == 1\n    branch_name, title, body, base, draft = fake_github.created_prs[0]\n    assert branch_name == expected_branch\n    assert title == \"planned/Implement feature X\"\n    assert draft is True\n    # PR body contains plan reference\n    assert \"**Plan:** #123\" in body\n\n    # Verify workflow was triggered\n    assert len(fake_github.triggered_workflows) == 1","numLines":15,"startLine":50,"totalLines":151}}}
{"parentUuid":"a768ae41-12b7-419e-950e-41b32ae87e26","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01UoZXToZqFZke9Q6cjj2HxL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FzhCJ4pJQ1FyPqzJDcfBXT","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/commands/submit/test_basic_submission.py","old_string":"    assert title == \"planned/Implement feature X\"","new_string":"    assert title == \"plnd/Implement feature X\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":742,"cache_read_input_tokens":93807,"cache_creation":{"ephemeral_5m_input_tokens":742,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHo83yDGwSgNZsGtm1b","type":"assistant","uuid":"1a0b0f78-b19e-4e92-a305-831e618278a9","timestamp":"2026-02-22T14:47:34.545Z"}
{"parentUuid":"1a0b0f78-b19e-4e92-a305-831e618278a9","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FzhCJ4pJQ1FyPqzJDcfBXT","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/commands/submit/test_basic_submission.py has been updated successfully."}]},"uuid":"965d228f-feee-433a-9fbe-6e9e1b2876e1","timestamp":"2026-02-22T14:47:35.214Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/commands/submit/test_basic_submission.py","oldString":"    assert title == \"planned/Implement feature X\"","newString":"    assert title == \"plnd/Implement feature X\"","originalFile":"\"\"\"Tests for basic submit command functionality.\"\"\"\n\nfrom pathlib import Path\n\nfrom click.testing import CliRunner\n\nfrom erk.cli.commands.submit import submit_cmd\nfrom erk_shared.gateway.graphite.types import BranchMetadata\nfrom tests.commands.submit.conftest import create_plan, setup_submit_context\n\n\ndef test_submit_creates_branch_and_draft_pr(tmp_path: Path) -> None:\n    \"\"\"Test submit creates linked branch, pushes, creates draft PR, triggers workflow.\"\"\"\n    plan = create_plan(\"123\", \"Implement feature X\")\n    repo_root = tmp_path / \"repo\"\n    ctx, fake_git, fake_github, _, _, repo_root = setup_submit_context(\n        tmp_path,\n        {\"123\": plan},\n        git_kwargs={\n            \"current_branches\": {repo_root: \"main\"},\n            \"trunk_branches\": {repo_root: \"master\"},\n            \"remote_branches\": {repo_root: [\"origin/main\"]},\n        },\n    )\n\n    runner = CliRunner()\n    result = runner.invoke(submit_cmd, [\"123\"], obj=ctx)\n\n    assert result.exit_code == 0, result.output\n    assert \"issue(s) submitted successfully!\" in result.output\n    assert \"Workflow:\" in result.output\n\n    # Branch name is sanitize_worktree_name(...) + timestamp suffix \"-01-15-1430\"\n    expected_branch = \"P123-implement-feature-x-01-15-1430\"\n\n    # Verify branch was created via git (from origin/<current_branch>)\n    # Note: submit defaults to current branch as base, not trunk_branch\n    # (tuple is cwd, branch_name, start_point, force)\n    assert len(fake_git.created_branches) == 1\n    created_repo, created_branch, created_base, created_force = fake_git.created_branches[0]\n    assert created_repo == repo_root\n    assert created_branch == expected_branch\n    assert created_base == \"origin/main\"  # Uses current branch as base\n    assert created_force is False\n\n    # Verify branch was pushed\n    assert len(fake_git.pushed_branches) == 1\n    remote, branch, set_upstream, force = fake_git.pushed_branches[0]\n    assert remote == \"origin\"\n    assert branch == expected_branch\n    assert set_upstream is True\n    assert force is False\n\n    # Verify draft PR was created\n    assert len(fake_github.created_prs) == 1\n    branch_name, title, body, base, draft = fake_github.created_prs[0]\n    assert branch_name == expected_branch\n    assert title == \"planned/Implement feature X\"\n    assert draft is True\n    # PR body contains plan reference\n    assert \"**Plan:** #123\" in body\n\n    # Verify workflow was triggered\n    assert len(fake_github.triggered_workflows) == 1\n    workflow, inputs = fake_github.triggered_workflows[0]\n    assert workflow == \"plan-implement.yml\"\n    assert inputs[\"plan_id\"] == \"123\"\n\n    # Verify local branch is preserved (for Graphite lineage tracking)\n    assert len(fake_git._deleted_branches) == 0\n\n\ndef test_submit_tracks_branch_with_graphite(tmp_path: Path) -> None:\n    \"\"\"Test submit tracks the created branch with Graphite for proper PR stacking.\n\n    When branches are created via submit, they must be tracked with Graphite\n    so that `erk land` can find child PRs and update their base branches before\n    merging. Without tracking, child PRs get auto-closed by GitHub when their\n    base branch is deleted.\n    \"\"\"\n    plan = create_plan(\"123\", \"Implement feature X\")\n    repo_root = tmp_path / \"repo\"\n    ctx, fake_git, fake_github, _, fake_graphite, repo_root = setup_submit_context(\n        tmp_path,\n        {\"123\": plan},\n        git_kwargs={\n            \"current_branches\": {repo_root: \"main\"},\n            \"trunk_branches\": {repo_root: \"master\"},\n            \"remote_branches\": {repo_root: [\"origin/main\"]},\n        },\n        graphite_kwargs={\n            # main must be tracked for stacking to work\n            \"branches\": {\n                \"main\": BranchMetadata.trunk(\"main\"),\n            },\n        },\n        use_graphite=True,\n    )\n\n    runner = CliRunner()\n    result = runner.invoke(submit_cmd, [\"123\"], obj=ctx)\n\n    assert result.exit_code == 0, result.output\n\n    # Branch name is sanitize_worktree_name(...) + timestamp suffix \"-01-15-1430\"\n    expected_branch = \"P123-implement-feature-x-01-15-1430\"\n\n    # Verify branch was tracked with Graphite (critical for child PR detection)\n    # BranchManager.create_branch() strips the origin/ prefix for Graphite tracking\n    # because gt track doesn't accept remote refs - it uses local branch names\n    assert len(fake_graphite.track_branch_calls) == 1\n    tracked_repo, tracked_branch, parent_branch = fake_graphite.track_branch_calls[0]\n    assert tracked_repo == repo_root\n    assert tracked_branch == expected_branch\n    assert parent_branch == \"main\"  # Local branch name (origin/ stripped by BranchManager)\n\n\ndef test_submit_displays_workflow_run_url(tmp_path: Path) -> None:\n    \"\"\"Test submit displays workflow run URL from trigger_workflow response.\"\"\"\n    plan = create_plan(\"123\", \"Add workflow run URL to erk submit output\")\n    ctx, fake_git, fake_github, _, _, _ = setup_submit_context(tmp_path, {\"123\": plan})\n\n    runner = CliRunner()\n    result = runner.invoke(submit_cmd, [\"123\"], obj=ctx)\n\n    assert result.exit_code == 0, result.output\n    assert \"issue(s) submitted successfully!\" in result.output\n    # Verify workflow run URL is displayed (uses run_id returned by trigger_workflow)\n    expected_url = \"https://github.com/test-owner/test-repo/actions/runs/1234567890\"\n    assert expected_url in result.output\n\n\ndef test_submit_single_issue_still_works(tmp_path: Path) -> None:\n    \"\"\"Test backwards compatibility: single issue argument still works.\"\"\"\n    plan = create_plan(\"123\", \"Implement feature X\")\n    ctx, fake_git, fake_github, _, _, _ = setup_submit_context(tmp_path, {\"123\": plan})\n\n    runner = CliRunner()\n    # Single argument - backwards compatibility\n    result = runner.invoke(submit_cmd, [\"123\"], obj=ctx)\n\n    assert result.exit_code == 0, result.output\n    assert \"1 issue(s) submitted successfully!\" in result.output\n    assert \"Workflow:\" in result.output\n\n    # Verify branch was created via git\n    assert len(fake_git.created_branches) == 1\n\n    # Verify workflow was triggered\n    assert len(fake_github.triggered_workflows) == 1\n","structuredPatch":[{"oldStart":55,"oldLines":7,"newStart":55,"newLines":7,"lines":["     assert len(fake_github.created_prs) == 1","     branch_name, title, body, base, draft = fake_github.created_prs[0]","     assert branch_name == expected_branch","-    assert title == \"planned/Implement feature X\"","+    assert title == \"plnd/Implement feature X\"","     assert draft is True","     # PR body contains plan reference","     assert \"**Plan:** #123\" in body"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"965d228f-feee-433a-9fbe-6e9e1b2876e1","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01L14XPgDhAMFFrzzoNyPnqW","type":"message","role":"assistant","content":[{"type":"text","text":"Now update test_get_objective_for_branch.py:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":183,"cache_read_input_tokens":94549,"cache_creation":{"ephemeral_5m_input_tokens":183,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHoSUVPPf2sNZu4hPYX","type":"assistant","uuid":"699f5483-dad3-45f0-97f4-22f1848d0b11","timestamp":"2026-02-22T14:47:37.652Z"}
{"parentUuid":"699f5483-dad3-45f0-97f4-22f1848d0b11","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01L14XPgDhAMFFrzzoNyPnqW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017buVXX1iwJBgyxn7oN7yyb","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/commands/land/test_get_objective_for_branch.py","offset":105,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":183,"cache_read_input_tokens":94549,"cache_creation":{"ephemeral_5m_input_tokens":183,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHoSUVPPf2sNZu4hPYX","type":"assistant","uuid":"10dfb016-60d1-40d5-9290-cbc48374db10","timestamp":"2026-02-22T14:47:38.428Z"}
{"parentUuid":"10dfb016-60d1-40d5-9290-cbc48374db10","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017buVXX1iwJBgyxn7oN7yyb","type":"tool_result","content":"   105→    assert result == 7709\n   106→\n   107→\n   108→def test_falls_back_to_planned_prefix(tmp_path: Path) -> None:\n   109→    \"\"\"Branch with planned/ prefix and no plan found — extract from name.\"\"\"\n   110→    issues_ops = FakeGitHubIssues(username=\"testuser\", issues={})\n   111→    ctx = context_for_test(issues=issues_ops, cwd=tmp_path)\n   112→\n   113→    result = get_objective_for_branch(ctx, tmp_path, \"planned/O456-fix-auth-01-15-1430\")\n   114→\n   115→    assert result == 456\n   116→\n   117→\n   118→def test_prefers_plan_metadata_over_branch_name(tmp_path: Path) -> None:\n   119→    \"\"\"Plan has objective_id in metadata — prefer it over branch name.\"\"\"\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e869d22b-5392-4c4b-957f-dd5ee1b1fef5","timestamp":"2026-02-22T14:47:38.458Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/commands/land/test_get_objective_for_branch.py","content":"    assert result == 7709\n\n\ndef test_falls_back_to_planned_prefix(tmp_path: Path) -> None:\n    \"\"\"Branch with planned/ prefix and no plan found — extract from name.\"\"\"\n    issues_ops = FakeGitHubIssues(username=\"testuser\", issues={})\n    ctx = context_for_test(issues=issues_ops, cwd=tmp_path)\n\n    result = get_objective_for_branch(ctx, tmp_path, \"planned/O456-fix-auth-01-15-1430\")\n\n    assert result == 456\n\n\ndef test_prefers_plan_metadata_over_branch_name(tmp_path: Path) -> None:\n    \"\"\"Plan has objective_id in metadata — prefer it over branch name.\"\"\"","numLines":15,"startLine":105,"totalLines":128}}}
{"parentUuid":"e869d22b-5392-4c4b-957f-dd5ee1b1fef5","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_011uAZGEzcTmArAK3joBtXqN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KJ6JT1vYAsj6wierbfXcCA","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/commands/land/test_get_objective_for_branch.py","old_string":"def test_falls_back_to_planned_prefix(tmp_path: Path) -> None:\n    \"\"\"Branch with planned/ prefix and no plan found — extract from name.\"\"\"\n    issues_ops = FakeGitHubIssues(username=\"testuser\", issues={})\n    ctx = context_for_test(issues=issues_ops, cwd=tmp_path)\n\n    result = get_objective_for_branch(ctx, tmp_path, \"planned/O456-fix-auth-01-15-1430\")","new_string":"def test_falls_back_to_plnd_prefix(tmp_path: Path) -> None:\n    \"\"\"Branch with plnd/ prefix and no plan found — extract from name.\"\"\"\n    issues_ops = FakeGitHubIssues(username=\"testuser\", issues={})\n    ctx = context_for_test(issues=issues_ops, cwd=tmp_path)\n\n    result = get_objective_for_branch(ctx, tmp_path, \"plnd/O456-fix-auth-01-15-1430\")"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":788,"cache_read_input_tokens":94732,"cache_creation":{"ephemeral_5m_input_tokens":788,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHogLRwSGeVyaP9fq5Z","type":"assistant","uuid":"ae5020c4-fb6d-4cb9-8047-cc51cc7e06ac","timestamp":"2026-02-22T14:47:43.039Z"}
{"parentUuid":"ae5020c4-fb6d-4cb9-8047-cc51cc7e06ac","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KJ6JT1vYAsj6wierbfXcCA","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/commands/land/test_get_objective_for_branch.py has been updated successfully."}]},"uuid":"334fe25d-b4cb-447e-9de3-f6dd9695fd3c","timestamp":"2026-02-22T14:47:43.710Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/commands/land/test_get_objective_for_branch.py","oldString":"def test_falls_back_to_planned_prefix(tmp_path: Path) -> None:\n    \"\"\"Branch with planned/ prefix and no plan found — extract from name.\"\"\"\n    issues_ops = FakeGitHubIssues(username=\"testuser\", issues={})\n    ctx = context_for_test(issues=issues_ops, cwd=tmp_path)\n\n    result = get_objective_for_branch(ctx, tmp_path, \"planned/O456-fix-auth-01-15-1430\")","newString":"def test_falls_back_to_plnd_prefix(tmp_path: Path) -> None:\n    \"\"\"Branch with plnd/ prefix and no plan found — extract from name.\"\"\"\n    issues_ops = FakeGitHubIssues(username=\"testuser\", issues={})\n    ctx = context_for_test(issues=issues_ops, cwd=tmp_path)\n\n    result = get_objective_for_branch(ctx, tmp_path, \"plnd/O456-fix-auth-01-15-1430\")","originalFile":"\"\"\"Tests for get_objective_for_branch helper in erk land command.\n\nTests the branch-name fallback behavior: when the plan backend returns\na plan with objective_id=None (e.g., because the PR body lost the\nplan-header block during implementation), the function falls back to\nparsing the objective number from the branch name.\n\"\"\"\n\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nfrom erk.cli.commands.objective_helpers import get_objective_for_branch\nfrom erk.core.context import context_for_test\nfrom erk_shared.gateway.github.issues.fake import FakeGitHubIssues\nfrom erk_shared.gateway.github.issues.types import IssueInfo\nfrom tests.test_utils.plan_helpers import format_plan_header_body_for_test\n\n\ndef _create_plan_issue(\n    number: int,\n    *,\n    objective_issue: int | None,\n) -> IssueInfo:\n    \"\"\"Create a plan issue with optional objective in plan-header metadata.\"\"\"\n    body = format_plan_header_body_for_test(objective_issue=objective_issue)\n    return IssueInfo(\n        number=number,\n        title=f\"P{number}: Test Plan\",\n        body=body,\n        state=\"OPEN\",\n        url=f\"https://github.com/owner/repo/issues/{number}\",\n        labels=[\"erk-plan\"],\n        assignees=[],\n        created_at=datetime.now(UTC),\n        updated_at=datetime.now(UTC),\n        author=\"testuser\",\n    )\n\n\ndef _create_plan_issue_without_header(number: int) -> IssueInfo:\n    \"\"\"Create a plan issue with no plan-header block (simulates overwritten body).\"\"\"\n    return IssueInfo(\n        number=number,\n        title=f\"P{number}: Test Plan\",\n        body=\"## Summary\\n\\nImplementation PR body without plan-header block.\",\n        state=\"OPEN\",\n        url=f\"https://github.com/owner/repo/issues/{number}\",\n        labels=[\"erk-plan\"],\n        assignees=[],\n        created_at=datetime.now(UTC),\n        updated_at=datetime.now(UTC),\n        author=\"testuser\",\n    )\n\n\ndef test_returns_objective_from_plan_metadata(tmp_path: Path) -> None:\n    \"\"\"Plan has objective_id in metadata — return it directly.\"\"\"\n    issue = _create_plan_issue(42, objective_issue=100)\n    issues_ops = FakeGitHubIssues(username=\"testuser\", issues={42: issue})\n    ctx = context_for_test(issues=issues_ops, cwd=tmp_path)\n\n    result = get_objective_for_branch(ctx, tmp_path, \"P42-O100-test-feature-01-15-1430\")\n\n    assert result == 100\n\n\ndef test_falls_back_to_branch_name_when_objective_id_none(tmp_path: Path) -> None:\n    \"\"\"Plan exists but objective_id is None — fall back to branch name parsing.\"\"\"\n    issue = _create_plan_issue_without_header(42)\n    issues_ops = FakeGitHubIssues(username=\"testuser\", issues={42: issue})\n    ctx = context_for_test(issues=issues_ops, cwd=tmp_path)\n\n    result = get_objective_for_branch(ctx, tmp_path, \"P42-O7709-plan-lazy-tip-sync-f-02-21-1116\")\n\n    assert result == 7709\n\n\ndef test_falls_back_to_branch_name_when_plan_not_found(tmp_path: Path) -> None:\n    \"\"\"No plan found for branch — fall back to branch name parsing.\"\"\"\n    issues_ops = FakeGitHubIssues(username=\"testuser\", issues={})\n    ctx = context_for_test(issues=issues_ops, cwd=tmp_path)\n\n    result = get_objective_for_branch(ctx, tmp_path, \"P42-O456-fix-auth-bug-01-15-1430\")\n\n    assert result == 456\n\n\ndef test_returns_none_when_no_objective_anywhere(tmp_path: Path) -> None:\n    \"\"\"No plan found and branch has no objective number — return None.\"\"\"\n    issues_ops = FakeGitHubIssues(username=\"testuser\", issues={})\n    ctx = context_for_test(issues=issues_ops, cwd=tmp_path)\n\n    result = get_objective_for_branch(ctx, tmp_path, \"feature-branch\")\n\n    assert result is None\n\n\ndef test_falls_back_to_legacy_plan_prefix(tmp_path: Path) -> None:\n    \"\"\"Branch with legacy plan/ prefix and no plan found — extract from name.\"\"\"\n    issues_ops = FakeGitHubIssues(username=\"testuser\", issues={})\n    ctx = context_for_test(issues=issues_ops, cwd=tmp_path)\n\n    result = get_objective_for_branch(ctx, tmp_path, \"plan/O7709-plan-lazy-tip-sync-f-02-21-1116\")\n\n    assert result == 7709\n\n\ndef test_falls_back_to_planned_prefix(tmp_path: Path) -> None:\n    \"\"\"Branch with planned/ prefix and no plan found — extract from name.\"\"\"\n    issues_ops = FakeGitHubIssues(username=\"testuser\", issues={})\n    ctx = context_for_test(issues=issues_ops, cwd=tmp_path)\n\n    result = get_objective_for_branch(ctx, tmp_path, \"planned/O456-fix-auth-01-15-1430\")\n\n    assert result == 456\n\n\ndef test_prefers_plan_metadata_over_branch_name(tmp_path: Path) -> None:\n    \"\"\"Plan has objective_id in metadata — prefer it over branch name.\"\"\"\n    issue = _create_plan_issue(42, objective_issue=100)\n    issues_ops = FakeGitHubIssues(username=\"testuser\", issues={42: issue})\n    ctx = context_for_test(issues=issues_ops, cwd=tmp_path)\n\n    # Branch encodes O999, but plan metadata says 100 — metadata wins\n    result = get_objective_for_branch(ctx, tmp_path, \"P42-O999-test-feature-01-15-1430\")\n\n    assert result == 100\n","structuredPatch":[{"oldStart":105,"oldLines":12,"newStart":105,"newLines":12,"lines":["     assert result == 7709"," "," ","-def test_falls_back_to_planned_prefix(tmp_path: Path) -> None:","-    \"\"\"Branch with planned/ prefix and no plan found — extract from name.\"\"\"","+def test_falls_back_to_plnd_prefix(tmp_path: Path) -> None:","+    \"\"\"Branch with plnd/ prefix and no plan found — extract from name.\"\"\"","     issues_ops = FakeGitHubIssues(username=\"testuser\", issues={})","     ctx = context_for_test(issues=issues_ops, cwd=tmp_path)"," ","-    result = get_objective_for_branch(ctx, tmp_path, \"planned/O456-fix-auth-01-15-1430\")","+    result = get_objective_for_branch(ctx, tmp_path, \"plnd/O456-fix-auth-01-15-1430\")"," ","     assert result == 456"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"334fe25d-b4cb-447e-9de3-f6dd9695fd3c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Ls7fPGmHq1ZTG15pnKzjB4","type":"message","role":"assistant","content":[{"type":"text","text":"Now update test_one_shot_dispatch.py:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":411,"cache_read_input_tokens":95520,"cache_creation":{"ephemeral_5m_input_tokens":411,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHp4n3xP2ZBXsA5u5eV","type":"assistant","uuid":"e3c8e3be-3cec-497d-a856-49c1ee8f257a","timestamp":"2026-02-22T14:47:46.148Z"}
{"parentUuid":"e3c8e3be-3cec-497d-a856-49c1ee8f257a","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Ls7fPGmHq1ZTG15pnKzjB4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VU31NuGcUK3G53CEr5sRTQ","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/commands/one_shot/test_one_shot_dispatch.py","offset":320,"limit":55},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":411,"cache_read_input_tokens":95520,"cache_creation":{"ephemeral_5m_input_tokens":411,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHp4n3xP2ZBXsA5u5eV","type":"assistant","uuid":"889f62c4-e7d3-4acf-bb9f-fcdf7001b190","timestamp":"2026-02-22T14:47:46.863Z"}
{"parentUuid":"889f62c4-e7d3-4acf-bb9f-fcdf7001b190","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VU31NuGcUK3G53CEr5sRTQ","type":"tool_result","content":"   320→        assert \"last_dispatched_node_id: WFR_fake_node_id_1234567890\" in issue_info.body\n   321→        assert \"last_dispatched_at:\" in issue_info.body\n   322→\n   323→\n   324→def test_dispatch_draft_pr_lifecycle() -> None:\n   325→    \"\"\"Test full draft_pr dispatch: no skeleton issue, planned/ branch, PR with metadata block.\n   326→\n   327→    In draft_pr mode, the draft PR IS the plan entity. The dispatch should:\n   328→    - NOT create a skeleton issue\n   329→    - Use planned/ branch naming\n   330→    - Create a draft PR with plan-header metadata block\n   331→    - Set plan_issue_number = pr_number for downstream code\n   332→    - Write dispatch metadata to the PR (the plan entity)\n   333→    - Post queued event comment to the PR\n   334→    \"\"\"\n   335→    runner = CliRunner()\n   336→    with erk_isolated_fs_env(runner) as env:\n   337→        env.setup_repo_structure()\n   338→\n   339→        git = FakeGit(\n   340→            git_common_dirs={env.cwd: env.git_dir},\n   341→            default_branches={env.cwd: \"main\"},\n   342→            trunk_branches={env.cwd: \"main\"},\n   343→            current_branches={env.cwd: \"main\"},\n   344→        )\n   345→        issues = FakeGitHubIssues()\n   346→        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n   347→\n   348→        # Explicitly use DraftPRPlanBackend so ctx.plan_backend.get_provider_name()\n   349→        # returns \"github-draft-pr\" and dispatch takes the draft_pr path.\n   350→        plan_store = DraftPRPlanBackend(github, issues, time=FakeTime())\n   351→\n   352→        ctx = build_workspace_test_context(\n   353→            env, git=git, github=github, issues=issues, plan_store=plan_store\n   354→        )\n   355→\n   356→        params = OneShotDispatchParams(\n   357→            prompt=\"fix the import in config.py\",\n   358→            model=None,\n   359→            extra_workflow_inputs={},\n   360→        )\n   361→\n   362→        result = dispatch_one_shot(ctx, params=params, dry_run=False)\n   363→\n   364→        assert result is not None\n   365→\n   366→        # No skeleton issue created — draft_pr skips issue creation\n   367→        assert len(issues.created_issues) == 0\n   368→\n   369→        # Branch uses planned/ prefix (not P<N>-)\n   370→        assert result.branch_name.startswith(\"planned/\")\n   371→        assert not result.branch_name.startswith(\"P\")\n   372→\n   373→        # PR created with plan-header metadata block\n   374→        assert len(github.created_prs) == 1\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f3434de8-be7d-4b9e-8549-b37dd38726e2","timestamp":"2026-02-22T14:47:46.888Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/commands/one_shot/test_one_shot_dispatch.py","content":"        assert \"last_dispatched_node_id: WFR_fake_node_id_1234567890\" in issue_info.body\n        assert \"last_dispatched_at:\" in issue_info.body\n\n\ndef test_dispatch_draft_pr_lifecycle() -> None:\n    \"\"\"Test full draft_pr dispatch: no skeleton issue, planned/ branch, PR with metadata block.\n\n    In draft_pr mode, the draft PR IS the plan entity. The dispatch should:\n    - NOT create a skeleton issue\n    - Use planned/ branch naming\n    - Create a draft PR with plan-header metadata block\n    - Set plan_issue_number = pr_number for downstream code\n    - Write dispatch metadata to the PR (the plan entity)\n    - Post queued event comment to the PR\n    \"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        # Explicitly use DraftPRPlanBackend so ctx.plan_backend.get_provider_name()\n        # returns \"github-draft-pr\" and dispatch takes the draft_pr path.\n        plan_store = DraftPRPlanBackend(github, issues, time=FakeTime())\n\n        ctx = build_workspace_test_context(\n            env, git=git, github=github, issues=issues, plan_store=plan_store\n        )\n\n        params = OneShotDispatchParams(\n            prompt=\"fix the import in config.py\",\n            model=None,\n            extra_workflow_inputs={},\n        )\n\n        result = dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        assert result is not None\n\n        # No skeleton issue created — draft_pr skips issue creation\n        assert len(issues.created_issues) == 0\n\n        # Branch uses planned/ prefix (not P<N>-)\n        assert result.branch_name.startswith(\"planned/\")\n        assert not result.branch_name.startswith(\"P\")\n\n        # PR created with plan-header metadata block\n        assert len(github.created_prs) == 1","numLines":55,"startLine":320,"totalLines":447}}}
{"parentUuid":"f3434de8-be7d-4b9e-8549-b37dd38726e2","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01WpKd86y3vm6stzTXe3dsXX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018CvJRgvehpCQaLr6aZ6q3f","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/commands/one_shot/test_one_shot_dispatch.py","old_string":"    \"\"\"Test full draft_pr dispatch: no skeleton issue, planned/ branch, PR with metadata block.\n\n    In draft_pr mode, the draft PR IS the plan entity. The dispatch should:\n    - NOT create a skeleton issue\n    - Use planned/ branch naming","new_string":"    \"\"\"Test full draft_pr dispatch: no skeleton issue, plnd/ branch, PR with metadata block.\n\n    In draft_pr mode, the draft PR IS the plan entity. The dispatch should:\n    - NOT create a skeleton issue\n    - Use plnd/ branch naming"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1336,"cache_read_input_tokens":95931,"cache_creation":{"ephemeral_5m_input_tokens":1336,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHpJP6vuWhRgrqRo7Be","type":"assistant","uuid":"e8ca8974-b123-4729-906c-67c735e87dad","timestamp":"2026-02-22T14:47:50.879Z"}
{"parentUuid":"e8ca8974-b123-4729-906c-67c735e87dad","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018CvJRgvehpCQaLr6aZ6q3f","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/commands/one_shot/test_one_shot_dispatch.py has been updated successfully."}]},"uuid":"db99fff1-d97d-4ea7-bca8-d84aeb7c5293","timestamp":"2026-02-22T14:47:51.557Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/commands/one_shot/test_one_shot_dispatch.py","oldString":"    \"\"\"Test full draft_pr dispatch: no skeleton issue, planned/ branch, PR with metadata block.\n\n    In draft_pr mode, the draft PR IS the plan entity. The dispatch should:\n    - NOT create a skeleton issue\n    - Use planned/ branch naming","newString":"    \"\"\"Test full draft_pr dispatch: no skeleton issue, plnd/ branch, PR with metadata block.\n\n    In draft_pr mode, the draft PR IS the plan entity. The dispatch should:\n    - NOT create a skeleton issue\n    - Use plnd/ branch naming","originalFile":"\"\"\"Tests for one-shot dispatch shared logic.\"\"\"\n\nfrom click.testing import CliRunner\n\nfrom erk.cli.cli import cli\nfrom erk.cli.commands.one_shot_dispatch import (\n    OneShotDispatchParams,\n    dispatch_one_shot,\n)\nfrom erk_shared.gateway.git.fake import FakeGit\nfrom erk_shared.gateway.git.remote_ops.types import PushError\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.issues.fake import FakeGitHubIssues\nfrom erk_shared.gateway.github.issues.types import IssueNotFound\nfrom erk_shared.gateway.time.fake import FakeTime\nfrom erk_shared.plan_store.draft_pr import DraftPRPlanBackend\nfrom tests.test_utils.context_builders import build_workspace_test_context\nfrom tests.test_utils.env_helpers import erk_isolated_fs_env\n\n\ndef test_dispatch_happy_path() -> None:\n    \"\"\"Test dispatch creates skeleton issue, branch with P<N>- prefix, PR, and triggers workflow.\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner, env_overrides=None) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        ctx = build_workspace_test_context(env, git=git, github=github, issues=issues)\n\n        params = OneShotDispatchParams(\n            prompt=\"fix the import in config.py\",\n            model=None,\n            extra_workflow_inputs={},\n        )\n\n        result = dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        assert result is not None\n        # Branch should have P<N>- prefix (skeleton issue created first)\n        assert result.branch_name.startswith(\"P1-\")\n\n        # Verify skeleton plan issue was created\n        assert len(issues.created_issues) == 1\n        title, _body, labels = issues.created_issues[0]\n        assert \"[erk-plan]\" in title\n        assert \"erk-plan\" in labels\n\n        # Verify branch was created\n        assert len(git.created_branches) == 1\n        assert git.created_branches[0][2] == \"main\"  # start_point is trunk\n\n        # Verify .worker-impl/prompt.md was committed directly to branch (no checkout)\n        assert len(git.branch_commits) == 1\n        assert git.branch_commits[0].files == {\n            \".worker-impl/prompt.md\": \"fix the import in config.py\\n\",\n        }\n        assert git.branch_commits[0].branch.startswith(\"P1-\")\n\n        # Verify push to remote\n        assert len(git.pushed_branches) == 1\n\n        # Verify PR was created with closing reference\n        assert len(github.created_prs) == 1\n        _branch, _title, pr_body, base, draft = github.created_prs[0]\n        assert draft is True\n        assert base == \"main\"\n        assert \"Closes #1\" in pr_body\n\n        # Verify workflow was triggered with plan_issue_number and plan_backend\n        assert len(github.triggered_workflows) == 1\n        workflow, inputs = github.triggered_workflows[0]\n        assert workflow == \"one-shot.yml\"\n        assert inputs[\"prompt\"] == \"fix the import in config.py\"\n        assert inputs[\"plan_issue_number\"] == \"1\"\n        assert inputs[\"plan_backend\"] == \"github\"\n\n        # Verify PR body was updated with workflow run link and closing reference\n        assert len(github.updated_pr_bodies) == 1\n        _pr_num, updated_body = github.updated_pr_bodies[0]\n        assert \"**Workflow run:**\" in updated_body\n        assert \"https://github.com/owner/repo/actions/runs/\" in updated_body\n        assert \"Closes #1\" in updated_body\n\n        # Verify dispatch metadata was written to plan issue\n        issue_info = issues.get_issue(env.cwd, 1)\n        assert not isinstance(issue_info, IssueNotFound)\n        assert \"last_dispatched_run_id\" in issue_info.body\n        assert \"last_dispatched_node_id\" in issue_info.body\n        assert \"last_dispatched_at\" in issue_info.body\n\n        # Verify we're back on original branch\n        assert git.branch.get_current_branch(env.cwd) == \"main\"\n\n\ndef test_dispatch_with_extra_inputs() -> None:\n    \"\"\"Test extra_workflow_inputs in workflow trigger and skeleton links to objective.\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner, env_overrides=None) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        ctx = build_workspace_test_context(env, git=git, github=github, issues=issues)\n\n        params = OneShotDispatchParams(\n            prompt=\"implement step 1.1\",\n            model=None,\n            extra_workflow_inputs={\n                \"objective_issue\": \"42\",\n                \"node_id\": \"1.1\",\n            },\n        )\n\n        result = dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        assert result is not None\n        # Branch should have P<N>- prefix\n        assert result.branch_name.startswith(\"P1-\")\n\n        # Verify extra inputs are in workflow trigger\n        _workflow, inputs = github.triggered_workflows[0]\n        assert inputs[\"objective_issue\"] == \"42\"\n        assert inputs[\"node_id\"] == \"1.1\"\n        assert inputs[\"prompt\"] == \"implement step 1.1\"\n        assert inputs[\"plan_issue_number\"] == \"1\"\n\n\ndef test_dispatch_dry_run() -> None:\n    \"\"\"Test dispatch_one_shot dry_run outputs info without mutations.\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner, env_overrides=None) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        github = FakeGitHub(authenticated=True)\n\n        ctx = build_workspace_test_context(env, git=git, github=github)\n\n        # Invoke via CLI to capture user_output via CliRunner\n        result = runner.invoke(\n            cli,\n            [\"one-shot\", \"add type hints\", \"--dry-run\", \"-m\", \"opus\"],\n            obj=ctx,\n            catch_exceptions=False,\n        )\n\n        assert result.exit_code == 0\n        assert \"Dry-run mode:\" in result.output\n        assert \"add type hints\" in result.output\n\n        # Verify no mutations occurred (skeleton issue NOT created in dry-run)\n        assert len(git.created_branches) == 0\n        assert len(git.pushed_branches) == 0\n        assert len(github.created_prs) == 0\n        assert len(github.triggered_workflows) == 0\n\n\ndef test_dispatch_stays_on_original_branch_on_error() -> None:\n    \"\"\"Test that we stay on original branch when push fails (no checkout = nothing to restore).\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner, env_overrides=None) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n            push_to_remote_error=PushError(message=\"network error\"),\n        )\n        github = FakeGitHub(authenticated=True)\n\n        ctx = build_workspace_test_context(env, git=git, github=github)\n\n        result = runner.invoke(\n            cli,\n            [\"one-shot\", \"fix the import in config.py\"],\n            obj=ctx,\n        )\n\n        # Verify command failed\n        assert result.exit_code != 0\n\n        # Verify we're still on original branch (no checkout occurred)\n        assert git.branch.get_current_branch(env.cwd) == \"main\"\n\n\ndef test_dispatch_creates_skeleton_plan_issue() -> None:\n    \"\"\"Test that skeleton plan issue is created with correct content and metadata.\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner, env_overrides=None) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        ctx = build_workspace_test_context(env, git=git, github=github, issues=issues)\n\n        params = OneShotDispatchParams(\n            prompt=\"add user authentication\",\n            model=None,\n            extra_workflow_inputs={},\n        )\n\n        dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        # Verify skeleton issue was created with expected content\n        assert len(issues.created_issues) == 1\n        title, _body, labels = issues.created_issues[0]\n        assert \"[erk-plan]\" in title\n        assert \"erk-plan\" in labels\n\n        # Verify plan comment was added (create_plan_issue adds plan as comment)\n        # Plus queued event comment from dispatch\n        assert len(issues.added_comments) == 2\n        issue_number, comment_body, _comment_id = issues.added_comments[0]\n        assert issue_number == 1\n        assert \"One-shot\" in comment_body\n        assert \"add user authentication\" in comment_body\n\n        # Verify queued event comment\n        issue_number, queued_body, _comment_id = issues.added_comments[1]\n        assert issue_number == 1\n        assert \"One-Shot Dispatched\" in queued_body\n        assert \"add user authentication\" in queued_body\n\n\ndef test_dispatch_posts_queued_event_comment() -> None:\n    \"\"\"Test dispatch posts a queued event comment with workflow run URL and prompt.\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner, env_overrides=None) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        ctx = build_workspace_test_context(env, git=git, github=github, issues=issues)\n\n        params = OneShotDispatchParams(\n            prompt=\"refactor the auth module\",\n            model=None,\n            extra_workflow_inputs={},\n        )\n\n        dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        # create_plan_issue adds 1 comment, dispatch adds queued event comment\n        assert len(issues.added_comments) == 2\n\n        # The queued event comment is the last one\n        issue_number, comment_body, _comment_id = issues.added_comments[-1]\n        assert issue_number == 1\n        assert \"One-Shot Dispatched\" in comment_body\n        assert \"refactor the auth module\" in comment_body\n        assert \"**Workflow run:**\" in comment_body\n        assert \"https://github.com/owner/repo/actions/runs/\" in comment_body\n\n\ndef test_dispatch_writes_metadata_to_plan_issue() -> None:\n    \"\"\"Test that dispatch writes run_id, node_id, and timestamp metadata to the plan issue.\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner, env_overrides={\"ERK_PLAN_BACKEND\": \"github\"}) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        ctx = build_workspace_test_context(env, git=git, github=github, issues=issues)\n\n        params = OneShotDispatchParams(\n            prompt=\"add logging to api routes\",\n            model=None,\n            extra_workflow_inputs={},\n        )\n\n        dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        # Read the plan issue and verify dispatch metadata was written\n        issue_info = issues.get_issue(env.cwd, 1)\n        assert not isinstance(issue_info, IssueNotFound)\n        assert \"last_dispatched_run_id: '1234567890'\" in issue_info.body\n        assert \"last_dispatched_node_id: WFR_fake_node_id_1234567890\" in issue_info.body\n        assert \"last_dispatched_at:\" in issue_info.body\n\n\ndef test_dispatch_draft_pr_lifecycle() -> None:\n    \"\"\"Test full draft_pr dispatch: no skeleton issue, planned/ branch, PR with metadata block.\n\n    In draft_pr mode, the draft PR IS the plan entity. The dispatch should:\n    - NOT create a skeleton issue\n    - Use planned/ branch naming\n    - Create a draft PR with plan-header metadata block\n    - Set plan_issue_number = pr_number for downstream code\n    - Write dispatch metadata to the PR (the plan entity)\n    - Post queued event comment to the PR\n    \"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        # Explicitly use DraftPRPlanBackend so ctx.plan_backend.get_provider_name()\n        # returns \"github-draft-pr\" and dispatch takes the draft_pr path.\n        plan_store = DraftPRPlanBackend(github, issues, time=FakeTime())\n\n        ctx = build_workspace_test_context(\n            env, git=git, github=github, issues=issues, plan_store=plan_store\n        )\n\n        params = OneShotDispatchParams(\n            prompt=\"fix the import in config.py\",\n            model=None,\n            extra_workflow_inputs={},\n        )\n\n        result = dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        assert result is not None\n\n        # No skeleton issue created — draft_pr skips issue creation\n        assert len(issues.created_issues) == 0\n\n        # Branch uses planned/ prefix (not P<N>-)\n        assert result.branch_name.startswith(\"planned/\")\n        assert not result.branch_name.startswith(\"P\")\n\n        # PR created with plan-header metadata block\n        assert len(github.created_prs) == 1\n        _branch, _title, pr_body, base, draft = github.created_prs[0]\n        assert draft is True\n        assert base == \"main\"\n        assert \"plan-header\" in pr_body\n        assert \"lifecycle_stage: prompted\" in pr_body\n        assert \"fix the import in config.py\" in pr_body\n\n        # No Closes #N in PR body (self-referential for draft_pr)\n        assert \"Closes #\" not in pr_body\n\n        # erk-plan label added to PR\n        pr_number = result.pr_number\n        assert (pr_number, \"erk-plan\") in github.added_labels\n\n        # Workflow inputs include plan_issue_number = pr_number and plan_backend\n        assert len(github.triggered_workflows) == 1\n        _workflow, inputs = github.triggered_workflows[0]\n        assert inputs[\"plan_issue_number\"] == str(pr_number)\n        assert inputs[\"plan_backend\"] == \"draft_pr\"\n\n        # Dispatch metadata written to the PR (the plan entity).\n        # The PR body is updated with footer, then dispatch metadata written\n        # via plan_backend.update_metadata targeting the PR number.\n        # updated_pr_bodies includes: (1) footer update, (2) dispatch metadata update\n        assert len(github.updated_pr_bodies) >= 2\n        # The dispatch metadata update should contain last_dispatched_run_id\n        last_body = github.updated_pr_bodies[-1][1]\n        assert \"last_dispatched_run_id\" in last_body\n\n        # Queued event comment is best-effort. In real GitHub, PRs are issues\n        # and add_comment works on PR numbers. In the fake, PRs and issues are\n        # separate, so the comment may fail. This is acceptable — dispatch\n        # metadata is the critical operation.\n\n\ndef test_dispatch_long_prompt_truncates_workflow_input() -> None:\n    \"\"\"Test that long prompts are truncated in workflow input but committed in full.\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        ctx = build_workspace_test_context(env, git=git, github=github, issues=issues)\n\n        long_prompt = \"x\" * 1000\n\n        params = OneShotDispatchParams(\n            prompt=long_prompt,\n            model=None,\n            extra_workflow_inputs={},\n        )\n\n        result = dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        assert result is not None\n\n        # Verify workflow input was truncated\n        _workflow, inputs = github.triggered_workflows[0]\n        assert len(inputs[\"prompt\"]) < len(long_prompt)\n        assert inputs[\"prompt\"].endswith(\"... (full prompt committed to .worker-impl/prompt.md)\")\n\n        # Verify full prompt was committed directly to branch via branch_commits\n        assert len(git.branch_commits) == 1\n        assert git.branch_commits[0].files == {\".worker-impl/prompt.md\": long_prompt + \"\\n\"}\n","structuredPatch":[{"oldStart":322,"oldLines":11,"newStart":322,"newLines":11,"lines":[" "," "," def test_dispatch_draft_pr_lifecycle() -> None:","-    \"\"\"Test full draft_pr dispatch: no skeleton issue, planned/ branch, PR with metadata block.","+    \"\"\"Test full draft_pr dispatch: no skeleton issue, plnd/ branch, PR with metadata block."," ","     In draft_pr mode, the draft PR IS the plan entity. The dispatch should:","     - NOT create a skeleton issue","-    - Use planned/ branch naming","+    - Use plnd/ branch naming","     - Create a draft PR with plan-header metadata block","     - Set plan_issue_number = pr_number for downstream code","     - Write dispatch metadata to the PR (the plan entity)"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"db99fff1-d97d-4ea7-bca8-d84aeb7c5293","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_018J7H3cmynB1FoVygtWGPhc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KtrS17sAPRM5ruh1BL5RTq","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/commands/one_shot/test_one_shot_dispatch.py","old_string":"        # Branch uses planned/ prefix (not P<N>-)\n        assert result.branch_name.startswith(\"planned/\")","new_string":"        # Branch uses plnd/ prefix (not P<N>-)\n        assert result.branch_name.startswith(\"plnd/\")"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":284,"cache_read_input_tokens":97267,"cache_creation":{"ephemeral_5m_input_tokens":284,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHpeMtppzntcZGWfRbU","type":"assistant","uuid":"9fec1ac6-0262-4d24-9d4c-d8ef4b789a71","timestamp":"2026-02-22T14:47:55.513Z"}
{"parentUuid":"9fec1ac6-0262-4d24-9d4c-d8ef4b789a71","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KtrS17sAPRM5ruh1BL5RTq","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/commands/one_shot/test_one_shot_dispatch.py has been updated successfully."}]},"uuid":"e092be17-64e9-4bd5-85a5-159fffd357d0","timestamp":"2026-02-22T14:47:56.213Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/commands/one_shot/test_one_shot_dispatch.py","oldString":"        # Branch uses planned/ prefix (not P<N>-)\n        assert result.branch_name.startswith(\"planned/\")","newString":"        # Branch uses plnd/ prefix (not P<N>-)\n        assert result.branch_name.startswith(\"plnd/\")","originalFile":"\"\"\"Tests for one-shot dispatch shared logic.\"\"\"\n\nfrom click.testing import CliRunner\n\nfrom erk.cli.cli import cli\nfrom erk.cli.commands.one_shot_dispatch import (\n    OneShotDispatchParams,\n    dispatch_one_shot,\n)\nfrom erk_shared.gateway.git.fake import FakeGit\nfrom erk_shared.gateway.git.remote_ops.types import PushError\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.issues.fake import FakeGitHubIssues\nfrom erk_shared.gateway.github.issues.types import IssueNotFound\nfrom erk_shared.gateway.time.fake import FakeTime\nfrom erk_shared.plan_store.draft_pr import DraftPRPlanBackend\nfrom tests.test_utils.context_builders import build_workspace_test_context\nfrom tests.test_utils.env_helpers import erk_isolated_fs_env\n\n\ndef test_dispatch_happy_path() -> None:\n    \"\"\"Test dispatch creates skeleton issue, branch with P<N>- prefix, PR, and triggers workflow.\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner, env_overrides=None) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        ctx = build_workspace_test_context(env, git=git, github=github, issues=issues)\n\n        params = OneShotDispatchParams(\n            prompt=\"fix the import in config.py\",\n            model=None,\n            extra_workflow_inputs={},\n        )\n\n        result = dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        assert result is not None\n        # Branch should have P<N>- prefix (skeleton issue created first)\n        assert result.branch_name.startswith(\"P1-\")\n\n        # Verify skeleton plan issue was created\n        assert len(issues.created_issues) == 1\n        title, _body, labels = issues.created_issues[0]\n        assert \"[erk-plan]\" in title\n        assert \"erk-plan\" in labels\n\n        # Verify branch was created\n        assert len(git.created_branches) == 1\n        assert git.created_branches[0][2] == \"main\"  # start_point is trunk\n\n        # Verify .worker-impl/prompt.md was committed directly to branch (no checkout)\n        assert len(git.branch_commits) == 1\n        assert git.branch_commits[0].files == {\n            \".worker-impl/prompt.md\": \"fix the import in config.py\\n\",\n        }\n        assert git.branch_commits[0].branch.startswith(\"P1-\")\n\n        # Verify push to remote\n        assert len(git.pushed_branches) == 1\n\n        # Verify PR was created with closing reference\n        assert len(github.created_prs) == 1\n        _branch, _title, pr_body, base, draft = github.created_prs[0]\n        assert draft is True\n        assert base == \"main\"\n        assert \"Closes #1\" in pr_body\n\n        # Verify workflow was triggered with plan_issue_number and plan_backend\n        assert len(github.triggered_workflows) == 1\n        workflow, inputs = github.triggered_workflows[0]\n        assert workflow == \"one-shot.yml\"\n        assert inputs[\"prompt\"] == \"fix the import in config.py\"\n        assert inputs[\"plan_issue_number\"] == \"1\"\n        assert inputs[\"plan_backend\"] == \"github\"\n\n        # Verify PR body was updated with workflow run link and closing reference\n        assert len(github.updated_pr_bodies) == 1\n        _pr_num, updated_body = github.updated_pr_bodies[0]\n        assert \"**Workflow run:**\" in updated_body\n        assert \"https://github.com/owner/repo/actions/runs/\" in updated_body\n        assert \"Closes #1\" in updated_body\n\n        # Verify dispatch metadata was written to plan issue\n        issue_info = issues.get_issue(env.cwd, 1)\n        assert not isinstance(issue_info, IssueNotFound)\n        assert \"last_dispatched_run_id\" in issue_info.body\n        assert \"last_dispatched_node_id\" in issue_info.body\n        assert \"last_dispatched_at\" in issue_info.body\n\n        # Verify we're back on original branch\n        assert git.branch.get_current_branch(env.cwd) == \"main\"\n\n\ndef test_dispatch_with_extra_inputs() -> None:\n    \"\"\"Test extra_workflow_inputs in workflow trigger and skeleton links to objective.\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner, env_overrides=None) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        ctx = build_workspace_test_context(env, git=git, github=github, issues=issues)\n\n        params = OneShotDispatchParams(\n            prompt=\"implement step 1.1\",\n            model=None,\n            extra_workflow_inputs={\n                \"objective_issue\": \"42\",\n                \"node_id\": \"1.1\",\n            },\n        )\n\n        result = dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        assert result is not None\n        # Branch should have P<N>- prefix\n        assert result.branch_name.startswith(\"P1-\")\n\n        # Verify extra inputs are in workflow trigger\n        _workflow, inputs = github.triggered_workflows[0]\n        assert inputs[\"objective_issue\"] == \"42\"\n        assert inputs[\"node_id\"] == \"1.1\"\n        assert inputs[\"prompt\"] == \"implement step 1.1\"\n        assert inputs[\"plan_issue_number\"] == \"1\"\n\n\ndef test_dispatch_dry_run() -> None:\n    \"\"\"Test dispatch_one_shot dry_run outputs info without mutations.\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner, env_overrides=None) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        github = FakeGitHub(authenticated=True)\n\n        ctx = build_workspace_test_context(env, git=git, github=github)\n\n        # Invoke via CLI to capture user_output via CliRunner\n        result = runner.invoke(\n            cli,\n            [\"one-shot\", \"add type hints\", \"--dry-run\", \"-m\", \"opus\"],\n            obj=ctx,\n            catch_exceptions=False,\n        )\n\n        assert result.exit_code == 0\n        assert \"Dry-run mode:\" in result.output\n        assert \"add type hints\" in result.output\n\n        # Verify no mutations occurred (skeleton issue NOT created in dry-run)\n        assert len(git.created_branches) == 0\n        assert len(git.pushed_branches) == 0\n        assert len(github.created_prs) == 0\n        assert len(github.triggered_workflows) == 0\n\n\ndef test_dispatch_stays_on_original_branch_on_error() -> None:\n    \"\"\"Test that we stay on original branch when push fails (no checkout = nothing to restore).\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner, env_overrides=None) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n            push_to_remote_error=PushError(message=\"network error\"),\n        )\n        github = FakeGitHub(authenticated=True)\n\n        ctx = build_workspace_test_context(env, git=git, github=github)\n\n        result = runner.invoke(\n            cli,\n            [\"one-shot\", \"fix the import in config.py\"],\n            obj=ctx,\n        )\n\n        # Verify command failed\n        assert result.exit_code != 0\n\n        # Verify we're still on original branch (no checkout occurred)\n        assert git.branch.get_current_branch(env.cwd) == \"main\"\n\n\ndef test_dispatch_creates_skeleton_plan_issue() -> None:\n    \"\"\"Test that skeleton plan issue is created with correct content and metadata.\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner, env_overrides=None) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        ctx = build_workspace_test_context(env, git=git, github=github, issues=issues)\n\n        params = OneShotDispatchParams(\n            prompt=\"add user authentication\",\n            model=None,\n            extra_workflow_inputs={},\n        )\n\n        dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        # Verify skeleton issue was created with expected content\n        assert len(issues.created_issues) == 1\n        title, _body, labels = issues.created_issues[0]\n        assert \"[erk-plan]\" in title\n        assert \"erk-plan\" in labels\n\n        # Verify plan comment was added (create_plan_issue adds plan as comment)\n        # Plus queued event comment from dispatch\n        assert len(issues.added_comments) == 2\n        issue_number, comment_body, _comment_id = issues.added_comments[0]\n        assert issue_number == 1\n        assert \"One-shot\" in comment_body\n        assert \"add user authentication\" in comment_body\n\n        # Verify queued event comment\n        issue_number, queued_body, _comment_id = issues.added_comments[1]\n        assert issue_number == 1\n        assert \"One-Shot Dispatched\" in queued_body\n        assert \"add user authentication\" in queued_body\n\n\ndef test_dispatch_posts_queued_event_comment() -> None:\n    \"\"\"Test dispatch posts a queued event comment with workflow run URL and prompt.\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner, env_overrides=None) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        ctx = build_workspace_test_context(env, git=git, github=github, issues=issues)\n\n        params = OneShotDispatchParams(\n            prompt=\"refactor the auth module\",\n            model=None,\n            extra_workflow_inputs={},\n        )\n\n        dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        # create_plan_issue adds 1 comment, dispatch adds queued event comment\n        assert len(issues.added_comments) == 2\n\n        # The queued event comment is the last one\n        issue_number, comment_body, _comment_id = issues.added_comments[-1]\n        assert issue_number == 1\n        assert \"One-Shot Dispatched\" in comment_body\n        assert \"refactor the auth module\" in comment_body\n        assert \"**Workflow run:**\" in comment_body\n        assert \"https://github.com/owner/repo/actions/runs/\" in comment_body\n\n\ndef test_dispatch_writes_metadata_to_plan_issue() -> None:\n    \"\"\"Test that dispatch writes run_id, node_id, and timestamp metadata to the plan issue.\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner, env_overrides={\"ERK_PLAN_BACKEND\": \"github\"}) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        ctx = build_workspace_test_context(env, git=git, github=github, issues=issues)\n\n        params = OneShotDispatchParams(\n            prompt=\"add logging to api routes\",\n            model=None,\n            extra_workflow_inputs={},\n        )\n\n        dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        # Read the plan issue and verify dispatch metadata was written\n        issue_info = issues.get_issue(env.cwd, 1)\n        assert not isinstance(issue_info, IssueNotFound)\n        assert \"last_dispatched_run_id: '1234567890'\" in issue_info.body\n        assert \"last_dispatched_node_id: WFR_fake_node_id_1234567890\" in issue_info.body\n        assert \"last_dispatched_at:\" in issue_info.body\n\n\ndef test_dispatch_draft_pr_lifecycle() -> None:\n    \"\"\"Test full draft_pr dispatch: no skeleton issue, plnd/ branch, PR with metadata block.\n\n    In draft_pr mode, the draft PR IS the plan entity. The dispatch should:\n    - NOT create a skeleton issue\n    - Use plnd/ branch naming\n    - Create a draft PR with plan-header metadata block\n    - Set plan_issue_number = pr_number for downstream code\n    - Write dispatch metadata to the PR (the plan entity)\n    - Post queued event comment to the PR\n    \"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        # Explicitly use DraftPRPlanBackend so ctx.plan_backend.get_provider_name()\n        # returns \"github-draft-pr\" and dispatch takes the draft_pr path.\n        plan_store = DraftPRPlanBackend(github, issues, time=FakeTime())\n\n        ctx = build_workspace_test_context(\n            env, git=git, github=github, issues=issues, plan_store=plan_store\n        )\n\n        params = OneShotDispatchParams(\n            prompt=\"fix the import in config.py\",\n            model=None,\n            extra_workflow_inputs={},\n        )\n\n        result = dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        assert result is not None\n\n        # No skeleton issue created — draft_pr skips issue creation\n        assert len(issues.created_issues) == 0\n\n        # Branch uses planned/ prefix (not P<N>-)\n        assert result.branch_name.startswith(\"planned/\")\n        assert not result.branch_name.startswith(\"P\")\n\n        # PR created with plan-header metadata block\n        assert len(github.created_prs) == 1\n        _branch, _title, pr_body, base, draft = github.created_prs[0]\n        assert draft is True\n        assert base == \"main\"\n        assert \"plan-header\" in pr_body\n        assert \"lifecycle_stage: prompted\" in pr_body\n        assert \"fix the import in config.py\" in pr_body\n\n        # No Closes #N in PR body (self-referential for draft_pr)\n        assert \"Closes #\" not in pr_body\n\n        # erk-plan label added to PR\n        pr_number = result.pr_number\n        assert (pr_number, \"erk-plan\") in github.added_labels\n\n        # Workflow inputs include plan_issue_number = pr_number and plan_backend\n        assert len(github.triggered_workflows) == 1\n        _workflow, inputs = github.triggered_workflows[0]\n        assert inputs[\"plan_issue_number\"] == str(pr_number)\n        assert inputs[\"plan_backend\"] == \"draft_pr\"\n\n        # Dispatch metadata written to the PR (the plan entity).\n        # The PR body is updated with footer, then dispatch metadata written\n        # via plan_backend.update_metadata targeting the PR number.\n        # updated_pr_bodies includes: (1) footer update, (2) dispatch metadata update\n        assert len(github.updated_pr_bodies) >= 2\n        # The dispatch metadata update should contain last_dispatched_run_id\n        last_body = github.updated_pr_bodies[-1][1]\n        assert \"last_dispatched_run_id\" in last_body\n\n        # Queued event comment is best-effort. In real GitHub, PRs are issues\n        # and add_comment works on PR numbers. In the fake, PRs and issues are\n        # separate, so the comment may fail. This is acceptable — dispatch\n        # metadata is the critical operation.\n\n\ndef test_dispatch_long_prompt_truncates_workflow_input() -> None:\n    \"\"\"Test that long prompts are truncated in workflow input but committed in full.\"\"\"\n    runner = CliRunner()\n    with erk_isolated_fs_env(runner) as env:\n        env.setup_repo_structure()\n\n        git = FakeGit(\n            git_common_dirs={env.cwd: env.git_dir},\n            default_branches={env.cwd: \"main\"},\n            trunk_branches={env.cwd: \"main\"},\n            current_branches={env.cwd: \"main\"},\n        )\n        issues = FakeGitHubIssues()\n        github = FakeGitHub(authenticated=True, issues_gateway=issues)\n\n        ctx = build_workspace_test_context(env, git=git, github=github, issues=issues)\n\n        long_prompt = \"x\" * 1000\n\n        params = OneShotDispatchParams(\n            prompt=long_prompt,\n            model=None,\n            extra_workflow_inputs={},\n        )\n\n        result = dispatch_one_shot(ctx, params=params, dry_run=False)\n\n        assert result is not None\n\n        # Verify workflow input was truncated\n        _workflow, inputs = github.triggered_workflows[0]\n        assert len(inputs[\"prompt\"]) < len(long_prompt)\n        assert inputs[\"prompt\"].endswith(\"... (full prompt committed to .worker-impl/prompt.md)\")\n\n        # Verify full prompt was committed directly to branch via branch_commits\n        assert len(git.branch_commits) == 1\n        assert git.branch_commits[0].files == {\".worker-impl/prompt.md\": long_prompt + \"\\n\"}\n","structuredPatch":[{"oldStart":366,"oldLines":8,"newStart":366,"newLines":8,"lines":["         # No skeleton issue created — draft_pr skips issue creation","         assert len(issues.created_issues) == 0"," ","-        # Branch uses planned/ prefix (not P<N>-)","-        assert result.branch_name.startswith(\"planned/\")","+        # Branch uses plnd/ prefix (not P<N>-)","+        assert result.branch_name.startswith(\"plnd/\")","         assert not result.branch_name.startswith(\"P\")"," ","         # PR created with plan-header metadata block"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"e092be17-64e9-4bd5-85a5-159fffd357d0","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01MMHzeNyEPPLeUcRuhLcg6s","type":"message","role":"assistant","content":[{"type":"text","text":"Now update test_plan_save.py:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":224,"cache_read_input_tokens":97551,"cache_creation":{"ephemeral_5m_input_tokens":224,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHpzFiic5cS6FJ41AsS","type":"assistant","uuid":"dc47d12d-cfe9-4b4a-92a7-d581002801c4","timestamp":"2026-02-22T14:47:59.004Z"}
{"parentUuid":"dc47d12d-cfe9-4b4a-92a7-d581002801c4","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01MMHzeNyEPPLeUcRuhLcg6s","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018WyN3GrBp9wkYeWkpmiEXd","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_save.py","offset":60,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":224,"cache_read_input_tokens":97551,"cache_creation":{"ephemeral_5m_input_tokens":224,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHpzFiic5cS6FJ41AsS","type":"assistant","uuid":"944fb543-2dd2-4185-8db2-256ddc8c4f9c","timestamp":"2026-02-22T14:47:59.982Z"}
{"parentUuid":"944fb543-2dd2-4185-8db2-256ddc8c4f9c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018WyN3GrBp9wkYeWkpmiEXd","type":"tool_result","content":"    60→    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n    61→\n    62→    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    63→    output = json.loads(result.output)\n    64→    assert output[\"success\"] is True\n    65→    assert \"issue_number\" in output\n    66→    assert \"branch_name\" in output\n    67→    assert output[\"branch_name\"].startswith(\"planned/\")\n    68→    assert output[\"plan_backend\"] == \"draft_pr\"\n    69→\n    70→\n    71→def test_draft_pr_success_display(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    72→    \"\"\"Display format: output contains 'Plan saved as draft PR'.\"\"\"\n    73→    ctx = _draft_pr_context(tmp_path=tmp_path, monkeypatch=monkeypatch)\n    74→    runner = CliRunner()\n    75→\n    76→    result = runner.invoke(plan_save, [\"--format\", \"display\"], obj=ctx)\n    77→\n    78→    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    79→    assert \"Plan saved as draft PR\" in result.output\n    80→    assert \"Title: [erk-plan] Feature Plan\" in result.output\n    81→    assert \"Branch: planned/\" in result.output\n    82→    assert \"erk br co\" in result.output\n    83→    assert \"planned/\" in result.output  # branch name appears in checkout command\n    84→\n    85→\n    86→def test_delegates_to_issue_when_not_draft_pr(\n    87→    tmp_path: Path, monkeypatch: pytest.MonkeyPatch\n    88→) -> None:\n    89→    \"\"\"plan_backend=\"github\" delegates to plan_save_to_issue.\"\"\"\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"2a92acb6-0706-4775-a103-8d5645c5154a","timestamp":"2026-02-22T14:48:00.032Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_save.py","content":"    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    assert \"issue_number\" in output\n    assert \"branch_name\" in output\n    assert output[\"branch_name\"].startswith(\"planned/\")\n    assert output[\"plan_backend\"] == \"draft_pr\"\n\n\ndef test_draft_pr_success_display(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Display format: output contains 'Plan saved as draft PR'.\"\"\"\n    ctx = _draft_pr_context(tmp_path=tmp_path, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"display\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    assert \"Plan saved as draft PR\" in result.output\n    assert \"Title: [erk-plan] Feature Plan\" in result.output\n    assert \"Branch: planned/\" in result.output\n    assert \"erk br co\" in result.output\n    assert \"planned/\" in result.output  # branch name appears in checkout command\n\n\ndef test_delegates_to_issue_when_not_draft_pr(\n    tmp_path: Path, monkeypatch: pytest.MonkeyPatch\n) -> None:\n    \"\"\"plan_backend=\"github\" delegates to plan_save_to_issue.\"\"\"","numLines":30,"startLine":60,"totalLines":313}}}
{"parentUuid":"2a92acb6-0706-4775-a103-8d5645c5154a","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01W5x7PHVz15oBk18Lt61wwc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DjwZjC7k95SsKgc6zmU2b4","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_save.py","old_string":"    assert output[\"branch_name\"].startswith(\"planned/\")\n    assert output[\"plan_backend\"] == \"draft_pr\"\n\n\ndef test_draft_pr_success_display(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Display format: output contains 'Plan saved as draft PR'.\"\"\"\n    ctx = _draft_pr_context(tmp_path=tmp_path, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"display\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    assert \"Plan saved as draft PR\" in result.output\n    assert \"Title: [erk-plan] Feature Plan\" in result.output\n    assert \"Branch: planned/\" in result.output\n    assert \"erk br co\" in result.output\n    assert \"planned/\" in result.output  # branch name appears in checkout command","new_string":"    assert output[\"branch_name\"].startswith(\"plnd/\")\n    assert output[\"plan_backend\"] == \"draft_pr\"\n\n\ndef test_draft_pr_success_display(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Display format: output contains 'Plan saved as draft PR'.\"\"\"\n    ctx = _draft_pr_context(tmp_path=tmp_path, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"display\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    assert \"Plan saved as draft PR\" in result.output\n    assert \"Title: [erk-plan] Feature Plan\" in result.output\n    assert \"Branch: plnd/\" in result.output\n    assert \"erk br co\" in result.output\n    assert \"plnd/\" in result.output  # branch name appears in checkout command"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1037,"cache_read_input_tokens":97775,"cache_creation":{"ephemeral_5m_input_tokens":1037,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHqGaEzV3TuRRcD26S8","type":"assistant","uuid":"ef1ce263-953c-4d5d-afda-2cbc0d7d20c2","timestamp":"2026-02-22T14:48:07.485Z"}
{"parentUuid":"ef1ce263-953c-4d5d-afda-2cbc0d7d20c2","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DjwZjC7k95SsKgc6zmU2b4","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_save.py has been updated successfully."}]},"uuid":"f4b5dc24-ff3a-47b2-a43d-23396e6a063b","timestamp":"2026-02-22T14:48:08.180Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_save.py","oldString":"    assert output[\"branch_name\"].startswith(\"planned/\")\n    assert output[\"plan_backend\"] == \"draft_pr\"\n\n\ndef test_draft_pr_success_display(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Display format: output contains 'Plan saved as draft PR'.\"\"\"\n    ctx = _draft_pr_context(tmp_path=tmp_path, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"display\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    assert \"Plan saved as draft PR\" in result.output\n    assert \"Title: [erk-plan] Feature Plan\" in result.output\n    assert \"Branch: planned/\" in result.output\n    assert \"erk br co\" in result.output\n    assert \"planned/\" in result.output  # branch name appears in checkout command","newString":"    assert output[\"branch_name\"].startswith(\"plnd/\")\n    assert output[\"plan_backend\"] == \"draft_pr\"\n\n\ndef test_draft_pr_success_display(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Display format: output contains 'Plan saved as draft PR'.\"\"\"\n    ctx = _draft_pr_context(tmp_path=tmp_path, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"display\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    assert \"Plan saved as draft PR\" in result.output\n    assert \"Title: [erk-plan] Feature Plan\" in result.output\n    assert \"Branch: plnd/\" in result.output\n    assert \"erk br co\" in result.output\n    assert \"plnd/\" in result.output  # branch name appears in checkout command","originalFile":"\"\"\"Unit tests for plan-save command (backend-aware dispatcher).\"\"\"\n\nimport json\nfrom pathlib import Path\n\nimport pytest\nfrom click.testing import CliRunner\n\nfrom erk.cli.commands.exec.scripts.plan_save import plan_save\nfrom erk_shared.context.context import ErkContext\nfrom erk_shared.context.testing import context_for_test\nfrom erk_shared.gateway.claude_installation.fake import FakeClaudeInstallation\nfrom erk_shared.gateway.git.fake import FakeGit\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.issues.fake import FakeGitHubIssues\nfrom erk_shared.gateway.graphite.fake import FakeGraphite\nfrom erk_shared.plan_store.draft_pr_lifecycle import IMPL_CONTEXT_DIR\n\n# Valid plan content that passes validation (100+ chars with structure)\nVALID_PLAN_CONTENT = \"\"\"# Feature Plan\n\nThis plan describes the implementation of a new feature.\n\n- Step 1: Set up the environment\n- Step 2: Implement the core logic\n- Step 3: Add tests and documentation\"\"\"\n\n\ndef _draft_pr_context(\n    *,\n    tmp_path: Path,\n    fake_github: FakeGitHub | None = None,\n    fake_git: FakeGit | None = None,\n    fake_claude: FakeClaudeInstallation | None = None,\n    monkeypatch: pytest.MonkeyPatch,\n) -> ErkContext:\n    \"\"\"Build an ErkContext configured for draft-PR plan backend.\"\"\"\n    if fake_git is None:\n        fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    if fake_github is None:\n        fake_github = FakeGitHub()\n    if fake_claude is None:\n        fake_claude = FakeClaudeInstallation.for_test(plans={\"plan\": VALID_PLAN_CONTENT})\n\n    monkeypatch.setenv(\"ERK_PLAN_BACKEND\", \"draft_pr\")\n    return context_for_test(\n        github=fake_github,\n        git=fake_git,\n        claude_installation=fake_claude,\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n\n\ndef test_draft_pr_success_json(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Happy path: exit 0, JSON output has success/issue_number/branch_name.\"\"\"\n    ctx = _draft_pr_context(tmp_path=tmp_path, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    assert \"issue_number\" in output\n    assert \"branch_name\" in output\n    assert output[\"branch_name\"].startswith(\"planned/\")\n    assert output[\"plan_backend\"] == \"draft_pr\"\n\n\ndef test_draft_pr_success_display(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Display format: output contains 'Plan saved as draft PR'.\"\"\"\n    ctx = _draft_pr_context(tmp_path=tmp_path, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"display\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    assert \"Plan saved as draft PR\" in result.output\n    assert \"Title: [erk-plan] Feature Plan\" in result.output\n    assert \"Branch: planned/\" in result.output\n    assert \"erk br co\" in result.output\n    assert \"planned/\" in result.output  # branch name appears in checkout command\n\n\ndef test_delegates_to_issue_when_not_draft_pr(\n    tmp_path: Path, monkeypatch: pytest.MonkeyPatch\n) -> None:\n    \"\"\"plan_backend=\"github\" delegates to plan_save_to_issue.\"\"\"\n    monkeypatch.delenv(\"ERK_PLAN_BACKEND\", raising=False)\n    fake_issues = FakeGitHubIssues()\n    fake_github = FakeGitHub(issues_gateway=fake_issues)\n    ctx = context_for_test(\n        github=fake_github,\n        github_issues=fake_issues,\n        claude_installation=FakeClaudeInstallation.for_test(plans={\"plan\": VALID_PLAN_CONTENT}),\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    # Issue-based save creates issues, not PRs\n    assert len(fake_issues.created_issues) == 1\n    assert len(fake_github.created_prs) == 0\n\n\ndef test_draft_pr_no_plan_found(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Empty claude_installation: exit code 1.\"\"\"\n    ctx = _draft_pr_context(\n        tmp_path=tmp_path,\n        fake_claude=FakeClaudeInstallation.for_test(),\n        monkeypatch=monkeypatch,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n    assert output[\"success\"] is False\n    assert \"No plan found\" in output[\"error\"]\n\n\ndef test_draft_pr_validation_failure(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Short plan: exit code 2, error_type='validation_failed'.\"\"\"\n    short_plan = \"# Short\\n\\n- Step\"\n    ctx = _draft_pr_context(\n        tmp_path=tmp_path,\n        fake_claude=FakeClaudeInstallation.for_test(plans={\"short\": short_plan}),\n        monkeypatch=monkeypatch,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 2\n    output = json.loads(result.output)\n    assert output[\"success\"] is False\n    assert output[\"error_type\"] == \"validation_failed\"\n\n\ndef test_draft_pr_session_deduplication(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Second call with same session_id: skipped_duplicate=True.\"\"\"\n    ctx = _draft_pr_context(tmp_path=tmp_path, monkeypatch=monkeypatch)\n    runner = CliRunner()\n    session_id = \"dedup-session\"\n\n    # First call creates the plan\n    result1 = runner.invoke(\n        plan_save,\n        [\"--format\", \"json\", \"--session-id\", session_id],\n        obj=ctx,\n    )\n    assert result1.exit_code == 0, f\"First call failed: {result1.output}\"\n    output1 = json.loads(result1.output)\n    assert output1[\"success\"] is True\n    assert \"skipped_duplicate\" not in output1\n\n    # Second call with same session_id should detect duplicate\n    result2 = runner.invoke(\n        plan_save,\n        [\"--format\", \"json\", \"--session-id\", session_id],\n        obj=ctx,\n    )\n    assert result2.exit_code == 0, f\"Second call failed: {result2.output}\"\n    output2 = json.loads(result2.output)\n    assert output2[\"success\"] is True\n    assert output2[\"skipped_duplicate\"] is True\n\n\ndef test_draft_pr_plan_file_priority(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"--plan-file takes priority over claude_installation.\"\"\"\n    plan_file = tmp_path / \"custom-plan.md\"\n    plan_file.write_text(\n        \"# Custom Plan\\n\\nThis is a custom plan from a file that should take priority.\\n\\n\"\n        \"- Step 1: Custom step\\n- Step 2: Another custom step\",\n        encoding=\"utf-8\",\n    )\n    ctx = _draft_pr_context(tmp_path=tmp_path, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_save,\n        [\"--format\", \"json\", \"--plan-file\", str(plan_file)],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    assert output[\"title\"] == \"[erk-plan] Custom Plan\"\n\n\ndef test_draft_pr_objective_issue_metadata(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"--objective-issue 123 includes in branch name, metadata, and ref.json.\"\"\"\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    ctx = _draft_pr_context(tmp_path=tmp_path, fake_git=fake_git, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_save,\n        [\"--format\", \"json\", \"--objective-issue\", \"123\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    # Branch name should include objective ID\n    assert \"O123\" in output[\"branch_name\"]\n    # ref.json content should include objective_id (via branch commit, no filesystem)\n    assert len(fake_git.branch_commits) == 1\n    ref_json = json.loads(fake_git.branch_commits[0].files[f\"{IMPL_CONTEXT_DIR}/ref.json\"])\n    assert ref_json[\"objective_id\"] == 123\n\n\ndef test_draft_pr_does_not_checkout_branch(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"plan-save uses git plumbing to commit without checking out the plan branch.\"\"\"\n    fake_git = FakeGit(current_branches={tmp_path: \"feature-branch\"})\n    ctx = _draft_pr_context(tmp_path=tmp_path, fake_git=fake_git, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    # No checkouts at all — gt track accepts branch positionally, and\n    # the plan commit uses git plumbing. No checkout/restore cycle needed.\n    assert len(fake_git.checked_out_branches) == 0\n\n\ndef test_draft_pr_commits_plan_file(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"plan-save commits plan.md to the plan branch via git plumbing.\"\"\"\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    ctx = _draft_pr_context(tmp_path=tmp_path, fake_git=fake_git, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    # Verify branch commit was created with impl-context files (via git plumbing)\n    assert len(fake_git.branch_commits) == 1\n    branch_commit = fake_git.branch_commits[0]\n    assert f\"{IMPL_CONTEXT_DIR}/plan.md\" in branch_commit.files\n    assert f\"{IMPL_CONTEXT_DIR}/ref.json\" in branch_commit.files\n    assert \"Feature Plan\" in branch_commit.message\n    assert branch_commit.branch.startswith(\"planned/\")\n    # Verify plan content\n    assert \"Feature Plan\" in branch_commit.files[f\"{IMPL_CONTEXT_DIR}/plan.md\"]\n    # Verify ref.json content\n    ref_data = json.loads(branch_commit.files[f\"{IMPL_CONTEXT_DIR}/ref.json\"])\n    assert ref_data[\"provider\"] == \"github-draft-pr\"\n    assert ref_data[\"title\"] == \"Feature Plan\"\n    assert \"url\" not in ref_data\n    # No regular commits should exist (git plumbing bypasses stage+commit)\n    assert len(fake_git.commits) == 0\n\n\ndef test_draft_pr_trunk_branch_passes_through_to_pr_base(\n    tmp_path: Path, monkeypatch: pytest.MonkeyPatch\n) -> None:\n    \"\"\"trunk_branch detected by detect_trunk_branch flows through metadata to PR base.\"\"\"\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"}, trunk_branches={tmp_path: \"master\"})\n    fake_github = FakeGitHub()\n    ctx = _draft_pr_context(\n        tmp_path=tmp_path,\n        fake_git=fake_git,\n        fake_github=fake_github,\n        monkeypatch=monkeypatch,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    assert len(fake_github.created_prs) == 1\n    assert fake_github.created_prs[0][3] == \"master\"\n\n\ndef test_draft_pr_tracks_branch_with_graphite(\n    tmp_path: Path, monkeypatch: pytest.MonkeyPatch\n) -> None:\n    \"\"\"Plan branch is tracked with Graphite so it can be used as a stack parent.\"\"\"\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"}, trunk_branches={tmp_path: \"master\"})\n    fake_graphite = FakeGraphite()\n    monkeypatch.setenv(\"ERK_PLAN_BACKEND\", \"draft_pr\")\n    ctx = context_for_test(\n        git=fake_git,\n        graphite=fake_graphite,\n        claude_installation=FakeClaudeInstallation.for_test(plans={\"plan\": VALID_PLAN_CONTENT}),\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    branch_name = output[\"branch_name\"]\n\n    # Verify track_branch was called with the plan branch and current branch as parent\n    # (branch_manager.create_branch uses base_branch as Graphite parent)\n    assert len(fake_graphite.track_branch_calls) == 1\n    tracked_call = fake_graphite.track_branch_calls[0]\n    assert tracked_call[0] == tmp_path  # repo_root\n    assert tracked_call[1] == branch_name  # branch_name\n    assert tracked_call[2] == \"main\"  # parent_branch (current branch used as base)\n","structuredPatch":[{"oldStart":64,"oldLines":7,"newStart":64,"newLines":7,"lines":["     assert output[\"success\"] is True","     assert \"issue_number\" in output","     assert \"branch_name\" in output","-    assert output[\"branch_name\"].startswith(\"planned/\")","+    assert output[\"branch_name\"].startswith(\"plnd/\")","     assert output[\"plan_backend\"] == \"draft_pr\""," "," "]},{"oldStart":78,"oldLines":9,"newStart":78,"newLines":9,"lines":["     assert result.exit_code == 0, f\"Failed: {result.output}\"","     assert \"Plan saved as draft PR\" in result.output","     assert \"Title: [erk-plan] Feature Plan\" in result.output","-    assert \"Branch: planned/\" in result.output","+    assert \"Branch: plnd/\" in result.output","     assert \"erk br co\" in result.output","-    assert \"planned/\" in result.output  # branch name appears in checkout command","+    assert \"plnd/\" in result.output  # branch name appears in checkout command"," "," "," def test_delegates_to_issue_when_not_draft_pr("]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"f4b5dc24-ff3a-47b2-a43d-23396e6a063b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_0195k9NidgkTX2wpWzXUgqYs","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the remaining test at line 251:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":647,"cache_read_input_tokens":98812,"cache_creation":{"ephemeral_5m_input_tokens":647,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHqsRV4e4J2xuZEaEM5","type":"assistant","uuid":"832d2897-49aa-4c94-9b5f-28fcd167c8ca","timestamp":"2026-02-22T14:48:11.186Z"}
{"parentUuid":"832d2897-49aa-4c94-9b5f-28fcd167c8ca","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_0195k9NidgkTX2wpWzXUgqYs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01N6W2Qm7Qe9RbYxakEyZHLD","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_save.py","offset":245,"limit":10},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":647,"cache_read_input_tokens":98812,"cache_creation":{"ephemeral_5m_input_tokens":647,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHqsRV4e4J2xuZEaEM5","type":"assistant","uuid":"598a084c-066a-4da1-b70e-7b49cec75b11","timestamp":"2026-02-22T14:48:11.885Z"}
{"parentUuid":"598a084c-066a-4da1-b70e-7b49cec75b11","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01N6W2Qm7Qe9RbYxakEyZHLD","type":"tool_result","content":"   245→    # Verify branch commit was created with impl-context files (via git plumbing)\n   246→    assert len(fake_git.branch_commits) == 1\n   247→    branch_commit = fake_git.branch_commits[0]\n   248→    assert f\"{IMPL_CONTEXT_DIR}/plan.md\" in branch_commit.files\n   249→    assert f\"{IMPL_CONTEXT_DIR}/ref.json\" in branch_commit.files\n   250→    assert \"Feature Plan\" in branch_commit.message\n   251→    assert branch_commit.branch.startswith(\"planned/\")\n   252→    # Verify plan content\n   253→    assert \"Feature Plan\" in branch_commit.files[f\"{IMPL_CONTEXT_DIR}/plan.md\"]\n   254→    # Verify ref.json content\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"2cdb4920-2078-4cd6-870a-10ff6356eed2","timestamp":"2026-02-22T14:48:11.950Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_save.py","content":"    # Verify branch commit was created with impl-context files (via git plumbing)\n    assert len(fake_git.branch_commits) == 1\n    branch_commit = fake_git.branch_commits[0]\n    assert f\"{IMPL_CONTEXT_DIR}/plan.md\" in branch_commit.files\n    assert f\"{IMPL_CONTEXT_DIR}/ref.json\" in branch_commit.files\n    assert \"Feature Plan\" in branch_commit.message\n    assert branch_commit.branch.startswith(\"planned/\")\n    # Verify plan content\n    assert \"Feature Plan\" in branch_commit.files[f\"{IMPL_CONTEXT_DIR}/plan.md\"]\n    # Verify ref.json content","numLines":10,"startLine":245,"totalLines":313}}}
{"parentUuid":"2cdb4920-2078-4cd6-870a-10ff6356eed2","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01W3ayuNZYSadpQn7H3iu2zz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JcczC7p4M1bey3JdychvqE","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_save.py","old_string":"    assert branch_commit.branch.startswith(\"planned/\")","new_string":"    assert branch_commit.branch.startswith(\"plnd/\")"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":758,"cache_read_input_tokens":99459,"cache_creation":{"ephemeral_5m_input_tokens":758,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHr9Wru6FEQXvNNjtVC","type":"assistant","uuid":"239cbabf-041d-45d9-8ac3-fc5ca5b8d7c8","timestamp":"2026-02-22T14:48:15.233Z"}
{"parentUuid":"239cbabf-041d-45d9-8ac3-fc5ca5b8d7c8","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JcczC7p4M1bey3JdychvqE","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_save.py has been updated successfully."}]},"uuid":"ceee3552-b6e6-4893-9d92-ad2ceb3aa0da","timestamp":"2026-02-22T14:48:15.930Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_save.py","oldString":"    assert branch_commit.branch.startswith(\"planned/\")","newString":"    assert branch_commit.branch.startswith(\"plnd/\")","originalFile":"\"\"\"Unit tests for plan-save command (backend-aware dispatcher).\"\"\"\n\nimport json\nfrom pathlib import Path\n\nimport pytest\nfrom click.testing import CliRunner\n\nfrom erk.cli.commands.exec.scripts.plan_save import plan_save\nfrom erk_shared.context.context import ErkContext\nfrom erk_shared.context.testing import context_for_test\nfrom erk_shared.gateway.claude_installation.fake import FakeClaudeInstallation\nfrom erk_shared.gateway.git.fake import FakeGit\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.issues.fake import FakeGitHubIssues\nfrom erk_shared.gateway.graphite.fake import FakeGraphite\nfrom erk_shared.plan_store.draft_pr_lifecycle import IMPL_CONTEXT_DIR\n\n# Valid plan content that passes validation (100+ chars with structure)\nVALID_PLAN_CONTENT = \"\"\"# Feature Plan\n\nThis plan describes the implementation of a new feature.\n\n- Step 1: Set up the environment\n- Step 2: Implement the core logic\n- Step 3: Add tests and documentation\"\"\"\n\n\ndef _draft_pr_context(\n    *,\n    tmp_path: Path,\n    fake_github: FakeGitHub | None = None,\n    fake_git: FakeGit | None = None,\n    fake_claude: FakeClaudeInstallation | None = None,\n    monkeypatch: pytest.MonkeyPatch,\n) -> ErkContext:\n    \"\"\"Build an ErkContext configured for draft-PR plan backend.\"\"\"\n    if fake_git is None:\n        fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    if fake_github is None:\n        fake_github = FakeGitHub()\n    if fake_claude is None:\n        fake_claude = FakeClaudeInstallation.for_test(plans={\"plan\": VALID_PLAN_CONTENT})\n\n    monkeypatch.setenv(\"ERK_PLAN_BACKEND\", \"draft_pr\")\n    return context_for_test(\n        github=fake_github,\n        git=fake_git,\n        claude_installation=fake_claude,\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n\n\ndef test_draft_pr_success_json(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Happy path: exit 0, JSON output has success/issue_number/branch_name.\"\"\"\n    ctx = _draft_pr_context(tmp_path=tmp_path, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    assert \"issue_number\" in output\n    assert \"branch_name\" in output\n    assert output[\"branch_name\"].startswith(\"plnd/\")\n    assert output[\"plan_backend\"] == \"draft_pr\"\n\n\ndef test_draft_pr_success_display(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Display format: output contains 'Plan saved as draft PR'.\"\"\"\n    ctx = _draft_pr_context(tmp_path=tmp_path, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"display\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    assert \"Plan saved as draft PR\" in result.output\n    assert \"Title: [erk-plan] Feature Plan\" in result.output\n    assert \"Branch: plnd/\" in result.output\n    assert \"erk br co\" in result.output\n    assert \"plnd/\" in result.output  # branch name appears in checkout command\n\n\ndef test_delegates_to_issue_when_not_draft_pr(\n    tmp_path: Path, monkeypatch: pytest.MonkeyPatch\n) -> None:\n    \"\"\"plan_backend=\"github\" delegates to plan_save_to_issue.\"\"\"\n    monkeypatch.delenv(\"ERK_PLAN_BACKEND\", raising=False)\n    fake_issues = FakeGitHubIssues()\n    fake_github = FakeGitHub(issues_gateway=fake_issues)\n    ctx = context_for_test(\n        github=fake_github,\n        github_issues=fake_issues,\n        claude_installation=FakeClaudeInstallation.for_test(plans={\"plan\": VALID_PLAN_CONTENT}),\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    # Issue-based save creates issues, not PRs\n    assert len(fake_issues.created_issues) == 1\n    assert len(fake_github.created_prs) == 0\n\n\ndef test_draft_pr_no_plan_found(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Empty claude_installation: exit code 1.\"\"\"\n    ctx = _draft_pr_context(\n        tmp_path=tmp_path,\n        fake_claude=FakeClaudeInstallation.for_test(),\n        monkeypatch=monkeypatch,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n    assert output[\"success\"] is False\n    assert \"No plan found\" in output[\"error\"]\n\n\ndef test_draft_pr_validation_failure(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Short plan: exit code 2, error_type='validation_failed'.\"\"\"\n    short_plan = \"# Short\\n\\n- Step\"\n    ctx = _draft_pr_context(\n        tmp_path=tmp_path,\n        fake_claude=FakeClaudeInstallation.for_test(plans={\"short\": short_plan}),\n        monkeypatch=monkeypatch,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 2\n    output = json.loads(result.output)\n    assert output[\"success\"] is False\n    assert output[\"error_type\"] == \"validation_failed\"\n\n\ndef test_draft_pr_session_deduplication(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Second call with same session_id: skipped_duplicate=True.\"\"\"\n    ctx = _draft_pr_context(tmp_path=tmp_path, monkeypatch=monkeypatch)\n    runner = CliRunner()\n    session_id = \"dedup-session\"\n\n    # First call creates the plan\n    result1 = runner.invoke(\n        plan_save,\n        [\"--format\", \"json\", \"--session-id\", session_id],\n        obj=ctx,\n    )\n    assert result1.exit_code == 0, f\"First call failed: {result1.output}\"\n    output1 = json.loads(result1.output)\n    assert output1[\"success\"] is True\n    assert \"skipped_duplicate\" not in output1\n\n    # Second call with same session_id should detect duplicate\n    result2 = runner.invoke(\n        plan_save,\n        [\"--format\", \"json\", \"--session-id\", session_id],\n        obj=ctx,\n    )\n    assert result2.exit_code == 0, f\"Second call failed: {result2.output}\"\n    output2 = json.loads(result2.output)\n    assert output2[\"success\"] is True\n    assert output2[\"skipped_duplicate\"] is True\n\n\ndef test_draft_pr_plan_file_priority(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"--plan-file takes priority over claude_installation.\"\"\"\n    plan_file = tmp_path / \"custom-plan.md\"\n    plan_file.write_text(\n        \"# Custom Plan\\n\\nThis is a custom plan from a file that should take priority.\\n\\n\"\n        \"- Step 1: Custom step\\n- Step 2: Another custom step\",\n        encoding=\"utf-8\",\n    )\n    ctx = _draft_pr_context(tmp_path=tmp_path, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_save,\n        [\"--format\", \"json\", \"--plan-file\", str(plan_file)],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    assert output[\"title\"] == \"[erk-plan] Custom Plan\"\n\n\ndef test_draft_pr_objective_issue_metadata(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"--objective-issue 123 includes in branch name, metadata, and ref.json.\"\"\"\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    ctx = _draft_pr_context(tmp_path=tmp_path, fake_git=fake_git, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_save,\n        [\"--format\", \"json\", \"--objective-issue\", \"123\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    # Branch name should include objective ID\n    assert \"O123\" in output[\"branch_name\"]\n    # ref.json content should include objective_id (via branch commit, no filesystem)\n    assert len(fake_git.branch_commits) == 1\n    ref_json = json.loads(fake_git.branch_commits[0].files[f\"{IMPL_CONTEXT_DIR}/ref.json\"])\n    assert ref_json[\"objective_id\"] == 123\n\n\ndef test_draft_pr_does_not_checkout_branch(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"plan-save uses git plumbing to commit without checking out the plan branch.\"\"\"\n    fake_git = FakeGit(current_branches={tmp_path: \"feature-branch\"})\n    ctx = _draft_pr_context(tmp_path=tmp_path, fake_git=fake_git, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    # No checkouts at all — gt track accepts branch positionally, and\n    # the plan commit uses git plumbing. No checkout/restore cycle needed.\n    assert len(fake_git.checked_out_branches) == 0\n\n\ndef test_draft_pr_commits_plan_file(tmp_path: Path, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"plan-save commits plan.md to the plan branch via git plumbing.\"\"\"\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    ctx = _draft_pr_context(tmp_path=tmp_path, fake_git=fake_git, monkeypatch=monkeypatch)\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    # Verify branch commit was created with impl-context files (via git plumbing)\n    assert len(fake_git.branch_commits) == 1\n    branch_commit = fake_git.branch_commits[0]\n    assert f\"{IMPL_CONTEXT_DIR}/plan.md\" in branch_commit.files\n    assert f\"{IMPL_CONTEXT_DIR}/ref.json\" in branch_commit.files\n    assert \"Feature Plan\" in branch_commit.message\n    assert branch_commit.branch.startswith(\"planned/\")\n    # Verify plan content\n    assert \"Feature Plan\" in branch_commit.files[f\"{IMPL_CONTEXT_DIR}/plan.md\"]\n    # Verify ref.json content\n    ref_data = json.loads(branch_commit.files[f\"{IMPL_CONTEXT_DIR}/ref.json\"])\n    assert ref_data[\"provider\"] == \"github-draft-pr\"\n    assert ref_data[\"title\"] == \"Feature Plan\"\n    assert \"url\" not in ref_data\n    # No regular commits should exist (git plumbing bypasses stage+commit)\n    assert len(fake_git.commits) == 0\n\n\ndef test_draft_pr_trunk_branch_passes_through_to_pr_base(\n    tmp_path: Path, monkeypatch: pytest.MonkeyPatch\n) -> None:\n    \"\"\"trunk_branch detected by detect_trunk_branch flows through metadata to PR base.\"\"\"\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"}, trunk_branches={tmp_path: \"master\"})\n    fake_github = FakeGitHub()\n    ctx = _draft_pr_context(\n        tmp_path=tmp_path,\n        fake_git=fake_git,\n        fake_github=fake_github,\n        monkeypatch=monkeypatch,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    assert len(fake_github.created_prs) == 1\n    assert fake_github.created_prs[0][3] == \"master\"\n\n\ndef test_draft_pr_tracks_branch_with_graphite(\n    tmp_path: Path, monkeypatch: pytest.MonkeyPatch\n) -> None:\n    \"\"\"Plan branch is tracked with Graphite so it can be used as a stack parent.\"\"\"\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"}, trunk_branches={tmp_path: \"master\"})\n    fake_graphite = FakeGraphite()\n    monkeypatch.setenv(\"ERK_PLAN_BACKEND\", \"draft_pr\")\n    ctx = context_for_test(\n        git=fake_git,\n        graphite=fake_graphite,\n        claude_installation=FakeClaudeInstallation.for_test(plans={\"plan\": VALID_PLAN_CONTENT}),\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(plan_save, [\"--format\", \"json\"], obj=ctx)\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    branch_name = output[\"branch_name\"]\n\n    # Verify track_branch was called with the plan branch and current branch as parent\n    # (branch_manager.create_branch uses base_branch as Graphite parent)\n    assert len(fake_graphite.track_branch_calls) == 1\n    tracked_call = fake_graphite.track_branch_calls[0]\n    assert tracked_call[0] == tmp_path  # repo_root\n    assert tracked_call[1] == branch_name  # branch_name\n    assert tracked_call[2] == \"main\"  # parent_branch (current branch used as base)\n","structuredPatch":[{"oldStart":248,"oldLines":7,"newStart":248,"newLines":7,"lines":["     assert f\"{IMPL_CONTEXT_DIR}/plan.md\" in branch_commit.files","     assert f\"{IMPL_CONTEXT_DIR}/ref.json\" in branch_commit.files","     assert \"Feature Plan\" in branch_commit.message","-    assert branch_commit.branch.startswith(\"planned/\")","+    assert branch_commit.branch.startswith(\"plnd/\")","     # Verify plan content","     assert \"Feature Plan\" in branch_commit.files[f\"{IMPL_CONTEXT_DIR}/plan.md\"]","     # Verify ref.json content"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"ceee3552-b6e6-4893-9d92-ad2ceb3aa0da","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01BHB6Sg6XuXRAyaZwB9vf4P","type":"message","role":"assistant","content":[{"type":"text","text":"Now update test_plan_migrate_to_draft_pr.py:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":197,"cache_read_input_tokens":100217,"cache_creation":{"ephemeral_5m_input_tokens":197,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHrSek6pQcPYsCQR3z8","type":"assistant","uuid":"b8895dfc-ee0e-4273-a7de-fd3332b5146f","timestamp":"2026-02-22T14:48:19.261Z"}
{"parentUuid":"b8895dfc-ee0e-4273-a7de-fd3332b5146f","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01BHB6Sg6XuXRAyaZwB9vf4P","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BPsRPEp274PeV6STzS8TwX","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py","offset":95,"limit":10},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":197,"cache_read_input_tokens":100217,"cache_creation":{"ephemeral_5m_input_tokens":197,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHrSek6pQcPYsCQR3z8","type":"assistant","uuid":"a3651309-2abd-4c5e-b437-fee8db3290cf","timestamp":"2026-02-22T14:48:20.079Z"}
{"parentUuid":"a3651309-2abd-4c5e-b437-fee8db3290cf","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BPsRPEp274PeV6STzS8TwX","type":"tool_result","content":"    95→    output = json.loads(result.output)\n    96→    assert output[\"success\"] is True\n    97→    assert output[\"original_issue_number\"] == 42\n    98→    assert \"pr_number\" in output\n    99→    assert \"pr_url\" in output\n   100→    assert output[\"branch_name\"].startswith(\"planned/\")\n   101→\n   102→\n   103→def test_migrate_success_display(tmp_path: Path) -> None:\n   104→    \"\"\"Display format shows human-readable migration summary.\"\"\"\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"2f187ace-033f-4c63-825e-a442c79195d1","timestamp":"2026-02-22T14:48:20.114Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py","content":"    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    assert output[\"original_issue_number\"] == 42\n    assert \"pr_number\" in output\n    assert \"pr_url\" in output\n    assert output[\"branch_name\"].startswith(\"planned/\")\n\n\ndef test_migrate_success_display(tmp_path: Path) -> None:\n    \"\"\"Display format shows human-readable migration summary.\"\"\"","numLines":10,"startLine":95,"totalLines":382}}}
{"parentUuid":"2f187ace-033f-4c63-825e-a442c79195d1","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01REERhAzuQfUWaGfM93ESbU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0185QPhx3t1xk2TzSttHhMJV","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py","old_string":"    assert output[\"branch_name\"].startswith(\"planned/\")","new_string":"    assert output[\"branch_name\"].startswith(\"plnd/\")"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":700,"cache_read_input_tokens":100414,"cache_creation":{"ephemeral_5m_input_tokens":700,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHrkRaTKYjJokX5GMCX","type":"assistant","uuid":"b2b3f22f-4717-4eea-853e-e7876fa71b79","timestamp":"2026-02-22T14:48:23.407Z"}
{"parentUuid":"b2b3f22f-4717-4eea-853e-e7876fa71b79","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0185QPhx3t1xk2TzSttHhMJV","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py has been updated successfully."}]},"uuid":"9ab0eef7-5579-4746-81aa-836679ec3c98","timestamp":"2026-02-22T14:48:24.074Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py","oldString":"    assert output[\"branch_name\"].startswith(\"planned/\")","newString":"    assert output[\"branch_name\"].startswith(\"plnd/\")","originalFile":"\"\"\"Unit tests for plan-migrate-to-draft-pr command.\"\"\"\n\nimport json\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nfrom click.testing import CliRunner\n\nfrom erk.cli.commands.exec.scripts.plan_migrate_to_draft_pr import plan_migrate_to_draft_pr\nfrom erk_shared.context.testing import context_for_test\nfrom erk_shared.gateway.git.fake import FakeGit\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.issues.fake import FakeGitHubIssues\nfrom erk_shared.gateway.github.issues.types import IssueInfo\nfrom erk_shared.gateway.github.metadata.plan_header import (\n    format_plan_content_comment,\n    format_plan_header_body,\n)\n\n_NOW = datetime(2025, 1, 15, 14, 30, tzinfo=UTC)\n\nPLAN_CONTENT = \"\"\"# Fix authentication bug\n\nThis plan describes fixing a bug in the auth flow.\n\n- Step 1: Identify the root cause\n- Step 2: Write a failing test\n- Step 3: Implement the fix\n\"\"\"\n\n\ndef _make_issue(\n    *,\n    number: int = 42,\n    title: str = \"Fix authentication bug\",\n    body: str = PLAN_CONTENT,\n    labels: list[str] | None = None,\n    state: str = \"OPEN\",\n) -> IssueInfo:\n    return IssueInfo(\n        number=number,\n        title=title,\n        body=body,\n        state=state,\n        url=f\"https://github.com/org/repo/issues/{number}\",\n        labels=labels or [\"erk-plan\"],\n        assignees=[],\n        created_at=_NOW,\n        updated_at=_NOW,\n        author=\"testuser\",\n    )\n\n\ndef _make_context(\n    *,\n    tmp_path: Path,\n    issue: IssueInfo | None = None,\n    fake_git: FakeGit | None = None,\n    comments: dict[int, list[str]] | None = None,\n) -> object:\n    \"\"\"Build test context with a pre-seeded issue.\"\"\"\n    issues_dict: dict[int, IssueInfo] = {issue.number: issue} if issue is not None else {}\n\n    fake_issues = FakeGitHubIssues(\n        issues=issues_dict,\n        comments=comments or {},\n    )\n    fake_github = FakeGitHub(issues_gateway=fake_issues)\n\n    if fake_git is None:\n        fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n\n    return context_for_test(\n        github_issues=fake_issues,\n        github=fake_github,\n        git=fake_git,\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n\n\ndef test_migrate_success_json(tmp_path: Path) -> None:\n    \"\"\"Happy path: issue migrated, returns JSON with pr_number and closes issue.\"\"\"\n    issue = _make_issue()\n    ctx = _make_context(tmp_path=tmp_path, issue=issue)\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    assert output[\"original_issue_number\"] == 42\n    assert \"pr_number\" in output\n    assert \"pr_url\" in output\n    assert output[\"branch_name\"].startswith(\"planned/\")\n\n\ndef test_migrate_success_display(tmp_path: Path) -> None:\n    \"\"\"Display format shows human-readable migration summary.\"\"\"\n    issue = _make_issue()\n    ctx = _make_context(tmp_path=tmp_path, issue=issue)\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"display\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    assert \"42\" in result.output\n    assert \"Fix authentication bug\" in result.output\n\n\ndef test_migrate_dry_run(tmp_path: Path) -> None:\n    \"\"\"--dry-run outputs intent but does not create draft PR or close issue.\"\"\"\n    issue = _make_issue()\n    fake_issues = FakeGitHubIssues(issues={42: issue})\n    fake_github = FakeGitHub(issues_gateway=fake_issues)\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    ctx = context_for_test(\n        github_issues=fake_issues,\n        github=fake_github,\n        git=fake_git,\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--dry-run\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    assert output[\"dry_run\"] is True\n    assert output[\"original_issue_number\"] == 42\n    assert \"branch_name\" in output\n    # Issue should NOT be closed\n    assert 42 not in fake_issues._closed_issues\n    # No PRs should be created\n    assert len(fake_github._created_prs) == 0\n\n\ndef test_migrate_issue_not_found(tmp_path: Path) -> None:\n    \"\"\"Returns error JSON when issue does not exist.\"\"\"\n    ctx = _make_context(tmp_path=tmp_path, issue=None)\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"999\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n    assert output[\"success\"] is False\n    assert output[\"error\"] == \"issue_not_found\"\n\n\ndef test_migrate_not_an_erk_plan(tmp_path: Path) -> None:\n    \"\"\"Returns error when issue lacks erk-plan label.\"\"\"\n    issue = _make_issue(labels=[\"bug\", \"enhancement\"])\n    ctx = _make_context(tmp_path=tmp_path, issue=issue)\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n    assert output[\"success\"] is False\n    assert output[\"error\"] == \"not_an_erk_plan\"\n\n\ndef test_migrate_preserves_objective_id(tmp_path: Path) -> None:\n    \"\"\"objective_id from plan-header flows through to draft PR metadata.\"\"\"\n    header_body = format_plan_header_body(\n        created_at=\"2025-01-15T00:00:00Z\",\n        created_by=\"testuser\",\n        worktree_name=None,\n        branch_name=None,\n        plan_comment_id=None,\n        last_dispatched_run_id=None,\n        last_dispatched_node_id=None,\n        last_dispatched_at=None,\n        last_local_impl_at=None,\n        last_local_impl_event=None,\n        last_local_impl_session=None,\n        last_local_impl_user=None,\n        last_remote_impl_at=None,\n        last_remote_impl_run_id=None,\n        last_remote_impl_session_id=None,\n        source_repo=None,\n        objective_issue=99,\n        created_from_session=None,\n        created_from_workflow_run_url=None,\n        last_learn_session=None,\n        last_learn_at=None,\n        learn_status=None,\n        learn_plan_issue=None,\n        learn_plan_pr=None,\n        learned_from_issue=None,\n        lifecycle_stage=None,\n    )\n    plan_comment = format_plan_content_comment(PLAN_CONTENT)\n    issue = _make_issue(body=header_body)\n    ctx = _make_context(\n        tmp_path=tmp_path,\n        issue=issue,\n        comments={42: [plan_comment]},\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    # Branch name should include objective slug\n    assert \"planned/\" in output[\"branch_name\"]\n\n\ndef test_migrate_preserves_erk_learn_label(tmp_path: Path) -> None:\n    \"\"\"erk-learn label on original issue is transferred to the draft PR.\"\"\"\n    issue = _make_issue(labels=[\"erk-plan\", \"erk-learn\"])\n    fake_issues = FakeGitHubIssues(issues={42: issue})\n    fake_github = FakeGitHub(issues_gateway=fake_issues)\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    ctx = context_for_test(\n        github_issues=fake_issues,\n        github=fake_github,\n        git=fake_git,\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n\n\ndef test_migrate_closes_original_issue(tmp_path: Path) -> None:\n    \"\"\"Original issue is closed after successful migration.\"\"\"\n    issue = _make_issue()\n    fake_issues = FakeGitHubIssues(issues={42: issue})\n    fake_github = FakeGitHub(issues_gateway=fake_issues)\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    ctx = context_for_test(\n        github_issues=fake_issues,\n        github=fake_github,\n        git=fake_git,\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    assert 42 in fake_issues._closed_issues\n\n\ndef test_migrate_preserves_operational_metadata(tmp_path: Path) -> None:\n    \"\"\"Operational metadata (dispatch, impl, session) carries over to draft PR.\"\"\"\n    header_body = format_plan_header_body(\n        created_at=\"2025-01-15T00:00:00Z\",\n        created_by=\"testuser\",\n        worktree_name=\"erk\",\n        branch_name=\"P42-fix-auth-01-15-0000\",\n        plan_comment_id=None,\n        last_dispatched_run_id=\"22119449865\",\n        last_dispatched_node_id=\"WFR_kwLOPxC3hc8AAAAFJmwFCQ\",\n        last_dispatched_at=\"2025-01-15T10:00:00\",\n        last_local_impl_at=None,\n        last_local_impl_event=None,\n        last_local_impl_session=None,\n        last_local_impl_user=None,\n        last_remote_impl_at=\"2025-01-15T12:00:00+00:00\",\n        last_remote_impl_run_id=\"22117566993\",\n        last_remote_impl_session_id=\"42215c6c-6b4c-4482-a711-bf2f09b754d5\",\n        source_repo=None,\n        objective_issue=99,\n        created_from_session=\"original-session-id\",\n        created_from_workflow_run_url=None,\n        last_learn_session=None,\n        last_learn_at=None,\n        learn_status=None,\n        learn_plan_issue=None,\n        learn_plan_pr=None,\n        learned_from_issue=None,\n        lifecycle_stage=None,\n    )\n    plan_comment = format_plan_content_comment(PLAN_CONTENT)\n    issue = _make_issue(body=header_body)\n    fake_issues = FakeGitHubIssues(issues={42: issue}, comments={42: [plan_comment]})\n    fake_github = FakeGitHub(issues_gateway=fake_issues)\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    ctx = context_for_test(\n        github_issues=fake_issues,\n        github=fake_github,\n        git=fake_git,\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    pr_number = output[\"pr_number\"]\n\n    # Check the final PR body has the operational metadata\n    final_body = fake_github._pr_details[pr_number].body\n    assert \"22119449865\" in final_body  # last_dispatched_run_id\n    assert \"WFR_kwLOPxC3hc8AAAAFJmwFCQ\" in final_body  # last_dispatched_node_id\n    assert \"22117566993\" in final_body  # last_remote_impl_run_id\n    assert \"42215c6c-6b4c-4482-a711-bf2f09b754d5\" in final_body  # last_remote_impl_session_id\n    assert \"erk\" in final_body  # worktree_name\n\n\ndef test_migrate_posts_migration_comment(tmp_path: Path) -> None:\n    \"\"\"Migration notice comment is posted to original issue.\"\"\"\n    issue = _make_issue()\n    fake_issues = FakeGitHubIssues(issues={42: issue})\n    fake_github = FakeGitHub(issues_gateway=fake_issues)\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    ctx = context_for_test(\n        github_issues=fake_issues,\n        github=fake_github,\n        git=fake_git,\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    # A comment should have been posted to issue 42\n    comments_on_42 = [\n        body for (issue_num, body, _) in fake_issues.added_comments if issue_num == 42\n    ]\n    assert len(comments_on_42) > 0\n    assert \"Migrated to draft PR\" in comments_on_42[0]\n","structuredPatch":[{"oldStart":97,"oldLines":7,"newStart":97,"newLines":7,"lines":["     assert output[\"original_issue_number\"] == 42","     assert \"pr_number\" in output","     assert \"pr_url\" in output","-    assert output[\"branch_name\"].startswith(\"planned/\")","+    assert output[\"branch_name\"].startswith(\"plnd/\")"," "," "," def test_migrate_success_display(tmp_path: Path) -> None:"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"9ab0eef7-5579-4746-81aa-836679ec3c98","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01P5PEdbi6iGTVKfbNoy8DAv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EPZGy1dnh3hjebdKjNj89n","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py","offset":232,"limit":10},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":209,"cache_read_input_tokens":101114,"cache_creation":{"ephemeral_5m_input_tokens":209,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHs3ZCxp3DhUYg4RmsC","type":"assistant","uuid":"ab0e9f2e-33c7-4a4b-a7e2-0e856221bfc2","timestamp":"2026-02-22T14:48:29.694Z"}
{"parentUuid":"ab0e9f2e-33c7-4a4b-a7e2-0e856221bfc2","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EPZGy1dnh3hjebdKjNj89n","type":"tool_result","content":"   232→\n   233→    assert result.exit_code == 0, f\"Failed: {result.output}\"\n   234→    output = json.loads(result.output)\n   235→    assert output[\"success\"] is True\n   236→    # Branch name should include objective slug\n   237→    assert \"planned/\" in output[\"branch_name\"]\n   238→\n   239→\n   240→def test_migrate_preserves_erk_learn_label(tmp_path: Path) -> None:\n   241→    \"\"\"erk-learn label on original issue is transferred to the draft PR.\"\"\"\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"6a89ca15-357a-4d0b-bd6c-f7599e587d34","timestamp":"2026-02-22T14:48:29.882Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py","content":"\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    # Branch name should include objective slug\n    assert \"planned/\" in output[\"branch_name\"]\n\n\ndef test_migrate_preserves_erk_learn_label(tmp_path: Path) -> None:\n    \"\"\"erk-learn label on original issue is transferred to the draft PR.\"\"\"","numLines":10,"startLine":232,"totalLines":382}}}
{"parentUuid":"6a89ca15-357a-4d0b-bd6c-f7599e587d34","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_014CaHS87WDnrR8mM1K7Lkd5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016E1RQADrRzUu34KwBoQiyJ","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py","old_string":"    assert \"planned/\" in output[\"branch_name\"]","new_string":"    assert \"plnd/\" in output[\"branch_name\"]"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":355,"cache_read_input_tokens":101323,"cache_creation":{"ephemeral_5m_input_tokens":355,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHsUC3DYvxD3MPLVsjX","type":"assistant","uuid":"193696d3-3892-4ad4-a355-733aaeed79eb","timestamp":"2026-02-22T14:48:33.276Z"}
{"parentUuid":"193696d3-3892-4ad4-a355-733aaeed79eb","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016E1RQADrRzUu34KwBoQiyJ","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py has been updated successfully."}]},"uuid":"dbc6beb3-df62-4809-ae58-950e2bc6c219","timestamp":"2026-02-22T14:48:33.961Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py","oldString":"    assert \"planned/\" in output[\"branch_name\"]","newString":"    assert \"plnd/\" in output[\"branch_name\"]","originalFile":"\"\"\"Unit tests for plan-migrate-to-draft-pr command.\"\"\"\n\nimport json\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nfrom click.testing import CliRunner\n\nfrom erk.cli.commands.exec.scripts.plan_migrate_to_draft_pr import plan_migrate_to_draft_pr\nfrom erk_shared.context.testing import context_for_test\nfrom erk_shared.gateway.git.fake import FakeGit\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.issues.fake import FakeGitHubIssues\nfrom erk_shared.gateway.github.issues.types import IssueInfo\nfrom erk_shared.gateway.github.metadata.plan_header import (\n    format_plan_content_comment,\n    format_plan_header_body,\n)\n\n_NOW = datetime(2025, 1, 15, 14, 30, tzinfo=UTC)\n\nPLAN_CONTENT = \"\"\"# Fix authentication bug\n\nThis plan describes fixing a bug in the auth flow.\n\n- Step 1: Identify the root cause\n- Step 2: Write a failing test\n- Step 3: Implement the fix\n\"\"\"\n\n\ndef _make_issue(\n    *,\n    number: int = 42,\n    title: str = \"Fix authentication bug\",\n    body: str = PLAN_CONTENT,\n    labels: list[str] | None = None,\n    state: str = \"OPEN\",\n) -> IssueInfo:\n    return IssueInfo(\n        number=number,\n        title=title,\n        body=body,\n        state=state,\n        url=f\"https://github.com/org/repo/issues/{number}\",\n        labels=labels or [\"erk-plan\"],\n        assignees=[],\n        created_at=_NOW,\n        updated_at=_NOW,\n        author=\"testuser\",\n    )\n\n\ndef _make_context(\n    *,\n    tmp_path: Path,\n    issue: IssueInfo | None = None,\n    fake_git: FakeGit | None = None,\n    comments: dict[int, list[str]] | None = None,\n) -> object:\n    \"\"\"Build test context with a pre-seeded issue.\"\"\"\n    issues_dict: dict[int, IssueInfo] = {issue.number: issue} if issue is not None else {}\n\n    fake_issues = FakeGitHubIssues(\n        issues=issues_dict,\n        comments=comments or {},\n    )\n    fake_github = FakeGitHub(issues_gateway=fake_issues)\n\n    if fake_git is None:\n        fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n\n    return context_for_test(\n        github_issues=fake_issues,\n        github=fake_github,\n        git=fake_git,\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n\n\ndef test_migrate_success_json(tmp_path: Path) -> None:\n    \"\"\"Happy path: issue migrated, returns JSON with pr_number and closes issue.\"\"\"\n    issue = _make_issue()\n    ctx = _make_context(tmp_path=tmp_path, issue=issue)\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    assert output[\"original_issue_number\"] == 42\n    assert \"pr_number\" in output\n    assert \"pr_url\" in output\n    assert output[\"branch_name\"].startswith(\"plnd/\")\n\n\ndef test_migrate_success_display(tmp_path: Path) -> None:\n    \"\"\"Display format shows human-readable migration summary.\"\"\"\n    issue = _make_issue()\n    ctx = _make_context(tmp_path=tmp_path, issue=issue)\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"display\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    assert \"42\" in result.output\n    assert \"Fix authentication bug\" in result.output\n\n\ndef test_migrate_dry_run(tmp_path: Path) -> None:\n    \"\"\"--dry-run outputs intent but does not create draft PR or close issue.\"\"\"\n    issue = _make_issue()\n    fake_issues = FakeGitHubIssues(issues={42: issue})\n    fake_github = FakeGitHub(issues_gateway=fake_issues)\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    ctx = context_for_test(\n        github_issues=fake_issues,\n        github=fake_github,\n        git=fake_git,\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--dry-run\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    assert output[\"dry_run\"] is True\n    assert output[\"original_issue_number\"] == 42\n    assert \"branch_name\" in output\n    # Issue should NOT be closed\n    assert 42 not in fake_issues._closed_issues\n    # No PRs should be created\n    assert len(fake_github._created_prs) == 0\n\n\ndef test_migrate_issue_not_found(tmp_path: Path) -> None:\n    \"\"\"Returns error JSON when issue does not exist.\"\"\"\n    ctx = _make_context(tmp_path=tmp_path, issue=None)\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"999\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n    assert output[\"success\"] is False\n    assert output[\"error\"] == \"issue_not_found\"\n\n\ndef test_migrate_not_an_erk_plan(tmp_path: Path) -> None:\n    \"\"\"Returns error when issue lacks erk-plan label.\"\"\"\n    issue = _make_issue(labels=[\"bug\", \"enhancement\"])\n    ctx = _make_context(tmp_path=tmp_path, issue=issue)\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n    assert output[\"success\"] is False\n    assert output[\"error\"] == \"not_an_erk_plan\"\n\n\ndef test_migrate_preserves_objective_id(tmp_path: Path) -> None:\n    \"\"\"objective_id from plan-header flows through to draft PR metadata.\"\"\"\n    header_body = format_plan_header_body(\n        created_at=\"2025-01-15T00:00:00Z\",\n        created_by=\"testuser\",\n        worktree_name=None,\n        branch_name=None,\n        plan_comment_id=None,\n        last_dispatched_run_id=None,\n        last_dispatched_node_id=None,\n        last_dispatched_at=None,\n        last_local_impl_at=None,\n        last_local_impl_event=None,\n        last_local_impl_session=None,\n        last_local_impl_user=None,\n        last_remote_impl_at=None,\n        last_remote_impl_run_id=None,\n        last_remote_impl_session_id=None,\n        source_repo=None,\n        objective_issue=99,\n        created_from_session=None,\n        created_from_workflow_run_url=None,\n        last_learn_session=None,\n        last_learn_at=None,\n        learn_status=None,\n        learn_plan_issue=None,\n        learn_plan_pr=None,\n        learned_from_issue=None,\n        lifecycle_stage=None,\n    )\n    plan_comment = format_plan_content_comment(PLAN_CONTENT)\n    issue = _make_issue(body=header_body)\n    ctx = _make_context(\n        tmp_path=tmp_path,\n        issue=issue,\n        comments={42: [plan_comment]},\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    # Branch name should include objective slug\n    assert \"planned/\" in output[\"branch_name\"]\n\n\ndef test_migrate_preserves_erk_learn_label(tmp_path: Path) -> None:\n    \"\"\"erk-learn label on original issue is transferred to the draft PR.\"\"\"\n    issue = _make_issue(labels=[\"erk-plan\", \"erk-learn\"])\n    fake_issues = FakeGitHubIssues(issues={42: issue})\n    fake_github = FakeGitHub(issues_gateway=fake_issues)\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    ctx = context_for_test(\n        github_issues=fake_issues,\n        github=fake_github,\n        git=fake_git,\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n\n\ndef test_migrate_closes_original_issue(tmp_path: Path) -> None:\n    \"\"\"Original issue is closed after successful migration.\"\"\"\n    issue = _make_issue()\n    fake_issues = FakeGitHubIssues(issues={42: issue})\n    fake_github = FakeGitHub(issues_gateway=fake_issues)\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    ctx = context_for_test(\n        github_issues=fake_issues,\n        github=fake_github,\n        git=fake_git,\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    assert 42 in fake_issues._closed_issues\n\n\ndef test_migrate_preserves_operational_metadata(tmp_path: Path) -> None:\n    \"\"\"Operational metadata (dispatch, impl, session) carries over to draft PR.\"\"\"\n    header_body = format_plan_header_body(\n        created_at=\"2025-01-15T00:00:00Z\",\n        created_by=\"testuser\",\n        worktree_name=\"erk\",\n        branch_name=\"P42-fix-auth-01-15-0000\",\n        plan_comment_id=None,\n        last_dispatched_run_id=\"22119449865\",\n        last_dispatched_node_id=\"WFR_kwLOPxC3hc8AAAAFJmwFCQ\",\n        last_dispatched_at=\"2025-01-15T10:00:00\",\n        last_local_impl_at=None,\n        last_local_impl_event=None,\n        last_local_impl_session=None,\n        last_local_impl_user=None,\n        last_remote_impl_at=\"2025-01-15T12:00:00+00:00\",\n        last_remote_impl_run_id=\"22117566993\",\n        last_remote_impl_session_id=\"42215c6c-6b4c-4482-a711-bf2f09b754d5\",\n        source_repo=None,\n        objective_issue=99,\n        created_from_session=\"original-session-id\",\n        created_from_workflow_run_url=None,\n        last_learn_session=None,\n        last_learn_at=None,\n        learn_status=None,\n        learn_plan_issue=None,\n        learn_plan_pr=None,\n        learned_from_issue=None,\n        lifecycle_stage=None,\n    )\n    plan_comment = format_plan_content_comment(PLAN_CONTENT)\n    issue = _make_issue(body=header_body)\n    fake_issues = FakeGitHubIssues(issues={42: issue}, comments={42: [plan_comment]})\n    fake_github = FakeGitHub(issues_gateway=fake_issues)\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    ctx = context_for_test(\n        github_issues=fake_issues,\n        github=fake_github,\n        git=fake_git,\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    output = json.loads(result.output)\n    pr_number = output[\"pr_number\"]\n\n    # Check the final PR body has the operational metadata\n    final_body = fake_github._pr_details[pr_number].body\n    assert \"22119449865\" in final_body  # last_dispatched_run_id\n    assert \"WFR_kwLOPxC3hc8AAAAFJmwFCQ\" in final_body  # last_dispatched_node_id\n    assert \"22117566993\" in final_body  # last_remote_impl_run_id\n    assert \"42215c6c-6b4c-4482-a711-bf2f09b754d5\" in final_body  # last_remote_impl_session_id\n    assert \"erk\" in final_body  # worktree_name\n\n\ndef test_migrate_posts_migration_comment(tmp_path: Path) -> None:\n    \"\"\"Migration notice comment is posted to original issue.\"\"\"\n    issue = _make_issue()\n    fake_issues = FakeGitHubIssues(issues={42: issue})\n    fake_github = FakeGitHub(issues_gateway=fake_issues)\n    fake_git = FakeGit(current_branches={tmp_path: \"main\"})\n    ctx = context_for_test(\n        github_issues=fake_issues,\n        github=fake_github,\n        git=fake_git,\n        cwd=tmp_path,\n        repo_root=tmp_path,\n    )\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_migrate_to_draft_pr,\n        [\"42\", \"--format\", \"json\"],\n        obj=ctx,\n    )\n\n    assert result.exit_code == 0, f\"Failed: {result.output}\"\n    # A comment should have been posted to issue 42\n    comments_on_42 = [\n        body for (issue_num, body, _) in fake_issues.added_comments if issue_num == 42\n    ]\n    assert len(comments_on_42) > 0\n    assert \"Migrated to draft PR\" in comments_on_42[0]\n","structuredPatch":[{"oldStart":234,"oldLines":7,"newStart":234,"newLines":7,"lines":["     output = json.loads(result.output)","     assert output[\"success\"] is True","     # Branch name should include objective slug","-    assert \"planned/\" in output[\"branch_name\"]","+    assert \"plnd/\" in output[\"branch_name\"]"," "," "," def test_migrate_preserves_erk_learn_label(tmp_path: Path) -> None:"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"dbc6beb3-df62-4809-ae58-950e2bc6c219","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01QUtYpF88cPcSicoy2sdGQU","type":"message","role":"assistant","content":[{"type":"text","text":"Now update test_plan_create_review_branch.py:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":545,"cache_read_input_tokens":101678,"cache_creation":{"ephemeral_5m_input_tokens":545,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHsme2cJzig7ywZPd2B","type":"assistant","uuid":"d394a566-441e-42fa-b980-2ea4f49bacbf","timestamp":"2026-02-22T14:48:36.418Z"}
{"parentUuid":"d394a566-441e-42fa-b980-2ea4f49bacbf","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01QUtYpF88cPcSicoy2sdGQU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019GTsvpE8qHt4yNLShj9zBj","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py","offset":130,"limit":10},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":545,"cache_read_input_tokens":101678,"cache_creation":{"ephemeral_5m_input_tokens":545,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHsme2cJzig7ywZPd2B","type":"assistant","uuid":"120db9e6-9203-4515-9f15-5bf4aa0692da","timestamp":"2026-02-22T14:48:37.290Z"}
{"parentUuid":"120db9e6-9203-4515-9f15-5bf4aa0692da","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019GTsvpE8qHt4yNLShj9zBj","type":"tool_result","content":"   130→        remote_branches={repo_root: [\"origin/master\"]},\n   131→        current_branches={repo_root: \"main\"},\n   132→        repository_roots={repo_root: repo_root},\n   133→    )\n   134→\n   135→    # FakeTime default: 2024-01-15 14:30:00 -> branch timestamp -01-15-1430\n   136→    expected_branch = f\"planned/review-{issue_number}-01-15-1430\"\n   137→\n   138→    runner = CliRunner()\n   139→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c1ba1cfd-67e1-413e-a3e3-81ac784766f3","timestamp":"2026-02-22T14:48:37.401Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py","content":"        remote_branches={repo_root: [\"origin/master\"]},\n        current_branches={repo_root: \"main\"},\n        repository_roots={repo_root: repo_root},\n    )\n\n    # FakeTime default: 2024-01-15 14:30:00 -> branch timestamp -01-15-1430\n    expected_branch = f\"planned/review-{issue_number}-01-15-1430\"\n\n    runner = CliRunner()\n","numLines":10,"startLine":130,"totalLines":437}}}
{"parentUuid":"c1ba1cfd-67e1-413e-a3e3-81ac784766f3","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_011Z9qCxBy1ixeA9iiM32JW6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VsbVA2HL1jivKFprobG3dt","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py","old_string":"    expected_branch = f\"planned/review-{issue_number}-01-15-1430\"\n\n    runner = CliRunner()\n","new_string":"    expected_branch = f\"plnd/review-{issue_number}-01-15-1430\"\n\n    runner = CliRunner()\n"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":371,"cache_read_input_tokens":102223,"cache_creation":{"ephemeral_5m_input_tokens":371,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHt2No7CGGP5i7E4gcE","type":"assistant","uuid":"00544fb9-9bde-4183-90ab-84731167ca3b","timestamp":"2026-02-22T14:48:42.073Z"}
{"parentUuid":"00544fb9-9bde-4183-90ab-84731167ca3b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>Found 2 matches of the string to replace, but replace_all is false. To replace all occurrences, set replace_all to true. To replace only one occurrence, please provide more context to uniquely identify the instance.\nString:     expected_branch = f\"planned/review-{issue_number}-01-15-1430\"\n\n    runner = CliRunner()\n</tool_use_error>","is_error":true,"tool_use_id":"toolu_01VsbVA2HL1jivKFprobG3dt"}]},"uuid":"88cead3b-821d-42cd-b73b-7778c9c7f32a","timestamp":"2026-02-22T14:48:42.106Z","toolUseResult":"Error: Found 2 matches of the string to replace, but replace_all is false. To replace all occurrences, set replace_all to true. To replace only one occurrence, please provide more context to uniquely identify the instance.\nString:     expected_branch = f\"planned/review-{issue_number}-01-15-1430\"\n\n    runner = CliRunner()\n"}
{"parentUuid":"88cead3b-821d-42cd-b73b-7778c9c7f32a","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01HrGCunXFqtgph3AARjgAkW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UkiCdL5r9NA97VNMzdHPaa","name":"Edit","input":{"replace_all":true,"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py","old_string":"    expected_branch = f\"planned/review-{issue_number}-01-15-1430\"","new_string":"    expected_branch = f\"plnd/review-{issue_number}-01-15-1430\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":643,"cache_read_input_tokens":102594,"cache_creation":{"ephemeral_5m_input_tokens":643,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHtNSYK6hbrBFEgjFZ1","type":"assistant","uuid":"1efa3aac-39dd-4fc7-8b86-1731afcbb903","timestamp":"2026-02-22T14:48:45.711Z"}
{"parentUuid":"1efa3aac-39dd-4fc7-8b86-1731afcbb903","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UkiCdL5r9NA97VNMzdHPaa","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py has been updated. All occurrences of '    expected_branch = f\"planned/review-{issue_number}-01-15-1430\"' were successfully replaced with '    expected_branch = f\"plnd/review-{issue_number}-01-15-1430\"'."}]},"uuid":"d70c3e41-1545-4111-9d5b-f104d872625c","timestamp":"2026-02-22T14:48:46.400Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py","oldString":"    expected_branch = f\"planned/review-{issue_number}-01-15-1430\"","newString":"    expected_branch = f\"plnd/review-{issue_number}-01-15-1430\"","originalFile":"\"\"\"Unit tests for plan_create_review_branch exec command.\n\nTests creation of plan review branches from GitHub issues.\nUses FakeGit and FakeGitHubIssues for fast, reliable testing.\n\"\"\"\n\nimport json\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nfrom click.testing import CliRunner\n\nfrom erk.cli.commands.exec.scripts.plan_create_review_branch import (\n    plan_create_review_branch,\n)\nfrom erk_shared.context.context import ErkContext\nfrom erk_shared.gateway.git.fake import FakeGit\nfrom erk_shared.gateway.github.issues.fake import FakeGitHubIssues\nfrom erk_shared.gateway.github.issues.types import IssueComment, IssueInfo\n\n\ndef make_plan_header_body(\n    plan_comment_id: int | None,\n) -> str:\n    \"\"\"Create a test issue body with plan-header metadata block.\"\"\"\n    comment_id_line = (\n        f\"plan_comment_id: {plan_comment_id}\"\n        if plan_comment_id is not None\n        else \"plan_comment_id: null\"\n    )\n\n    return f\"\"\"<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\n<!-- erk:metadata-block:plan-header -->\n<details>\n<summary><code>plan-header</code></summary>\n\n```yaml\n\nschema_version: '2'\ncreated_at: '2025-11-25T14:37:43.513418+00:00'\ncreated_by: testuser\n{comment_id_line}\nlast_dispatched_run_id: null\nlast_dispatched_at: null\n\n```\n\n</details>\n<!-- /erk:metadata-block:plan-header -->\"\"\"\n\n\ndef make_plan_comment_body_v2(plan_content: str) -> str:\n    \"\"\"Create a comment body with plan-body metadata block (Schema v2).\"\"\"\n    return f\"\"\"<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\n<!-- erk:metadata-block:plan-body -->\n<details open>\n<summary><strong>plan-body</strong></summary>\n\n{plan_content}\n\n</details>\n<!-- /erk:metadata-block:plan-body -->\"\"\"\n\n\ndef make_issue_info(\n    number: int,\n    body: str,\n    title: str,\n    labels: list[str] | None,\n) -> IssueInfo:\n    \"\"\"Create test IssueInfo with given number, body, and labels.\"\"\"\n    if labels is None:\n        labels = [\"erk-plan\"]\n    now = datetime.now(UTC)\n    return IssueInfo(\n        number=number,\n        title=title,\n        body=body,\n        state=\"OPEN\",\n        url=f\"https://github.com/test-owner/test-repo/issues/{number}\",\n        labels=labels,\n        assignees=[],\n        created_at=now,\n        updated_at=now,\n        author=\"test-user\",\n    )\n\n\ndef make_issue_comment(\n    comment_id: int,\n    body: str,\n) -> IssueComment:\n    \"\"\"Create test IssueComment with given ID and body.\"\"\"\n    return IssueComment(\n        id=comment_id,\n        body=body,\n        url=f\"https://github.com/test-owner/test-repo/issues/1234#issuecomment-{comment_id}\",\n        author=\"test-user\",\n    )\n\n\n# ============================================================================\n# Success Cases\n# ============================================================================\n\n\ndef test_plan_create_review_branch_success(tmp_path: Path) -> None:\n    \"\"\"Test successful branch creation and file write.\"\"\"\n    plan_content = \"## Implementation Plan\\n\\nThis is the plan content.\"\n    comment_id = 123456789\n    issue_number = 1234\n    repo_root = tmp_path / \"repo\"\n    repo_root.mkdir(parents=True, exist_ok=True)\n\n    # Create issue with plan-header\n    body = make_plan_header_body(plan_comment_id=comment_id)\n    issue = make_issue_info(issue_number, body, title=\"Plan: Add feature X\", labels=None)\n\n    # Create comment with plan-body block\n    comment_body = make_plan_comment_body_v2(plan_content)\n    comment = make_issue_comment(comment_id, comment_body)\n\n    fake_gh = FakeGitHubIssues(\n        issues={issue_number: issue},\n        comments_with_urls={issue_number: [comment]},\n    )\n\n    fake_git = FakeGit(\n        local_branches={repo_root: []},\n        remote_branches={repo_root: [\"origin/master\"]},\n        current_branches={repo_root: \"main\"},\n        repository_roots={repo_root: repo_root},\n    )\n\n    # FakeTime default: 2024-01-15 14:30:00 -> branch timestamp -01-15-1430\n    expected_branch = f\"planned/review-{issue_number}-01-15-1430\"\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_branch,\n        [str(issue_number)],\n        obj=ErkContext.for_test(\n            github_issues=fake_gh,\n            git=fake_git,\n            repo_root=repo_root,\n        ),\n    )\n\n    assert result.exit_code == 0\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    assert output[\"issue_number\"] == issue_number\n    assert output[\"branch\"] == expected_branch\n    assert output[\"file_path\"] == f\"PLAN-REVIEW-{issue_number}.md\"\n    assert output[\"plan_title\"] == \"Plan: Add feature X\"\n\n    # Verify branch was created from origin/master\n    assert len(fake_git.created_branches) == 1\n    created = fake_git.created_branches[0]\n    assert created[0] == repo_root  # cwd\n    assert created[1] == expected_branch  # branch_name\n    assert created[2] == \"origin/master\"  # start_point\n    assert created[3] is False  # force\n\n    # Verify branch was checked out\n    assert len(fake_git.branch.checked_out_branches) == 1\n    assert fake_git.branch.checked_out_branches[0] == (repo_root, expected_branch)\n\n    # Verify file was written (check via filesystem since FakeGit doesn't track file writes)\n    file_path = repo_root / f\"PLAN-REVIEW-{issue_number}.md\"\n    assert file_path.exists()\n    assert file_path.read_text() == plan_content\n\n    # Verify commit was created with the staged file\n    assert len(fake_git.commit.commits) == 1\n    commit = fake_git.commit.commits[0]\n    assert commit.cwd == repo_root\n    assert commit.message == f\"Add plan #{issue_number} for review\"\n    assert f\"PLAN-REVIEW-{issue_number}.md\" in commit.staged_files\n\n    # Verify branch was pushed with upstream tracking\n    assert len(fake_git.pushed_branches) == 1\n    pushed = fake_git.pushed_branches[0]\n    assert pushed.remote == \"origin\"\n    assert pushed.branch == expected_branch\n    assert pushed.set_upstream is True\n    assert pushed.force is False\n\n\ndef test_plan_create_review_branch_multiline_plan(tmp_path: Path) -> None:\n    \"\"\"Test creation with multi-line plan content.\"\"\"\n    plan_content = \"\"\"# Plan: Complex Feature\n\n## Context\nBackground info here\n\n## Implementation\n- Step 1\n- Step 2\n- Step 3\n\n## Success Criteria\nAll tests pass\"\"\"\n\n    comment_id = 111222333\n    issue_number = 9999\n    repo_root = tmp_path / \"repo\"\n    repo_root.mkdir(parents=True, exist_ok=True)\n\n    body = make_plan_header_body(plan_comment_id=comment_id)\n    issue = make_issue_info(issue_number, body, title=\"Complex Plan\", labels=None)\n    comment_body = make_plan_comment_body_v2(plan_content)\n    comment = make_issue_comment(comment_id, comment_body)\n\n    fake_gh = FakeGitHubIssues(\n        issues={issue_number: issue},\n        comments_with_urls={issue_number: [comment]},\n    )\n\n    fake_git = FakeGit(\n        local_branches={repo_root: []},\n        remote_branches={repo_root: [\"origin/master\"]},\n        current_branches={repo_root: \"main\"},\n        repository_roots={repo_root: repo_root},\n    )\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_branch,\n        [str(issue_number)],\n        obj=ErkContext.for_test(\n            github_issues=fake_gh,\n            git=fake_git,\n            repo_root=repo_root,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify file contains full multi-line content\n    file_path = repo_root / f\"PLAN-REVIEW-{issue_number}.md\"\n    assert file_path.exists()\n    assert file_path.read_text() == plan_content\n\n\n# ============================================================================\n# Error Cases\n# ============================================================================\n\n\ndef test_plan_create_review_branch_issue_not_found(tmp_path: Path) -> None:\n    \"\"\"Test error when issue doesn't exist.\"\"\"\n    repo_root = tmp_path / \"repo\"\n    fake_gh = FakeGitHubIssues()\n    fake_git = FakeGit()\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_branch,\n        [\"9999\"],\n        obj=ErkContext.for_test(\n            github_issues=fake_gh,\n            git=fake_git,\n            repo_root=repo_root,\n        ),\n    )\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n    assert output[\"success\"] is False\n    assert output[\"error\"] == \"issue_not_found\"\n    assert \"#9999\" in output[\"message\"]\n\n\ndef test_plan_create_review_branch_missing_erk_plan_label(tmp_path: Path) -> None:\n    \"\"\"Test error when issue doesn't have erk-plan label.\"\"\"\n    issue_number = 1234\n    repo_root = tmp_path / \"repo\"\n    body = make_plan_header_body(plan_comment_id=123456789)\n    issue = make_issue_info(\n        issue_number, body, title=\"Test Plan Issue\", labels=[\"bug\", \"enhancement\"]\n    )\n\n    fake_gh = FakeGitHubIssues(issues={issue_number: issue})\n    fake_git = FakeGit()\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_branch,\n        [str(issue_number)],\n        obj=ErkContext.for_test(\n            github_issues=fake_gh,\n            git=fake_git,\n            repo_root=repo_root,\n        ),\n    )\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n    assert output[\"success\"] is False\n    assert output[\"error\"] == \"missing_erk_plan_label\"\n    assert \"#1234\" in output[\"message\"]\n\n\ndef test_plan_create_review_branch_no_plan_content(tmp_path: Path) -> None:\n    \"\"\"Test error when issue has no plan content.\"\"\"\n    issue_number = 1234\n    repo_root = tmp_path / \"repo\"\n    body = make_plan_header_body(plan_comment_id=None)\n    issue = make_issue_info(issue_number, body, title=\"Test Plan Issue\", labels=None)\n\n    fake_gh = FakeGitHubIssues(issues={issue_number: issue})\n    fake_git = FakeGit()\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_branch,\n        [str(issue_number)],\n        obj=ErkContext.for_test(\n            github_issues=fake_gh,\n            git=fake_git,\n            repo_root=repo_root,\n        ),\n    )\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n    assert output[\"success\"] is False\n    assert output[\"error\"] == \"no_plan_content\"\n    assert \"no plan_comment_id\" in output[\"message\"]\n\n\n# ============================================================================\n# JSON Output Structure Tests\n# ============================================================================\n\n\ndef test_json_output_structure_success(tmp_path: Path) -> None:\n    \"\"\"Test JSON output structure on success.\"\"\"\n    plan_content = \"## Plan content here\"\n    comment_id = 123456789\n    issue_number = 1234\n    repo_root = tmp_path / \"repo\"\n    repo_root.mkdir(parents=True, exist_ok=True)\n\n    body = make_plan_header_body(plan_comment_id=comment_id)\n    issue = make_issue_info(issue_number, body, title=\"Plan: Test Feature\", labels=None)\n    comment_body = make_plan_comment_body_v2(plan_content)\n    comment = make_issue_comment(comment_id, comment_body)\n\n    fake_gh = FakeGitHubIssues(\n        issues={issue_number: issue},\n        comments_with_urls={issue_number: [comment]},\n    )\n\n    fake_git = FakeGit(\n        local_branches={repo_root: []},\n        remote_branches={repo_root: [\"origin/master\"]},\n        current_branches={repo_root: \"main\"},\n        repository_roots={repo_root: repo_root},\n    )\n\n    # FakeTime default: 2024-01-15 14:30:00 -> branch timestamp -01-15-1430\n    expected_branch = f\"planned/review-{issue_number}-01-15-1430\"\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_branch,\n        [str(issue_number)],\n        obj=ErkContext.for_test(\n            github_issues=fake_gh,\n            git=fake_git,\n            repo_root=repo_root,\n        ),\n    )\n\n    assert result.exit_code == 0\n    output = json.loads(result.output)\n\n    # Verify expected keys\n    assert \"success\" in output\n    assert \"issue_number\" in output\n    assert \"branch\" in output\n    assert \"file_path\" in output\n    assert \"plan_title\" in output\n\n    # Verify types\n    assert isinstance(output[\"success\"], bool)\n    assert isinstance(output[\"issue_number\"], int)\n    assert isinstance(output[\"branch\"], str)\n    assert isinstance(output[\"file_path\"], str)\n    assert isinstance(output[\"plan_title\"], str)\n\n    # Verify values\n    assert output[\"success\"] is True\n    assert output[\"issue_number\"] == issue_number\n    assert output[\"branch\"] == expected_branch\n    assert output[\"file_path\"] == f\"PLAN-REVIEW-{issue_number}.md\"\n    assert output[\"plan_title\"] == \"Plan: Test Feature\"\n\n\ndef test_json_output_structure_error(tmp_path: Path) -> None:\n    \"\"\"Test JSON output structure on error.\"\"\"\n    repo_root = tmp_path / \"repo\"\n    fake_gh = FakeGitHubIssues()\n    fake_git = FakeGit()\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_branch,\n        [\"9999\"],\n        obj=ErkContext.for_test(\n            github_issues=fake_gh,\n            git=fake_git,\n            repo_root=repo_root,\n        ),\n    )\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n\n    # Verify expected keys\n    assert \"success\" in output\n    assert \"error\" in output\n    assert \"message\" in output\n\n    # Verify types\n    assert isinstance(output[\"success\"], bool)\n    assert isinstance(output[\"error\"], str)\n    assert isinstance(output[\"message\"], str)\n\n    # Verify values\n    assert output[\"success\"] is False\n","structuredPatch":[{"oldStart":133,"oldLines":7,"newStart":133,"newLines":7,"lines":["     )"," ","     # FakeTime default: 2024-01-15 14:30:00 -> branch timestamp -01-15-1430","-    expected_branch = f\"planned/review-{issue_number}-01-15-1430\"","+    expected_branch = f\"plnd/review-{issue_number}-01-15-1430\""," ","     runner = CliRunner()"," "]},{"oldStart":363,"oldLines":7,"newStart":363,"newLines":7,"lines":["     )"," ","     # FakeTime default: 2024-01-15 14:30:00 -> branch timestamp -01-15-1430","-    expected_branch = f\"planned/review-{issue_number}-01-15-1430\"","+    expected_branch = f\"plnd/review-{issue_number}-01-15-1430\""," ","     runner = CliRunner()"," "]}],"userModified":false,"replaceAll":true}}
{"parentUuid":"d70c3e41-1545-4111-9d5b-f104d872625c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_016Q4rvbMXZWrBVeWY2MN9Qi","type":"message","role":"assistant","content":[{"type":"text","text":"Now update test_plan_create_review_pr.py:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":304,"cache_read_input_tokens":103237,"cache_creation":{"ephemeral_5m_input_tokens":304,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHtgrZrCKFiqP48ucRD","type":"assistant","uuid":"fa8126e7-f593-4855-8530-b58d33878e48","timestamp":"2026-02-22T14:48:49.395Z"}
{"parentUuid":"fa8126e7-f593-4855-8530-b58d33878e48","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_016Q4rvbMXZWrBVeWY2MN9Qi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SePVQ7QUbVYyWTg38a4joN","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py","old_string":"    branch_name = \"planned/review-1234-01-15-1430\"","new_string":"    branch_name = \"plnd/review-1234-01-15-1430\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":304,"cache_read_input_tokens":103237,"cache_creation":{"ephemeral_5m_input_tokens":304,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHtgrZrCKFiqP48ucRD","type":"assistant","uuid":"b0abe78e-c5e9-4ca3-8991-b330a39f88d3","timestamp":"2026-02-22T14:48:50.633Z"}
{"parentUuid":"b0abe78e-c5e9-4ca3-8991-b330a39f88d3","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File has not been read yet. Read it first before writing to it.</tool_use_error>","is_error":true,"tool_use_id":"toolu_01SePVQ7QUbVYyWTg38a4joN"}]},"uuid":"5d9256a8-a3cf-4689-af71-3fcd94285eab","timestamp":"2026-02-22T14:48:50.651Z","toolUseResult":"Error: File has not been read yet. Read it first before writing to it."}
{"parentUuid":"5d9256a8-a3cf-4689-af71-3fcd94285eab","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01B4siP2fMwQLAUwvWuwxSKG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KJ3dE71t8pzTKNEWSypwrP","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":564,"cache_read_input_tokens":103541,"cache_creation":{"ephemeral_5m_input_tokens":564,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHtzyzCyFua3cFqHk11","type":"assistant","uuid":"8e5452b9-70e2-4709-bd63-6c2bf5d20266","timestamp":"2026-02-22T14:48:53.311Z"}
{"parentUuid":"8e5452b9-70e2-4709-bd63-6c2bf5d20266","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KJ3dE71t8pzTKNEWSypwrP","type":"tool_result","content":"     1→\"\"\"Unit tests for plan_create_review_pr exec command.\n     2→\n     3→Tests creation of draft PRs for plan review from GitHub issues.\n     4→Uses FakeGitHub and FakeGitHubIssues for fast, reliable testing.\n     5→\"\"\"\n     6→\n     7→import json\n     8→from datetime import UTC, datetime\n     9→from pathlib import Path\n    10→\n    11→from click.testing import CliRunner\n    12→\n    13→from erk.cli.commands.exec.scripts.plan_create_review_pr import plan_create_review_pr\n    14→from erk_shared.context.context import ErkContext\n    15→from erk_shared.gateway.github.fake import FakeGitHub\n    16→from erk_shared.gateway.github.issues.fake import FakeGitHubIssues\n    17→from erk_shared.gateway.github.issues.types import IssueInfo\n    18→from erk_shared.gateway.github.types import RepoInfo\n    19→\n    20→TEST_REPO_INFO = RepoInfo(owner=\"test-owner\", name=\"test-repo\")\n    21→\n    22→\n    23→def make_plan_header_body(\n    24→    *,\n    25→    plan_comment_id: int | None,\n    26→) -> str:\n    27→    \"\"\"Create a test issue body with plan-header metadata block.\"\"\"\n    28→    comment_id_line = (\n    29→        f\"plan_comment_id: {plan_comment_id}\"\n    30→        if plan_comment_id is not None\n    31→        else \"plan_comment_id: null\"\n    32→    )\n    33→\n    34→    return f\"\"\"<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\n    35→<!-- erk:metadata-block:plan-header -->\n    36→<details>\n    37→<summary><code>plan-header</code></summary>\n    38→\n    39→```yaml\n    40→\n    41→schema_version: '2'\n    42→created_at: '2025-11-25T14:37:43.513418+00:00'\n    43→created_by: testuser\n    44→{comment_id_line}\n    45→last_dispatched_run_id: null\n    46→last_dispatched_at: null\n    47→\n    48→```\n    49→\n    50→</details>\n    51→<!-- /erk:metadata-block:plan-header -->\"\"\"\n    52→\n    53→\n    54→def make_issue_info(\n    55→    number: int,\n    56→    body: str,\n    57→    title: str,\n    58→    labels: list[str] | None,\n    59→) -> IssueInfo:\n    60→    \"\"\"Create test IssueInfo with given number, body, and labels.\"\"\"\n    61→    if labels is None:\n    62→        labels = [\"erk-plan\"]\n    63→    now = datetime.now(UTC)\n    64→    return IssueInfo(\n    65→        number=number,\n    66→        title=title,\n    67→        body=body,\n    68→        state=\"OPEN\",\n    69→        url=f\"https://github.com/test-owner/test-repo/issues/{number}\",\n    70→        labels=labels,\n    71→        assignees=[],\n    72→        created_at=now,\n    73→        updated_at=now,\n    74→        author=\"test-user\",\n    75→    )\n    76→\n    77→\n    78→# ============================================================================\n    79→# Success Cases\n    80→# ============================================================================\n    81→\n    82→\n    83→def test_plan_create_review_pr_success(tmp_path: Path) -> None:\n    84→    \"\"\"Test successful PR creation and metadata update.\"\"\"\n    85→    issue_number = 1234\n    86→    branch_name = \"planned/review-1234-01-15-1430\"\n    87→    plan_title = \"Add feature X\"\n    88→    repo_root = tmp_path / \"repo\"\n    89→    repo_root.mkdir(parents=True, exist_ok=True)\n    90→\n    91→    # Create issue with plan-header\n    92→    body = make_plan_header_body(plan_comment_id=123456789)\n    93→    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n    94→\n    95→    fake_gh_issues = FakeGitHubIssues(\n    96→        issues={issue_number: issue},\n    97→    )\n    98→\n    99→    fake_gh = FakeGitHub(\n   100→        issues_gateway=fake_gh_issues,\n   101→    )\n   102→\n   103→    runner = CliRunner()\n   104→\n   105→    result = runner.invoke(\n   106→        plan_create_review_pr,\n   107→        [str(issue_number), branch_name, plan_title],\n   108→        obj=ErkContext.for_test(\n   109→            github=fake_gh,\n   110→            github_issues=fake_gh_issues,\n   111→            repo_root=repo_root,\n   112→            repo_info=TEST_REPO_INFO,\n   113→        ),\n   114→    )\n   115→\n   116→    assert result.exit_code == 0\n   117→    output = json.loads(result.output)\n   118→    assert output[\"success\"] is True\n   119→    assert output[\"issue_number\"] == issue_number\n   120→    assert output[\"pr_number\"] == 999\n   121→    assert output[\"pr_url\"] == \"https://github.com/test-owner/test-repo/pull/999\"\n   122→\n   123→    # Verify PR was created as draft\n   124→    assert len(fake_gh.created_prs) == 1\n   125→    pr = fake_gh.created_prs[0]\n   126→    assert pr[0] == branch_name  # branch\n   127→    assert pr[1] == f\"[erk-plan-review] {plan_title} (#{issue_number})\"  # title\n   128→    assert f\"issue #{issue_number}\" in pr[2]  # body contains issue reference\n   129→    assert \"Quick Start\" in pr[2]  # body contains Quick Start section\n   130→    assert f\"erk br co --for-plan {issue_number}\" in pr[2]  # body contains prepare command\n   131→    assert pr[3] == \"master\"  # base\n   132→    assert pr[4] is True  # draft=True\n   133→\n   134→    # Verify plan-review label was added\n   135→    assert (999, \"erk-plan-review\") in fake_gh.added_labels\n   136→\n   137→    # Verify issue body was updated with review_pr field via PlanBackend\n   138→    assert len(fake_gh_issues.updated_bodies) == 1\n   139→    updated_issue_number, updated_body = fake_gh_issues.updated_bodies[0]\n   140→    assert updated_issue_number == issue_number\n   141→    assert \"review_pr: 999\" in updated_body\n   142→\n   143→\n   144→def test_plan_create_review_pr_title_format(tmp_path: Path) -> None:\n   145→    \"\"\"Test PR title contains issue reference.\"\"\"\n   146→    issue_number = 5678\n   147→    branch_name = \"planned/review-5678-01-15-1430\"\n   148→    plan_title = \"Implement new backend\"\n   149→    repo_root = tmp_path / \"repo\"\n   150→\n   151→    body = make_plan_header_body(plan_comment_id=123)\n   152→    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n   153→\n   154→    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n   155→    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n   156→\n   157→    runner = CliRunner()\n   158→\n   159→    result = runner.invoke(\n   160→        plan_create_review_pr,\n   161→        [str(issue_number), branch_name, plan_title],\n   162→        obj=ErkContext.for_test(\n   163→            github=fake_gh,\n   164→            github_issues=fake_gh_issues,\n   165→            repo_root=repo_root,\n   166→            repo_info=TEST_REPO_INFO,\n   167→        ),\n   168→    )\n   169→\n   170→    assert result.exit_code == 0\n   171→\n   172→    # Verify PR title format\n   173→    pr = fake_gh.created_prs[0]\n   174→    assert pr[1] == f\"[erk-plan-review] {plan_title} (#{issue_number})\"\n   175→\n   176→\n   177→def test_plan_create_review_pr_strips_erk_plan_prefix(tmp_path: Path) -> None:\n   178→    \"\"\"Test PR title strips [erk-plan] prefix from plan_title.\"\"\"\n   179→    issue_number = 5679\n   180→    branch_name = \"planned/review-5679-01-15-1430\"\n   181→    plan_title = \"[erk-plan] Implement new backend\"\n   182→    repo_root = tmp_path / \"repo\"\n   183→\n   184→    body = make_plan_header_body(plan_comment_id=123)\n   185→    issue = make_issue_info(issue_number, body, title=plan_title, labels=None)\n   186→\n   187→    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n   188→    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n   189→\n   190→    runner = CliRunner()\n   191→\n   192→    result = runner.invoke(\n   193→        plan_create_review_pr,\n   194→        [str(issue_number), branch_name, plan_title],\n   195→        obj=ErkContext.for_test(\n   196→            github=fake_gh,\n   197→            github_issues=fake_gh_issues,\n   198→            repo_root=repo_root,\n   199→            repo_info=TEST_REPO_INFO,\n   200→        ),\n   201→    )\n   202→\n   203→    assert result.exit_code == 0\n   204→\n   205→    # Verify [erk-plan] prefix was stripped and [erk-plan-review] used instead\n   206→    pr = fake_gh.created_prs[0]\n   207→    assert pr[1] == f\"[erk-plan-review] Implement new backend (#{issue_number})\"\n   208→\n   209→\n   210→def test_plan_create_review_pr_body_format(tmp_path: Path) -> None:\n   211→    \"\"\"Test PR body has issue link and warning.\"\"\"\n   212→    issue_number = 9999\n   213→    branch_name = \"planned/review-9999-01-15-1430\"\n   214→    plan_title = \"Test Plan\"\n   215→    repo_root = tmp_path / \"repo\"\n   216→\n   217→    body = make_plan_header_body(plan_comment_id=456)\n   218→    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n   219→\n   220→    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n   221→    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n   222→\n   223→    runner = CliRunner()\n   224→\n   225→    result = runner.invoke(\n   226→        plan_create_review_pr,\n   227→        [str(issue_number), branch_name, plan_title],\n   228→        obj=ErkContext.for_test(\n   229→            github=fake_gh,\n   230→            github_issues=fake_gh_issues,\n   231→            repo_root=repo_root,\n   232→            repo_info=TEST_REPO_INFO,\n   233→        ),\n   234→    )\n   235→\n   236→    assert result.exit_code == 0\n   237→\n   238→    # Verify PR body format\n   239→    pr_body = fake_gh.created_prs[0][2]\n   240→    assert f\"Plan Review: {plan_title}\" in pr_body\n   241→    assert f\"issue #{issue_number}\" in pr_body\n   242→    assert \"will not be merged\" in pr_body\n   243→    assert \"inline review comments\" in pr_body\n   244→    assert \"Quick Start\" in pr_body\n   245→    assert f\"erk br co --for-plan {issue_number}\" in pr_body\n   246→    prepare_and_implement_cmd = (\n   247→        f'source \"$(erk br co --for-plan {issue_number} --script)\" && erk implement --dangerous'\n   248→    )\n   249→    assert prepare_and_implement_cmd in pr_body\n   250→\n   251→\n   252→def test_plan_create_review_pr_draft_mode(tmp_path: Path) -> None:\n   253→    \"\"\"Test PR is created in draft mode.\"\"\"\n   254→    issue_number = 2222\n   255→    branch_name = \"planned/review-2222-01-15-1430\"\n   256→    plan_title = \"Draft PR Test\"\n   257→    repo_root = tmp_path / \"repo\"\n   258→\n   259→    body = make_plan_header_body(plan_comment_id=789)\n   260→    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n   261→\n   262→    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n   263→    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n   264→\n   265→    runner = CliRunner()\n   266→\n   267→    result = runner.invoke(\n   268→        plan_create_review_pr,\n   269→        [str(issue_number), branch_name, plan_title],\n   270→        obj=ErkContext.for_test(\n   271→            github=fake_gh,\n   272→            github_issues=fake_gh_issues,\n   273→            repo_root=repo_root,\n   274→            repo_info=TEST_REPO_INFO,\n   275→        ),\n   276→    )\n   277→\n   278→    assert result.exit_code == 0\n   279→\n   280→    # Verify draft=True was passed\n   281→    pr = fake_gh.created_prs[0]\n   282→    assert pr[4] is True\n   283→\n   284→\n   285→def test_plan_create_review_pr_metadata_updated(tmp_path: Path) -> None:\n   286→    \"\"\"Test issue metadata contains review_pr field after creation.\"\"\"\n   287→    issue_number = 3333\n   288→    branch_name = \"planned/review-3333-01-15-1430\"\n   289→    plan_title = \"Metadata Update Test\"\n   290→    repo_root = tmp_path / \"repo\"\n   291→\n   292→    body = make_plan_header_body(plan_comment_id=111)\n   293→    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n   294→\n   295→    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n   296→    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n   297→\n   298→    runner = CliRunner()\n   299→\n   300→    result = runner.invoke(\n   301→        plan_create_review_pr,\n   302→        [str(issue_number), branch_name, plan_title],\n   303→        obj=ErkContext.for_test(\n   304→            github=fake_gh,\n   305→            github_issues=fake_gh_issues,\n   306→            repo_root=repo_root,\n   307→            repo_info=TEST_REPO_INFO,\n   308→        ),\n   309→    )\n   310→\n   311→    assert result.exit_code == 0\n   312→\n   313→    # Verify metadata was updated via PlanBackend\n   314→    assert len(fake_gh_issues.updated_bodies) == 1\n   315→    updated_issue_number, updated_body = fake_gh_issues.updated_bodies[0]\n   316→    assert updated_issue_number == issue_number\n   317→    assert \"review_pr:\" in updated_body\n   318→    assert \"review_pr: 999\" in updated_body\n   319→\n   320→\n   321→def test_plan_create_review_pr_uses_dynamic_repo_url(tmp_path: Path) -> None:\n   322→    \"\"\"Test PR URL uses repo identifier from context, not a hardcoded value.\"\"\"\n   323→    issue_number = 7777\n   324→    branch_name = \"planned/review-7777-01-15-1430\"\n   325→    plan_title = \"Dynamic URL Test\"\n   326→    repo_root = tmp_path / \"repo\"\n   327→\n   328→    body = make_plan_header_body(plan_comment_id=333)\n   329→    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n   330→\n   331→    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n   332→    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n   333→\n   334→    custom_repo_info = RepoInfo(owner=\"my-org\", name=\"my-project\")\n   335→\n   336→    runner = CliRunner()\n   337→\n   338→    result = runner.invoke(\n   339→        plan_create_review_pr,\n   340→        [str(issue_number), branch_name, plan_title],\n   341→        obj=ErkContext.for_test(\n   342→            github=fake_gh,\n   343→            github_issues=fake_gh_issues,\n   344→            repo_root=repo_root,\n   345→            repo_info=custom_repo_info,\n   346→        ),\n   347→    )\n   348→\n   349→    assert result.exit_code == 0\n   350→    output = json.loads(result.output)\n   351→    assert output[\"pr_url\"] == \"https://github.com/my-org/my-project/pull/999\"\n   352→\n   353→\n   354→# ============================================================================\n   355→# Error Cases\n   356→# ============================================================================\n   357→\n   358→\n   359→def test_plan_create_review_pr_issue_not_found(tmp_path: Path) -> None:\n   360→    \"\"\"Test error when issue doesn't exist.\"\"\"\n   361→    repo_root = tmp_path / \"repo\"\n   362→    fake_gh_issues = FakeGitHubIssues()\n   363→    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n   364→\n   365→    runner = CliRunner()\n   366→\n   367→    result = runner.invoke(\n   368→        plan_create_review_pr,\n   369→        [\"9999\", \"test-branch\", \"Test Plan\"],\n   370→        obj=ErkContext.for_test(\n   371→            github=fake_gh,\n   372→            github_issues=fake_gh_issues,\n   373→            repo_root=repo_root,\n   374→            repo_info=TEST_REPO_INFO,\n   375→        ),\n   376→    )\n   377→\n   378→    assert result.exit_code == 1\n   379→    output = json.loads(result.output)\n   380→    assert output[\"success\"] is False\n   381→    assert output[\"error\"] == \"issue_not_found\"\n   382→    assert \"#9999\" in output[\"message\"]\n   383→\n   384→\n   385→# ============================================================================\n   386→# JSON Output Schema\n   387→# ============================================================================\n   388→\n   389→\n   390→def test_json_output_structure_success(tmp_path: Path) -> None:\n   391→    \"\"\"Test success JSON output has correct structure.\"\"\"\n   392→    issue_number = 4444\n   393→    branch_name = \"planned/review-4444-01-15-1430\"\n   394→    plan_title = \"JSON Test\"\n   395→    repo_root = tmp_path / \"repo\"\n   396→\n   397→    body = make_plan_header_body(plan_comment_id=222)\n   398→    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n   399→\n   400→    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n   401→    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n   402→\n   403→    runner = CliRunner()\n   404→\n   405→    result = runner.invoke(\n   406→        plan_create_review_pr,\n   407→        [str(issue_number), branch_name, plan_title],\n   408→        obj=ErkContext.for_test(\n   409→            github=fake_gh,\n   410→            github_issues=fake_gh_issues,\n   411→            repo_root=repo_root,\n   412→            repo_info=TEST_REPO_INFO,\n   413→        ),\n   414→    )\n   415→\n   416→    assert result.exit_code == 0\n   417→    output = json.loads(result.output)\n   418→\n   419→    # Verify all required fields present\n   420→    assert \"success\" in output\n   421→    assert \"issue_number\" in output\n   422→    assert \"pr_number\" in output\n   423→    assert \"pr_url\" in output\n   424→\n   425→    # Verify types\n   426→    assert isinstance(output[\"success\"], bool)\n   427→    assert isinstance(output[\"issue_number\"], int)\n   428→    assert isinstance(output[\"pr_number\"], int)\n   429→    assert isinstance(output[\"pr_url\"], str)\n   430→\n   431→\n   432→def test_json_output_structure_error(tmp_path: Path) -> None:\n   433→    \"\"\"Test error JSON output has correct structure.\"\"\"\n   434→    repo_root = tmp_path / \"repo\"\n   435→    fake_gh_issues = FakeGitHubIssues()\n   436→    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n   437→\n   438→    runner = CliRunner()\n   439→\n   440→    result = runner.invoke(\n   441→        plan_create_review_pr,\n   442→        [\"8888\", \"test-branch\", \"Error Test\"],\n   443→        obj=ErkContext.for_test(\n   444→            github=fake_gh,\n   445→            github_issues=fake_gh_issues,\n   446→            repo_root=repo_root,\n   447→            repo_info=TEST_REPO_INFO,\n   448→        ),\n   449→    )\n   450→\n   451→    assert result.exit_code == 1\n   452→    output = json.loads(result.output)\n   453→\n   454→    # Verify all required fields present\n   455→    assert \"success\" in output\n   456→    assert \"error\" in output\n   457→    assert \"message\" in output\n   458→\n   459→    # Verify types\n   460→    assert isinstance(output[\"success\"], bool)\n   461→    assert isinstance(output[\"error\"], str)\n   462→    assert isinstance(output[\"message\"], str)\n   463→\n   464→    # Verify values\n   465→    assert output[\"success\"] is False\n   466→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"ce85b822-3786-481c-ae4b-ae3da03dec56","timestamp":"2026-02-22T14:48:53.326Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py","content":"\"\"\"Unit tests for plan_create_review_pr exec command.\n\nTests creation of draft PRs for plan review from GitHub issues.\nUses FakeGitHub and FakeGitHubIssues for fast, reliable testing.\n\"\"\"\n\nimport json\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nfrom click.testing import CliRunner\n\nfrom erk.cli.commands.exec.scripts.plan_create_review_pr import plan_create_review_pr\nfrom erk_shared.context.context import ErkContext\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.issues.fake import FakeGitHubIssues\nfrom erk_shared.gateway.github.issues.types import IssueInfo\nfrom erk_shared.gateway.github.types import RepoInfo\n\nTEST_REPO_INFO = RepoInfo(owner=\"test-owner\", name=\"test-repo\")\n\n\ndef make_plan_header_body(\n    *,\n    plan_comment_id: int | None,\n) -> str:\n    \"\"\"Create a test issue body with plan-header metadata block.\"\"\"\n    comment_id_line = (\n        f\"plan_comment_id: {plan_comment_id}\"\n        if plan_comment_id is not None\n        else \"plan_comment_id: null\"\n    )\n\n    return f\"\"\"<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\n<!-- erk:metadata-block:plan-header -->\n<details>\n<summary><code>plan-header</code></summary>\n\n```yaml\n\nschema_version: '2'\ncreated_at: '2025-11-25T14:37:43.513418+00:00'\ncreated_by: testuser\n{comment_id_line}\nlast_dispatched_run_id: null\nlast_dispatched_at: null\n\n```\n\n</details>\n<!-- /erk:metadata-block:plan-header -->\"\"\"\n\n\ndef make_issue_info(\n    number: int,\n    body: str,\n    title: str,\n    labels: list[str] | None,\n) -> IssueInfo:\n    \"\"\"Create test IssueInfo with given number, body, and labels.\"\"\"\n    if labels is None:\n        labels = [\"erk-plan\"]\n    now = datetime.now(UTC)\n    return IssueInfo(\n        number=number,\n        title=title,\n        body=body,\n        state=\"OPEN\",\n        url=f\"https://github.com/test-owner/test-repo/issues/{number}\",\n        labels=labels,\n        assignees=[],\n        created_at=now,\n        updated_at=now,\n        author=\"test-user\",\n    )\n\n\n# ============================================================================\n# Success Cases\n# ============================================================================\n\n\ndef test_plan_create_review_pr_success(tmp_path: Path) -> None:\n    \"\"\"Test successful PR creation and metadata update.\"\"\"\n    issue_number = 1234\n    branch_name = \"planned/review-1234-01-15-1430\"\n    plan_title = \"Add feature X\"\n    repo_root = tmp_path / \"repo\"\n    repo_root.mkdir(parents=True, exist_ok=True)\n\n    # Create issue with plan-header\n    body = make_plan_header_body(plan_comment_id=123456789)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(\n        issues={issue_number: issue},\n    )\n\n    fake_gh = FakeGitHub(\n        issues_gateway=fake_gh_issues,\n    )\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    assert output[\"issue_number\"] == issue_number\n    assert output[\"pr_number\"] == 999\n    assert output[\"pr_url\"] == \"https://github.com/test-owner/test-repo/pull/999\"\n\n    # Verify PR was created as draft\n    assert len(fake_gh.created_prs) == 1\n    pr = fake_gh.created_prs[0]\n    assert pr[0] == branch_name  # branch\n    assert pr[1] == f\"[erk-plan-review] {plan_title} (#{issue_number})\"  # title\n    assert f\"issue #{issue_number}\" in pr[2]  # body contains issue reference\n    assert \"Quick Start\" in pr[2]  # body contains Quick Start section\n    assert f\"erk br co --for-plan {issue_number}\" in pr[2]  # body contains prepare command\n    assert pr[3] == \"master\"  # base\n    assert pr[4] is True  # draft=True\n\n    # Verify plan-review label was added\n    assert (999, \"erk-plan-review\") in fake_gh.added_labels\n\n    # Verify issue body was updated with review_pr field via PlanBackend\n    assert len(fake_gh_issues.updated_bodies) == 1\n    updated_issue_number, updated_body = fake_gh_issues.updated_bodies[0]\n    assert updated_issue_number == issue_number\n    assert \"review_pr: 999\" in updated_body\n\n\ndef test_plan_create_review_pr_title_format(tmp_path: Path) -> None:\n    \"\"\"Test PR title contains issue reference.\"\"\"\n    issue_number = 5678\n    branch_name = \"planned/review-5678-01-15-1430\"\n    plan_title = \"Implement new backend\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=123)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify PR title format\n    pr = fake_gh.created_prs[0]\n    assert pr[1] == f\"[erk-plan-review] {plan_title} (#{issue_number})\"\n\n\ndef test_plan_create_review_pr_strips_erk_plan_prefix(tmp_path: Path) -> None:\n    \"\"\"Test PR title strips [erk-plan] prefix from plan_title.\"\"\"\n    issue_number = 5679\n    branch_name = \"planned/review-5679-01-15-1430\"\n    plan_title = \"[erk-plan] Implement new backend\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=123)\n    issue = make_issue_info(issue_number, body, title=plan_title, labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify [erk-plan] prefix was stripped and [erk-plan-review] used instead\n    pr = fake_gh.created_prs[0]\n    assert pr[1] == f\"[erk-plan-review] Implement new backend (#{issue_number})\"\n\n\ndef test_plan_create_review_pr_body_format(tmp_path: Path) -> None:\n    \"\"\"Test PR body has issue link and warning.\"\"\"\n    issue_number = 9999\n    branch_name = \"planned/review-9999-01-15-1430\"\n    plan_title = \"Test Plan\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=456)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify PR body format\n    pr_body = fake_gh.created_prs[0][2]\n    assert f\"Plan Review: {plan_title}\" in pr_body\n    assert f\"issue #{issue_number}\" in pr_body\n    assert \"will not be merged\" in pr_body\n    assert \"inline review comments\" in pr_body\n    assert \"Quick Start\" in pr_body\n    assert f\"erk br co --for-plan {issue_number}\" in pr_body\n    prepare_and_implement_cmd = (\n        f'source \"$(erk br co --for-plan {issue_number} --script)\" && erk implement --dangerous'\n    )\n    assert prepare_and_implement_cmd in pr_body\n\n\ndef test_plan_create_review_pr_draft_mode(tmp_path: Path) -> None:\n    \"\"\"Test PR is created in draft mode.\"\"\"\n    issue_number = 2222\n    branch_name = \"planned/review-2222-01-15-1430\"\n    plan_title = \"Draft PR Test\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=789)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify draft=True was passed\n    pr = fake_gh.created_prs[0]\n    assert pr[4] is True\n\n\ndef test_plan_create_review_pr_metadata_updated(tmp_path: Path) -> None:\n    \"\"\"Test issue metadata contains review_pr field after creation.\"\"\"\n    issue_number = 3333\n    branch_name = \"planned/review-3333-01-15-1430\"\n    plan_title = \"Metadata Update Test\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=111)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify metadata was updated via PlanBackend\n    assert len(fake_gh_issues.updated_bodies) == 1\n    updated_issue_number, updated_body = fake_gh_issues.updated_bodies[0]\n    assert updated_issue_number == issue_number\n    assert \"review_pr:\" in updated_body\n    assert \"review_pr: 999\" in updated_body\n\n\ndef test_plan_create_review_pr_uses_dynamic_repo_url(tmp_path: Path) -> None:\n    \"\"\"Test PR URL uses repo identifier from context, not a hardcoded value.\"\"\"\n    issue_number = 7777\n    branch_name = \"planned/review-7777-01-15-1430\"\n    plan_title = \"Dynamic URL Test\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=333)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    custom_repo_info = RepoInfo(owner=\"my-org\", name=\"my-project\")\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=custom_repo_info,\n        ),\n    )\n\n    assert result.exit_code == 0\n    output = json.loads(result.output)\n    assert output[\"pr_url\"] == \"https://github.com/my-org/my-project/pull/999\"\n\n\n# ============================================================================\n# Error Cases\n# ============================================================================\n\n\ndef test_plan_create_review_pr_issue_not_found(tmp_path: Path) -> None:\n    \"\"\"Test error when issue doesn't exist.\"\"\"\n    repo_root = tmp_path / \"repo\"\n    fake_gh_issues = FakeGitHubIssues()\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [\"9999\", \"test-branch\", \"Test Plan\"],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n    assert output[\"success\"] is False\n    assert output[\"error\"] == \"issue_not_found\"\n    assert \"#9999\" in output[\"message\"]\n\n\n# ============================================================================\n# JSON Output Schema\n# ============================================================================\n\n\ndef test_json_output_structure_success(tmp_path: Path) -> None:\n    \"\"\"Test success JSON output has correct structure.\"\"\"\n    issue_number = 4444\n    branch_name = \"planned/review-4444-01-15-1430\"\n    plan_title = \"JSON Test\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=222)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n    output = json.loads(result.output)\n\n    # Verify all required fields present\n    assert \"success\" in output\n    assert \"issue_number\" in output\n    assert \"pr_number\" in output\n    assert \"pr_url\" in output\n\n    # Verify types\n    assert isinstance(output[\"success\"], bool)\n    assert isinstance(output[\"issue_number\"], int)\n    assert isinstance(output[\"pr_number\"], int)\n    assert isinstance(output[\"pr_url\"], str)\n\n\ndef test_json_output_structure_error(tmp_path: Path) -> None:\n    \"\"\"Test error JSON output has correct structure.\"\"\"\n    repo_root = tmp_path / \"repo\"\n    fake_gh_issues = FakeGitHubIssues()\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [\"8888\", \"test-branch\", \"Error Test\"],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n\n    # Verify all required fields present\n    assert \"success\" in output\n    assert \"error\" in output\n    assert \"message\" in output\n\n    # Verify types\n    assert isinstance(output[\"success\"], bool)\n    assert isinstance(output[\"error\"], str)\n    assert isinstance(output[\"message\"], str)\n\n    # Verify values\n    assert output[\"success\"] is False\n","numLines":466,"startLine":1,"totalLines":466}}}
{"parentUuid":"ce85b822-3786-481c-ae4b-ae3da03dec56","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_018Tc9645rNVBnihVP7kHs6h","type":"message","role":"assistant","content":[{"type":"text","text":"These branch names are just test data passed as arguments - they're not generated by the code, but rather used as fixture inputs. The branch_name values in these tests are passed directly to the `plan_create_review_pr` command as arguments. They don't test the naming generation - that's tested in test_plan_create_review_branch.py. However, since the actual generated branch names will now be `plnd/`, I should update these to be consistent:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":6406,"cache_read_input_tokens":104105,"cache_creation":{"ephemeral_5m_input_tokens":6406,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHuCQpPjzwomrnF7rPY","type":"assistant","uuid":"cba2515c-36a1-4032-8a15-5ed9433b4ed8","timestamp":"2026-02-22T14:48:58.922Z"}
{"parentUuid":"cba2515c-36a1-4032-8a15-5ed9433b4ed8","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_018Tc9645rNVBnihVP7kHs6h","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012fazaLh8WnCcjr4UzTPTMw","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py","old_string":"    branch_name = \"planned/review-1234-01-15-1430\"","new_string":"    branch_name = \"plnd/review-1234-01-15-1430\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":6406,"cache_read_input_tokens":104105,"cache_creation":{"ephemeral_5m_input_tokens":6406,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHuCQpPjzwomrnF7rPY","type":"assistant","uuid":"85c1bb21-aff5-44d2-aae7-076222d34b8e","timestamp":"2026-02-22T14:49:00.664Z"}
{"parentUuid":"85c1bb21-aff5-44d2-aae7-076222d34b8e","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012fazaLh8WnCcjr4UzTPTMw","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py has been updated successfully."}]},"uuid":"dfffa656-b902-4d83-88df-0d888d148537","timestamp":"2026-02-22T14:49:01.351Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py","oldString":"    branch_name = \"planned/review-1234-01-15-1430\"","newString":"    branch_name = \"plnd/review-1234-01-15-1430\"","originalFile":"\"\"\"Unit tests for plan_create_review_pr exec command.\n\nTests creation of draft PRs for plan review from GitHub issues.\nUses FakeGitHub and FakeGitHubIssues for fast, reliable testing.\n\"\"\"\n\nimport json\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nfrom click.testing import CliRunner\n\nfrom erk.cli.commands.exec.scripts.plan_create_review_pr import plan_create_review_pr\nfrom erk_shared.context.context import ErkContext\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.issues.fake import FakeGitHubIssues\nfrom erk_shared.gateway.github.issues.types import IssueInfo\nfrom erk_shared.gateway.github.types import RepoInfo\n\nTEST_REPO_INFO = RepoInfo(owner=\"test-owner\", name=\"test-repo\")\n\n\ndef make_plan_header_body(\n    *,\n    plan_comment_id: int | None,\n) -> str:\n    \"\"\"Create a test issue body with plan-header metadata block.\"\"\"\n    comment_id_line = (\n        f\"plan_comment_id: {plan_comment_id}\"\n        if plan_comment_id is not None\n        else \"plan_comment_id: null\"\n    )\n\n    return f\"\"\"<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\n<!-- erk:metadata-block:plan-header -->\n<details>\n<summary><code>plan-header</code></summary>\n\n```yaml\n\nschema_version: '2'\ncreated_at: '2025-11-25T14:37:43.513418+00:00'\ncreated_by: testuser\n{comment_id_line}\nlast_dispatched_run_id: null\nlast_dispatched_at: null\n\n```\n\n</details>\n<!-- /erk:metadata-block:plan-header -->\"\"\"\n\n\ndef make_issue_info(\n    number: int,\n    body: str,\n    title: str,\n    labels: list[str] | None,\n) -> IssueInfo:\n    \"\"\"Create test IssueInfo with given number, body, and labels.\"\"\"\n    if labels is None:\n        labels = [\"erk-plan\"]\n    now = datetime.now(UTC)\n    return IssueInfo(\n        number=number,\n        title=title,\n        body=body,\n        state=\"OPEN\",\n        url=f\"https://github.com/test-owner/test-repo/issues/{number}\",\n        labels=labels,\n        assignees=[],\n        created_at=now,\n        updated_at=now,\n        author=\"test-user\",\n    )\n\n\n# ============================================================================\n# Success Cases\n# ============================================================================\n\n\ndef test_plan_create_review_pr_success(tmp_path: Path) -> None:\n    \"\"\"Test successful PR creation and metadata update.\"\"\"\n    issue_number = 1234\n    branch_name = \"planned/review-1234-01-15-1430\"\n    plan_title = \"Add feature X\"\n    repo_root = tmp_path / \"repo\"\n    repo_root.mkdir(parents=True, exist_ok=True)\n\n    # Create issue with plan-header\n    body = make_plan_header_body(plan_comment_id=123456789)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(\n        issues={issue_number: issue},\n    )\n\n    fake_gh = FakeGitHub(\n        issues_gateway=fake_gh_issues,\n    )\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    assert output[\"issue_number\"] == issue_number\n    assert output[\"pr_number\"] == 999\n    assert output[\"pr_url\"] == \"https://github.com/test-owner/test-repo/pull/999\"\n\n    # Verify PR was created as draft\n    assert len(fake_gh.created_prs) == 1\n    pr = fake_gh.created_prs[0]\n    assert pr[0] == branch_name  # branch\n    assert pr[1] == f\"[erk-plan-review] {plan_title} (#{issue_number})\"  # title\n    assert f\"issue #{issue_number}\" in pr[2]  # body contains issue reference\n    assert \"Quick Start\" in pr[2]  # body contains Quick Start section\n    assert f\"erk br co --for-plan {issue_number}\" in pr[2]  # body contains prepare command\n    assert pr[3] == \"master\"  # base\n    assert pr[4] is True  # draft=True\n\n    # Verify plan-review label was added\n    assert (999, \"erk-plan-review\") in fake_gh.added_labels\n\n    # Verify issue body was updated with review_pr field via PlanBackend\n    assert len(fake_gh_issues.updated_bodies) == 1\n    updated_issue_number, updated_body = fake_gh_issues.updated_bodies[0]\n    assert updated_issue_number == issue_number\n    assert \"review_pr: 999\" in updated_body\n\n\ndef test_plan_create_review_pr_title_format(tmp_path: Path) -> None:\n    \"\"\"Test PR title contains issue reference.\"\"\"\n    issue_number = 5678\n    branch_name = \"planned/review-5678-01-15-1430\"\n    plan_title = \"Implement new backend\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=123)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify PR title format\n    pr = fake_gh.created_prs[0]\n    assert pr[1] == f\"[erk-plan-review] {plan_title} (#{issue_number})\"\n\n\ndef test_plan_create_review_pr_strips_erk_plan_prefix(tmp_path: Path) -> None:\n    \"\"\"Test PR title strips [erk-plan] prefix from plan_title.\"\"\"\n    issue_number = 5679\n    branch_name = \"planned/review-5679-01-15-1430\"\n    plan_title = \"[erk-plan] Implement new backend\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=123)\n    issue = make_issue_info(issue_number, body, title=plan_title, labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify [erk-plan] prefix was stripped and [erk-plan-review] used instead\n    pr = fake_gh.created_prs[0]\n    assert pr[1] == f\"[erk-plan-review] Implement new backend (#{issue_number})\"\n\n\ndef test_plan_create_review_pr_body_format(tmp_path: Path) -> None:\n    \"\"\"Test PR body has issue link and warning.\"\"\"\n    issue_number = 9999\n    branch_name = \"planned/review-9999-01-15-1430\"\n    plan_title = \"Test Plan\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=456)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify PR body format\n    pr_body = fake_gh.created_prs[0][2]\n    assert f\"Plan Review: {plan_title}\" in pr_body\n    assert f\"issue #{issue_number}\" in pr_body\n    assert \"will not be merged\" in pr_body\n    assert \"inline review comments\" in pr_body\n    assert \"Quick Start\" in pr_body\n    assert f\"erk br co --for-plan {issue_number}\" in pr_body\n    prepare_and_implement_cmd = (\n        f'source \"$(erk br co --for-plan {issue_number} --script)\" && erk implement --dangerous'\n    )\n    assert prepare_and_implement_cmd in pr_body\n\n\ndef test_plan_create_review_pr_draft_mode(tmp_path: Path) -> None:\n    \"\"\"Test PR is created in draft mode.\"\"\"\n    issue_number = 2222\n    branch_name = \"planned/review-2222-01-15-1430\"\n    plan_title = \"Draft PR Test\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=789)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify draft=True was passed\n    pr = fake_gh.created_prs[0]\n    assert pr[4] is True\n\n\ndef test_plan_create_review_pr_metadata_updated(tmp_path: Path) -> None:\n    \"\"\"Test issue metadata contains review_pr field after creation.\"\"\"\n    issue_number = 3333\n    branch_name = \"planned/review-3333-01-15-1430\"\n    plan_title = \"Metadata Update Test\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=111)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify metadata was updated via PlanBackend\n    assert len(fake_gh_issues.updated_bodies) == 1\n    updated_issue_number, updated_body = fake_gh_issues.updated_bodies[0]\n    assert updated_issue_number == issue_number\n    assert \"review_pr:\" in updated_body\n    assert \"review_pr: 999\" in updated_body\n\n\ndef test_plan_create_review_pr_uses_dynamic_repo_url(tmp_path: Path) -> None:\n    \"\"\"Test PR URL uses repo identifier from context, not a hardcoded value.\"\"\"\n    issue_number = 7777\n    branch_name = \"planned/review-7777-01-15-1430\"\n    plan_title = \"Dynamic URL Test\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=333)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    custom_repo_info = RepoInfo(owner=\"my-org\", name=\"my-project\")\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=custom_repo_info,\n        ),\n    )\n\n    assert result.exit_code == 0\n    output = json.loads(result.output)\n    assert output[\"pr_url\"] == \"https://github.com/my-org/my-project/pull/999\"\n\n\n# ============================================================================\n# Error Cases\n# ============================================================================\n\n\ndef test_plan_create_review_pr_issue_not_found(tmp_path: Path) -> None:\n    \"\"\"Test error when issue doesn't exist.\"\"\"\n    repo_root = tmp_path / \"repo\"\n    fake_gh_issues = FakeGitHubIssues()\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [\"9999\", \"test-branch\", \"Test Plan\"],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n    assert output[\"success\"] is False\n    assert output[\"error\"] == \"issue_not_found\"\n    assert \"#9999\" in output[\"message\"]\n\n\n# ============================================================================\n# JSON Output Schema\n# ============================================================================\n\n\ndef test_json_output_structure_success(tmp_path: Path) -> None:\n    \"\"\"Test success JSON output has correct structure.\"\"\"\n    issue_number = 4444\n    branch_name = \"planned/review-4444-01-15-1430\"\n    plan_title = \"JSON Test\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=222)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n    output = json.loads(result.output)\n\n    # Verify all required fields present\n    assert \"success\" in output\n    assert \"issue_number\" in output\n    assert \"pr_number\" in output\n    assert \"pr_url\" in output\n\n    # Verify types\n    assert isinstance(output[\"success\"], bool)\n    assert isinstance(output[\"issue_number\"], int)\n    assert isinstance(output[\"pr_number\"], int)\n    assert isinstance(output[\"pr_url\"], str)\n\n\ndef test_json_output_structure_error(tmp_path: Path) -> None:\n    \"\"\"Test error JSON output has correct structure.\"\"\"\n    repo_root = tmp_path / \"repo\"\n    fake_gh_issues = FakeGitHubIssues()\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [\"8888\", \"test-branch\", \"Error Test\"],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n\n    # Verify all required fields present\n    assert \"success\" in output\n    assert \"error\" in output\n    assert \"message\" in output\n\n    # Verify types\n    assert isinstance(output[\"success\"], bool)\n    assert isinstance(output[\"error\"], str)\n    assert isinstance(output[\"message\"], str)\n\n    # Verify values\n    assert output[\"success\"] is False\n","structuredPatch":[{"oldStart":83,"oldLines":7,"newStart":83,"newLines":7,"lines":[" def test_plan_create_review_pr_success(tmp_path: Path) -> None:","     \"\"\"Test successful PR creation and metadata update.\"\"\"","     issue_number = 1234","-    branch_name = \"planned/review-1234-01-15-1430\"","+    branch_name = \"plnd/review-1234-01-15-1430\"","     plan_title = \"Add feature X\"","     repo_root = tmp_path / \"repo\"","     repo_root.mkdir(parents=True, exist_ok=True)"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"dfffa656-b902-4d83-88df-0d888d148537","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01WNqunzL5nvz73hAdAGcciW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012ixiLSSBBdewjmAwfKr35G","name":"Edit","input":{"replace_all":true,"file_path":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py","old_string":"    branch_name = \"planned/review-","new_string":"    branch_name = \"plnd/review-"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":658,"cache_read_input_tokens":110511,"cache_creation":{"ephemeral_5m_input_tokens":658,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHunkZK7VegvVpqzGzd","type":"assistant","uuid":"0a395077-831c-4848-bbeb-94a2f760b7fd","timestamp":"2026-02-22T14:49:05.205Z"}
{"parentUuid":"0a395077-831c-4848-bbeb-94a2f760b7fd","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012ixiLSSBBdewjmAwfKr35G","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py has been updated. All occurrences of '    branch_name = \"planned/review-' were successfully replaced with '    branch_name = \"plnd/review-'."}]},"uuid":"2f9b1a48-02d0-471e-a3c8-777babfbd510","timestamp":"2026-02-22T14:49:05.889Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py","oldString":"    branch_name = \"planned/review-","newString":"    branch_name = \"plnd/review-","originalFile":"\"\"\"Unit tests for plan_create_review_pr exec command.\n\nTests creation of draft PRs for plan review from GitHub issues.\nUses FakeGitHub and FakeGitHubIssues for fast, reliable testing.\n\"\"\"\n\nimport json\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nfrom click.testing import CliRunner\n\nfrom erk.cli.commands.exec.scripts.plan_create_review_pr import plan_create_review_pr\nfrom erk_shared.context.context import ErkContext\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.issues.fake import FakeGitHubIssues\nfrom erk_shared.gateway.github.issues.types import IssueInfo\nfrom erk_shared.gateway.github.types import RepoInfo\n\nTEST_REPO_INFO = RepoInfo(owner=\"test-owner\", name=\"test-repo\")\n\n\ndef make_plan_header_body(\n    *,\n    plan_comment_id: int | None,\n) -> str:\n    \"\"\"Create a test issue body with plan-header metadata block.\"\"\"\n    comment_id_line = (\n        f\"plan_comment_id: {plan_comment_id}\"\n        if plan_comment_id is not None\n        else \"plan_comment_id: null\"\n    )\n\n    return f\"\"\"<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->\n<!-- erk:metadata-block:plan-header -->\n<details>\n<summary><code>plan-header</code></summary>\n\n```yaml\n\nschema_version: '2'\ncreated_at: '2025-11-25T14:37:43.513418+00:00'\ncreated_by: testuser\n{comment_id_line}\nlast_dispatched_run_id: null\nlast_dispatched_at: null\n\n```\n\n</details>\n<!-- /erk:metadata-block:plan-header -->\"\"\"\n\n\ndef make_issue_info(\n    number: int,\n    body: str,\n    title: str,\n    labels: list[str] | None,\n) -> IssueInfo:\n    \"\"\"Create test IssueInfo with given number, body, and labels.\"\"\"\n    if labels is None:\n        labels = [\"erk-plan\"]\n    now = datetime.now(UTC)\n    return IssueInfo(\n        number=number,\n        title=title,\n        body=body,\n        state=\"OPEN\",\n        url=f\"https://github.com/test-owner/test-repo/issues/{number}\",\n        labels=labels,\n        assignees=[],\n        created_at=now,\n        updated_at=now,\n        author=\"test-user\",\n    )\n\n\n# ============================================================================\n# Success Cases\n# ============================================================================\n\n\ndef test_plan_create_review_pr_success(tmp_path: Path) -> None:\n    \"\"\"Test successful PR creation and metadata update.\"\"\"\n    issue_number = 1234\n    branch_name = \"plnd/review-1234-01-15-1430\"\n    plan_title = \"Add feature X\"\n    repo_root = tmp_path / \"repo\"\n    repo_root.mkdir(parents=True, exist_ok=True)\n\n    # Create issue with plan-header\n    body = make_plan_header_body(plan_comment_id=123456789)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(\n        issues={issue_number: issue},\n    )\n\n    fake_gh = FakeGitHub(\n        issues_gateway=fake_gh_issues,\n    )\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n    output = json.loads(result.output)\n    assert output[\"success\"] is True\n    assert output[\"issue_number\"] == issue_number\n    assert output[\"pr_number\"] == 999\n    assert output[\"pr_url\"] == \"https://github.com/test-owner/test-repo/pull/999\"\n\n    # Verify PR was created as draft\n    assert len(fake_gh.created_prs) == 1\n    pr = fake_gh.created_prs[0]\n    assert pr[0] == branch_name  # branch\n    assert pr[1] == f\"[erk-plan-review] {plan_title} (#{issue_number})\"  # title\n    assert f\"issue #{issue_number}\" in pr[2]  # body contains issue reference\n    assert \"Quick Start\" in pr[2]  # body contains Quick Start section\n    assert f\"erk br co --for-plan {issue_number}\" in pr[2]  # body contains prepare command\n    assert pr[3] == \"master\"  # base\n    assert pr[4] is True  # draft=True\n\n    # Verify plan-review label was added\n    assert (999, \"erk-plan-review\") in fake_gh.added_labels\n\n    # Verify issue body was updated with review_pr field via PlanBackend\n    assert len(fake_gh_issues.updated_bodies) == 1\n    updated_issue_number, updated_body = fake_gh_issues.updated_bodies[0]\n    assert updated_issue_number == issue_number\n    assert \"review_pr: 999\" in updated_body\n\n\ndef test_plan_create_review_pr_title_format(tmp_path: Path) -> None:\n    \"\"\"Test PR title contains issue reference.\"\"\"\n    issue_number = 5678\n    branch_name = \"planned/review-5678-01-15-1430\"\n    plan_title = \"Implement new backend\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=123)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify PR title format\n    pr = fake_gh.created_prs[0]\n    assert pr[1] == f\"[erk-plan-review] {plan_title} (#{issue_number})\"\n\n\ndef test_plan_create_review_pr_strips_erk_plan_prefix(tmp_path: Path) -> None:\n    \"\"\"Test PR title strips [erk-plan] prefix from plan_title.\"\"\"\n    issue_number = 5679\n    branch_name = \"planned/review-5679-01-15-1430\"\n    plan_title = \"[erk-plan] Implement new backend\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=123)\n    issue = make_issue_info(issue_number, body, title=plan_title, labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify [erk-plan] prefix was stripped and [erk-plan-review] used instead\n    pr = fake_gh.created_prs[0]\n    assert pr[1] == f\"[erk-plan-review] Implement new backend (#{issue_number})\"\n\n\ndef test_plan_create_review_pr_body_format(tmp_path: Path) -> None:\n    \"\"\"Test PR body has issue link and warning.\"\"\"\n    issue_number = 9999\n    branch_name = \"planned/review-9999-01-15-1430\"\n    plan_title = \"Test Plan\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=456)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify PR body format\n    pr_body = fake_gh.created_prs[0][2]\n    assert f\"Plan Review: {plan_title}\" in pr_body\n    assert f\"issue #{issue_number}\" in pr_body\n    assert \"will not be merged\" in pr_body\n    assert \"inline review comments\" in pr_body\n    assert \"Quick Start\" in pr_body\n    assert f\"erk br co --for-plan {issue_number}\" in pr_body\n    prepare_and_implement_cmd = (\n        f'source \"$(erk br co --for-plan {issue_number} --script)\" && erk implement --dangerous'\n    )\n    assert prepare_and_implement_cmd in pr_body\n\n\ndef test_plan_create_review_pr_draft_mode(tmp_path: Path) -> None:\n    \"\"\"Test PR is created in draft mode.\"\"\"\n    issue_number = 2222\n    branch_name = \"planned/review-2222-01-15-1430\"\n    plan_title = \"Draft PR Test\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=789)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify draft=True was passed\n    pr = fake_gh.created_prs[0]\n    assert pr[4] is True\n\n\ndef test_plan_create_review_pr_metadata_updated(tmp_path: Path) -> None:\n    \"\"\"Test issue metadata contains review_pr field after creation.\"\"\"\n    issue_number = 3333\n    branch_name = \"planned/review-3333-01-15-1430\"\n    plan_title = \"Metadata Update Test\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=111)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n\n    # Verify metadata was updated via PlanBackend\n    assert len(fake_gh_issues.updated_bodies) == 1\n    updated_issue_number, updated_body = fake_gh_issues.updated_bodies[0]\n    assert updated_issue_number == issue_number\n    assert \"review_pr:\" in updated_body\n    assert \"review_pr: 999\" in updated_body\n\n\ndef test_plan_create_review_pr_uses_dynamic_repo_url(tmp_path: Path) -> None:\n    \"\"\"Test PR URL uses repo identifier from context, not a hardcoded value.\"\"\"\n    issue_number = 7777\n    branch_name = \"planned/review-7777-01-15-1430\"\n    plan_title = \"Dynamic URL Test\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=333)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    custom_repo_info = RepoInfo(owner=\"my-org\", name=\"my-project\")\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=custom_repo_info,\n        ),\n    )\n\n    assert result.exit_code == 0\n    output = json.loads(result.output)\n    assert output[\"pr_url\"] == \"https://github.com/my-org/my-project/pull/999\"\n\n\n# ============================================================================\n# Error Cases\n# ============================================================================\n\n\ndef test_plan_create_review_pr_issue_not_found(tmp_path: Path) -> None:\n    \"\"\"Test error when issue doesn't exist.\"\"\"\n    repo_root = tmp_path / \"repo\"\n    fake_gh_issues = FakeGitHubIssues()\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [\"9999\", \"test-branch\", \"Test Plan\"],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n    assert output[\"success\"] is False\n    assert output[\"error\"] == \"issue_not_found\"\n    assert \"#9999\" in output[\"message\"]\n\n\n# ============================================================================\n# JSON Output Schema\n# ============================================================================\n\n\ndef test_json_output_structure_success(tmp_path: Path) -> None:\n    \"\"\"Test success JSON output has correct structure.\"\"\"\n    issue_number = 4444\n    branch_name = \"planned/review-4444-01-15-1430\"\n    plan_title = \"JSON Test\"\n    repo_root = tmp_path / \"repo\"\n\n    body = make_plan_header_body(plan_comment_id=222)\n    issue = make_issue_info(issue_number, body, title=f\"Plan: {plan_title}\", labels=None)\n\n    fake_gh_issues = FakeGitHubIssues(issues={issue_number: issue})\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [str(issue_number), branch_name, plan_title],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 0\n    output = json.loads(result.output)\n\n    # Verify all required fields present\n    assert \"success\" in output\n    assert \"issue_number\" in output\n    assert \"pr_number\" in output\n    assert \"pr_url\" in output\n\n    # Verify types\n    assert isinstance(output[\"success\"], bool)\n    assert isinstance(output[\"issue_number\"], int)\n    assert isinstance(output[\"pr_number\"], int)\n    assert isinstance(output[\"pr_url\"], str)\n\n\ndef test_json_output_structure_error(tmp_path: Path) -> None:\n    \"\"\"Test error JSON output has correct structure.\"\"\"\n    repo_root = tmp_path / \"repo\"\n    fake_gh_issues = FakeGitHubIssues()\n    fake_gh = FakeGitHub(issues_gateway=fake_gh_issues)\n\n    runner = CliRunner()\n\n    result = runner.invoke(\n        plan_create_review_pr,\n        [\"8888\", \"test-branch\", \"Error Test\"],\n        obj=ErkContext.for_test(\n            github=fake_gh,\n            github_issues=fake_gh_issues,\n            repo_root=repo_root,\n            repo_info=TEST_REPO_INFO,\n        ),\n    )\n\n    assert result.exit_code == 1\n    output = json.loads(result.output)\n\n    # Verify all required fields present\n    assert \"success\" in output\n    assert \"error\" in output\n    assert \"message\" in output\n\n    # Verify types\n    assert isinstance(output[\"success\"], bool)\n    assert isinstance(output[\"error\"], str)\n    assert isinstance(output[\"message\"], str)\n\n    # Verify values\n    assert output[\"success\"] is False\n","structuredPatch":[{"oldStart":144,"oldLines":7,"newStart":144,"newLines":7,"lines":[" def test_plan_create_review_pr_title_format(tmp_path: Path) -> None:","     \"\"\"Test PR title contains issue reference.\"\"\"","     issue_number = 5678","-    branch_name = \"planned/review-5678-01-15-1430\"","+    branch_name = \"plnd/review-5678-01-15-1430\"","     plan_title = \"Implement new backend\"","     repo_root = tmp_path / \"repo\""," "]},{"oldStart":177,"oldLines":7,"newStart":177,"newLines":7,"lines":[" def test_plan_create_review_pr_strips_erk_plan_prefix(tmp_path: Path) -> None:","     \"\"\"Test PR title strips [erk-plan] prefix from plan_title.\"\"\"","     issue_number = 5679","-    branch_name = \"planned/review-5679-01-15-1430\"","+    branch_name = \"plnd/review-5679-01-15-1430\"","     plan_title = \"[erk-plan] Implement new backend\"","     repo_root = tmp_path / \"repo\""," "]},{"oldStart":210,"oldLines":7,"newStart":210,"newLines":7,"lines":[" def test_plan_create_review_pr_body_format(tmp_path: Path) -> None:","     \"\"\"Test PR body has issue link and warning.\"\"\"","     issue_number = 9999","-    branch_name = \"planned/review-9999-01-15-1430\"","+    branch_name = \"plnd/review-9999-01-15-1430\"","     plan_title = \"Test Plan\"","     repo_root = tmp_path / \"repo\""," "]},{"oldStart":252,"oldLines":7,"newStart":252,"newLines":7,"lines":[" def test_plan_create_review_pr_draft_mode(tmp_path: Path) -> None:","     \"\"\"Test PR is created in draft mode.\"\"\"","     issue_number = 2222","-    branch_name = \"planned/review-2222-01-15-1430\"","+    branch_name = \"plnd/review-2222-01-15-1430\"","     plan_title = \"Draft PR Test\"","     repo_root = tmp_path / \"repo\""," "]},{"oldStart":285,"oldLines":7,"newStart":285,"newLines":7,"lines":[" def test_plan_create_review_pr_metadata_updated(tmp_path: Path) -> None:","     \"\"\"Test issue metadata contains review_pr field after creation.\"\"\"","     issue_number = 3333","-    branch_name = \"planned/review-3333-01-15-1430\"","+    branch_name = \"plnd/review-3333-01-15-1430\"","     plan_title = \"Metadata Update Test\"","     repo_root = tmp_path / \"repo\""," "]},{"oldStart":321,"oldLines":7,"newStart":321,"newLines":7,"lines":[" def test_plan_create_review_pr_uses_dynamic_repo_url(tmp_path: Path) -> None:","     \"\"\"Test PR URL uses repo identifier from context, not a hardcoded value.\"\"\"","     issue_number = 7777","-    branch_name = \"planned/review-7777-01-15-1430\"","+    branch_name = \"plnd/review-7777-01-15-1430\"","     plan_title = \"Dynamic URL Test\"","     repo_root = tmp_path / \"repo\""," "]},{"oldStart":390,"oldLines":7,"newStart":390,"newLines":7,"lines":[" def test_json_output_structure_success(tmp_path: Path) -> None:","     \"\"\"Test success JSON output has correct structure.\"\"\"","     issue_number = 4444","-    branch_name = \"planned/review-4444-01-15-1430\"","+    branch_name = \"plnd/review-4444-01-15-1430\"","     plan_title = \"JSON Test\"","     repo_root = tmp_path / \"repo\""," "]}],"userModified":false,"replaceAll":true}}
{"parentUuid":"2f9b1a48-02d0-471e-a3c8-777babfbd510","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_012FxX27BTgcjvVMofwFsYrj","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the TUI test file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":252,"cache_read_input_tokens":111169,"cache_creation":{"ephemeral_5m_input_tokens":252,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHv89NRwFeepas7ACz2","type":"assistant","uuid":"510c8fca-dfd9-4a80-b21b-4f64a33d4671","timestamp":"2026-02-22T14:49:08.428Z"}
{"parentUuid":"510c8fca-dfd9-4a80-b21b-4f64a33d4671","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_012FxX27BTgcjvVMofwFsYrj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RuqKqznKRjHQkViob6N6pK","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","offset":235,"limit":75},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":252,"cache_read_input_tokens":111169,"cache_creation":{"ephemeral_5m_input_tokens":252,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHv89NRwFeepas7ACz2","type":"assistant","uuid":"8346bd86-9a11-4d94-9fb3-9933f7c4ba5c","timestamp":"2026-02-22T14:49:09.317Z"}
{"parentUuid":"8346bd86-9a11-4d94-9fb3-9933f7c4ba5c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RuqKqznKRjHQkViob6N6pK","type":"tool_result","content":"   235→\n   236→        mapping = provider._build_worktree_mapping()\n   237→\n   238→        # Non-plan branch should not produce an entry\n   239→        assert len(mapping) == 0\n   240→\n   241→    def test_draft_pr_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n   242→        \"\"\"Draft PR branch (planned/*) resolved via .impl/plan-ref.json.\n   243→\n   244→        Branch name 'planned/fix-missing-data-02-19-1416' doesn't contain a\n   245→        numeric issue prefix. The plan ID (PR number) comes from\n   246→        .impl/plan-ref.json inside the worktree directory.\n   247→        \"\"\"\n   248→        repo_root = tmp_path / \"repo\"\n   249→        repo_root.mkdir()\n   250→\n   251→        erk_dir = repo_root / \".erk\"\n   252→        erk_dir.mkdir()\n   253→\n   254→        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n   255→        worktree_path.mkdir(parents=True)\n   256→        branch_name = \"planned/fix-missing-data-02-19-1416\"\n   257→\n   258→        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n   259→        impl_dir = worktree_path / \".impl\"\n   260→        impl_dir.mkdir()\n   261→        plan_ref_data = {\n   262→            \"provider\": \"github-draft-pr\",\n   263→            \"plan_id\": \"7624\",\n   264→            \"url\": \"https://github.com/test/repo/pull/7624\",\n   265→            \"created_at\": \"2026-02-19T14:16:00+00:00\",\n   266→            \"synced_at\": \"2026-02-19T14:16:00+00:00\",\n   267→            \"labels\": [\"erk-plan\"],\n   268→            \"objective_id\": None,\n   269→        }\n   270→        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n   271→\n   272→        git = FakeGit(\n   273→            worktrees={\n   274→                repo_root: [\n   275→                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n   276→                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n   277→                ]\n   278→            },\n   279→            git_common_dirs={repo_root: repo_root / \".git\"},\n   280→        )\n   281→\n   282→        ctx = create_test_context(\n   283→            git=git,\n   284→            cwd=repo_root,\n   285→            repo=_make_repo_context(repo_root, tmp_path),\n   286→        )\n   287→\n   288→        location = GitHubRepoLocation(\n   289→            root=repo_root,\n   290→            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n   291→        )\n   292→        provider = RealPlanDataProvider(\n   293→            ctx=ctx,\n   294→            location=location,\n   295→            clipboard=FakeClipboard(),\n   296→            browser=FakeBrowserLauncher(),\n   297→            http_client=FakeHttpClient(),\n   298→        )\n   299→\n   300→        mapping = provider._build_worktree_mapping()\n   301→\n   302→        # Plan ID 7624 should be extracted from .impl/plan-ref.json\n   303→        assert 7624 in mapping\n   304→        worktree_name, worktree_branch = mapping[7624]\n   305→        assert worktree_name == \"erk-slot-05\"\n   306→        assert worktree_branch == branch_name\n   307→\n   308→    def test_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n   309→        \"\"\"Draft PR branch with planned/ prefix resolved via .impl/plan-ref.json.\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"76058a09-0200-487f-887e-78a8b56ec312","timestamp":"2026-02-22T14:49:09.342Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","content":"\n        mapping = provider._build_worktree_mapping()\n\n        # Non-plan branch should not produce an entry\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch (planned/*) resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-missing-data-02-19-1416' doesn't contain a\n        numeric issue prefix. The plan ID (PR number) comes from\n        .impl/plan-ref.json inside the worktree directory.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-missing-data-02-19-1416\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"7624\",\n            \"url\": \"https://github.com/test/repo/pull/7624\",\n            \"created_at\": \"2026-02-19T14:16:00+00:00\",\n            \"synced_at\": \"2026-02-19T14:16:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 7624 should be extracted from .impl/plan-ref.json\n        assert 7624 in mapping\n        worktree_name, worktree_branch = mapping[7624]\n        assert worktree_name == \"erk-slot-05\"\n        assert worktree_branch == branch_name\n\n    def test_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch with planned/ prefix resolved via .impl/plan-ref.json.","numLines":75,"startLine":235,"totalLines":1392}}}
{"parentUuid":"76058a09-0200-487f-887e-78a8b56ec312","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01MYkTociLqRrbSAU99X99Wu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QqwhHNtfY6PAKiKL1CPBW4","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","offset":308,"limit":180},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1646,"cache_read_input_tokens":111421,"cache_creation":{"ephemeral_5m_input_tokens":1646,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHvNusa7E43y7yEiWX5","type":"assistant","uuid":"60c1496d-a71b-4dae-8e79-d97ab13dcce3","timestamp":"2026-02-22T14:49:12.641Z"}
{"parentUuid":"60c1496d-a71b-4dae-8e79-d97ab13dcce3","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QqwhHNtfY6PAKiKL1CPBW4","type":"tool_result","content":"   308→    def test_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n   309→        \"\"\"Draft PR branch with planned/ prefix resolved via .impl/plan-ref.json.\n   310→\n   311→        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\n   312→        numeric issue prefix. The plan ID comes from .impl/plan-ref.json.\n   313→        \"\"\"\n   314→        repo_root = tmp_path / \"repo\"\n   315→        repo_root.mkdir()\n   316→\n   317→        erk_dir = repo_root / \".erk\"\n   318→        erk_dir.mkdir()\n   319→\n   320→        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-03\"\n   321→        worktree_path.mkdir(parents=True)\n   322→        branch_name = \"planned/fix-auth-bug-01-15-1430\"\n   323→\n   324→        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n   325→        impl_dir = worktree_path / \".impl\"\n   326→        impl_dir.mkdir()\n   327→        plan_ref_data = {\n   328→            \"provider\": \"github-draft-pr\",\n   329→            \"plan_id\": \"8001\",\n   330→            \"url\": \"https://github.com/test/repo/pull/8001\",\n   331→            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n   332→            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n   333→            \"labels\": [\"erk-plan\"],\n   334→            \"objective_id\": None,\n   335→        }\n   336→        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n   337→\n   338→        git = FakeGit(\n   339→            worktrees={\n   340→                repo_root: [\n   341→                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n   342→                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n   343→                ]\n   344→            },\n   345→            git_common_dirs={repo_root: repo_root / \".git\"},\n   346→        )\n   347→\n   348→        ctx = create_test_context(\n   349→            git=git,\n   350→            cwd=repo_root,\n   351→            repo=_make_repo_context(repo_root, tmp_path),\n   352→        )\n   353→\n   354→        location = GitHubRepoLocation(\n   355→            root=repo_root,\n   356→            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n   357→        )\n   358→        provider = RealPlanDataProvider(\n   359→            ctx=ctx,\n   360→            location=location,\n   361→            clipboard=FakeClipboard(),\n   362→            browser=FakeBrowserLauncher(),\n   363→            http_client=FakeHttpClient(),\n   364→        )\n   365→\n   366→        mapping = provider._build_worktree_mapping()\n   367→\n   368→        # Plan ID 8001 should be extracted from .impl/plan-ref.json\n   369→        assert 8001 in mapping\n   370→        worktree_name, worktree_branch = mapping[8001]\n   371→        assert worktree_name == \"erk-slot-03\"\n   372→        assert worktree_branch == branch_name\n   373→\n   374→    def test_planned_hyphen_branch_not_matched(self, tmp_path: Path) -> None:\n   375→        \"\"\"Branch with 'planned-' (hyphen) prefix is NOT matched.\n   376→\n   377→        Only 'planned/' (forward slash) is valid. This test ensures the\n   378→        startswith check uses the correct delimiter.\n   379→        \"\"\"\n   380→        repo_root = tmp_path / \"repo\"\n   381→        repo_root.mkdir()\n   382→\n   383→        erk_dir = repo_root / \".erk\"\n   384→        erk_dir.mkdir()\n   385→\n   386→        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-04\"\n   387→        worktree_path.mkdir(parents=True)\n   388→        branch_name = \"planned-fix-auth-bug-01-15-1430\"\n   389→\n   390→        # Create .impl/plan-ref.json — should NOT be read because prefix is wrong\n   391→        impl_dir = worktree_path / \".impl\"\n   392→        impl_dir.mkdir()\n   393→        plan_ref_data = {\n   394→            \"provider\": \"github-draft-pr\",\n   395→            \"plan_id\": \"9999\",\n   396→            \"url\": \"https://github.com/test/repo/pull/9999\",\n   397→            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n   398→            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n   399→            \"labels\": [\"erk-plan\"],\n   400→            \"objective_id\": None,\n   401→        }\n   402→        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n   403→\n   404→        git = FakeGit(\n   405→            worktrees={\n   406→                repo_root: [\n   407→                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n   408→                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n   409→                ]\n   410→            },\n   411→            git_common_dirs={repo_root: repo_root / \".git\"},\n   412→        )\n   413→\n   414→        ctx = create_test_context(\n   415→            git=git,\n   416→            cwd=repo_root,\n   417→            repo=_make_repo_context(repo_root, tmp_path),\n   418→        )\n   419→\n   420→        location = GitHubRepoLocation(\n   421→            root=repo_root,\n   422→            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n   423→        )\n   424→        provider = RealPlanDataProvider(\n   425→            ctx=ctx,\n   426→            location=location,\n   427→            clipboard=FakeClipboard(),\n   428→            browser=FakeBrowserLauncher(),\n   429→            http_client=FakeHttpClient(),\n   430→        )\n   431→\n   432→        mapping = provider._build_worktree_mapping()\n   433→\n   434→        # planned- (hyphen) should NOT be recognized — only planned/ (slash) is valid\n   435→        assert 9999 not in mapping\n   436→        assert len(mapping) == 0\n   437→\n   438→    def test_draft_pr_branch_without_plan_ref_not_in_mapping(self, tmp_path: Path) -> None:\n   439→        \"\"\"Draft PR branch without .impl/plan-ref.json is not in mapping.\"\"\"\n   440→        repo_root = tmp_path / \"repo\"\n   441→        repo_root.mkdir()\n   442→\n   443→        erk_dir = repo_root / \".erk\"\n   444→        erk_dir.mkdir()\n   445→\n   446→        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n   447→        worktree_path.mkdir(parents=True)\n   448→        branch_name = \"planned/fix-something-02-19-1416\"\n   449→\n   450→        # No .impl/plan-ref.json created\n   451→\n   452→        git = FakeGit(\n   453→            worktrees={\n   454→                repo_root: [\n   455→                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n   456→                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n   457→                ]\n   458→            },\n   459→            git_common_dirs={repo_root: repo_root / \".git\"},\n   460→        )\n   461→\n   462→        ctx = create_test_context(\n   463→            git=git,\n   464→            cwd=repo_root,\n   465→            repo=_make_repo_context(repo_root, tmp_path),\n   466→        )\n   467→\n   468→        location = GitHubRepoLocation(\n   469→            root=repo_root,\n   470→            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n   471→        )\n   472→        provider = RealPlanDataProvider(\n   473→            ctx=ctx,\n   474→            location=location,\n   475→            clipboard=FakeClipboard(),\n   476→            browser=FakeBrowserLauncher(),\n   477→            http_client=FakeHttpClient(),\n   478→        )\n   479→\n   480→        mapping = provider._build_worktree_mapping()\n   481→\n   482→        # No plan-ref.json, so planned/* branch should not produce an entry\n   483→        assert len(mapping) == 0\n   484→\n   485→\n   486→class TestClosePlan:\n   487→    \"\"\"Tests for close_plan method using HTTP client.\"\"\"\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"988cdf9b-4db5-4691-bec8-de17a4c93845","timestamp":"2026-02-22T14:49:12.668Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","content":"    def test_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch with planned/ prefix resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\n        numeric issue prefix. The plan ID comes from .impl/plan-ref.json.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-03\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"8001\",\n            \"url\": \"https://github.com/test/repo/pull/8001\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 8001 should be extracted from .impl/plan-ref.json\n        assert 8001 in mapping\n        worktree_name, worktree_branch = mapping[8001]\n        assert worktree_name == \"erk-slot-03\"\n        assert worktree_branch == branch_name\n\n    def test_planned_hyphen_branch_not_matched(self, tmp_path: Path) -> None:\n        \"\"\"Branch with 'planned-' (hyphen) prefix is NOT matched.\n\n        Only 'planned/' (forward slash) is valid. This test ensures the\n        startswith check uses the correct delimiter.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-04\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned-fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json — should NOT be read because prefix is wrong\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"9999\",\n            \"url\": \"https://github.com/test/repo/pull/9999\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # planned- (hyphen) should NOT be recognized — only planned/ (slash) is valid\n        assert 9999 not in mapping\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_without_plan_ref_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch without .impl/plan-ref.json is not in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-something-02-19-1416\"\n\n        # No .impl/plan-ref.json created\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # No plan-ref.json, so planned/* branch should not produce an entry\n        assert len(mapping) == 0\n\n\nclass TestClosePlan:\n    \"\"\"Tests for close_plan method using HTTP client.\"\"\"","numLines":180,"startLine":308,"totalLines":1392}}}
{"parentUuid":"988cdf9b-4db5-4691-bec8-de17a4c93845","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_015eMtk3zjfvBun211LtYM5v","type":"message","role":"assistant","content":[{"type":"text","text":"For these TUI tests, I need to update the first test to use `plnd/` (it's testing the current/new behavior), keep the second test with `planned/` as a legacy backward-compat test, keep the `planned-` hyphen test as-is (negative test), and update the no-plan-ref test to `plnd/`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2715,"cache_read_input_tokens":113067,"cache_creation":{"ephemeral_5m_input_tokens":2715,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHvd7u6fUYSRdvxc7mE","type":"assistant","uuid":"bc4bb49c-8c2a-449f-84b3-ab3b851401ad","timestamp":"2026-02-22T14:49:17.285Z"}
{"parentUuid":"bc4bb49c-8c2a-449f-84b3-ab3b851401ad","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_015eMtk3zjfvBun211LtYM5v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013ddwt9RHsYikFfRYNXzp6g","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","old_string":"    def test_draft_pr_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch (planned/*) resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-missing-data-02-19-1416' doesn't contain a\n        numeric issue prefix. The plan ID (PR number) comes from\n        .impl/plan-ref.json inside the worktree directory.\n        \"\"\"","new_string":"    def test_draft_pr_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch (plnd/*) resolved via .impl/plan-ref.json.\n\n        Branch name 'plnd/fix-missing-data-02-19-1416' doesn't contain a\n        numeric issue prefix. The plan ID (PR number) comes from\n        .impl/plan-ref.json inside the worktree directory.\n        \"\"\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2715,"cache_read_input_tokens":113067,"cache_creation":{"ephemeral_5m_input_tokens":2715,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHvd7u6fUYSRdvxc7mE","type":"assistant","uuid":"8a802a73-bcd5-4b77-9f74-2cef269832e5","timestamp":"2026-02-22T14:49:19.894Z"}
{"parentUuid":"8a802a73-bcd5-4b77-9f74-2cef269832e5","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013ddwt9RHsYikFfRYNXzp6g","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/tui/data/test_provider.py has been updated successfully."}]},"uuid":"9d80e725-ee87-40be-b819-20e7f0d200ee","timestamp":"2026-02-22T14:49:20.571Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","oldString":"    def test_draft_pr_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch (planned/*) resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-missing-data-02-19-1416' doesn't contain a\n        numeric issue prefix. The plan ID (PR number) comes from\n        .impl/plan-ref.json inside the worktree directory.\n        \"\"\"","newString":"    def test_draft_pr_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch (plnd/*) resolved via .impl/plan-ref.json.\n\n        Branch name 'plnd/fix-missing-data-02-19-1416' doesn't contain a\n        numeric issue prefix. The plan ID (PR number) comes from\n        .impl/plan-ref.json inside the worktree directory.\n        \"\"\"","originalFile":"\"\"\"Tests for plan data provider.\"\"\"\n\nimport json\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nfrom erk.core.repo_discovery import RepoContext\nfrom erk_shared.gateway.browser.fake import FakeBrowserLauncher\nfrom erk_shared.gateway.clipboard.fake import FakeClipboard\nfrom erk_shared.gateway.git.abc import WorktreeInfo\nfrom erk_shared.gateway.git.fake import FakeGit\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.metadata.core import find_metadata_block\nfrom erk_shared.gateway.github.types import (\n    GitHubRepoId,\n    GitHubRepoLocation,\n    PullRequestInfo,\n)\nfrom erk_shared.gateway.http.fake import FakeHttpClient\nfrom erk_shared.gateway.plan_data_provider.real import RealPlanDataProvider\nfrom erk_shared.plan_store.types import Plan, PlanState\nfrom tests.fakes.context import create_test_context\nfrom tests.test_utils.plan_helpers import format_plan_header_body_for_test\n\n\ndef _parse_header_fields(body: str) -> dict[str, object]:\n    \"\"\"Parse header_fields from a plan body for test Plan construction.\"\"\"\n    block = find_metadata_block(body, \"plan-header\")\n    if block is None:\n        return {}\n    return dict(block.data)\n\n\ndef _make_repo_context(repo_root: Path, tmp_path: Path) -> RepoContext:\n    \"\"\"Create a RepoContext for testing.\"\"\"\n    erk_dir = tmp_path / \".erk\"\n    repo_dir = erk_dir / \"repos\" / \"test-repo\"\n    return RepoContext(\n        root=repo_root,\n        repo_name=\"test-repo\",\n        repo_dir=repo_dir,\n        worktrees_dir=repo_dir / \"worktrees\",\n        pool_json_path=repo_dir / \"pool.json\",\n    )\n\n\nclass TestBuildWorktreeMapping:\n    \"\"\"Tests for _build_worktree_mapping method.\"\"\"\n\n    def test_pool_managed_worktree_extracts_from_branch_name(self, tmp_path: Path) -> None:\n        \"\"\"Pool-managed worktree with generic directory name maps via branch.\n\n        The directory name is 'erk-slot-02' (no issue prefix),\n        but the branch name is 'P4280-add-required-kwargs-01-05-2230',\n        so issue 4280 should be extracted from the branch.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        # Create .erk directory to satisfy _ensure_erk_metadata_dir_from_context\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-02\"\n        branch_name = \"P4280-add-required-kwargs-01-05-2230\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Issue 4280 should be extracted from the branch name\n        assert 4280 in mapping\n        worktree_name, worktree_branch = mapping[4280]\n        assert worktree_name == \"erk-slot-02\"\n        assert worktree_branch == branch_name\n\n    def test_issue_named_worktree_extracts_from_branch_name(self, tmp_path: Path) -> None:\n        \"\"\"Issue-named worktree with P-prefixed directory also extracts from branch.\n\n        The directory name is 'P1234-feature-01-01-1200' (has issue prefix),\n        and the branch name matches. Issue 1234 should be extracted from branch.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"P1234-feature-01-01-1200\"\n        branch_name = \"P1234-feature-01-01-1200\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Issue 1234 should be extracted from the branch name\n        assert 1234 in mapping\n        worktree_name, worktree_branch = mapping[1234]\n        assert worktree_name == \"P1234-feature-01-01-1200\"\n        assert worktree_branch == branch_name\n\n    def test_detached_head_worktree_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Worktree with detached HEAD (branch=None) should not be in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        # Detached HEAD worktree has branch=None\n        worktree_path = tmp_path / \"worktrees\" / \"detached-wt\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=None, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Detached HEAD should not produce an entry in mapping\n        assert len(mapping) == 0\n\n    def test_non_plan_branch_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Worktree with non-P-prefixed branch should not be in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"feature-branch\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=\"feature-branch\", is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Non-plan branch should not produce an entry\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch (planned/*) resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-missing-data-02-19-1416' doesn't contain a\n        numeric issue prefix. The plan ID (PR number) comes from\n        .impl/plan-ref.json inside the worktree directory.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-missing-data-02-19-1416\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"7624\",\n            \"url\": \"https://github.com/test/repo/pull/7624\",\n            \"created_at\": \"2026-02-19T14:16:00+00:00\",\n            \"synced_at\": \"2026-02-19T14:16:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 7624 should be extracted from .impl/plan-ref.json\n        assert 7624 in mapping\n        worktree_name, worktree_branch = mapping[7624]\n        assert worktree_name == \"erk-slot-05\"\n        assert worktree_branch == branch_name\n\n    def test_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch with planned/ prefix resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\n        numeric issue prefix. The plan ID comes from .impl/plan-ref.json.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-03\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"8001\",\n            \"url\": \"https://github.com/test/repo/pull/8001\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 8001 should be extracted from .impl/plan-ref.json\n        assert 8001 in mapping\n        worktree_name, worktree_branch = mapping[8001]\n        assert worktree_name == \"erk-slot-03\"\n        assert worktree_branch == branch_name\n\n    def test_planned_hyphen_branch_not_matched(self, tmp_path: Path) -> None:\n        \"\"\"Branch with 'planned-' (hyphen) prefix is NOT matched.\n\n        Only 'planned/' (forward slash) is valid. This test ensures the\n        startswith check uses the correct delimiter.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-04\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned-fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json — should NOT be read because prefix is wrong\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"9999\",\n            \"url\": \"https://github.com/test/repo/pull/9999\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # planned- (hyphen) should NOT be recognized — only planned/ (slash) is valid\n        assert 9999 not in mapping\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_without_plan_ref_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch without .impl/plan-ref.json is not in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-something-02-19-1416\"\n\n        # No .impl/plan-ref.json created\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # No plan-ref.json, so planned/* branch should not produce an entry\n        assert len(mapping) == 0\n\n\nclass TestClosePlan:\n    \"\"\"Tests for close_plan method using HTTP client.\"\"\"\n\n    def test_close_plan_uses_http_client(self, tmp_path: Path) -> None:\n        \"\"\"close_plan should use HTTP client to close issue via API.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        # Configure fake GitHub to return empty PR linkages\n        from erk_shared.gateway.github.fake import FakeGitHub\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        http_client = FakeHttpClient()\n        http_client.set_response(\n            \"repos/test/repo/issues/123\",\n            response={\"state\": \"closed\"},\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=http_client,\n        )\n\n        closed_prs = provider.close_plan(123, \"https://github.com/test/repo/issues/123\")\n\n        # Verify HTTP client was used to close the issue\n        assert len(http_client.requests) == 1\n        request = http_client.requests[0]\n        assert request.method == \"PATCH\"\n        assert request.endpoint == \"repos/test/repo/issues/123\"\n        assert request.data == {\"state\": \"closed\"}\n        assert closed_prs == []\n\n    def test_close_plan_closes_linked_prs(self, tmp_path: Path) -> None:\n        \"\"\"close_plan should close linked PRs before closing issue.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        # Configure fake GitHub to return linked PRs\n        from erk_shared.gateway.github.fake import FakeGitHub\n        from erk_shared.gateway.github.types import PullRequestInfo\n\n        github = FakeGitHub(\n            pr_issue_linkages={\n                123: [\n                    PullRequestInfo(\n                        number=456,\n                        state=\"OPEN\",\n                        url=\"https://github.com/test/repo/pulls/456\",\n                        is_draft=False,\n                        title=\"Fix issue\",\n                        checks_passing=None,\n                        owner=\"test\",\n                        repo=\"repo\",\n                    ),\n                ],\n            }\n        )\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        http_client = FakeHttpClient()\n        http_client.set_response(\n            \"repos/test/repo/pulls/456\",\n            response={\"state\": \"closed\"},\n        )\n        http_client.set_response(\n            \"repos/test/repo/issues/123\",\n            response={\"state\": \"closed\"},\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=http_client,\n        )\n\n        closed_prs = provider.close_plan(123, \"https://github.com/test/repo/issues/123\")\n\n        # Verify HTTP client was used to close PR first, then issue\n        assert len(http_client.requests) == 2\n        assert http_client.requests[0].endpoint == \"repos/test/repo/pulls/456\"\n        assert http_client.requests[1].endpoint == \"repos/test/repo/issues/123\"\n        assert closed_prs == [456]\n\n    def test_parse_owner_repo_from_url(self, tmp_path: Path) -> None:\n        \"\"\"_parse_owner_repo_from_url should extract owner/repo from URL.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        result = provider._parse_owner_repo_from_url(\"https://github.com/owner/repo/issues/123\")\n        assert result == (\"owner\", \"repo\")\n\n        result = provider._parse_owner_repo_from_url(\"https://github.com/anthropic/erk/pulls/456\")\n        assert result == (\"anthropic\", \"erk\")\n\n        # Invalid URL returns None\n        result = provider._parse_owner_repo_from_url(\"invalid\")\n        assert result is None\n\n\nclass TestCommentCountsDisplay:\n    \"\"\"Tests for review comment counts display in _build_row_data.\n\n    Comment counts are now fetched via the batched PR linkages GraphQL query\n    and stored in PullRequestInfo.review_thread_counts as (resolved, total).\n    \"\"\"\n\n    def test_comment_counts_from_pr_data(self, tmp_path: Path) -> None:\n        \"\"\"When PR has review_thread_counts, display as resolved/total.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan and PR linkage with comment counts\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages = {\n            123: [\n                PullRequestInfo(\n                    number=456,\n                    state=\"OPEN\",\n                    url=\"https://github.com/test/repo/pulls/456\",\n                    is_draft=False,\n                    title=\"Fix issue\",\n                    checks_passing=True,\n                    owner=\"test\",\n                    repo=\"repo\",\n                    review_thread_counts=(3, 5),  # 3 resolved out of 5 total\n                ),\n            ],\n        }\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 3\n        assert row.total_comment_count == 5\n        assert row.comments_display == \"3/5\"\n\n    def test_comment_counts_none_shows_zero(self, tmp_path: Path) -> None:\n        \"\"\"When PR has no review_thread_counts (None), display 0/0.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan and PR linkage without comment counts\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages = {\n            123: [\n                PullRequestInfo(\n                    number=456,\n                    state=\"OPEN\",\n                    url=\"https://github.com/test/repo/pulls/456\",\n                    is_draft=False,\n                    title=\"Fix issue\",\n                    checks_passing=True,\n                    owner=\"test\",\n                    repo=\"repo\",\n                    # review_thread_counts defaults to None\n                ),\n            ],\n        }\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 0\n        assert row.total_comment_count == 0\n        assert row.comments_display == \"0/0\"\n\n    def test_no_pr_shows_dash(self, tmp_path: Path) -> None:\n        \"\"\"When plan has no linked PR, display '-' for comments.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan without PR linkage\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages: dict[int, list[PullRequestInfo]] = {}  # No linked PRs\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 0\n        assert row.total_comment_count == 0\n        assert row.comments_display == \"-\"\n\n\nclass TestLearnStatusDisplay:\n    \"\"\"Tests for learn status display in _build_row_data.\"\"\"\n\n    def test_learn_status_none_shows_dash(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is None, display '-'.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan without learn_status metadata\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",  # No metadata block\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status is None\n        assert row.learn_plan_issue is None\n        assert row.learn_plan_pr is None\n        assert row.learn_display == \"- not started\"\n\n    def test_learn_status_pending_shows_spinner(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'pending', display spinner symbol.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: pending in metadata\n        plan_body = format_plan_header_body_for_test(learn_status=\"pending\")\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"pending\"\n        assert row.learn_display == \"⟳ in progress\"\n\n    def test_learn_status_completed_no_plan_shows_empty_set(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'completed_no_plan', display empty set symbol.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_no_plan\n        plan_body = format_plan_header_body_for_test(learn_status=\"completed_no_plan\")\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"completed_no_plan\"\n        assert row.learn_display == \"∅ no insights\"\n\n    def test_learn_status_completed_with_plan_shows_issue_number(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'completed_with_plan', display issue number.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is None\n        assert row.learn_display == \"📋 #456\"\n\n    def test_learn_status_plan_completed_shows_pr_number(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'plan_completed', display checkmark and PR number.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: plan_completed and learn_plan_pr\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"plan_completed\", learn_plan_issue=456, learn_plan_pr=789\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"plan_completed\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_pr == 789\n        assert row.learn_display == \"✓ #789\"\n\n    def test_learn_status_completed_with_plan_closed_shows_checkmark(self, tmp_path: Path) -> None:\n        \"\"\"When learn plan issue is closed, display checkmark instead of clipboard.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime(2024, 1, 1, tzinfo=UTC),\n            updated_at=datetime(2024, 1, 1, tzinfo=UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        # Learn issue 456 is closed\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={456: True},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is True\n        assert row.learn_display == \"✅ #456\"\n        assert row.learn_display_icon == \"✅ #456\"\n\n    def test_learn_status_completed_with_plan_open_shows_clipboard(self, tmp_path: Path) -> None:\n        \"\"\"When learn plan issue is open, display clipboard emoji.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime(2024, 1, 1, tzinfo=UTC),\n            updated_at=datetime(2024, 1, 1, tzinfo=UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        # Learn issue 456 is open\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={456: False},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is False\n        assert row.learn_display == \"📋 #456\"\n        assert row.learn_display_icon == \"📋 #456\"\n","structuredPatch":[{"oldStart":239,"oldLines":9,"newStart":239,"newLines":9,"lines":["         assert len(mapping) == 0"," ","     def test_draft_pr_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:","-        \"\"\"Draft PR branch (planned/*) resolved via .impl/plan-ref.json.","+        \"\"\"Draft PR branch (plnd/*) resolved via .impl/plan-ref.json."," ","-        Branch name 'planned/fix-missing-data-02-19-1416' doesn't contain a","+        Branch name 'plnd/fix-missing-data-02-19-1416' doesn't contain a","         numeric issue prefix. The plan ID (PR number) comes from","         .impl/plan-ref.json inside the worktree directory.","         \"\"\""]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"9d80e725-ee87-40be-b819-20e7f0d200ee","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_015agabVszJLCxGYUBoTCdqD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NN7QcpMmMSGtSErASH5AUU","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","old_string":"        branch_name = \"planned/fix-missing-data-02-19-1416\"","new_string":"        branch_name = \"plnd/fix-missing-data-02-19-1416\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":800,"cache_read_input_tokens":115782,"cache_creation":{"ephemeral_5m_input_tokens":800,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHwCx827WHdjatwgM4q","type":"assistant","uuid":"088374c4-07c2-46c7-a869-0d905f5076c8","timestamp":"2026-02-22T14:49:23.780Z"}
{"parentUuid":"088374c4-07c2-46c7-a869-0d905f5076c8","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NN7QcpMmMSGtSErASH5AUU","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/tui/data/test_provider.py has been updated successfully."}]},"uuid":"02cfabaa-2549-41f8-95ed-fd1f87269005","timestamp":"2026-02-22T14:49:24.444Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","oldString":"        branch_name = \"planned/fix-missing-data-02-19-1416\"","newString":"        branch_name = \"plnd/fix-missing-data-02-19-1416\"","originalFile":"\"\"\"Tests for plan data provider.\"\"\"\n\nimport json\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nfrom erk.core.repo_discovery import RepoContext\nfrom erk_shared.gateway.browser.fake import FakeBrowserLauncher\nfrom erk_shared.gateway.clipboard.fake import FakeClipboard\nfrom erk_shared.gateway.git.abc import WorktreeInfo\nfrom erk_shared.gateway.git.fake import FakeGit\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.metadata.core import find_metadata_block\nfrom erk_shared.gateway.github.types import (\n    GitHubRepoId,\n    GitHubRepoLocation,\n    PullRequestInfo,\n)\nfrom erk_shared.gateway.http.fake import FakeHttpClient\nfrom erk_shared.gateway.plan_data_provider.real import RealPlanDataProvider\nfrom erk_shared.plan_store.types import Plan, PlanState\nfrom tests.fakes.context import create_test_context\nfrom tests.test_utils.plan_helpers import format_plan_header_body_for_test\n\n\ndef _parse_header_fields(body: str) -> dict[str, object]:\n    \"\"\"Parse header_fields from a plan body for test Plan construction.\"\"\"\n    block = find_metadata_block(body, \"plan-header\")\n    if block is None:\n        return {}\n    return dict(block.data)\n\n\ndef _make_repo_context(repo_root: Path, tmp_path: Path) -> RepoContext:\n    \"\"\"Create a RepoContext for testing.\"\"\"\n    erk_dir = tmp_path / \".erk\"\n    repo_dir = erk_dir / \"repos\" / \"test-repo\"\n    return RepoContext(\n        root=repo_root,\n        repo_name=\"test-repo\",\n        repo_dir=repo_dir,\n        worktrees_dir=repo_dir / \"worktrees\",\n        pool_json_path=repo_dir / \"pool.json\",\n    )\n\n\nclass TestBuildWorktreeMapping:\n    \"\"\"Tests for _build_worktree_mapping method.\"\"\"\n\n    def test_pool_managed_worktree_extracts_from_branch_name(self, tmp_path: Path) -> None:\n        \"\"\"Pool-managed worktree with generic directory name maps via branch.\n\n        The directory name is 'erk-slot-02' (no issue prefix),\n        but the branch name is 'P4280-add-required-kwargs-01-05-2230',\n        so issue 4280 should be extracted from the branch.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        # Create .erk directory to satisfy _ensure_erk_metadata_dir_from_context\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-02\"\n        branch_name = \"P4280-add-required-kwargs-01-05-2230\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Issue 4280 should be extracted from the branch name\n        assert 4280 in mapping\n        worktree_name, worktree_branch = mapping[4280]\n        assert worktree_name == \"erk-slot-02\"\n        assert worktree_branch == branch_name\n\n    def test_issue_named_worktree_extracts_from_branch_name(self, tmp_path: Path) -> None:\n        \"\"\"Issue-named worktree with P-prefixed directory also extracts from branch.\n\n        The directory name is 'P1234-feature-01-01-1200' (has issue prefix),\n        and the branch name matches. Issue 1234 should be extracted from branch.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"P1234-feature-01-01-1200\"\n        branch_name = \"P1234-feature-01-01-1200\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Issue 1234 should be extracted from the branch name\n        assert 1234 in mapping\n        worktree_name, worktree_branch = mapping[1234]\n        assert worktree_name == \"P1234-feature-01-01-1200\"\n        assert worktree_branch == branch_name\n\n    def test_detached_head_worktree_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Worktree with detached HEAD (branch=None) should not be in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        # Detached HEAD worktree has branch=None\n        worktree_path = tmp_path / \"worktrees\" / \"detached-wt\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=None, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Detached HEAD should not produce an entry in mapping\n        assert len(mapping) == 0\n\n    def test_non_plan_branch_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Worktree with non-P-prefixed branch should not be in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"feature-branch\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=\"feature-branch\", is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Non-plan branch should not produce an entry\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch (plnd/*) resolved via .impl/plan-ref.json.\n\n        Branch name 'plnd/fix-missing-data-02-19-1416' doesn't contain a\n        numeric issue prefix. The plan ID (PR number) comes from\n        .impl/plan-ref.json inside the worktree directory.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-missing-data-02-19-1416\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"7624\",\n            \"url\": \"https://github.com/test/repo/pull/7624\",\n            \"created_at\": \"2026-02-19T14:16:00+00:00\",\n            \"synced_at\": \"2026-02-19T14:16:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 7624 should be extracted from .impl/plan-ref.json\n        assert 7624 in mapping\n        worktree_name, worktree_branch = mapping[7624]\n        assert worktree_name == \"erk-slot-05\"\n        assert worktree_branch == branch_name\n\n    def test_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch with planned/ prefix resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\n        numeric issue prefix. The plan ID comes from .impl/plan-ref.json.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-03\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"8001\",\n            \"url\": \"https://github.com/test/repo/pull/8001\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 8001 should be extracted from .impl/plan-ref.json\n        assert 8001 in mapping\n        worktree_name, worktree_branch = mapping[8001]\n        assert worktree_name == \"erk-slot-03\"\n        assert worktree_branch == branch_name\n\n    def test_planned_hyphen_branch_not_matched(self, tmp_path: Path) -> None:\n        \"\"\"Branch with 'planned-' (hyphen) prefix is NOT matched.\n\n        Only 'planned/' (forward slash) is valid. This test ensures the\n        startswith check uses the correct delimiter.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-04\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned-fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json — should NOT be read because prefix is wrong\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"9999\",\n            \"url\": \"https://github.com/test/repo/pull/9999\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # planned- (hyphen) should NOT be recognized — only planned/ (slash) is valid\n        assert 9999 not in mapping\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_without_plan_ref_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch without .impl/plan-ref.json is not in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-something-02-19-1416\"\n\n        # No .impl/plan-ref.json created\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # No plan-ref.json, so planned/* branch should not produce an entry\n        assert len(mapping) == 0\n\n\nclass TestClosePlan:\n    \"\"\"Tests for close_plan method using HTTP client.\"\"\"\n\n    def test_close_plan_uses_http_client(self, tmp_path: Path) -> None:\n        \"\"\"close_plan should use HTTP client to close issue via API.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        # Configure fake GitHub to return empty PR linkages\n        from erk_shared.gateway.github.fake import FakeGitHub\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        http_client = FakeHttpClient()\n        http_client.set_response(\n            \"repos/test/repo/issues/123\",\n            response={\"state\": \"closed\"},\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=http_client,\n        )\n\n        closed_prs = provider.close_plan(123, \"https://github.com/test/repo/issues/123\")\n\n        # Verify HTTP client was used to close the issue\n        assert len(http_client.requests) == 1\n        request = http_client.requests[0]\n        assert request.method == \"PATCH\"\n        assert request.endpoint == \"repos/test/repo/issues/123\"\n        assert request.data == {\"state\": \"closed\"}\n        assert closed_prs == []\n\n    def test_close_plan_closes_linked_prs(self, tmp_path: Path) -> None:\n        \"\"\"close_plan should close linked PRs before closing issue.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        # Configure fake GitHub to return linked PRs\n        from erk_shared.gateway.github.fake import FakeGitHub\n        from erk_shared.gateway.github.types import PullRequestInfo\n\n        github = FakeGitHub(\n            pr_issue_linkages={\n                123: [\n                    PullRequestInfo(\n                        number=456,\n                        state=\"OPEN\",\n                        url=\"https://github.com/test/repo/pulls/456\",\n                        is_draft=False,\n                        title=\"Fix issue\",\n                        checks_passing=None,\n                        owner=\"test\",\n                        repo=\"repo\",\n                    ),\n                ],\n            }\n        )\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        http_client = FakeHttpClient()\n        http_client.set_response(\n            \"repos/test/repo/pulls/456\",\n            response={\"state\": \"closed\"},\n        )\n        http_client.set_response(\n            \"repos/test/repo/issues/123\",\n            response={\"state\": \"closed\"},\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=http_client,\n        )\n\n        closed_prs = provider.close_plan(123, \"https://github.com/test/repo/issues/123\")\n\n        # Verify HTTP client was used to close PR first, then issue\n        assert len(http_client.requests) == 2\n        assert http_client.requests[0].endpoint == \"repos/test/repo/pulls/456\"\n        assert http_client.requests[1].endpoint == \"repos/test/repo/issues/123\"\n        assert closed_prs == [456]\n\n    def test_parse_owner_repo_from_url(self, tmp_path: Path) -> None:\n        \"\"\"_parse_owner_repo_from_url should extract owner/repo from URL.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        result = provider._parse_owner_repo_from_url(\"https://github.com/owner/repo/issues/123\")\n        assert result == (\"owner\", \"repo\")\n\n        result = provider._parse_owner_repo_from_url(\"https://github.com/anthropic/erk/pulls/456\")\n        assert result == (\"anthropic\", \"erk\")\n\n        # Invalid URL returns None\n        result = provider._parse_owner_repo_from_url(\"invalid\")\n        assert result is None\n\n\nclass TestCommentCountsDisplay:\n    \"\"\"Tests for review comment counts display in _build_row_data.\n\n    Comment counts are now fetched via the batched PR linkages GraphQL query\n    and stored in PullRequestInfo.review_thread_counts as (resolved, total).\n    \"\"\"\n\n    def test_comment_counts_from_pr_data(self, tmp_path: Path) -> None:\n        \"\"\"When PR has review_thread_counts, display as resolved/total.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan and PR linkage with comment counts\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages = {\n            123: [\n                PullRequestInfo(\n                    number=456,\n                    state=\"OPEN\",\n                    url=\"https://github.com/test/repo/pulls/456\",\n                    is_draft=False,\n                    title=\"Fix issue\",\n                    checks_passing=True,\n                    owner=\"test\",\n                    repo=\"repo\",\n                    review_thread_counts=(3, 5),  # 3 resolved out of 5 total\n                ),\n            ],\n        }\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 3\n        assert row.total_comment_count == 5\n        assert row.comments_display == \"3/5\"\n\n    def test_comment_counts_none_shows_zero(self, tmp_path: Path) -> None:\n        \"\"\"When PR has no review_thread_counts (None), display 0/0.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan and PR linkage without comment counts\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages = {\n            123: [\n                PullRequestInfo(\n                    number=456,\n                    state=\"OPEN\",\n                    url=\"https://github.com/test/repo/pulls/456\",\n                    is_draft=False,\n                    title=\"Fix issue\",\n                    checks_passing=True,\n                    owner=\"test\",\n                    repo=\"repo\",\n                    # review_thread_counts defaults to None\n                ),\n            ],\n        }\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 0\n        assert row.total_comment_count == 0\n        assert row.comments_display == \"0/0\"\n\n    def test_no_pr_shows_dash(self, tmp_path: Path) -> None:\n        \"\"\"When plan has no linked PR, display '-' for comments.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan without PR linkage\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages: dict[int, list[PullRequestInfo]] = {}  # No linked PRs\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 0\n        assert row.total_comment_count == 0\n        assert row.comments_display == \"-\"\n\n\nclass TestLearnStatusDisplay:\n    \"\"\"Tests for learn status display in _build_row_data.\"\"\"\n\n    def test_learn_status_none_shows_dash(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is None, display '-'.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan without learn_status metadata\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",  # No metadata block\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status is None\n        assert row.learn_plan_issue is None\n        assert row.learn_plan_pr is None\n        assert row.learn_display == \"- not started\"\n\n    def test_learn_status_pending_shows_spinner(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'pending', display spinner symbol.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: pending in metadata\n        plan_body = format_plan_header_body_for_test(learn_status=\"pending\")\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"pending\"\n        assert row.learn_display == \"⟳ in progress\"\n\n    def test_learn_status_completed_no_plan_shows_empty_set(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'completed_no_plan', display empty set symbol.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_no_plan\n        plan_body = format_plan_header_body_for_test(learn_status=\"completed_no_plan\")\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"completed_no_plan\"\n        assert row.learn_display == \"∅ no insights\"\n\n    def test_learn_status_completed_with_plan_shows_issue_number(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'completed_with_plan', display issue number.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is None\n        assert row.learn_display == \"📋 #456\"\n\n    def test_learn_status_plan_completed_shows_pr_number(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'plan_completed', display checkmark and PR number.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: plan_completed and learn_plan_pr\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"plan_completed\", learn_plan_issue=456, learn_plan_pr=789\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"plan_completed\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_pr == 789\n        assert row.learn_display == \"✓ #789\"\n\n    def test_learn_status_completed_with_plan_closed_shows_checkmark(self, tmp_path: Path) -> None:\n        \"\"\"When learn plan issue is closed, display checkmark instead of clipboard.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime(2024, 1, 1, tzinfo=UTC),\n            updated_at=datetime(2024, 1, 1, tzinfo=UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        # Learn issue 456 is closed\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={456: True},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is True\n        assert row.learn_display == \"✅ #456\"\n        assert row.learn_display_icon == \"✅ #456\"\n\n    def test_learn_status_completed_with_plan_open_shows_clipboard(self, tmp_path: Path) -> None:\n        \"\"\"When learn plan issue is open, display clipboard emoji.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime(2024, 1, 1, tzinfo=UTC),\n            updated_at=datetime(2024, 1, 1, tzinfo=UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        # Learn issue 456 is open\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={456: False},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is False\n        assert row.learn_display == \"📋 #456\"\n        assert row.learn_display_icon == \"📋 #456\"\n","structuredPatch":[{"oldStart":253,"oldLines":7,"newStart":253,"newLines":7,"lines":[" ","         worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"","         worktree_path.mkdir(parents=True)","-        branch_name = \"planned/fix-missing-data-02-19-1416\"","+        branch_name = \"plnd/fix-missing-data-02-19-1416\""," ","         # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)","         impl_dir = worktree_path / \".impl\""]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"02cfabaa-2549-41f8-95ed-fd1f87269005","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_0149ojCH8RPhUETnrwGxXEzh","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the second test (planned/ prefix with slash) - this one tests that `planned/` (the legacy prefix) still works via the fallback:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":199,"cache_read_input_tokens":116582,"cache_creation":{"ephemeral_5m_input_tokens":199,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHwVW2svxYiXDX83YCt","type":"assistant","uuid":"c091ddfa-a802-42fa-a0ee-8c9a6387c869","timestamp":"2026-02-22T14:49:27.639Z"}
{"parentUuid":"c091ddfa-a802-42fa-a0ee-8c9a6387c869","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_0149ojCH8RPhUETnrwGxXEzh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HSn9frJn3E5qYUsupHqACk","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","old_string":"    def test_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch with planned/ prefix resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\n        numeric issue prefix. The plan ID comes from .impl/plan-ref.json.\n        \"\"\"","new_string":"    def test_legacy_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Legacy planned/ prefix branch resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\n        numeric issue prefix. The plan ID comes from .impl/plan-ref.json.\n        \"\"\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":199,"cache_read_input_tokens":116582,"cache_creation":{"ephemeral_5m_input_tokens":199,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHwVW2svxYiXDX83YCt","type":"assistant","uuid":"681d721f-bb95-4f31-87e3-8ad46c068216","timestamp":"2026-02-22T14:49:29.959Z"}
{"parentUuid":"681d721f-bb95-4f31-87e3-8ad46c068216","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HSn9frJn3E5qYUsupHqACk","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/tui/data/test_provider.py has been updated successfully."}]},"uuid":"871bfceb-5b76-46f5-b30e-cfc361efe263","timestamp":"2026-02-22T14:49:30.650Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","oldString":"    def test_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch with planned/ prefix resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\n        numeric issue prefix. The plan ID comes from .impl/plan-ref.json.\n        \"\"\"","newString":"    def test_legacy_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Legacy planned/ prefix branch resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\n        numeric issue prefix. The plan ID comes from .impl/plan-ref.json.\n        \"\"\"","originalFile":"\"\"\"Tests for plan data provider.\"\"\"\n\nimport json\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nfrom erk.core.repo_discovery import RepoContext\nfrom erk_shared.gateway.browser.fake import FakeBrowserLauncher\nfrom erk_shared.gateway.clipboard.fake import FakeClipboard\nfrom erk_shared.gateway.git.abc import WorktreeInfo\nfrom erk_shared.gateway.git.fake import FakeGit\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.metadata.core import find_metadata_block\nfrom erk_shared.gateway.github.types import (\n    GitHubRepoId,\n    GitHubRepoLocation,\n    PullRequestInfo,\n)\nfrom erk_shared.gateway.http.fake import FakeHttpClient\nfrom erk_shared.gateway.plan_data_provider.real import RealPlanDataProvider\nfrom erk_shared.plan_store.types import Plan, PlanState\nfrom tests.fakes.context import create_test_context\nfrom tests.test_utils.plan_helpers import format_plan_header_body_for_test\n\n\ndef _parse_header_fields(body: str) -> dict[str, object]:\n    \"\"\"Parse header_fields from a plan body for test Plan construction.\"\"\"\n    block = find_metadata_block(body, \"plan-header\")\n    if block is None:\n        return {}\n    return dict(block.data)\n\n\ndef _make_repo_context(repo_root: Path, tmp_path: Path) -> RepoContext:\n    \"\"\"Create a RepoContext for testing.\"\"\"\n    erk_dir = tmp_path / \".erk\"\n    repo_dir = erk_dir / \"repos\" / \"test-repo\"\n    return RepoContext(\n        root=repo_root,\n        repo_name=\"test-repo\",\n        repo_dir=repo_dir,\n        worktrees_dir=repo_dir / \"worktrees\",\n        pool_json_path=repo_dir / \"pool.json\",\n    )\n\n\nclass TestBuildWorktreeMapping:\n    \"\"\"Tests for _build_worktree_mapping method.\"\"\"\n\n    def test_pool_managed_worktree_extracts_from_branch_name(self, tmp_path: Path) -> None:\n        \"\"\"Pool-managed worktree with generic directory name maps via branch.\n\n        The directory name is 'erk-slot-02' (no issue prefix),\n        but the branch name is 'P4280-add-required-kwargs-01-05-2230',\n        so issue 4280 should be extracted from the branch.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        # Create .erk directory to satisfy _ensure_erk_metadata_dir_from_context\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-02\"\n        branch_name = \"P4280-add-required-kwargs-01-05-2230\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Issue 4280 should be extracted from the branch name\n        assert 4280 in mapping\n        worktree_name, worktree_branch = mapping[4280]\n        assert worktree_name == \"erk-slot-02\"\n        assert worktree_branch == branch_name\n\n    def test_issue_named_worktree_extracts_from_branch_name(self, tmp_path: Path) -> None:\n        \"\"\"Issue-named worktree with P-prefixed directory also extracts from branch.\n\n        The directory name is 'P1234-feature-01-01-1200' (has issue prefix),\n        and the branch name matches. Issue 1234 should be extracted from branch.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"P1234-feature-01-01-1200\"\n        branch_name = \"P1234-feature-01-01-1200\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Issue 1234 should be extracted from the branch name\n        assert 1234 in mapping\n        worktree_name, worktree_branch = mapping[1234]\n        assert worktree_name == \"P1234-feature-01-01-1200\"\n        assert worktree_branch == branch_name\n\n    def test_detached_head_worktree_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Worktree with detached HEAD (branch=None) should not be in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        # Detached HEAD worktree has branch=None\n        worktree_path = tmp_path / \"worktrees\" / \"detached-wt\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=None, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Detached HEAD should not produce an entry in mapping\n        assert len(mapping) == 0\n\n    def test_non_plan_branch_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Worktree with non-P-prefixed branch should not be in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"feature-branch\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=\"feature-branch\", is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Non-plan branch should not produce an entry\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch (plnd/*) resolved via .impl/plan-ref.json.\n\n        Branch name 'plnd/fix-missing-data-02-19-1416' doesn't contain a\n        numeric issue prefix. The plan ID (PR number) comes from\n        .impl/plan-ref.json inside the worktree directory.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"plnd/fix-missing-data-02-19-1416\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"7624\",\n            \"url\": \"https://github.com/test/repo/pull/7624\",\n            \"created_at\": \"2026-02-19T14:16:00+00:00\",\n            \"synced_at\": \"2026-02-19T14:16:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 7624 should be extracted from .impl/plan-ref.json\n        assert 7624 in mapping\n        worktree_name, worktree_branch = mapping[7624]\n        assert worktree_name == \"erk-slot-05\"\n        assert worktree_branch == branch_name\n\n    def test_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch with planned/ prefix resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\n        numeric issue prefix. The plan ID comes from .impl/plan-ref.json.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-03\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"8001\",\n            \"url\": \"https://github.com/test/repo/pull/8001\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 8001 should be extracted from .impl/plan-ref.json\n        assert 8001 in mapping\n        worktree_name, worktree_branch = mapping[8001]\n        assert worktree_name == \"erk-slot-03\"\n        assert worktree_branch == branch_name\n\n    def test_planned_hyphen_branch_not_matched(self, tmp_path: Path) -> None:\n        \"\"\"Branch with 'planned-' (hyphen) prefix is NOT matched.\n\n        Only 'planned/' (forward slash) is valid. This test ensures the\n        startswith check uses the correct delimiter.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-04\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned-fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json — should NOT be read because prefix is wrong\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"9999\",\n            \"url\": \"https://github.com/test/repo/pull/9999\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # planned- (hyphen) should NOT be recognized — only planned/ (slash) is valid\n        assert 9999 not in mapping\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_without_plan_ref_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch without .impl/plan-ref.json is not in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-something-02-19-1416\"\n\n        # No .impl/plan-ref.json created\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # No plan-ref.json, so planned/* branch should not produce an entry\n        assert len(mapping) == 0\n\n\nclass TestClosePlan:\n    \"\"\"Tests for close_plan method using HTTP client.\"\"\"\n\n    def test_close_plan_uses_http_client(self, tmp_path: Path) -> None:\n        \"\"\"close_plan should use HTTP client to close issue via API.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        # Configure fake GitHub to return empty PR linkages\n        from erk_shared.gateway.github.fake import FakeGitHub\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        http_client = FakeHttpClient()\n        http_client.set_response(\n            \"repos/test/repo/issues/123\",\n            response={\"state\": \"closed\"},\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=http_client,\n        )\n\n        closed_prs = provider.close_plan(123, \"https://github.com/test/repo/issues/123\")\n\n        # Verify HTTP client was used to close the issue\n        assert len(http_client.requests) == 1\n        request = http_client.requests[0]\n        assert request.method == \"PATCH\"\n        assert request.endpoint == \"repos/test/repo/issues/123\"\n        assert request.data == {\"state\": \"closed\"}\n        assert closed_prs == []\n\n    def test_close_plan_closes_linked_prs(self, tmp_path: Path) -> None:\n        \"\"\"close_plan should close linked PRs before closing issue.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        # Configure fake GitHub to return linked PRs\n        from erk_shared.gateway.github.fake import FakeGitHub\n        from erk_shared.gateway.github.types import PullRequestInfo\n\n        github = FakeGitHub(\n            pr_issue_linkages={\n                123: [\n                    PullRequestInfo(\n                        number=456,\n                        state=\"OPEN\",\n                        url=\"https://github.com/test/repo/pulls/456\",\n                        is_draft=False,\n                        title=\"Fix issue\",\n                        checks_passing=None,\n                        owner=\"test\",\n                        repo=\"repo\",\n                    ),\n                ],\n            }\n        )\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        http_client = FakeHttpClient()\n        http_client.set_response(\n            \"repos/test/repo/pulls/456\",\n            response={\"state\": \"closed\"},\n        )\n        http_client.set_response(\n            \"repos/test/repo/issues/123\",\n            response={\"state\": \"closed\"},\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=http_client,\n        )\n\n        closed_prs = provider.close_plan(123, \"https://github.com/test/repo/issues/123\")\n\n        # Verify HTTP client was used to close PR first, then issue\n        assert len(http_client.requests) == 2\n        assert http_client.requests[0].endpoint == \"repos/test/repo/pulls/456\"\n        assert http_client.requests[1].endpoint == \"repos/test/repo/issues/123\"\n        assert closed_prs == [456]\n\n    def test_parse_owner_repo_from_url(self, tmp_path: Path) -> None:\n        \"\"\"_parse_owner_repo_from_url should extract owner/repo from URL.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        result = provider._parse_owner_repo_from_url(\"https://github.com/owner/repo/issues/123\")\n        assert result == (\"owner\", \"repo\")\n\n        result = provider._parse_owner_repo_from_url(\"https://github.com/anthropic/erk/pulls/456\")\n        assert result == (\"anthropic\", \"erk\")\n\n        # Invalid URL returns None\n        result = provider._parse_owner_repo_from_url(\"invalid\")\n        assert result is None\n\n\nclass TestCommentCountsDisplay:\n    \"\"\"Tests for review comment counts display in _build_row_data.\n\n    Comment counts are now fetched via the batched PR linkages GraphQL query\n    and stored in PullRequestInfo.review_thread_counts as (resolved, total).\n    \"\"\"\n\n    def test_comment_counts_from_pr_data(self, tmp_path: Path) -> None:\n        \"\"\"When PR has review_thread_counts, display as resolved/total.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan and PR linkage with comment counts\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages = {\n            123: [\n                PullRequestInfo(\n                    number=456,\n                    state=\"OPEN\",\n                    url=\"https://github.com/test/repo/pulls/456\",\n                    is_draft=False,\n                    title=\"Fix issue\",\n                    checks_passing=True,\n                    owner=\"test\",\n                    repo=\"repo\",\n                    review_thread_counts=(3, 5),  # 3 resolved out of 5 total\n                ),\n            ],\n        }\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 3\n        assert row.total_comment_count == 5\n        assert row.comments_display == \"3/5\"\n\n    def test_comment_counts_none_shows_zero(self, tmp_path: Path) -> None:\n        \"\"\"When PR has no review_thread_counts (None), display 0/0.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan and PR linkage without comment counts\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages = {\n            123: [\n                PullRequestInfo(\n                    number=456,\n                    state=\"OPEN\",\n                    url=\"https://github.com/test/repo/pulls/456\",\n                    is_draft=False,\n                    title=\"Fix issue\",\n                    checks_passing=True,\n                    owner=\"test\",\n                    repo=\"repo\",\n                    # review_thread_counts defaults to None\n                ),\n            ],\n        }\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 0\n        assert row.total_comment_count == 0\n        assert row.comments_display == \"0/0\"\n\n    def test_no_pr_shows_dash(self, tmp_path: Path) -> None:\n        \"\"\"When plan has no linked PR, display '-' for comments.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan without PR linkage\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages: dict[int, list[PullRequestInfo]] = {}  # No linked PRs\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 0\n        assert row.total_comment_count == 0\n        assert row.comments_display == \"-\"\n\n\nclass TestLearnStatusDisplay:\n    \"\"\"Tests for learn status display in _build_row_data.\"\"\"\n\n    def test_learn_status_none_shows_dash(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is None, display '-'.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan without learn_status metadata\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",  # No metadata block\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status is None\n        assert row.learn_plan_issue is None\n        assert row.learn_plan_pr is None\n        assert row.learn_display == \"- not started\"\n\n    def test_learn_status_pending_shows_spinner(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'pending', display spinner symbol.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: pending in metadata\n        plan_body = format_plan_header_body_for_test(learn_status=\"pending\")\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"pending\"\n        assert row.learn_display == \"⟳ in progress\"\n\n    def test_learn_status_completed_no_plan_shows_empty_set(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'completed_no_plan', display empty set symbol.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_no_plan\n        plan_body = format_plan_header_body_for_test(learn_status=\"completed_no_plan\")\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"completed_no_plan\"\n        assert row.learn_display == \"∅ no insights\"\n\n    def test_learn_status_completed_with_plan_shows_issue_number(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'completed_with_plan', display issue number.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is None\n        assert row.learn_display == \"📋 #456\"\n\n    def test_learn_status_plan_completed_shows_pr_number(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'plan_completed', display checkmark and PR number.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: plan_completed and learn_plan_pr\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"plan_completed\", learn_plan_issue=456, learn_plan_pr=789\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"plan_completed\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_pr == 789\n        assert row.learn_display == \"✓ #789\"\n\n    def test_learn_status_completed_with_plan_closed_shows_checkmark(self, tmp_path: Path) -> None:\n        \"\"\"When learn plan issue is closed, display checkmark instead of clipboard.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime(2024, 1, 1, tzinfo=UTC),\n            updated_at=datetime(2024, 1, 1, tzinfo=UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        # Learn issue 456 is closed\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={456: True},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is True\n        assert row.learn_display == \"✅ #456\"\n        assert row.learn_display_icon == \"✅ #456\"\n\n    def test_learn_status_completed_with_plan_open_shows_clipboard(self, tmp_path: Path) -> None:\n        \"\"\"When learn plan issue is open, display clipboard emoji.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime(2024, 1, 1, tzinfo=UTC),\n            updated_at=datetime(2024, 1, 1, tzinfo=UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        # Learn issue 456 is open\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={456: False},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is False\n        assert row.learn_display == \"📋 #456\"\n        assert row.learn_display_icon == \"📋 #456\"\n","structuredPatch":[{"oldStart":305,"oldLines":8,"newStart":305,"newLines":8,"lines":["         assert worktree_name == \"erk-slot-05\"","         assert worktree_branch == branch_name"," ","-    def test_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:","-        \"\"\"Draft PR branch with planned/ prefix resolved via .impl/plan-ref.json.","+    def test_legacy_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:","+        \"\"\"Legacy planned/ prefix branch resolved via .impl/plan-ref.json."," ","         Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a","         numeric issue prefix. The plan ID comes from .impl/plan-ref.json."]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"871bfceb-5b76-46f5-b30e-cfc361efe263","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01FyG17JTayhpB49zt3oDYvj","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the \"planned hyphen\" negative test - the comment should reference both `plnd/` and `planned/`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":728,"cache_read_input_tokens":116781,"cache_creation":{"ephemeral_5m_input_tokens":728,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHwx1yNWHinSEm5Cztx","type":"assistant","uuid":"0dd8ab6e-843c-4257-8648-0821dddbd738","timestamp":"2026-02-22T14:49:34.043Z"}
{"parentUuid":"0dd8ab6e-843c-4257-8648-0821dddbd738","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01FyG17JTayhpB49zt3oDYvj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014gX5CWDbGo8wYH17VXsGZw","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","old_string":"    def test_planned_hyphen_branch_not_matched(self, tmp_path: Path) -> None:\n        \"\"\"Branch with 'planned-' (hyphen) prefix is NOT matched.\n\n        Only 'planned/' (forward slash) is valid. This test ensures the\n        startswith check uses the correct delimiter.\n        \"\"\"","new_string":"    def test_planned_hyphen_branch_not_matched(self, tmp_path: Path) -> None:\n        \"\"\"Branch with 'planned-' (hyphen) prefix is NOT matched.\n\n        Only 'plnd/' or 'planned/' (forward slash) is valid. This test ensures\n        the startswith check uses the correct delimiter.\n        \"\"\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":728,"cache_read_input_tokens":116781,"cache_creation":{"ephemeral_5m_input_tokens":728,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHwx1yNWHinSEm5Cztx","type":"assistant","uuid":"4a7b28e9-d715-4db7-a963-dceddc3a7510","timestamp":"2026-02-22T14:49:36.020Z"}
{"parentUuid":"4a7b28e9-d715-4db7-a963-dceddc3a7510","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014gX5CWDbGo8wYH17VXsGZw","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/tui/data/test_provider.py has been updated successfully."}]},"uuid":"1a82f2e8-b18a-4b8f-a27b-66223eefbad4","timestamp":"2026-02-22T14:49:36.690Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","oldString":"    def test_planned_hyphen_branch_not_matched(self, tmp_path: Path) -> None:\n        \"\"\"Branch with 'planned-' (hyphen) prefix is NOT matched.\n\n        Only 'planned/' (forward slash) is valid. This test ensures the\n        startswith check uses the correct delimiter.\n        \"\"\"","newString":"    def test_planned_hyphen_branch_not_matched(self, tmp_path: Path) -> None:\n        \"\"\"Branch with 'planned-' (hyphen) prefix is NOT matched.\n\n        Only 'plnd/' or 'planned/' (forward slash) is valid. This test ensures\n        the startswith check uses the correct delimiter.\n        \"\"\"","originalFile":"\"\"\"Tests for plan data provider.\"\"\"\n\nimport json\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nfrom erk.core.repo_discovery import RepoContext\nfrom erk_shared.gateway.browser.fake import FakeBrowserLauncher\nfrom erk_shared.gateway.clipboard.fake import FakeClipboard\nfrom erk_shared.gateway.git.abc import WorktreeInfo\nfrom erk_shared.gateway.git.fake import FakeGit\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.metadata.core import find_metadata_block\nfrom erk_shared.gateway.github.types import (\n    GitHubRepoId,\n    GitHubRepoLocation,\n    PullRequestInfo,\n)\nfrom erk_shared.gateway.http.fake import FakeHttpClient\nfrom erk_shared.gateway.plan_data_provider.real import RealPlanDataProvider\nfrom erk_shared.plan_store.types import Plan, PlanState\nfrom tests.fakes.context import create_test_context\nfrom tests.test_utils.plan_helpers import format_plan_header_body_for_test\n\n\ndef _parse_header_fields(body: str) -> dict[str, object]:\n    \"\"\"Parse header_fields from a plan body for test Plan construction.\"\"\"\n    block = find_metadata_block(body, \"plan-header\")\n    if block is None:\n        return {}\n    return dict(block.data)\n\n\ndef _make_repo_context(repo_root: Path, tmp_path: Path) -> RepoContext:\n    \"\"\"Create a RepoContext for testing.\"\"\"\n    erk_dir = tmp_path / \".erk\"\n    repo_dir = erk_dir / \"repos\" / \"test-repo\"\n    return RepoContext(\n        root=repo_root,\n        repo_name=\"test-repo\",\n        repo_dir=repo_dir,\n        worktrees_dir=repo_dir / \"worktrees\",\n        pool_json_path=repo_dir / \"pool.json\",\n    )\n\n\nclass TestBuildWorktreeMapping:\n    \"\"\"Tests for _build_worktree_mapping method.\"\"\"\n\n    def test_pool_managed_worktree_extracts_from_branch_name(self, tmp_path: Path) -> None:\n        \"\"\"Pool-managed worktree with generic directory name maps via branch.\n\n        The directory name is 'erk-slot-02' (no issue prefix),\n        but the branch name is 'P4280-add-required-kwargs-01-05-2230',\n        so issue 4280 should be extracted from the branch.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        # Create .erk directory to satisfy _ensure_erk_metadata_dir_from_context\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-02\"\n        branch_name = \"P4280-add-required-kwargs-01-05-2230\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Issue 4280 should be extracted from the branch name\n        assert 4280 in mapping\n        worktree_name, worktree_branch = mapping[4280]\n        assert worktree_name == \"erk-slot-02\"\n        assert worktree_branch == branch_name\n\n    def test_issue_named_worktree_extracts_from_branch_name(self, tmp_path: Path) -> None:\n        \"\"\"Issue-named worktree with P-prefixed directory also extracts from branch.\n\n        The directory name is 'P1234-feature-01-01-1200' (has issue prefix),\n        and the branch name matches. Issue 1234 should be extracted from branch.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"P1234-feature-01-01-1200\"\n        branch_name = \"P1234-feature-01-01-1200\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Issue 1234 should be extracted from the branch name\n        assert 1234 in mapping\n        worktree_name, worktree_branch = mapping[1234]\n        assert worktree_name == \"P1234-feature-01-01-1200\"\n        assert worktree_branch == branch_name\n\n    def test_detached_head_worktree_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Worktree with detached HEAD (branch=None) should not be in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        # Detached HEAD worktree has branch=None\n        worktree_path = tmp_path / \"worktrees\" / \"detached-wt\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=None, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Detached HEAD should not produce an entry in mapping\n        assert len(mapping) == 0\n\n    def test_non_plan_branch_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Worktree with non-P-prefixed branch should not be in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"feature-branch\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=\"feature-branch\", is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Non-plan branch should not produce an entry\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch (plnd/*) resolved via .impl/plan-ref.json.\n\n        Branch name 'plnd/fix-missing-data-02-19-1416' doesn't contain a\n        numeric issue prefix. The plan ID (PR number) comes from\n        .impl/plan-ref.json inside the worktree directory.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"plnd/fix-missing-data-02-19-1416\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"7624\",\n            \"url\": \"https://github.com/test/repo/pull/7624\",\n            \"created_at\": \"2026-02-19T14:16:00+00:00\",\n            \"synced_at\": \"2026-02-19T14:16:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 7624 should be extracted from .impl/plan-ref.json\n        assert 7624 in mapping\n        worktree_name, worktree_branch = mapping[7624]\n        assert worktree_name == \"erk-slot-05\"\n        assert worktree_branch == branch_name\n\n    def test_legacy_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Legacy planned/ prefix branch resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\n        numeric issue prefix. The plan ID comes from .impl/plan-ref.json.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-03\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"8001\",\n            \"url\": \"https://github.com/test/repo/pull/8001\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 8001 should be extracted from .impl/plan-ref.json\n        assert 8001 in mapping\n        worktree_name, worktree_branch = mapping[8001]\n        assert worktree_name == \"erk-slot-03\"\n        assert worktree_branch == branch_name\n\n    def test_planned_hyphen_branch_not_matched(self, tmp_path: Path) -> None:\n        \"\"\"Branch with 'planned-' (hyphen) prefix is NOT matched.\n\n        Only 'planned/' (forward slash) is valid. This test ensures the\n        startswith check uses the correct delimiter.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-04\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned-fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json — should NOT be read because prefix is wrong\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"9999\",\n            \"url\": \"https://github.com/test/repo/pull/9999\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # planned- (hyphen) should NOT be recognized — only planned/ (slash) is valid\n        assert 9999 not in mapping\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_without_plan_ref_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch without .impl/plan-ref.json is not in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-something-02-19-1416\"\n\n        # No .impl/plan-ref.json created\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # No plan-ref.json, so planned/* branch should not produce an entry\n        assert len(mapping) == 0\n\n\nclass TestClosePlan:\n    \"\"\"Tests for close_plan method using HTTP client.\"\"\"\n\n    def test_close_plan_uses_http_client(self, tmp_path: Path) -> None:\n        \"\"\"close_plan should use HTTP client to close issue via API.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        # Configure fake GitHub to return empty PR linkages\n        from erk_shared.gateway.github.fake import FakeGitHub\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        http_client = FakeHttpClient()\n        http_client.set_response(\n            \"repos/test/repo/issues/123\",\n            response={\"state\": \"closed\"},\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=http_client,\n        )\n\n        closed_prs = provider.close_plan(123, \"https://github.com/test/repo/issues/123\")\n\n        # Verify HTTP client was used to close the issue\n        assert len(http_client.requests) == 1\n        request = http_client.requests[0]\n        assert request.method == \"PATCH\"\n        assert request.endpoint == \"repos/test/repo/issues/123\"\n        assert request.data == {\"state\": \"closed\"}\n        assert closed_prs == []\n\n    def test_close_plan_closes_linked_prs(self, tmp_path: Path) -> None:\n        \"\"\"close_plan should close linked PRs before closing issue.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        # Configure fake GitHub to return linked PRs\n        from erk_shared.gateway.github.fake import FakeGitHub\n        from erk_shared.gateway.github.types import PullRequestInfo\n\n        github = FakeGitHub(\n            pr_issue_linkages={\n                123: [\n                    PullRequestInfo(\n                        number=456,\n                        state=\"OPEN\",\n                        url=\"https://github.com/test/repo/pulls/456\",\n                        is_draft=False,\n                        title=\"Fix issue\",\n                        checks_passing=None,\n                        owner=\"test\",\n                        repo=\"repo\",\n                    ),\n                ],\n            }\n        )\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        http_client = FakeHttpClient()\n        http_client.set_response(\n            \"repos/test/repo/pulls/456\",\n            response={\"state\": \"closed\"},\n        )\n        http_client.set_response(\n            \"repos/test/repo/issues/123\",\n            response={\"state\": \"closed\"},\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=http_client,\n        )\n\n        closed_prs = provider.close_plan(123, \"https://github.com/test/repo/issues/123\")\n\n        # Verify HTTP client was used to close PR first, then issue\n        assert len(http_client.requests) == 2\n        assert http_client.requests[0].endpoint == \"repos/test/repo/pulls/456\"\n        assert http_client.requests[1].endpoint == \"repos/test/repo/issues/123\"\n        assert closed_prs == [456]\n\n    def test_parse_owner_repo_from_url(self, tmp_path: Path) -> None:\n        \"\"\"_parse_owner_repo_from_url should extract owner/repo from URL.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        result = provider._parse_owner_repo_from_url(\"https://github.com/owner/repo/issues/123\")\n        assert result == (\"owner\", \"repo\")\n\n        result = provider._parse_owner_repo_from_url(\"https://github.com/anthropic/erk/pulls/456\")\n        assert result == (\"anthropic\", \"erk\")\n\n        # Invalid URL returns None\n        result = provider._parse_owner_repo_from_url(\"invalid\")\n        assert result is None\n\n\nclass TestCommentCountsDisplay:\n    \"\"\"Tests for review comment counts display in _build_row_data.\n\n    Comment counts are now fetched via the batched PR linkages GraphQL query\n    and stored in PullRequestInfo.review_thread_counts as (resolved, total).\n    \"\"\"\n\n    def test_comment_counts_from_pr_data(self, tmp_path: Path) -> None:\n        \"\"\"When PR has review_thread_counts, display as resolved/total.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan and PR linkage with comment counts\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages = {\n            123: [\n                PullRequestInfo(\n                    number=456,\n                    state=\"OPEN\",\n                    url=\"https://github.com/test/repo/pulls/456\",\n                    is_draft=False,\n                    title=\"Fix issue\",\n                    checks_passing=True,\n                    owner=\"test\",\n                    repo=\"repo\",\n                    review_thread_counts=(3, 5),  # 3 resolved out of 5 total\n                ),\n            ],\n        }\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 3\n        assert row.total_comment_count == 5\n        assert row.comments_display == \"3/5\"\n\n    def test_comment_counts_none_shows_zero(self, tmp_path: Path) -> None:\n        \"\"\"When PR has no review_thread_counts (None), display 0/0.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan and PR linkage without comment counts\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages = {\n            123: [\n                PullRequestInfo(\n                    number=456,\n                    state=\"OPEN\",\n                    url=\"https://github.com/test/repo/pulls/456\",\n                    is_draft=False,\n                    title=\"Fix issue\",\n                    checks_passing=True,\n                    owner=\"test\",\n                    repo=\"repo\",\n                    # review_thread_counts defaults to None\n                ),\n            ],\n        }\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 0\n        assert row.total_comment_count == 0\n        assert row.comments_display == \"0/0\"\n\n    def test_no_pr_shows_dash(self, tmp_path: Path) -> None:\n        \"\"\"When plan has no linked PR, display '-' for comments.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan without PR linkage\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages: dict[int, list[PullRequestInfo]] = {}  # No linked PRs\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 0\n        assert row.total_comment_count == 0\n        assert row.comments_display == \"-\"\n\n\nclass TestLearnStatusDisplay:\n    \"\"\"Tests for learn status display in _build_row_data.\"\"\"\n\n    def test_learn_status_none_shows_dash(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is None, display '-'.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan without learn_status metadata\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",  # No metadata block\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status is None\n        assert row.learn_plan_issue is None\n        assert row.learn_plan_pr is None\n        assert row.learn_display == \"- not started\"\n\n    def test_learn_status_pending_shows_spinner(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'pending', display spinner symbol.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: pending in metadata\n        plan_body = format_plan_header_body_for_test(learn_status=\"pending\")\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"pending\"\n        assert row.learn_display == \"⟳ in progress\"\n\n    def test_learn_status_completed_no_plan_shows_empty_set(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'completed_no_plan', display empty set symbol.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_no_plan\n        plan_body = format_plan_header_body_for_test(learn_status=\"completed_no_plan\")\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"completed_no_plan\"\n        assert row.learn_display == \"∅ no insights\"\n\n    def test_learn_status_completed_with_plan_shows_issue_number(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'completed_with_plan', display issue number.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is None\n        assert row.learn_display == \"📋 #456\"\n\n    def test_learn_status_plan_completed_shows_pr_number(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'plan_completed', display checkmark and PR number.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: plan_completed and learn_plan_pr\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"plan_completed\", learn_plan_issue=456, learn_plan_pr=789\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"plan_completed\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_pr == 789\n        assert row.learn_display == \"✓ #789\"\n\n    def test_learn_status_completed_with_plan_closed_shows_checkmark(self, tmp_path: Path) -> None:\n        \"\"\"When learn plan issue is closed, display checkmark instead of clipboard.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime(2024, 1, 1, tzinfo=UTC),\n            updated_at=datetime(2024, 1, 1, tzinfo=UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        # Learn issue 456 is closed\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={456: True},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is True\n        assert row.learn_display == \"✅ #456\"\n        assert row.learn_display_icon == \"✅ #456\"\n\n    def test_learn_status_completed_with_plan_open_shows_clipboard(self, tmp_path: Path) -> None:\n        \"\"\"When learn plan issue is open, display clipboard emoji.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime(2024, 1, 1, tzinfo=UTC),\n            updated_at=datetime(2024, 1, 1, tzinfo=UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        # Learn issue 456 is open\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={456: False},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is False\n        assert row.learn_display == \"📋 #456\"\n        assert row.learn_display_icon == \"📋 #456\"\n","structuredPatch":[{"oldStart":374,"oldLines":8,"newStart":374,"newLines":8,"lines":["     def test_planned_hyphen_branch_not_matched(self, tmp_path: Path) -> None:","         \"\"\"Branch with 'planned-' (hyphen) prefix is NOT matched."," ","-        Only 'planned/' (forward slash) is valid. This test ensures the","-        startswith check uses the correct delimiter.","+        Only 'plnd/' or 'planned/' (forward slash) is valid. This test ensures","+        the startswith check uses the correct delimiter.","         \"\"\"","         repo_root = tmp_path / \"repo\"","         repo_root.mkdir()"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"1a82f2e8-b18a-4b8f-a27b-66223eefbad4","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01ULFpbBuVqSRNkn98JcaZyo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Va7xEqxjW5fUNtiwEFFFFs","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","old_string":"        # planned- (hyphen) should NOT be recognized — only planned/ (slash) is valid","new_string":"        # planned- (hyphen) should NOT be recognized — only plnd/ or planned/ (slash) is valid"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":341,"cache_read_input_tokens":117509,"cache_creation":{"ephemeral_5m_input_tokens":341,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHxPtiiH6hqF5FETn3A","type":"assistant","uuid":"5f95bba7-fe70-458a-955c-c173af141915","timestamp":"2026-02-22T14:49:41.002Z"}
{"parentUuid":"5f95bba7-fe70-458a-955c-c173af141915","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Va7xEqxjW5fUNtiwEFFFFs","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/tui/data/test_provider.py has been updated successfully."}]},"uuid":"0721fd62-8c12-43ea-8f68-b505c16a738b","timestamp":"2026-02-22T14:49:41.708Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","oldString":"        # planned- (hyphen) should NOT be recognized — only planned/ (slash) is valid","newString":"        # planned- (hyphen) should NOT be recognized — only plnd/ or planned/ (slash) is valid","originalFile":"\"\"\"Tests for plan data provider.\"\"\"\n\nimport json\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nfrom erk.core.repo_discovery import RepoContext\nfrom erk_shared.gateway.browser.fake import FakeBrowserLauncher\nfrom erk_shared.gateway.clipboard.fake import FakeClipboard\nfrom erk_shared.gateway.git.abc import WorktreeInfo\nfrom erk_shared.gateway.git.fake import FakeGit\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.metadata.core import find_metadata_block\nfrom erk_shared.gateway.github.types import (\n    GitHubRepoId,\n    GitHubRepoLocation,\n    PullRequestInfo,\n)\nfrom erk_shared.gateway.http.fake import FakeHttpClient\nfrom erk_shared.gateway.plan_data_provider.real import RealPlanDataProvider\nfrom erk_shared.plan_store.types import Plan, PlanState\nfrom tests.fakes.context import create_test_context\nfrom tests.test_utils.plan_helpers import format_plan_header_body_for_test\n\n\ndef _parse_header_fields(body: str) -> dict[str, object]:\n    \"\"\"Parse header_fields from a plan body for test Plan construction.\"\"\"\n    block = find_metadata_block(body, \"plan-header\")\n    if block is None:\n        return {}\n    return dict(block.data)\n\n\ndef _make_repo_context(repo_root: Path, tmp_path: Path) -> RepoContext:\n    \"\"\"Create a RepoContext for testing.\"\"\"\n    erk_dir = tmp_path / \".erk\"\n    repo_dir = erk_dir / \"repos\" / \"test-repo\"\n    return RepoContext(\n        root=repo_root,\n        repo_name=\"test-repo\",\n        repo_dir=repo_dir,\n        worktrees_dir=repo_dir / \"worktrees\",\n        pool_json_path=repo_dir / \"pool.json\",\n    )\n\n\nclass TestBuildWorktreeMapping:\n    \"\"\"Tests for _build_worktree_mapping method.\"\"\"\n\n    def test_pool_managed_worktree_extracts_from_branch_name(self, tmp_path: Path) -> None:\n        \"\"\"Pool-managed worktree with generic directory name maps via branch.\n\n        The directory name is 'erk-slot-02' (no issue prefix),\n        but the branch name is 'P4280-add-required-kwargs-01-05-2230',\n        so issue 4280 should be extracted from the branch.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        # Create .erk directory to satisfy _ensure_erk_metadata_dir_from_context\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-02\"\n        branch_name = \"P4280-add-required-kwargs-01-05-2230\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Issue 4280 should be extracted from the branch name\n        assert 4280 in mapping\n        worktree_name, worktree_branch = mapping[4280]\n        assert worktree_name == \"erk-slot-02\"\n        assert worktree_branch == branch_name\n\n    def test_issue_named_worktree_extracts_from_branch_name(self, tmp_path: Path) -> None:\n        \"\"\"Issue-named worktree with P-prefixed directory also extracts from branch.\n\n        The directory name is 'P1234-feature-01-01-1200' (has issue prefix),\n        and the branch name matches. Issue 1234 should be extracted from branch.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"P1234-feature-01-01-1200\"\n        branch_name = \"P1234-feature-01-01-1200\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Issue 1234 should be extracted from the branch name\n        assert 1234 in mapping\n        worktree_name, worktree_branch = mapping[1234]\n        assert worktree_name == \"P1234-feature-01-01-1200\"\n        assert worktree_branch == branch_name\n\n    def test_detached_head_worktree_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Worktree with detached HEAD (branch=None) should not be in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        # Detached HEAD worktree has branch=None\n        worktree_path = tmp_path / \"worktrees\" / \"detached-wt\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=None, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Detached HEAD should not produce an entry in mapping\n        assert len(mapping) == 0\n\n    def test_non_plan_branch_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Worktree with non-P-prefixed branch should not be in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"feature-branch\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=\"feature-branch\", is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Non-plan branch should not produce an entry\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch (plnd/*) resolved via .impl/plan-ref.json.\n\n        Branch name 'plnd/fix-missing-data-02-19-1416' doesn't contain a\n        numeric issue prefix. The plan ID (PR number) comes from\n        .impl/plan-ref.json inside the worktree directory.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"plnd/fix-missing-data-02-19-1416\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"7624\",\n            \"url\": \"https://github.com/test/repo/pull/7624\",\n            \"created_at\": \"2026-02-19T14:16:00+00:00\",\n            \"synced_at\": \"2026-02-19T14:16:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 7624 should be extracted from .impl/plan-ref.json\n        assert 7624 in mapping\n        worktree_name, worktree_branch = mapping[7624]\n        assert worktree_name == \"erk-slot-05\"\n        assert worktree_branch == branch_name\n\n    def test_legacy_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Legacy planned/ prefix branch resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\n        numeric issue prefix. The plan ID comes from .impl/plan-ref.json.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-03\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"8001\",\n            \"url\": \"https://github.com/test/repo/pull/8001\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 8001 should be extracted from .impl/plan-ref.json\n        assert 8001 in mapping\n        worktree_name, worktree_branch = mapping[8001]\n        assert worktree_name == \"erk-slot-03\"\n        assert worktree_branch == branch_name\n\n    def test_planned_hyphen_branch_not_matched(self, tmp_path: Path) -> None:\n        \"\"\"Branch with 'planned-' (hyphen) prefix is NOT matched.\n\n        Only 'plnd/' or 'planned/' (forward slash) is valid. This test ensures\n        the startswith check uses the correct delimiter.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-04\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned-fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json — should NOT be read because prefix is wrong\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"9999\",\n            \"url\": \"https://github.com/test/repo/pull/9999\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # planned- (hyphen) should NOT be recognized — only planned/ (slash) is valid\n        assert 9999 not in mapping\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_without_plan_ref_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch without .impl/plan-ref.json is not in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-something-02-19-1416\"\n\n        # No .impl/plan-ref.json created\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # No plan-ref.json, so planned/* branch should not produce an entry\n        assert len(mapping) == 0\n\n\nclass TestClosePlan:\n    \"\"\"Tests for close_plan method using HTTP client.\"\"\"\n\n    def test_close_plan_uses_http_client(self, tmp_path: Path) -> None:\n        \"\"\"close_plan should use HTTP client to close issue via API.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        # Configure fake GitHub to return empty PR linkages\n        from erk_shared.gateway.github.fake import FakeGitHub\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        http_client = FakeHttpClient()\n        http_client.set_response(\n            \"repos/test/repo/issues/123\",\n            response={\"state\": \"closed\"},\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=http_client,\n        )\n\n        closed_prs = provider.close_plan(123, \"https://github.com/test/repo/issues/123\")\n\n        # Verify HTTP client was used to close the issue\n        assert len(http_client.requests) == 1\n        request = http_client.requests[0]\n        assert request.method == \"PATCH\"\n        assert request.endpoint == \"repos/test/repo/issues/123\"\n        assert request.data == {\"state\": \"closed\"}\n        assert closed_prs == []\n\n    def test_close_plan_closes_linked_prs(self, tmp_path: Path) -> None:\n        \"\"\"close_plan should close linked PRs before closing issue.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        # Configure fake GitHub to return linked PRs\n        from erk_shared.gateway.github.fake import FakeGitHub\n        from erk_shared.gateway.github.types import PullRequestInfo\n\n        github = FakeGitHub(\n            pr_issue_linkages={\n                123: [\n                    PullRequestInfo(\n                        number=456,\n                        state=\"OPEN\",\n                        url=\"https://github.com/test/repo/pulls/456\",\n                        is_draft=False,\n                        title=\"Fix issue\",\n                        checks_passing=None,\n                        owner=\"test\",\n                        repo=\"repo\",\n                    ),\n                ],\n            }\n        )\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        http_client = FakeHttpClient()\n        http_client.set_response(\n            \"repos/test/repo/pulls/456\",\n            response={\"state\": \"closed\"},\n        )\n        http_client.set_response(\n            \"repos/test/repo/issues/123\",\n            response={\"state\": \"closed\"},\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=http_client,\n        )\n\n        closed_prs = provider.close_plan(123, \"https://github.com/test/repo/issues/123\")\n\n        # Verify HTTP client was used to close PR first, then issue\n        assert len(http_client.requests) == 2\n        assert http_client.requests[0].endpoint == \"repos/test/repo/pulls/456\"\n        assert http_client.requests[1].endpoint == \"repos/test/repo/issues/123\"\n        assert closed_prs == [456]\n\n    def test_parse_owner_repo_from_url(self, tmp_path: Path) -> None:\n        \"\"\"_parse_owner_repo_from_url should extract owner/repo from URL.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        result = provider._parse_owner_repo_from_url(\"https://github.com/owner/repo/issues/123\")\n        assert result == (\"owner\", \"repo\")\n\n        result = provider._parse_owner_repo_from_url(\"https://github.com/anthropic/erk/pulls/456\")\n        assert result == (\"anthropic\", \"erk\")\n\n        # Invalid URL returns None\n        result = provider._parse_owner_repo_from_url(\"invalid\")\n        assert result is None\n\n\nclass TestCommentCountsDisplay:\n    \"\"\"Tests for review comment counts display in _build_row_data.\n\n    Comment counts are now fetched via the batched PR linkages GraphQL query\n    and stored in PullRequestInfo.review_thread_counts as (resolved, total).\n    \"\"\"\n\n    def test_comment_counts_from_pr_data(self, tmp_path: Path) -> None:\n        \"\"\"When PR has review_thread_counts, display as resolved/total.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan and PR linkage with comment counts\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages = {\n            123: [\n                PullRequestInfo(\n                    number=456,\n                    state=\"OPEN\",\n                    url=\"https://github.com/test/repo/pulls/456\",\n                    is_draft=False,\n                    title=\"Fix issue\",\n                    checks_passing=True,\n                    owner=\"test\",\n                    repo=\"repo\",\n                    review_thread_counts=(3, 5),  # 3 resolved out of 5 total\n                ),\n            ],\n        }\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 3\n        assert row.total_comment_count == 5\n        assert row.comments_display == \"3/5\"\n\n    def test_comment_counts_none_shows_zero(self, tmp_path: Path) -> None:\n        \"\"\"When PR has no review_thread_counts (None), display 0/0.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan and PR linkage without comment counts\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages = {\n            123: [\n                PullRequestInfo(\n                    number=456,\n                    state=\"OPEN\",\n                    url=\"https://github.com/test/repo/pulls/456\",\n                    is_draft=False,\n                    title=\"Fix issue\",\n                    checks_passing=True,\n                    owner=\"test\",\n                    repo=\"repo\",\n                    # review_thread_counts defaults to None\n                ),\n            ],\n        }\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 0\n        assert row.total_comment_count == 0\n        assert row.comments_display == \"0/0\"\n\n    def test_no_pr_shows_dash(self, tmp_path: Path) -> None:\n        \"\"\"When plan has no linked PR, display '-' for comments.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan without PR linkage\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages: dict[int, list[PullRequestInfo]] = {}  # No linked PRs\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 0\n        assert row.total_comment_count == 0\n        assert row.comments_display == \"-\"\n\n\nclass TestLearnStatusDisplay:\n    \"\"\"Tests for learn status display in _build_row_data.\"\"\"\n\n    def test_learn_status_none_shows_dash(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is None, display '-'.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan without learn_status metadata\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",  # No metadata block\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status is None\n        assert row.learn_plan_issue is None\n        assert row.learn_plan_pr is None\n        assert row.learn_display == \"- not started\"\n\n    def test_learn_status_pending_shows_spinner(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'pending', display spinner symbol.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: pending in metadata\n        plan_body = format_plan_header_body_for_test(learn_status=\"pending\")\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"pending\"\n        assert row.learn_display == \"⟳ in progress\"\n\n    def test_learn_status_completed_no_plan_shows_empty_set(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'completed_no_plan', display empty set symbol.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_no_plan\n        plan_body = format_plan_header_body_for_test(learn_status=\"completed_no_plan\")\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"completed_no_plan\"\n        assert row.learn_display == \"∅ no insights\"\n\n    def test_learn_status_completed_with_plan_shows_issue_number(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'completed_with_plan', display issue number.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is None\n        assert row.learn_display == \"📋 #456\"\n\n    def test_learn_status_plan_completed_shows_pr_number(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'plan_completed', display checkmark and PR number.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: plan_completed and learn_plan_pr\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"plan_completed\", learn_plan_issue=456, learn_plan_pr=789\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"plan_completed\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_pr == 789\n        assert row.learn_display == \"✓ #789\"\n\n    def test_learn_status_completed_with_plan_closed_shows_checkmark(self, tmp_path: Path) -> None:\n        \"\"\"When learn plan issue is closed, display checkmark instead of clipboard.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime(2024, 1, 1, tzinfo=UTC),\n            updated_at=datetime(2024, 1, 1, tzinfo=UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        # Learn issue 456 is closed\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={456: True},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is True\n        assert row.learn_display == \"✅ #456\"\n        assert row.learn_display_icon == \"✅ #456\"\n\n    def test_learn_status_completed_with_plan_open_shows_clipboard(self, tmp_path: Path) -> None:\n        \"\"\"When learn plan issue is open, display clipboard emoji.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime(2024, 1, 1, tzinfo=UTC),\n            updated_at=datetime(2024, 1, 1, tzinfo=UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        # Learn issue 456 is open\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={456: False},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is False\n        assert row.learn_display == \"📋 #456\"\n        assert row.learn_display_icon == \"📋 #456\"\n","structuredPatch":[{"oldStart":431,"oldLines":7,"newStart":431,"newLines":7,"lines":[" ","         mapping = provider._build_worktree_mapping()"," ","-        # planned- (hyphen) should NOT be recognized — only planned/ (slash) is valid","+        # planned- (hyphen) should NOT be recognized — only plnd/ or planned/ (slash) is valid","         assert 9999 not in mapping","         assert len(mapping) == 0"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"0721fd62-8c12-43ea-8f68-b505c16a738b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01DrUSAXLnsBBS2ZRmECj8gu","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the \"without plan ref\" test to use `plnd/`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":540,"cache_read_input_tokens":117850,"cache_creation":{"ephemeral_5m_input_tokens":540,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHxmKZucCnCJJoXbkqk","type":"assistant","uuid":"65a17fa2-ecfa-4309-95a4-2e727c99e5c7","timestamp":"2026-02-22T14:49:44.240Z"}
{"parentUuid":"65a17fa2-ecfa-4309-95a4-2e727c99e5c7","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01DrUSAXLnsBBS2ZRmECj8gu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NoFyj8Maoa2fFXJijgLpiX","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","old_string":"        branch_name = \"planned/fix-something-02-19-1416\"","new_string":"        branch_name = \"plnd/fix-something-02-19-1416\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":540,"cache_read_input_tokens":117850,"cache_creation":{"ephemeral_5m_input_tokens":540,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHxmKZucCnCJJoXbkqk","type":"assistant","uuid":"6a887821-5e88-48ee-86b5-056b45671fd2","timestamp":"2026-02-22T14:49:45.372Z"}
{"parentUuid":"6a887821-5e88-48ee-86b5-056b45671fd2","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NoFyj8Maoa2fFXJijgLpiX","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/tui/data/test_provider.py has been updated successfully."}]},"uuid":"5a8e8233-1564-4f81-a429-8d4616f61bb9","timestamp":"2026-02-22T14:49:46.064Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","oldString":"        branch_name = \"planned/fix-something-02-19-1416\"","newString":"        branch_name = \"plnd/fix-something-02-19-1416\"","originalFile":"\"\"\"Tests for plan data provider.\"\"\"\n\nimport json\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nfrom erk.core.repo_discovery import RepoContext\nfrom erk_shared.gateway.browser.fake import FakeBrowserLauncher\nfrom erk_shared.gateway.clipboard.fake import FakeClipboard\nfrom erk_shared.gateway.git.abc import WorktreeInfo\nfrom erk_shared.gateway.git.fake import FakeGit\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.metadata.core import find_metadata_block\nfrom erk_shared.gateway.github.types import (\n    GitHubRepoId,\n    GitHubRepoLocation,\n    PullRequestInfo,\n)\nfrom erk_shared.gateway.http.fake import FakeHttpClient\nfrom erk_shared.gateway.plan_data_provider.real import RealPlanDataProvider\nfrom erk_shared.plan_store.types import Plan, PlanState\nfrom tests.fakes.context import create_test_context\nfrom tests.test_utils.plan_helpers import format_plan_header_body_for_test\n\n\ndef _parse_header_fields(body: str) -> dict[str, object]:\n    \"\"\"Parse header_fields from a plan body for test Plan construction.\"\"\"\n    block = find_metadata_block(body, \"plan-header\")\n    if block is None:\n        return {}\n    return dict(block.data)\n\n\ndef _make_repo_context(repo_root: Path, tmp_path: Path) -> RepoContext:\n    \"\"\"Create a RepoContext for testing.\"\"\"\n    erk_dir = tmp_path / \".erk\"\n    repo_dir = erk_dir / \"repos\" / \"test-repo\"\n    return RepoContext(\n        root=repo_root,\n        repo_name=\"test-repo\",\n        repo_dir=repo_dir,\n        worktrees_dir=repo_dir / \"worktrees\",\n        pool_json_path=repo_dir / \"pool.json\",\n    )\n\n\nclass TestBuildWorktreeMapping:\n    \"\"\"Tests for _build_worktree_mapping method.\"\"\"\n\n    def test_pool_managed_worktree_extracts_from_branch_name(self, tmp_path: Path) -> None:\n        \"\"\"Pool-managed worktree with generic directory name maps via branch.\n\n        The directory name is 'erk-slot-02' (no issue prefix),\n        but the branch name is 'P4280-add-required-kwargs-01-05-2230',\n        so issue 4280 should be extracted from the branch.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        # Create .erk directory to satisfy _ensure_erk_metadata_dir_from_context\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-02\"\n        branch_name = \"P4280-add-required-kwargs-01-05-2230\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Issue 4280 should be extracted from the branch name\n        assert 4280 in mapping\n        worktree_name, worktree_branch = mapping[4280]\n        assert worktree_name == \"erk-slot-02\"\n        assert worktree_branch == branch_name\n\n    def test_issue_named_worktree_extracts_from_branch_name(self, tmp_path: Path) -> None:\n        \"\"\"Issue-named worktree with P-prefixed directory also extracts from branch.\n\n        The directory name is 'P1234-feature-01-01-1200' (has issue prefix),\n        and the branch name matches. Issue 1234 should be extracted from branch.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"P1234-feature-01-01-1200\"\n        branch_name = \"P1234-feature-01-01-1200\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Issue 1234 should be extracted from the branch name\n        assert 1234 in mapping\n        worktree_name, worktree_branch = mapping[1234]\n        assert worktree_name == \"P1234-feature-01-01-1200\"\n        assert worktree_branch == branch_name\n\n    def test_detached_head_worktree_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Worktree with detached HEAD (branch=None) should not be in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        # Detached HEAD worktree has branch=None\n        worktree_path = tmp_path / \"worktrees\" / \"detached-wt\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=None, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Detached HEAD should not produce an entry in mapping\n        assert len(mapping) == 0\n\n    def test_non_plan_branch_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Worktree with non-P-prefixed branch should not be in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"feature-branch\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=\"feature-branch\", is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Non-plan branch should not produce an entry\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch (plnd/*) resolved via .impl/plan-ref.json.\n\n        Branch name 'plnd/fix-missing-data-02-19-1416' doesn't contain a\n        numeric issue prefix. The plan ID (PR number) comes from\n        .impl/plan-ref.json inside the worktree directory.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"plnd/fix-missing-data-02-19-1416\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"7624\",\n            \"url\": \"https://github.com/test/repo/pull/7624\",\n            \"created_at\": \"2026-02-19T14:16:00+00:00\",\n            \"synced_at\": \"2026-02-19T14:16:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 7624 should be extracted from .impl/plan-ref.json\n        assert 7624 in mapping\n        worktree_name, worktree_branch = mapping[7624]\n        assert worktree_name == \"erk-slot-05\"\n        assert worktree_branch == branch_name\n\n    def test_legacy_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Legacy planned/ prefix branch resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\n        numeric issue prefix. The plan ID comes from .impl/plan-ref.json.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-03\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"8001\",\n            \"url\": \"https://github.com/test/repo/pull/8001\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 8001 should be extracted from .impl/plan-ref.json\n        assert 8001 in mapping\n        worktree_name, worktree_branch = mapping[8001]\n        assert worktree_name == \"erk-slot-03\"\n        assert worktree_branch == branch_name\n\n    def test_planned_hyphen_branch_not_matched(self, tmp_path: Path) -> None:\n        \"\"\"Branch with 'planned-' (hyphen) prefix is NOT matched.\n\n        Only 'plnd/' or 'planned/' (forward slash) is valid. This test ensures\n        the startswith check uses the correct delimiter.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-04\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned-fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json — should NOT be read because prefix is wrong\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"9999\",\n            \"url\": \"https://github.com/test/repo/pull/9999\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # planned- (hyphen) should NOT be recognized — only plnd/ or planned/ (slash) is valid\n        assert 9999 not in mapping\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_without_plan_ref_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch without .impl/plan-ref.json is not in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-something-02-19-1416\"\n\n        # No .impl/plan-ref.json created\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # No plan-ref.json, so planned/* branch should not produce an entry\n        assert len(mapping) == 0\n\n\nclass TestClosePlan:\n    \"\"\"Tests for close_plan method using HTTP client.\"\"\"\n\n    def test_close_plan_uses_http_client(self, tmp_path: Path) -> None:\n        \"\"\"close_plan should use HTTP client to close issue via API.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        # Configure fake GitHub to return empty PR linkages\n        from erk_shared.gateway.github.fake import FakeGitHub\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        http_client = FakeHttpClient()\n        http_client.set_response(\n            \"repos/test/repo/issues/123\",\n            response={\"state\": \"closed\"},\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=http_client,\n        )\n\n        closed_prs = provider.close_plan(123, \"https://github.com/test/repo/issues/123\")\n\n        # Verify HTTP client was used to close the issue\n        assert len(http_client.requests) == 1\n        request = http_client.requests[0]\n        assert request.method == \"PATCH\"\n        assert request.endpoint == \"repos/test/repo/issues/123\"\n        assert request.data == {\"state\": \"closed\"}\n        assert closed_prs == []\n\n    def test_close_plan_closes_linked_prs(self, tmp_path: Path) -> None:\n        \"\"\"close_plan should close linked PRs before closing issue.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        # Configure fake GitHub to return linked PRs\n        from erk_shared.gateway.github.fake import FakeGitHub\n        from erk_shared.gateway.github.types import PullRequestInfo\n\n        github = FakeGitHub(\n            pr_issue_linkages={\n                123: [\n                    PullRequestInfo(\n                        number=456,\n                        state=\"OPEN\",\n                        url=\"https://github.com/test/repo/pulls/456\",\n                        is_draft=False,\n                        title=\"Fix issue\",\n                        checks_passing=None,\n                        owner=\"test\",\n                        repo=\"repo\",\n                    ),\n                ],\n            }\n        )\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        http_client = FakeHttpClient()\n        http_client.set_response(\n            \"repos/test/repo/pulls/456\",\n            response={\"state\": \"closed\"},\n        )\n        http_client.set_response(\n            \"repos/test/repo/issues/123\",\n            response={\"state\": \"closed\"},\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=http_client,\n        )\n\n        closed_prs = provider.close_plan(123, \"https://github.com/test/repo/issues/123\")\n\n        # Verify HTTP client was used to close PR first, then issue\n        assert len(http_client.requests) == 2\n        assert http_client.requests[0].endpoint == \"repos/test/repo/pulls/456\"\n        assert http_client.requests[1].endpoint == \"repos/test/repo/issues/123\"\n        assert closed_prs == [456]\n\n    def test_parse_owner_repo_from_url(self, tmp_path: Path) -> None:\n        \"\"\"_parse_owner_repo_from_url should extract owner/repo from URL.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        result = provider._parse_owner_repo_from_url(\"https://github.com/owner/repo/issues/123\")\n        assert result == (\"owner\", \"repo\")\n\n        result = provider._parse_owner_repo_from_url(\"https://github.com/anthropic/erk/pulls/456\")\n        assert result == (\"anthropic\", \"erk\")\n\n        # Invalid URL returns None\n        result = provider._parse_owner_repo_from_url(\"invalid\")\n        assert result is None\n\n\nclass TestCommentCountsDisplay:\n    \"\"\"Tests for review comment counts display in _build_row_data.\n\n    Comment counts are now fetched via the batched PR linkages GraphQL query\n    and stored in PullRequestInfo.review_thread_counts as (resolved, total).\n    \"\"\"\n\n    def test_comment_counts_from_pr_data(self, tmp_path: Path) -> None:\n        \"\"\"When PR has review_thread_counts, display as resolved/total.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan and PR linkage with comment counts\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages = {\n            123: [\n                PullRequestInfo(\n                    number=456,\n                    state=\"OPEN\",\n                    url=\"https://github.com/test/repo/pulls/456\",\n                    is_draft=False,\n                    title=\"Fix issue\",\n                    checks_passing=True,\n                    owner=\"test\",\n                    repo=\"repo\",\n                    review_thread_counts=(3, 5),  # 3 resolved out of 5 total\n                ),\n            ],\n        }\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 3\n        assert row.total_comment_count == 5\n        assert row.comments_display == \"3/5\"\n\n    def test_comment_counts_none_shows_zero(self, tmp_path: Path) -> None:\n        \"\"\"When PR has no review_thread_counts (None), display 0/0.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan and PR linkage without comment counts\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages = {\n            123: [\n                PullRequestInfo(\n                    number=456,\n                    state=\"OPEN\",\n                    url=\"https://github.com/test/repo/pulls/456\",\n                    is_draft=False,\n                    title=\"Fix issue\",\n                    checks_passing=True,\n                    owner=\"test\",\n                    repo=\"repo\",\n                    # review_thread_counts defaults to None\n                ),\n            ],\n        }\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 0\n        assert row.total_comment_count == 0\n        assert row.comments_display == \"0/0\"\n\n    def test_no_pr_shows_dash(self, tmp_path: Path) -> None:\n        \"\"\"When plan has no linked PR, display '-' for comments.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan without PR linkage\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages: dict[int, list[PullRequestInfo]] = {}  # No linked PRs\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 0\n        assert row.total_comment_count == 0\n        assert row.comments_display == \"-\"\n\n\nclass TestLearnStatusDisplay:\n    \"\"\"Tests for learn status display in _build_row_data.\"\"\"\n\n    def test_learn_status_none_shows_dash(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is None, display '-'.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan without learn_status metadata\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",  # No metadata block\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status is None\n        assert row.learn_plan_issue is None\n        assert row.learn_plan_pr is None\n        assert row.learn_display == \"- not started\"\n\n    def test_learn_status_pending_shows_spinner(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'pending', display spinner symbol.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: pending in metadata\n        plan_body = format_plan_header_body_for_test(learn_status=\"pending\")\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"pending\"\n        assert row.learn_display == \"⟳ in progress\"\n\n    def test_learn_status_completed_no_plan_shows_empty_set(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'completed_no_plan', display empty set symbol.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_no_plan\n        plan_body = format_plan_header_body_for_test(learn_status=\"completed_no_plan\")\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"completed_no_plan\"\n        assert row.learn_display == \"∅ no insights\"\n\n    def test_learn_status_completed_with_plan_shows_issue_number(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'completed_with_plan', display issue number.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is None\n        assert row.learn_display == \"📋 #456\"\n\n    def test_learn_status_plan_completed_shows_pr_number(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'plan_completed', display checkmark and PR number.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: plan_completed and learn_plan_pr\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"plan_completed\", learn_plan_issue=456, learn_plan_pr=789\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"plan_completed\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_pr == 789\n        assert row.learn_display == \"✓ #789\"\n\n    def test_learn_status_completed_with_plan_closed_shows_checkmark(self, tmp_path: Path) -> None:\n        \"\"\"When learn plan issue is closed, display checkmark instead of clipboard.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime(2024, 1, 1, tzinfo=UTC),\n            updated_at=datetime(2024, 1, 1, tzinfo=UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        # Learn issue 456 is closed\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={456: True},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is True\n        assert row.learn_display == \"✅ #456\"\n        assert row.learn_display_icon == \"✅ #456\"\n\n    def test_learn_status_completed_with_plan_open_shows_clipboard(self, tmp_path: Path) -> None:\n        \"\"\"When learn plan issue is open, display clipboard emoji.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime(2024, 1, 1, tzinfo=UTC),\n            updated_at=datetime(2024, 1, 1, tzinfo=UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        # Learn issue 456 is open\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={456: False},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is False\n        assert row.learn_display == \"📋 #456\"\n        assert row.learn_display_icon == \"📋 #456\"\n","structuredPatch":[{"oldStart":445,"oldLines":7,"newStart":445,"newLines":7,"lines":[" ","         worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"","         worktree_path.mkdir(parents=True)","-        branch_name = \"planned/fix-something-02-19-1416\"","+        branch_name = \"plnd/fix-something-02-19-1416\""," ","         # No .impl/plan-ref.json created"," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"5a8e8233-1564-4f81-a429-8d4616f61bb9","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01B79SNNEp8iUSZgnqVnMJLJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016X1AdyzSXKD8TH8ytSmfR7","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","old_string":"        # No plan-ref.json, so planned/* branch should not produce an entry","new_string":"        # No plan-ref.json, so plnd/* branch should not produce an entry"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":212,"cache_read_input_tokens":118390,"cache_creation":{"ephemeral_5m_input_tokens":212,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHy5ukyw9Gc8soZkrgK","type":"assistant","uuid":"0aeb5b64-3491-45cd-98f6-750cb605b8d1","timestamp":"2026-02-22T14:49:49.960Z"}
{"parentUuid":"0aeb5b64-3491-45cd-98f6-750cb605b8d1","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016X1AdyzSXKD8TH8ytSmfR7","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/tui/data/test_provider.py has been updated successfully."}]},"uuid":"4aba80a2-26b3-4cf7-919c-24d077db0755","timestamp":"2026-02-22T14:49:50.662Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/tui/data/test_provider.py","oldString":"        # No plan-ref.json, so planned/* branch should not produce an entry","newString":"        # No plan-ref.json, so plnd/* branch should not produce an entry","originalFile":"\"\"\"Tests for plan data provider.\"\"\"\n\nimport json\nfrom datetime import UTC, datetime\nfrom pathlib import Path\n\nfrom erk.core.repo_discovery import RepoContext\nfrom erk_shared.gateway.browser.fake import FakeBrowserLauncher\nfrom erk_shared.gateway.clipboard.fake import FakeClipboard\nfrom erk_shared.gateway.git.abc import WorktreeInfo\nfrom erk_shared.gateway.git.fake import FakeGit\nfrom erk_shared.gateway.github.fake import FakeGitHub\nfrom erk_shared.gateway.github.metadata.core import find_metadata_block\nfrom erk_shared.gateway.github.types import (\n    GitHubRepoId,\n    GitHubRepoLocation,\n    PullRequestInfo,\n)\nfrom erk_shared.gateway.http.fake import FakeHttpClient\nfrom erk_shared.gateway.plan_data_provider.real import RealPlanDataProvider\nfrom erk_shared.plan_store.types import Plan, PlanState\nfrom tests.fakes.context import create_test_context\nfrom tests.test_utils.plan_helpers import format_plan_header_body_for_test\n\n\ndef _parse_header_fields(body: str) -> dict[str, object]:\n    \"\"\"Parse header_fields from a plan body for test Plan construction.\"\"\"\n    block = find_metadata_block(body, \"plan-header\")\n    if block is None:\n        return {}\n    return dict(block.data)\n\n\ndef _make_repo_context(repo_root: Path, tmp_path: Path) -> RepoContext:\n    \"\"\"Create a RepoContext for testing.\"\"\"\n    erk_dir = tmp_path / \".erk\"\n    repo_dir = erk_dir / \"repos\" / \"test-repo\"\n    return RepoContext(\n        root=repo_root,\n        repo_name=\"test-repo\",\n        repo_dir=repo_dir,\n        worktrees_dir=repo_dir / \"worktrees\",\n        pool_json_path=repo_dir / \"pool.json\",\n    )\n\n\nclass TestBuildWorktreeMapping:\n    \"\"\"Tests for _build_worktree_mapping method.\"\"\"\n\n    def test_pool_managed_worktree_extracts_from_branch_name(self, tmp_path: Path) -> None:\n        \"\"\"Pool-managed worktree with generic directory name maps via branch.\n\n        The directory name is 'erk-slot-02' (no issue prefix),\n        but the branch name is 'P4280-add-required-kwargs-01-05-2230',\n        so issue 4280 should be extracted from the branch.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        # Create .erk directory to satisfy _ensure_erk_metadata_dir_from_context\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-02\"\n        branch_name = \"P4280-add-required-kwargs-01-05-2230\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Issue 4280 should be extracted from the branch name\n        assert 4280 in mapping\n        worktree_name, worktree_branch = mapping[4280]\n        assert worktree_name == \"erk-slot-02\"\n        assert worktree_branch == branch_name\n\n    def test_issue_named_worktree_extracts_from_branch_name(self, tmp_path: Path) -> None:\n        \"\"\"Issue-named worktree with P-prefixed directory also extracts from branch.\n\n        The directory name is 'P1234-feature-01-01-1200' (has issue prefix),\n        and the branch name matches. Issue 1234 should be extracted from branch.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"P1234-feature-01-01-1200\"\n        branch_name = \"P1234-feature-01-01-1200\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Issue 1234 should be extracted from the branch name\n        assert 1234 in mapping\n        worktree_name, worktree_branch = mapping[1234]\n        assert worktree_name == \"P1234-feature-01-01-1200\"\n        assert worktree_branch == branch_name\n\n    def test_detached_head_worktree_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Worktree with detached HEAD (branch=None) should not be in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        # Detached HEAD worktree has branch=None\n        worktree_path = tmp_path / \"worktrees\" / \"detached-wt\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=None, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Detached HEAD should not produce an entry in mapping\n        assert len(mapping) == 0\n\n    def test_non_plan_branch_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Worktree with non-P-prefixed branch should not be in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"feature-branch\"\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=\"feature-branch\", is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Non-plan branch should not produce an entry\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch (plnd/*) resolved via .impl/plan-ref.json.\n\n        Branch name 'plnd/fix-missing-data-02-19-1416' doesn't contain a\n        numeric issue prefix. The plan ID (PR number) comes from\n        .impl/plan-ref.json inside the worktree directory.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"plnd/fix-missing-data-02-19-1416\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"7624\",\n            \"url\": \"https://github.com/test/repo/pull/7624\",\n            \"created_at\": \"2026-02-19T14:16:00+00:00\",\n            \"synced_at\": \"2026-02-19T14:16:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 7624 should be extracted from .impl/plan-ref.json\n        assert 7624 in mapping\n        worktree_name, worktree_branch = mapping[7624]\n        assert worktree_name == \"erk-slot-05\"\n        assert worktree_branch == branch_name\n\n    def test_legacy_planned_slash_branch_resolved_via_plan_ref_json(self, tmp_path: Path) -> None:\n        \"\"\"Legacy planned/ prefix branch resolved via .impl/plan-ref.json.\n\n        Branch name 'planned/fix-auth-bug-01-15-1430' doesn't contain a\n        numeric issue prefix. The plan ID comes from .impl/plan-ref.json.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-03\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned/fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json on disk (read_plan_ref does direct I/O)\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"8001\",\n            \"url\": \"https://github.com/test/repo/pull/8001\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # Plan ID 8001 should be extracted from .impl/plan-ref.json\n        assert 8001 in mapping\n        worktree_name, worktree_branch = mapping[8001]\n        assert worktree_name == \"erk-slot-03\"\n        assert worktree_branch == branch_name\n\n    def test_planned_hyphen_branch_not_matched(self, tmp_path: Path) -> None:\n        \"\"\"Branch with 'planned-' (hyphen) prefix is NOT matched.\n\n        Only 'plnd/' or 'planned/' (forward slash) is valid. This test ensures\n        the startswith check uses the correct delimiter.\n        \"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-04\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"planned-fix-auth-bug-01-15-1430\"\n\n        # Create .impl/plan-ref.json — should NOT be read because prefix is wrong\n        impl_dir = worktree_path / \".impl\"\n        impl_dir.mkdir()\n        plan_ref_data = {\n            \"provider\": \"github-draft-pr\",\n            \"plan_id\": \"9999\",\n            \"url\": \"https://github.com/test/repo/pull/9999\",\n            \"created_at\": \"2026-01-15T14:30:00+00:00\",\n            \"synced_at\": \"2026-01-15T14:30:00+00:00\",\n            \"labels\": [\"erk-plan\"],\n            \"objective_id\": None,\n        }\n        (impl_dir / \"plan-ref.json\").write_text(json.dumps(plan_ref_data), encoding=\"utf-8\")\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # planned- (hyphen) should NOT be recognized — only plnd/ or planned/ (slash) is valid\n        assert 9999 not in mapping\n        assert len(mapping) == 0\n\n    def test_draft_pr_branch_without_plan_ref_not_in_mapping(self, tmp_path: Path) -> None:\n        \"\"\"Draft PR branch without .impl/plan-ref.json is not in mapping.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        worktree_path = tmp_path / \"worktrees\" / \"erk-slot-05\"\n        worktree_path.mkdir(parents=True)\n        branch_name = \"plnd/fix-something-02-19-1416\"\n\n        # No .impl/plan-ref.json created\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                    WorktreeInfo(path=worktree_path, branch=branch_name, is_root=False),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        mapping = provider._build_worktree_mapping()\n\n        # No plan-ref.json, so planned/* branch should not produce an entry\n        assert len(mapping) == 0\n\n\nclass TestClosePlan:\n    \"\"\"Tests for close_plan method using HTTP client.\"\"\"\n\n    def test_close_plan_uses_http_client(self, tmp_path: Path) -> None:\n        \"\"\"close_plan should use HTTP client to close issue via API.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        # Configure fake GitHub to return empty PR linkages\n        from erk_shared.gateway.github.fake import FakeGitHub\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        http_client = FakeHttpClient()\n        http_client.set_response(\n            \"repos/test/repo/issues/123\",\n            response={\"state\": \"closed\"},\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=http_client,\n        )\n\n        closed_prs = provider.close_plan(123, \"https://github.com/test/repo/issues/123\")\n\n        # Verify HTTP client was used to close the issue\n        assert len(http_client.requests) == 1\n        request = http_client.requests[0]\n        assert request.method == \"PATCH\"\n        assert request.endpoint == \"repos/test/repo/issues/123\"\n        assert request.data == {\"state\": \"closed\"}\n        assert closed_prs == []\n\n    def test_close_plan_closes_linked_prs(self, tmp_path: Path) -> None:\n        \"\"\"close_plan should close linked PRs before closing issue.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        # Configure fake GitHub to return linked PRs\n        from erk_shared.gateway.github.fake import FakeGitHub\n        from erk_shared.gateway.github.types import PullRequestInfo\n\n        github = FakeGitHub(\n            pr_issue_linkages={\n                123: [\n                    PullRequestInfo(\n                        number=456,\n                        state=\"OPEN\",\n                        url=\"https://github.com/test/repo/pulls/456\",\n                        is_draft=False,\n                        title=\"Fix issue\",\n                        checks_passing=None,\n                        owner=\"test\",\n                        repo=\"repo\",\n                    ),\n                ],\n            }\n        )\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        http_client = FakeHttpClient()\n        http_client.set_response(\n            \"repos/test/repo/pulls/456\",\n            response={\"state\": \"closed\"},\n        )\n        http_client.set_response(\n            \"repos/test/repo/issues/123\",\n            response={\"state\": \"closed\"},\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=http_client,\n        )\n\n        closed_prs = provider.close_plan(123, \"https://github.com/test/repo/issues/123\")\n\n        # Verify HTTP client was used to close PR first, then issue\n        assert len(http_client.requests) == 2\n        assert http_client.requests[0].endpoint == \"repos/test/repo/pulls/456\"\n        assert http_client.requests[1].endpoint == \"repos/test/repo/issues/123\"\n        assert closed_prs == [456]\n\n    def test_parse_owner_repo_from_url(self, tmp_path: Path) -> None:\n        \"\"\"_parse_owner_repo_from_url should extract owner/repo from URL.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        ctx = create_test_context(\n            git=git,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        result = provider._parse_owner_repo_from_url(\"https://github.com/owner/repo/issues/123\")\n        assert result == (\"owner\", \"repo\")\n\n        result = provider._parse_owner_repo_from_url(\"https://github.com/anthropic/erk/pulls/456\")\n        assert result == (\"anthropic\", \"erk\")\n\n        # Invalid URL returns None\n        result = provider._parse_owner_repo_from_url(\"invalid\")\n        assert result is None\n\n\nclass TestCommentCountsDisplay:\n    \"\"\"Tests for review comment counts display in _build_row_data.\n\n    Comment counts are now fetched via the batched PR linkages GraphQL query\n    and stored in PullRequestInfo.review_thread_counts as (resolved, total).\n    \"\"\"\n\n    def test_comment_counts_from_pr_data(self, tmp_path: Path) -> None:\n        \"\"\"When PR has review_thread_counts, display as resolved/total.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan and PR linkage with comment counts\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages = {\n            123: [\n                PullRequestInfo(\n                    number=456,\n                    state=\"OPEN\",\n                    url=\"https://github.com/test/repo/pulls/456\",\n                    is_draft=False,\n                    title=\"Fix issue\",\n                    checks_passing=True,\n                    owner=\"test\",\n                    repo=\"repo\",\n                    review_thread_counts=(3, 5),  # 3 resolved out of 5 total\n                ),\n            ],\n        }\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 3\n        assert row.total_comment_count == 5\n        assert row.comments_display == \"3/5\"\n\n    def test_comment_counts_none_shows_zero(self, tmp_path: Path) -> None:\n        \"\"\"When PR has no review_thread_counts (None), display 0/0.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan and PR linkage without comment counts\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages = {\n            123: [\n                PullRequestInfo(\n                    number=456,\n                    state=\"OPEN\",\n                    url=\"https://github.com/test/repo/pulls/456\",\n                    is_draft=False,\n                    title=\"Fix issue\",\n                    checks_passing=True,\n                    owner=\"test\",\n                    repo=\"repo\",\n                    # review_thread_counts defaults to None\n                ),\n            ],\n        }\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 0\n        assert row.total_comment_count == 0\n        assert row.comments_display == \"0/0\"\n\n    def test_no_pr_shows_dash(self, tmp_path: Path) -> None:\n        \"\"\"When plan has no linked PR, display '-' for comments.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Create test plan without PR linkage\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n        pr_linkages: dict[int, list[PullRequestInfo]] = {}  # No linked PRs\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages=pr_linkages,\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.resolved_comment_count == 0\n        assert row.total_comment_count == 0\n        assert row.comments_display == \"-\"\n\n\nclass TestLearnStatusDisplay:\n    \"\"\"Tests for learn status display in _build_row_data.\"\"\"\n\n    def test_learn_status_none_shows_dash(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is None, display '-'.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan without learn_status metadata\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=\"\",  # No metadata block\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status is None\n        assert row.learn_plan_issue is None\n        assert row.learn_plan_pr is None\n        assert row.learn_display == \"- not started\"\n\n    def test_learn_status_pending_shows_spinner(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'pending', display spinner symbol.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: pending in metadata\n        plan_body = format_plan_header_body_for_test(learn_status=\"pending\")\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"pending\"\n        assert row.learn_display == \"⟳ in progress\"\n\n    def test_learn_status_completed_no_plan_shows_empty_set(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'completed_no_plan', display empty set symbol.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_no_plan\n        plan_body = format_plan_header_body_for_test(learn_status=\"completed_no_plan\")\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"completed_no_plan\"\n        assert row.learn_display == \"∅ no insights\"\n\n    def test_learn_status_completed_with_plan_shows_issue_number(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'completed_with_plan', display issue number.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is None\n        assert row.learn_display == \"📋 #456\"\n\n    def test_learn_status_plan_completed_shows_pr_number(self, tmp_path: Path) -> None:\n        \"\"\"When learn_status is 'plan_completed', display checkmark and PR number.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: plan_completed and learn_plan_pr\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"plan_completed\", learn_plan_issue=456, learn_plan_pr=789\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime.now(UTC),\n            updated_at=datetime.now(UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={},\n        )\n\n        assert row.learn_status == \"plan_completed\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_pr == 789\n        assert row.learn_display == \"✓ #789\"\n\n    def test_learn_status_completed_with_plan_closed_shows_checkmark(self, tmp_path: Path) -> None:\n        \"\"\"When learn plan issue is closed, display checkmark instead of clipboard.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime(2024, 1, 1, tzinfo=UTC),\n            updated_at=datetime(2024, 1, 1, tzinfo=UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        # Learn issue 456 is closed\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={456: True},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is True\n        assert row.learn_display == \"✅ #456\"\n        assert row.learn_display_icon == \"✅ #456\"\n\n    def test_learn_status_completed_with_plan_open_shows_clipboard(self, tmp_path: Path) -> None:\n        \"\"\"When learn plan issue is open, display clipboard emoji.\"\"\"\n        repo_root = tmp_path / \"repo\"\n        repo_root.mkdir()\n        erk_dir = repo_root / \".erk\"\n        erk_dir.mkdir()\n\n        git = FakeGit(\n            worktrees={\n                repo_root: [\n                    WorktreeInfo(path=repo_root, branch=\"main\", is_root=True),\n                ]\n            },\n            git_common_dirs={repo_root: repo_root / \".git\"},\n        )\n\n        github = FakeGitHub(pr_issue_linkages={})\n\n        ctx = create_test_context(\n            git=git,\n            github=github,\n            cwd=repo_root,\n            repo=_make_repo_context(repo_root, tmp_path),\n        )\n\n        location = GitHubRepoLocation(\n            root=repo_root,\n            repo_id=GitHubRepoId(owner=\"test\", repo=\"repo\"),\n        )\n        provider = RealPlanDataProvider(\n            ctx=ctx,\n            location=location,\n            clipboard=FakeClipboard(),\n            browser=FakeBrowserLauncher(),\n            http_client=FakeHttpClient(),\n        )\n\n        # Plan with learn_status: completed_with_plan and learn_plan_issue\n        plan_body = format_plan_header_body_for_test(\n            learn_status=\"completed_with_plan\", learn_plan_issue=456\n        )\n        plan = Plan(\n            plan_identifier=\"123\",\n            title=\"Test Plan\",\n            body=plan_body,\n            state=PlanState.OPEN,\n            url=\"https://github.com/test/repo/issues/123\",\n            labels=[],\n            assignees=[],\n            created_at=datetime(2024, 1, 1, tzinfo=UTC),\n            updated_at=datetime(2024, 1, 1, tzinfo=UTC),\n            metadata={},\n            objective_id=None,\n            header_fields=_parse_header_fields(plan_body),\n        )\n\n        # Learn issue 456 is open\n        row = provider._build_row_data(\n            plan=plan,\n            plan_id=123,\n            pr_linkages={},\n            workflow_run=None,\n            worktree_by_plan_id={},\n            use_graphite=False,\n            learn_issue_states={456: False},\n        )\n\n        assert row.learn_status == \"completed_with_plan\"\n        assert row.learn_plan_issue == 456\n        assert row.learn_plan_issue_closed is False\n        assert row.learn_display == \"📋 #456\"\n        assert row.learn_display_icon == \"📋 #456\"\n","structuredPatch":[{"oldStart":479,"oldLines":7,"newStart":479,"newLines":7,"lines":[" ","         mapping = provider._build_worktree_mapping()"," ","-        # No plan-ref.json, so planned/* branch should not produce an entry","+        # No plan-ref.json, so plnd/* branch should not produce an entry","         assert len(mapping) == 0"," "," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"4aba80a2-26b3-4cf7-919c-24d077db0755","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01H1AHqQu9xd9oYhNp1ezMRM","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the fake_git test:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":531,"cache_read_input_tokens":118602,"cache_creation":{"ephemeral_5m_input_tokens":531,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHyRmrLB2YLT92UYWsx","type":"assistant","uuid":"7cf02b85-d14f-45e6-961d-c1dfd2cc9e70","timestamp":"2026-02-22T14:49:53.195Z"}
{"parentUuid":"7cf02b85-d14f-45e6-961d-c1dfd2cc9e70","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01H1AHqQu9xd9oYhNp1ezMRM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y5bCbdsb8KRP7pHXfQebhL","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/fakes/test_fake_git.py","offset":505,"limit":20},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":531,"cache_read_input_tokens":118602,"cache_creation":{"ephemeral_5m_input_tokens":531,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHyRmrLB2YLT92UYWsx","type":"assistant","uuid":"31d7bbc4-581f-40c8-86ac-b017e5971b6b","timestamp":"2026-02-22T14:49:54.091Z"}
{"parentUuid":"31d7bbc4-581f-40c8-86ac-b017e5971b6b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y5bCbdsb8KRP7pHXfQebhL","type":"tool_result","content":"   505→    git_ops = FakeGit()\n   506→\n   507→    git_ops.commit.commit_files_to_branch(\n   508→        cwd,\n   509→        branch=\"planned/my-feature\",\n   510→        files={\"dir/plan.md\": \"# Plan\", \"dir/ref.json\": '{\"key\": \"value\"}'},\n   511→        message=\"Add plan: My Feature\",\n   512→    )\n   513→\n   514→    assert len(git_ops.branch_commits) == 1\n   515→    record = git_ops.branch_commits[0]\n   516→    assert record.cwd == cwd\n   517→    assert record.branch == \"planned/my-feature\"\n   518→    assert record.files == {\"dir/plan.md\": \"# Plan\", \"dir/ref.json\": '{\"key\": \"value\"}'}\n   519→    assert record.message == \"Add plan: My Feature\"\n   520→\n   521→\n   522→def test_fake_git_commit_files_to_branch_multiple_commits() -> None:\n   523→    \"\"\"Test multiple branch commits are tracked independently.\"\"\"\n   524→    cwd = Path(\"/repo\")\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e43b4c37-9e17-4ab8-a76d-5135accd007c","timestamp":"2026-02-22T14:49:54.118Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/tests/unit/fakes/test_fake_git.py","content":"    git_ops = FakeGit()\n\n    git_ops.commit.commit_files_to_branch(\n        cwd,\n        branch=\"planned/my-feature\",\n        files={\"dir/plan.md\": \"# Plan\", \"dir/ref.json\": '{\"key\": \"value\"}'},\n        message=\"Add plan: My Feature\",\n    )\n\n    assert len(git_ops.branch_commits) == 1\n    record = git_ops.branch_commits[0]\n    assert record.cwd == cwd\n    assert record.branch == \"planned/my-feature\"\n    assert record.files == {\"dir/plan.md\": \"# Plan\", \"dir/ref.json\": '{\"key\": \"value\"}'}\n    assert record.message == \"Add plan: My Feature\"\n\n\ndef test_fake_git_commit_files_to_branch_multiple_commits() -> None:\n    \"\"\"Test multiple branch commits are tracked independently.\"\"\"\n    cwd = Path(\"/repo\")","numLines":20,"startLine":505,"totalLines":659}}}
{"parentUuid":"e43b4c37-9e17-4ab8-a76d-5135accd007c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_018ZkjPdCmG7SRGGPiXRUpkf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0158XCCGoaA28RnwoMhXLksU","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/fakes/test_fake_git.py","old_string":"        branch=\"planned/my-feature\",","new_string":"        branch=\"plnd/my-feature\","},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":506,"cache_read_input_tokens":119133,"cache_creation":{"ephemeral_5m_input_tokens":506,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHygMCTud7q4rDpZXup","type":"assistant","uuid":"02eaef12-c33b-43ad-8b94-654999e72188","timestamp":"2026-02-22T14:49:58.027Z"}
{"parentUuid":"02eaef12-c33b-43ad-8b94-654999e72188","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0158XCCGoaA28RnwoMhXLksU","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/unit/fakes/test_fake_git.py has been updated successfully."}]},"uuid":"d5b18703-3fc0-4c22-9705-400d931f89de","timestamp":"2026-02-22T14:49:58.716Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/unit/fakes/test_fake_git.py","oldString":"        branch=\"planned/my-feature\",","newString":"        branch=\"plnd/my-feature\",","originalFile":"\"\"\"Tests for FakeGit test infrastructure.\n\nThese tests verify that FakeGit correctly simulates git behavior,\ntracks mutations, and provides reliable test doubles for CLI tests.\n\"\"\"\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom erk_shared.gateway.git.abc import BranchDivergence, WorktreeInfo\nfrom erk_shared.gateway.git.branch_ops.types import BranchAlreadyExists, BranchCreated\nfrom erk_shared.gateway.git.fake import FakeGit\n\n\ndef test_fake_gitops_list_worktrees() -> None:\n    \"\"\"Test that FakeGit lists pre-configured worktrees.\"\"\"\n    repo_root = Path(\"/repo\")\n    wt1 = Path(\"/repo/wt1\")\n    wt2 = Path(\"/repo/wt2\")\n\n    worktrees = {\n        repo_root: [\n            WorktreeInfo(path=repo_root, branch=\"main\"),\n            WorktreeInfo(path=wt1, branch=\"feature-1\"),\n            WorktreeInfo(path=wt2, branch=\"feature-2\"),\n        ]\n    }\n\n    git_ops = FakeGit(worktrees=worktrees)\n    result = git_ops.worktree.list_worktrees(repo_root)\n\n    assert len(result) == 3\n    assert result[0].path == repo_root\n    assert result[1].path == wt1\n    assert result[2].path == wt2\n\n\ndef test_fake_gitops_add_worktree(tmp_path: Path) -> None:\n    \"\"\"Test that FakeGit can add worktrees (in-memory only, no filesystem operations).\"\"\"\n    repo_root = tmp_path / \"repo\"\n    repo_root.mkdir()\n    git_ops = FakeGit()\n\n    new_wt = repo_root / \"new-wt\"\n    git_ops.worktree.add_worktree(\n        repo_root, new_wt, branch=\"new-branch\", ref=None, create_branch=True\n    )\n\n    worktrees = git_ops.worktree.list_worktrees(repo_root)\n    assert len(worktrees) == 1\n    assert worktrees[0].path == new_wt\n    assert worktrees[0].branch == \"new-branch\"\n    # FakeGit is purely in-memory - does not create directories\n\n\ndef test_fake_gitops_remove_worktree() -> None:\n    \"\"\"Test that FakeGit can remove worktrees.\"\"\"\n    repo_root = Path(\"/repo\")\n    wt1 = Path(\"/repo/wt1\")\n\n    git_ops = FakeGit(\n        worktrees={\n            repo_root: [\n                WorktreeInfo(path=wt1, branch=\"feature-1\"),\n            ]\n        }\n    )\n\n    git_ops.worktree.remove_worktree(repo_root, wt1, force=False)\n\n    worktrees = git_ops.worktree.list_worktrees(repo_root)\n    assert len(worktrees) == 0\n\n\ndef test_fake_gitops_get_current_branch() -> None:\n    \"\"\"Test that FakeGit returns configured current branch.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(current_branches={cwd: \"feature-branch\"})\n\n    branch = git_ops.branch.get_current_branch(cwd)\n    assert branch == \"feature-branch\"\n\n\ndef test_fake_gitops_get_default_branch() -> None:\n    \"\"\"Test that FakeGit returns configured trunk branch.\"\"\"\n    repo_root = Path(\"/repo\")\n    git_ops = FakeGit(trunk_branches={repo_root: \"main\"})\n\n    branch = git_ops.branch.detect_trunk_branch(repo_root)\n    assert branch == \"main\"\n\n\ndef test_fake_gitops_get_git_common_dir() -> None:\n    \"\"\"Test that FakeGit returns configured git common dir.\"\"\"\n    cwd = Path(\"/repo\")\n    git_dir = Path(\"/repo/.git\")\n\n    git_ops = FakeGit(git_common_dirs={cwd: git_dir})\n\n    common_dir = git_ops.repo.get_git_common_dir(cwd)\n    assert common_dir == git_dir\n\n\ndef test_fake_gitops_detached_head() -> None:\n    \"\"\"Test FakeGit with detached HEAD (None branch).\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(current_branches={cwd: None})\n\n    branch = git_ops.branch.get_current_branch(cwd)\n    assert branch is None\n\n\ndef test_fake_gitops_worktree_not_found() -> None:\n    \"\"\"Test FakeGit when worktree not found.\"\"\"\n    repo_root = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    worktrees = git_ops.worktree.list_worktrees(repo_root)\n    assert len(worktrees) == 0\n\n\ndef test_fake_gitops_has_uncommitted_changes_no_changes() -> None:\n    \"\"\"Test has_uncommitted_changes returns False when no changes.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([], [], [])})\n\n    assert not git_ops.status.has_uncommitted_changes(cwd)\n\n\ndef test_fake_gitops_has_uncommitted_changes_staged() -> None:\n    \"\"\"Test has_uncommitted_changes returns True when staged changes exist.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([\"file.txt\"], [], [])})\n\n    assert git_ops.status.has_uncommitted_changes(cwd)\n\n\ndef test_fake_gitops_has_uncommitted_changes_modified() -> None:\n    \"\"\"Test has_uncommitted_changes returns True when modified changes exist.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([], [\"file.txt\"], [])})\n\n    assert git_ops.status.has_uncommitted_changes(cwd)\n\n\ndef test_fake_gitops_has_uncommitted_changes_untracked() -> None:\n    \"\"\"Test has_uncommitted_changes returns True when untracked files exist.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([], [], [\"file.txt\"])})\n\n    assert git_ops.status.has_uncommitted_changes(cwd)\n\n\ndef test_fake_gitops_has_uncommitted_changes_all_types() -> None:\n    \"\"\"Test has_uncommitted_changes with all types of changes.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([\"staged.txt\"], [\"modified.txt\"], [\"untracked.txt\"])})\n\n    assert git_ops.status.has_uncommitted_changes(cwd)\n\n\ndef test_fake_gitops_has_uncommitted_changes_unknown_path() -> None:\n    \"\"\"Test has_uncommitted_changes returns False for unknown path.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    assert not git_ops.status.has_uncommitted_changes(cwd)\n\n\n# ========================================\n# Critical Gap Tests: High-Risk Methods\n# ========================================\n\n\ndef test_fake_gitops_get_file_status_empty() -> None:\n    \"\"\"Test get_file_status with no changes.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([], [], [])})\n\n    staged, modified, untracked = git_ops.status.get_file_status(cwd)\n\n    assert staged == []\n    assert modified == []\n    assert untracked == []\n\n\ndef test_fake_gitops_get_file_status_staged_only() -> None:\n    \"\"\"Test get_file_status with only staged files.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([\"file.txt\"], [], [])})\n\n    staged, modified, untracked = git_ops.status.get_file_status(cwd)\n\n    assert staged == [\"file.txt\"]\n    assert modified == []\n    assert untracked == []\n\n\ndef test_fake_gitops_get_file_status_modified_only() -> None:\n    \"\"\"Test get_file_status with only modified files.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([], [\"file.txt\"], [])})\n\n    staged, modified, untracked = git_ops.status.get_file_status(cwd)\n\n    assert staged == []\n    assert modified == [\"file.txt\"]\n    assert untracked == []\n\n\ndef test_fake_gitops_get_file_status_untracked_only() -> None:\n    \"\"\"Test get_file_status with only untracked files.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([], [], [\"file.txt\"])})\n\n    staged, modified, untracked = git_ops.status.get_file_status(cwd)\n\n    assert staged == []\n    assert modified == []\n    assert untracked == [\"file.txt\"]\n\n\ndef test_fake_gitops_get_file_status_mixed() -> None:\n    \"\"\"Test get_file_status with all change types.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([\"a.txt\"], [\"b.txt\"], [\"c.txt\"])})\n\n    staged, modified, untracked = git_ops.status.get_file_status(cwd)\n\n    assert staged == [\"a.txt\"]\n    assert modified == [\"b.txt\"]\n    assert untracked == [\"c.txt\"]\n\n\ndef test_fake_gitops_move_worktree(tmp_path: Path) -> None:\n    \"\"\"Test move_worktree updates state (in-memory only, no filesystem operations).\"\"\"\n    repo_root = tmp_path / \"repo\"\n    old_wt = tmp_path / \"old-wt\"\n    new_wt = tmp_path / \"new-wt\"\n\n    git_ops = FakeGit(\n        worktrees={repo_root: [WorktreeInfo(path=old_wt, branch=\"feature\", is_root=False)]}\n    )\n\n    git_ops.worktree.move_worktree(repo_root, old_wt, new_wt)\n\n    # Verify state updated\n    worktrees = git_ops.worktree.list_worktrees(repo_root)\n    assert len(worktrees) == 1\n    assert worktrees[0].path == new_wt\n    assert worktrees[0].branch == \"feature\"\n\n    # FakeGit is purely in-memory - does not rename directories\n\n\ndef test_fake_gitops_get_branch_head() -> None:\n    \"\"\"Test get_branch_head returns commit SHA from dict.\"\"\"\n    repo_root = Path(\"/repo\")\n    git_ops = FakeGit(branch_heads={\"main\": \"abc123\", \"feature\": \"def456\"})\n\n    assert git_ops.branch.get_branch_head(repo_root, \"main\") == \"abc123\"\n    assert git_ops.branch.get_branch_head(repo_root, \"feature\") == \"def456\"\n    assert git_ops.branch.get_branch_head(repo_root, \"nonexistent\") is None\n\n\ndef test_fake_gitops_get_commit_message() -> None:\n    \"\"\"Test get_commit_message returns message from dict via commit subgateway.\"\"\"\n    repo_root = Path(\"/repo\")\n    git_ops = FakeGit(commit_messages={\"abc123\": \"Initial commit\", \"def456\": \"Add feature\"})\n\n    assert git_ops.commit.get_commit_message(repo_root, \"abc123\") == \"Initial commit\"\n    assert git_ops.commit.get_commit_message(repo_root, \"def456\") == \"Add feature\"\n    assert git_ops.commit.get_commit_message(repo_root, \"unknown\") is None\n\n\ndef test_fake_gitops_get_ahead_behind() -> None:\n    \"\"\"Test get_ahead_behind returns (ahead, behind) tuple.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(\n        ahead_behind={\n            (cwd, \"main\"): (0, 0),\n            (cwd, \"feature\"): (3, 1),\n        }\n    )\n\n    assert git_ops.branch.get_ahead_behind(cwd, \"main\") == (0, 0)\n    assert git_ops.branch.get_ahead_behind(cwd, \"feature\") == (3, 1)\n    assert git_ops.branch.get_ahead_behind(cwd, \"unknown\") == (0, 0)\n\n\ndef test_fake_gitops_get_recent_commits() -> None:\n    \"\"\"Test get_recent_commits returns commit list with limit.\"\"\"\n    cwd = Path(\"/repo\")\n    commits = [\n        {\"sha\": \"abc123\", \"message\": \"Commit 1\"},\n        {\"sha\": \"def456\", \"message\": \"Commit 2\"},\n        {\"sha\": \"ghi789\", \"message\": \"Commit 3\"},\n        {\"sha\": \"jkl012\", \"message\": \"Commit 4\"},\n        {\"sha\": \"mno345\", \"message\": \"Commit 5\"},\n        {\"sha\": \"pqr678\", \"message\": \"Commit 6\"},\n    ]\n    git_ops = FakeGit(recent_commits={cwd: commits})\n\n    # Default limit is 5\n    result = git_ops.commit.get_recent_commits(cwd, limit=5)\n    assert len(result) == 5\n    assert result[0][\"sha\"] == \"abc123\"\n\n    # Custom limit\n    result = git_ops.commit.get_recent_commits(cwd, limit=3)\n    assert len(result) == 3\n\n    # No commits configured\n    result = git_ops.commit.get_recent_commits(Path(\"/other\"), limit=5)\n    assert result == []\n\n\ndef test_fake_gitops_prune_worktrees_noop() -> None:\n    \"\"\"Test prune_worktrees is a no-op (doesn't crash).\"\"\"\n    repo_root = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    # Should not raise\n    git_ops.worktree.prune_worktrees(repo_root)\n\n\ndef test_fake_gitops_removed_worktrees_tracking() -> None:\n    \"\"\"Test removed_worktrees tracking property updates on remove.\"\"\"\n    repo_root = Path(\"/repo\")\n    wt1 = Path(\"/repo/wt1\")\n    wt2 = Path(\"/repo/wt2\")\n\n    git_ops = FakeGit(\n        worktrees={\n            repo_root: [\n                WorktreeInfo(path=wt1, branch=\"feat-1\", is_root=False),\n                WorktreeInfo(path=wt2, branch=\"feat-2\", is_root=False),\n            ]\n        }\n    )\n\n    git_ops.worktree.remove_worktree(repo_root, wt1, force=False)\n    git_ops.worktree.remove_worktree(repo_root, wt2, force=False)\n\n    assert wt1 in git_ops.removed_worktrees\n    assert wt2 in git_ops.removed_worktrees\n    assert len(git_ops.removed_worktrees) == 2\n\n\ndef test_fake_gitops_remove_worktree_error_injection() -> None:\n    \"\"\"Test that FakeGit raises RuntimeError when remove_worktree_error is configured.\"\"\"\n    repo_root = Path(\"/repo\")\n    wt1 = Path(\"/repo/wt1\")\n\n    git_ops = FakeGit(\n        worktrees={\n            repo_root: [\n                WorktreeInfo(path=wt1, branch=\"feature-1\"),\n            ]\n        },\n        remove_worktree_error=\"Failed to remove worktree\",\n    )\n\n    with pytest.raises(RuntimeError, match=\"Failed to remove worktree\"):\n        git_ops.worktree.remove_worktree(repo_root, wt1, force=False)\n\n    # Worktree should not have been removed\n    worktrees = git_ops.worktree.list_worktrees(repo_root)\n    assert len(worktrees) == 1\n\n\ndef test_fake_git_is_worktree_clean_with_clean_worktree() -> None:\n    \"\"\"Test that is_worktree_clean returns True for clean worktree.\"\"\"\n    worktree_path = Path(\"/repo/worktree\")\n    git_ops = FakeGit(\n        existing_paths={worktree_path},\n    )\n\n    result = git_ops.worktree.is_worktree_clean(worktree_path)\n    assert result is True\n\n\ndef test_fake_git_is_worktree_clean_with_uncommitted_changes() -> None:\n    \"\"\"Test that is_worktree_clean returns False for dirty worktree.\"\"\"\n    worktree_path = Path(\"/repo/worktree\")\n    git_ops = FakeGit(\n        existing_paths={worktree_path},\n        dirty_worktrees={worktree_path},\n    )\n\n    result = git_ops.worktree.is_worktree_clean(worktree_path)\n    assert result is False\n\n\ndef test_fake_git_is_worktree_clean_with_nonexistent_path() -> None:\n    \"\"\"Test that is_worktree_clean returns False for nonexistent path.\"\"\"\n    worktree_path = Path(\"/repo/nonexistent\")\n    git_ops = FakeGit()\n\n    result = git_ops.worktree.is_worktree_clean(worktree_path)\n    assert result is False\n\n\n# ============================================================================\n# Branch-Issue Extraction Tests\n# ============================================================================\n\n\ndef test_fake_git_get_branch_issue_extracts_from_branch_name() -> None:\n    \"\"\"Test get_branch_issue extracts issue number from branch name prefix.\"\"\"\n    git_ops = FakeGit()\n\n    # Branch names with P-prefixed issue number (new format uses uppercase P)\n    assert (\n        git_ops.branch.get_branch_issue(\n            Path(\"/repo\"), \"P2382-convert-erk-create-raw-ext-12-05-2359\"\n        )\n        == 2382\n    )\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"P42-fix-bug\") == 42\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"P123-feature-name\") == 123\n    # Lowercase p also supported for backwards compatibility\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"p100-lowercase-prefix\") == 100\n\n    # Branch names with legacy format (no P prefix, backwards compatibility)\n    assert (\n        git_ops.branch.get_branch_issue(Path(\"/repo\"), \"2382-convert-erk-create-raw-ext-12-05-2359\")\n        == 2382\n    )\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"42-fix-bug\") == 42\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"123-feature-name\") == 123\n\n\ndef test_fake_git_get_branch_issue_returns_none_for_no_prefix() -> None:\n    \"\"\"Test get_branch_issue returns None when branch has no issue number prefix.\"\"\"\n    git_ops = FakeGit()\n\n    # Branch names without issue number prefix\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"feature-branch\") is None\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"master\") is None\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"main\") is None\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"develop\") is None\n\n\ndef test_fake_git_get_branch_issue_requires_hyphen_after_number() -> None:\n    \"\"\"Test get_branch_issue requires hyphen after issue number.\"\"\"\n    git_ops = FakeGit()\n\n    # Numbers without trailing hyphen are not issue numbers\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"123\") is None\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"v2.0.0\") is None\n\n\n# ============================================================================\n# Commit Messages Since Tests\n# ============================================================================\n\n\ndef test_fake_git_get_commit_messages_since_returns_configured_messages() -> None:\n    \"\"\"Test get_commit_messages_since returns configured commit messages.\"\"\"\n    cwd = Path(\"/repo\")\n    messages = [\n        \"Initial commit\\n\\nThis is the body of the first commit.\",\n        \"Add feature\\n\\nImplemented new feature X.\",\n        \"Fix bug\",\n    ]\n    git_ops = FakeGit(commit_messages_since={(cwd, \"main\"): messages})\n\n    result = git_ops.commit.get_commit_messages_since(cwd, \"main\")\n\n    assert result == messages\n\n\ndef test_fake_git_get_commit_messages_since_returns_empty_for_unknown_branch() -> None:\n    \"\"\"Test get_commit_messages_since returns empty list for unknown branch.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    result = git_ops.commit.get_commit_messages_since(cwd, \"main\")\n\n    assert result == []\n\n\ndef test_fake_git_get_commit_messages_since_returns_empty_for_unknown_cwd() -> None:\n    \"\"\"Test get_commit_messages_since returns empty list for unknown cwd.\"\"\"\n    cwd = Path(\"/repo\")\n    other_cwd = Path(\"/other\")\n    messages = [\"Some commit\"]\n    git_ops = FakeGit(commit_messages_since={(cwd, \"main\"): messages})\n\n    result = git_ops.commit.get_commit_messages_since(other_cwd, \"main\")\n\n    assert result == []\n\n\n# ============================================================================\n# Branch Commit Tests (commit_files_to_branch)\n# ============================================================================\n\n\ndef test_fake_git_commit_files_to_branch_tracks_record() -> None:\n    \"\"\"Test commit_files_to_branch records a BranchCommitRecord.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    git_ops.commit.commit_files_to_branch(\n        cwd,\n        branch=\"planned/my-feature\",\n        files={\"dir/plan.md\": \"# Plan\", \"dir/ref.json\": '{\"key\": \"value\"}'},\n        message=\"Add plan: My Feature\",\n    )\n\n    assert len(git_ops.branch_commits) == 1\n    record = git_ops.branch_commits[0]\n    assert record.cwd == cwd\n    assert record.branch == \"planned/my-feature\"\n    assert record.files == {\"dir/plan.md\": \"# Plan\", \"dir/ref.json\": '{\"key\": \"value\"}'}\n    assert record.message == \"Add plan: My Feature\"\n\n\ndef test_fake_git_commit_files_to_branch_multiple_commits() -> None:\n    \"\"\"Test multiple branch commits are tracked independently.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    git_ops.commit.commit_files_to_branch(\n        cwd, branch=\"branch-a\", files={\"a.txt\": \"A\"}, message=\"First\"\n    )\n    git_ops.commit.commit_files_to_branch(\n        cwd, branch=\"branch-b\", files={\"b.txt\": \"B\"}, message=\"Second\"\n    )\n\n    assert len(git_ops.branch_commits) == 2\n    assert git_ops.branch_commits[0].branch == \"branch-a\"\n    assert git_ops.branch_commits[1].branch == \"branch-b\"\n\n\ndef test_fake_git_commit_files_to_branch_does_not_affect_regular_commits() -> None:\n    \"\"\"Test that branch commits and regular commits are tracked separately.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    git_ops.commit.commit_files_to_branch(\n        cwd, branch=\"feature\", files={\"f.txt\": \"content\"}, message=\"Branch commit\"\n    )\n    git_ops.commit.commit(cwd, \"Regular commit\")\n\n    assert len(git_ops.branch_commits) == 1\n    assert len(git_ops.commits) == 1\n    assert git_ops.branch_commits[0].message == \"Branch commit\"\n    assert git_ops.commits[0].message == \"Regular commit\"\n\n\n# ============================================================================\n# Branch Divergence Tests\n# ============================================================================\n\n\ndef test_fake_git_is_branch_diverged_returns_configured_divergence() -> None:\n    \"\"\"Test is_branch_diverged_from_remote returns configured divergence state.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(\n        branch_divergence={\n            (cwd, \"feature\", \"origin\"): BranchDivergence(is_diverged=True, ahead=3, behind=2)\n        }\n    )\n\n    result = git_ops.branch.is_branch_diverged_from_remote(cwd, \"feature\", \"origin\")\n\n    assert result.is_diverged is True\n    assert result.ahead == 3\n    assert result.behind == 2\n\n\ndef test_fake_git_is_branch_diverged_returns_default_for_unconfigured() -> None:\n    \"\"\"Test is_branch_diverged_from_remote returns default for unconfigured branch.\"\"\"\n    git_ops = FakeGit()\n\n    result = git_ops.branch.is_branch_diverged_from_remote(Path(\"/repo\"), \"feature\", \"origin\")\n\n    assert result.is_diverged is False\n    assert result.ahead == 0\n    assert result.behind == 0\n\n\ndef test_fake_git_is_branch_diverged_not_diverged_when_only_ahead() -> None:\n    \"\"\"Test is_branch_diverged_from_remote with only ahead commits (not diverged).\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(\n        branch_divergence={\n            (cwd, \"feature\", \"origin\"): BranchDivergence(is_diverged=False, ahead=3, behind=0)\n        }\n    )\n\n    result = git_ops.branch.is_branch_diverged_from_remote(cwd, \"feature\", \"origin\")\n\n    assert result.is_diverged is False\n    assert result.ahead == 3\n    assert result.behind == 0\n\n\n# ============================================================================\n# Discriminated Union Return Types Tests\n# ============================================================================\n\n\ndef test_fake_create_branch_returns_branch_created() -> None:\n    \"\"\"Test that FakeGitBranchOps.create_branch returns BranchCreated on success.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    result = git_ops.branch.create_branch(cwd, \"feature\", \"main\", force=False)\n\n    assert isinstance(result, BranchCreated)\n\n\ndef test_fake_create_branch_returns_error_when_configured() -> None:\n    \"\"\"Test that FakeGitBranchOps.create_branch returns BranchAlreadyExists when configured.\"\"\"\n    cwd = Path(\"/repo\")\n    error = BranchAlreadyExists(branch_name=\"feature\", message=\"branch 'feature' already exists\")\n    git_ops = FakeGit(create_branch_error=error)\n\n    result = git_ops.branch.create_branch(cwd, \"feature\", \"main\", force=False)\n\n    assert isinstance(result, BranchAlreadyExists)\n    assert result.branch_name == \"feature\"\n    assert result.error_type == \"branch-already-exists\"\n\n\ndef test_fake_add_worktree_succeeds(tmp_path: Path) -> None:\n    \"\"\"Test that FakeWorktree.add_worktree succeeds without error.\"\"\"\n    repo_root = tmp_path / \"repo\"\n    repo_root.mkdir()\n    git_ops = FakeGit()\n\n    new_wt = repo_root / \"new-wt\"\n    git_ops.worktree.add_worktree(\n        repo_root, new_wt, branch=\"new-branch\", ref=None, create_branch=True\n    )\n\n    # Verify worktree was added\n    worktrees = git_ops.worktree.list_worktrees(repo_root)\n    assert len(worktrees) == 1\n    assert worktrees[0].branch == \"new-branch\"\n\n\ndef test_fake_add_worktree_raises_when_error_configured(tmp_path: Path) -> None:\n    \"\"\"Test that FakeWorktree.add_worktree raises RuntimeError when configured.\"\"\"\n    repo_root = tmp_path / \"repo\"\n    repo_root.mkdir()\n    git_ops = FakeGit(add_worktree_error=\"worktree add failed: path already exists\")\n\n    new_wt = repo_root / \"new-wt\"\n    with pytest.raises(RuntimeError, match=\"path already exists\"):\n        git_ops.worktree.add_worktree(\n            repo_root, new_wt, branch=\"new-branch\", ref=None, create_branch=True\n        )\n","structuredPatch":[{"oldStart":506,"oldLines":7,"newStart":506,"newLines":7,"lines":[" ","     git_ops.commit.commit_files_to_branch(","         cwd,","-        branch=\"planned/my-feature\",","+        branch=\"plnd/my-feature\",","         files={\"dir/plan.md\": \"# Plan\", \"dir/ref.json\": '{\"key\": \"value\"}'},","         message=\"Add plan: My Feature\",","     )"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"d5b18703-3fc0-4c22-9705-400d931f89de","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Uu8Ttq3xPks85oRqqR8S7v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017PGpvkNEpfAf48XPTWc8Gr","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/tests/unit/fakes/test_fake_git.py","old_string":"    assert record.branch == \"planned/my-feature\"","new_string":"    assert record.branch == \"plnd/my-feature\""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":517,"cache_read_input_tokens":119639,"cache_creation":{"ephemeral_5m_input_tokens":517,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHz266pHXgqftPWueDx","type":"assistant","uuid":"112e529f-16f7-42bf-909b-5c2edc5ce33c","timestamp":"2026-02-22T14:50:04.772Z"}
{"parentUuid":"112e529f-16f7-42bf-909b-5c2edc5ce33c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017PGpvkNEpfAf48XPTWc8Gr","type":"tool_result","content":"The file /home/runner/work/erk/erk/tests/unit/fakes/test_fake_git.py has been updated successfully."}]},"uuid":"fb93f353-af59-49a0-aa57-dfc7720db227","timestamp":"2026-02-22T14:50:05.672Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/tests/unit/fakes/test_fake_git.py","oldString":"    assert record.branch == \"planned/my-feature\"","newString":"    assert record.branch == \"plnd/my-feature\"","originalFile":"\"\"\"Tests for FakeGit test infrastructure.\n\nThese tests verify that FakeGit correctly simulates git behavior,\ntracks mutations, and provides reliable test doubles for CLI tests.\n\"\"\"\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom erk_shared.gateway.git.abc import BranchDivergence, WorktreeInfo\nfrom erk_shared.gateway.git.branch_ops.types import BranchAlreadyExists, BranchCreated\nfrom erk_shared.gateway.git.fake import FakeGit\n\n\ndef test_fake_gitops_list_worktrees() -> None:\n    \"\"\"Test that FakeGit lists pre-configured worktrees.\"\"\"\n    repo_root = Path(\"/repo\")\n    wt1 = Path(\"/repo/wt1\")\n    wt2 = Path(\"/repo/wt2\")\n\n    worktrees = {\n        repo_root: [\n            WorktreeInfo(path=repo_root, branch=\"main\"),\n            WorktreeInfo(path=wt1, branch=\"feature-1\"),\n            WorktreeInfo(path=wt2, branch=\"feature-2\"),\n        ]\n    }\n\n    git_ops = FakeGit(worktrees=worktrees)\n    result = git_ops.worktree.list_worktrees(repo_root)\n\n    assert len(result) == 3\n    assert result[0].path == repo_root\n    assert result[1].path == wt1\n    assert result[2].path == wt2\n\n\ndef test_fake_gitops_add_worktree(tmp_path: Path) -> None:\n    \"\"\"Test that FakeGit can add worktrees (in-memory only, no filesystem operations).\"\"\"\n    repo_root = tmp_path / \"repo\"\n    repo_root.mkdir()\n    git_ops = FakeGit()\n\n    new_wt = repo_root / \"new-wt\"\n    git_ops.worktree.add_worktree(\n        repo_root, new_wt, branch=\"new-branch\", ref=None, create_branch=True\n    )\n\n    worktrees = git_ops.worktree.list_worktrees(repo_root)\n    assert len(worktrees) == 1\n    assert worktrees[0].path == new_wt\n    assert worktrees[0].branch == \"new-branch\"\n    # FakeGit is purely in-memory - does not create directories\n\n\ndef test_fake_gitops_remove_worktree() -> None:\n    \"\"\"Test that FakeGit can remove worktrees.\"\"\"\n    repo_root = Path(\"/repo\")\n    wt1 = Path(\"/repo/wt1\")\n\n    git_ops = FakeGit(\n        worktrees={\n            repo_root: [\n                WorktreeInfo(path=wt1, branch=\"feature-1\"),\n            ]\n        }\n    )\n\n    git_ops.worktree.remove_worktree(repo_root, wt1, force=False)\n\n    worktrees = git_ops.worktree.list_worktrees(repo_root)\n    assert len(worktrees) == 0\n\n\ndef test_fake_gitops_get_current_branch() -> None:\n    \"\"\"Test that FakeGit returns configured current branch.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(current_branches={cwd: \"feature-branch\"})\n\n    branch = git_ops.branch.get_current_branch(cwd)\n    assert branch == \"feature-branch\"\n\n\ndef test_fake_gitops_get_default_branch() -> None:\n    \"\"\"Test that FakeGit returns configured trunk branch.\"\"\"\n    repo_root = Path(\"/repo\")\n    git_ops = FakeGit(trunk_branches={repo_root: \"main\"})\n\n    branch = git_ops.branch.detect_trunk_branch(repo_root)\n    assert branch == \"main\"\n\n\ndef test_fake_gitops_get_git_common_dir() -> None:\n    \"\"\"Test that FakeGit returns configured git common dir.\"\"\"\n    cwd = Path(\"/repo\")\n    git_dir = Path(\"/repo/.git\")\n\n    git_ops = FakeGit(git_common_dirs={cwd: git_dir})\n\n    common_dir = git_ops.repo.get_git_common_dir(cwd)\n    assert common_dir == git_dir\n\n\ndef test_fake_gitops_detached_head() -> None:\n    \"\"\"Test FakeGit with detached HEAD (None branch).\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(current_branches={cwd: None})\n\n    branch = git_ops.branch.get_current_branch(cwd)\n    assert branch is None\n\n\ndef test_fake_gitops_worktree_not_found() -> None:\n    \"\"\"Test FakeGit when worktree not found.\"\"\"\n    repo_root = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    worktrees = git_ops.worktree.list_worktrees(repo_root)\n    assert len(worktrees) == 0\n\n\ndef test_fake_gitops_has_uncommitted_changes_no_changes() -> None:\n    \"\"\"Test has_uncommitted_changes returns False when no changes.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([], [], [])})\n\n    assert not git_ops.status.has_uncommitted_changes(cwd)\n\n\ndef test_fake_gitops_has_uncommitted_changes_staged() -> None:\n    \"\"\"Test has_uncommitted_changes returns True when staged changes exist.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([\"file.txt\"], [], [])})\n\n    assert git_ops.status.has_uncommitted_changes(cwd)\n\n\ndef test_fake_gitops_has_uncommitted_changes_modified() -> None:\n    \"\"\"Test has_uncommitted_changes returns True when modified changes exist.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([], [\"file.txt\"], [])})\n\n    assert git_ops.status.has_uncommitted_changes(cwd)\n\n\ndef test_fake_gitops_has_uncommitted_changes_untracked() -> None:\n    \"\"\"Test has_uncommitted_changes returns True when untracked files exist.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([], [], [\"file.txt\"])})\n\n    assert git_ops.status.has_uncommitted_changes(cwd)\n\n\ndef test_fake_gitops_has_uncommitted_changes_all_types() -> None:\n    \"\"\"Test has_uncommitted_changes with all types of changes.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([\"staged.txt\"], [\"modified.txt\"], [\"untracked.txt\"])})\n\n    assert git_ops.status.has_uncommitted_changes(cwd)\n\n\ndef test_fake_gitops_has_uncommitted_changes_unknown_path() -> None:\n    \"\"\"Test has_uncommitted_changes returns False for unknown path.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    assert not git_ops.status.has_uncommitted_changes(cwd)\n\n\n# ========================================\n# Critical Gap Tests: High-Risk Methods\n# ========================================\n\n\ndef test_fake_gitops_get_file_status_empty() -> None:\n    \"\"\"Test get_file_status with no changes.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([], [], [])})\n\n    staged, modified, untracked = git_ops.status.get_file_status(cwd)\n\n    assert staged == []\n    assert modified == []\n    assert untracked == []\n\n\ndef test_fake_gitops_get_file_status_staged_only() -> None:\n    \"\"\"Test get_file_status with only staged files.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([\"file.txt\"], [], [])})\n\n    staged, modified, untracked = git_ops.status.get_file_status(cwd)\n\n    assert staged == [\"file.txt\"]\n    assert modified == []\n    assert untracked == []\n\n\ndef test_fake_gitops_get_file_status_modified_only() -> None:\n    \"\"\"Test get_file_status with only modified files.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([], [\"file.txt\"], [])})\n\n    staged, modified, untracked = git_ops.status.get_file_status(cwd)\n\n    assert staged == []\n    assert modified == [\"file.txt\"]\n    assert untracked == []\n\n\ndef test_fake_gitops_get_file_status_untracked_only() -> None:\n    \"\"\"Test get_file_status with only untracked files.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([], [], [\"file.txt\"])})\n\n    staged, modified, untracked = git_ops.status.get_file_status(cwd)\n\n    assert staged == []\n    assert modified == []\n    assert untracked == [\"file.txt\"]\n\n\ndef test_fake_gitops_get_file_status_mixed() -> None:\n    \"\"\"Test get_file_status with all change types.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(file_statuses={cwd: ([\"a.txt\"], [\"b.txt\"], [\"c.txt\"])})\n\n    staged, modified, untracked = git_ops.status.get_file_status(cwd)\n\n    assert staged == [\"a.txt\"]\n    assert modified == [\"b.txt\"]\n    assert untracked == [\"c.txt\"]\n\n\ndef test_fake_gitops_move_worktree(tmp_path: Path) -> None:\n    \"\"\"Test move_worktree updates state (in-memory only, no filesystem operations).\"\"\"\n    repo_root = tmp_path / \"repo\"\n    old_wt = tmp_path / \"old-wt\"\n    new_wt = tmp_path / \"new-wt\"\n\n    git_ops = FakeGit(\n        worktrees={repo_root: [WorktreeInfo(path=old_wt, branch=\"feature\", is_root=False)]}\n    )\n\n    git_ops.worktree.move_worktree(repo_root, old_wt, new_wt)\n\n    # Verify state updated\n    worktrees = git_ops.worktree.list_worktrees(repo_root)\n    assert len(worktrees) == 1\n    assert worktrees[0].path == new_wt\n    assert worktrees[0].branch == \"feature\"\n\n    # FakeGit is purely in-memory - does not rename directories\n\n\ndef test_fake_gitops_get_branch_head() -> None:\n    \"\"\"Test get_branch_head returns commit SHA from dict.\"\"\"\n    repo_root = Path(\"/repo\")\n    git_ops = FakeGit(branch_heads={\"main\": \"abc123\", \"feature\": \"def456\"})\n\n    assert git_ops.branch.get_branch_head(repo_root, \"main\") == \"abc123\"\n    assert git_ops.branch.get_branch_head(repo_root, \"feature\") == \"def456\"\n    assert git_ops.branch.get_branch_head(repo_root, \"nonexistent\") is None\n\n\ndef test_fake_gitops_get_commit_message() -> None:\n    \"\"\"Test get_commit_message returns message from dict via commit subgateway.\"\"\"\n    repo_root = Path(\"/repo\")\n    git_ops = FakeGit(commit_messages={\"abc123\": \"Initial commit\", \"def456\": \"Add feature\"})\n\n    assert git_ops.commit.get_commit_message(repo_root, \"abc123\") == \"Initial commit\"\n    assert git_ops.commit.get_commit_message(repo_root, \"def456\") == \"Add feature\"\n    assert git_ops.commit.get_commit_message(repo_root, \"unknown\") is None\n\n\ndef test_fake_gitops_get_ahead_behind() -> None:\n    \"\"\"Test get_ahead_behind returns (ahead, behind) tuple.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(\n        ahead_behind={\n            (cwd, \"main\"): (0, 0),\n            (cwd, \"feature\"): (3, 1),\n        }\n    )\n\n    assert git_ops.branch.get_ahead_behind(cwd, \"main\") == (0, 0)\n    assert git_ops.branch.get_ahead_behind(cwd, \"feature\") == (3, 1)\n    assert git_ops.branch.get_ahead_behind(cwd, \"unknown\") == (0, 0)\n\n\ndef test_fake_gitops_get_recent_commits() -> None:\n    \"\"\"Test get_recent_commits returns commit list with limit.\"\"\"\n    cwd = Path(\"/repo\")\n    commits = [\n        {\"sha\": \"abc123\", \"message\": \"Commit 1\"},\n        {\"sha\": \"def456\", \"message\": \"Commit 2\"},\n        {\"sha\": \"ghi789\", \"message\": \"Commit 3\"},\n        {\"sha\": \"jkl012\", \"message\": \"Commit 4\"},\n        {\"sha\": \"mno345\", \"message\": \"Commit 5\"},\n        {\"sha\": \"pqr678\", \"message\": \"Commit 6\"},\n    ]\n    git_ops = FakeGit(recent_commits={cwd: commits})\n\n    # Default limit is 5\n    result = git_ops.commit.get_recent_commits(cwd, limit=5)\n    assert len(result) == 5\n    assert result[0][\"sha\"] == \"abc123\"\n\n    # Custom limit\n    result = git_ops.commit.get_recent_commits(cwd, limit=3)\n    assert len(result) == 3\n\n    # No commits configured\n    result = git_ops.commit.get_recent_commits(Path(\"/other\"), limit=5)\n    assert result == []\n\n\ndef test_fake_gitops_prune_worktrees_noop() -> None:\n    \"\"\"Test prune_worktrees is a no-op (doesn't crash).\"\"\"\n    repo_root = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    # Should not raise\n    git_ops.worktree.prune_worktrees(repo_root)\n\n\ndef test_fake_gitops_removed_worktrees_tracking() -> None:\n    \"\"\"Test removed_worktrees tracking property updates on remove.\"\"\"\n    repo_root = Path(\"/repo\")\n    wt1 = Path(\"/repo/wt1\")\n    wt2 = Path(\"/repo/wt2\")\n\n    git_ops = FakeGit(\n        worktrees={\n            repo_root: [\n                WorktreeInfo(path=wt1, branch=\"feat-1\", is_root=False),\n                WorktreeInfo(path=wt2, branch=\"feat-2\", is_root=False),\n            ]\n        }\n    )\n\n    git_ops.worktree.remove_worktree(repo_root, wt1, force=False)\n    git_ops.worktree.remove_worktree(repo_root, wt2, force=False)\n\n    assert wt1 in git_ops.removed_worktrees\n    assert wt2 in git_ops.removed_worktrees\n    assert len(git_ops.removed_worktrees) == 2\n\n\ndef test_fake_gitops_remove_worktree_error_injection() -> None:\n    \"\"\"Test that FakeGit raises RuntimeError when remove_worktree_error is configured.\"\"\"\n    repo_root = Path(\"/repo\")\n    wt1 = Path(\"/repo/wt1\")\n\n    git_ops = FakeGit(\n        worktrees={\n            repo_root: [\n                WorktreeInfo(path=wt1, branch=\"feature-1\"),\n            ]\n        },\n        remove_worktree_error=\"Failed to remove worktree\",\n    )\n\n    with pytest.raises(RuntimeError, match=\"Failed to remove worktree\"):\n        git_ops.worktree.remove_worktree(repo_root, wt1, force=False)\n\n    # Worktree should not have been removed\n    worktrees = git_ops.worktree.list_worktrees(repo_root)\n    assert len(worktrees) == 1\n\n\ndef test_fake_git_is_worktree_clean_with_clean_worktree() -> None:\n    \"\"\"Test that is_worktree_clean returns True for clean worktree.\"\"\"\n    worktree_path = Path(\"/repo/worktree\")\n    git_ops = FakeGit(\n        existing_paths={worktree_path},\n    )\n\n    result = git_ops.worktree.is_worktree_clean(worktree_path)\n    assert result is True\n\n\ndef test_fake_git_is_worktree_clean_with_uncommitted_changes() -> None:\n    \"\"\"Test that is_worktree_clean returns False for dirty worktree.\"\"\"\n    worktree_path = Path(\"/repo/worktree\")\n    git_ops = FakeGit(\n        existing_paths={worktree_path},\n        dirty_worktrees={worktree_path},\n    )\n\n    result = git_ops.worktree.is_worktree_clean(worktree_path)\n    assert result is False\n\n\ndef test_fake_git_is_worktree_clean_with_nonexistent_path() -> None:\n    \"\"\"Test that is_worktree_clean returns False for nonexistent path.\"\"\"\n    worktree_path = Path(\"/repo/nonexistent\")\n    git_ops = FakeGit()\n\n    result = git_ops.worktree.is_worktree_clean(worktree_path)\n    assert result is False\n\n\n# ============================================================================\n# Branch-Issue Extraction Tests\n# ============================================================================\n\n\ndef test_fake_git_get_branch_issue_extracts_from_branch_name() -> None:\n    \"\"\"Test get_branch_issue extracts issue number from branch name prefix.\"\"\"\n    git_ops = FakeGit()\n\n    # Branch names with P-prefixed issue number (new format uses uppercase P)\n    assert (\n        git_ops.branch.get_branch_issue(\n            Path(\"/repo\"), \"P2382-convert-erk-create-raw-ext-12-05-2359\"\n        )\n        == 2382\n    )\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"P42-fix-bug\") == 42\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"P123-feature-name\") == 123\n    # Lowercase p also supported for backwards compatibility\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"p100-lowercase-prefix\") == 100\n\n    # Branch names with legacy format (no P prefix, backwards compatibility)\n    assert (\n        git_ops.branch.get_branch_issue(Path(\"/repo\"), \"2382-convert-erk-create-raw-ext-12-05-2359\")\n        == 2382\n    )\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"42-fix-bug\") == 42\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"123-feature-name\") == 123\n\n\ndef test_fake_git_get_branch_issue_returns_none_for_no_prefix() -> None:\n    \"\"\"Test get_branch_issue returns None when branch has no issue number prefix.\"\"\"\n    git_ops = FakeGit()\n\n    # Branch names without issue number prefix\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"feature-branch\") is None\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"master\") is None\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"main\") is None\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"develop\") is None\n\n\ndef test_fake_git_get_branch_issue_requires_hyphen_after_number() -> None:\n    \"\"\"Test get_branch_issue requires hyphen after issue number.\"\"\"\n    git_ops = FakeGit()\n\n    # Numbers without trailing hyphen are not issue numbers\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"123\") is None\n    assert git_ops.branch.get_branch_issue(Path(\"/repo\"), \"v2.0.0\") is None\n\n\n# ============================================================================\n# Commit Messages Since Tests\n# ============================================================================\n\n\ndef test_fake_git_get_commit_messages_since_returns_configured_messages() -> None:\n    \"\"\"Test get_commit_messages_since returns configured commit messages.\"\"\"\n    cwd = Path(\"/repo\")\n    messages = [\n        \"Initial commit\\n\\nThis is the body of the first commit.\",\n        \"Add feature\\n\\nImplemented new feature X.\",\n        \"Fix bug\",\n    ]\n    git_ops = FakeGit(commit_messages_since={(cwd, \"main\"): messages})\n\n    result = git_ops.commit.get_commit_messages_since(cwd, \"main\")\n\n    assert result == messages\n\n\ndef test_fake_git_get_commit_messages_since_returns_empty_for_unknown_branch() -> None:\n    \"\"\"Test get_commit_messages_since returns empty list for unknown branch.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    result = git_ops.commit.get_commit_messages_since(cwd, \"main\")\n\n    assert result == []\n\n\ndef test_fake_git_get_commit_messages_since_returns_empty_for_unknown_cwd() -> None:\n    \"\"\"Test get_commit_messages_since returns empty list for unknown cwd.\"\"\"\n    cwd = Path(\"/repo\")\n    other_cwd = Path(\"/other\")\n    messages = [\"Some commit\"]\n    git_ops = FakeGit(commit_messages_since={(cwd, \"main\"): messages})\n\n    result = git_ops.commit.get_commit_messages_since(other_cwd, \"main\")\n\n    assert result == []\n\n\n# ============================================================================\n# Branch Commit Tests (commit_files_to_branch)\n# ============================================================================\n\n\ndef test_fake_git_commit_files_to_branch_tracks_record() -> None:\n    \"\"\"Test commit_files_to_branch records a BranchCommitRecord.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    git_ops.commit.commit_files_to_branch(\n        cwd,\n        branch=\"plnd/my-feature\",\n        files={\"dir/plan.md\": \"# Plan\", \"dir/ref.json\": '{\"key\": \"value\"}'},\n        message=\"Add plan: My Feature\",\n    )\n\n    assert len(git_ops.branch_commits) == 1\n    record = git_ops.branch_commits[0]\n    assert record.cwd == cwd\n    assert record.branch == \"planned/my-feature\"\n    assert record.files == {\"dir/plan.md\": \"# Plan\", \"dir/ref.json\": '{\"key\": \"value\"}'}\n    assert record.message == \"Add plan: My Feature\"\n\n\ndef test_fake_git_commit_files_to_branch_multiple_commits() -> None:\n    \"\"\"Test multiple branch commits are tracked independently.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    git_ops.commit.commit_files_to_branch(\n        cwd, branch=\"branch-a\", files={\"a.txt\": \"A\"}, message=\"First\"\n    )\n    git_ops.commit.commit_files_to_branch(\n        cwd, branch=\"branch-b\", files={\"b.txt\": \"B\"}, message=\"Second\"\n    )\n\n    assert len(git_ops.branch_commits) == 2\n    assert git_ops.branch_commits[0].branch == \"branch-a\"\n    assert git_ops.branch_commits[1].branch == \"branch-b\"\n\n\ndef test_fake_git_commit_files_to_branch_does_not_affect_regular_commits() -> None:\n    \"\"\"Test that branch commits and regular commits are tracked separately.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    git_ops.commit.commit_files_to_branch(\n        cwd, branch=\"feature\", files={\"f.txt\": \"content\"}, message=\"Branch commit\"\n    )\n    git_ops.commit.commit(cwd, \"Regular commit\")\n\n    assert len(git_ops.branch_commits) == 1\n    assert len(git_ops.commits) == 1\n    assert git_ops.branch_commits[0].message == \"Branch commit\"\n    assert git_ops.commits[0].message == \"Regular commit\"\n\n\n# ============================================================================\n# Branch Divergence Tests\n# ============================================================================\n\n\ndef test_fake_git_is_branch_diverged_returns_configured_divergence() -> None:\n    \"\"\"Test is_branch_diverged_from_remote returns configured divergence state.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(\n        branch_divergence={\n            (cwd, \"feature\", \"origin\"): BranchDivergence(is_diverged=True, ahead=3, behind=2)\n        }\n    )\n\n    result = git_ops.branch.is_branch_diverged_from_remote(cwd, \"feature\", \"origin\")\n\n    assert result.is_diverged is True\n    assert result.ahead == 3\n    assert result.behind == 2\n\n\ndef test_fake_git_is_branch_diverged_returns_default_for_unconfigured() -> None:\n    \"\"\"Test is_branch_diverged_from_remote returns default for unconfigured branch.\"\"\"\n    git_ops = FakeGit()\n\n    result = git_ops.branch.is_branch_diverged_from_remote(Path(\"/repo\"), \"feature\", \"origin\")\n\n    assert result.is_diverged is False\n    assert result.ahead == 0\n    assert result.behind == 0\n\n\ndef test_fake_git_is_branch_diverged_not_diverged_when_only_ahead() -> None:\n    \"\"\"Test is_branch_diverged_from_remote with only ahead commits (not diverged).\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit(\n        branch_divergence={\n            (cwd, \"feature\", \"origin\"): BranchDivergence(is_diverged=False, ahead=3, behind=0)\n        }\n    )\n\n    result = git_ops.branch.is_branch_diverged_from_remote(cwd, \"feature\", \"origin\")\n\n    assert result.is_diverged is False\n    assert result.ahead == 3\n    assert result.behind == 0\n\n\n# ============================================================================\n# Discriminated Union Return Types Tests\n# ============================================================================\n\n\ndef test_fake_create_branch_returns_branch_created() -> None:\n    \"\"\"Test that FakeGitBranchOps.create_branch returns BranchCreated on success.\"\"\"\n    cwd = Path(\"/repo\")\n    git_ops = FakeGit()\n\n    result = git_ops.branch.create_branch(cwd, \"feature\", \"main\", force=False)\n\n    assert isinstance(result, BranchCreated)\n\n\ndef test_fake_create_branch_returns_error_when_configured() -> None:\n    \"\"\"Test that FakeGitBranchOps.create_branch returns BranchAlreadyExists when configured.\"\"\"\n    cwd = Path(\"/repo\")\n    error = BranchAlreadyExists(branch_name=\"feature\", message=\"branch 'feature' already exists\")\n    git_ops = FakeGit(create_branch_error=error)\n\n    result = git_ops.branch.create_branch(cwd, \"feature\", \"main\", force=False)\n\n    assert isinstance(result, BranchAlreadyExists)\n    assert result.branch_name == \"feature\"\n    assert result.error_type == \"branch-already-exists\"\n\n\ndef test_fake_add_worktree_succeeds(tmp_path: Path) -> None:\n    \"\"\"Test that FakeWorktree.add_worktree succeeds without error.\"\"\"\n    repo_root = tmp_path / \"repo\"\n    repo_root.mkdir()\n    git_ops = FakeGit()\n\n    new_wt = repo_root / \"new-wt\"\n    git_ops.worktree.add_worktree(\n        repo_root, new_wt, branch=\"new-branch\", ref=None, create_branch=True\n    )\n\n    # Verify worktree was added\n    worktrees = git_ops.worktree.list_worktrees(repo_root)\n    assert len(worktrees) == 1\n    assert worktrees[0].branch == \"new-branch\"\n\n\ndef test_fake_add_worktree_raises_when_error_configured(tmp_path: Path) -> None:\n    \"\"\"Test that FakeWorktree.add_worktree raises RuntimeError when configured.\"\"\"\n    repo_root = tmp_path / \"repo\"\n    repo_root.mkdir()\n    git_ops = FakeGit(add_worktree_error=\"worktree add failed: path already exists\")\n\n    new_wt = repo_root / \"new-wt\"\n    with pytest.raises(RuntimeError, match=\"path already exists\"):\n        git_ops.worktree.add_worktree(\n            repo_root, new_wt, branch=\"new-branch\", ref=None, create_branch=True\n        )\n","structuredPatch":[{"oldStart":514,"oldLines":7,"newStart":514,"newLines":7,"lines":["     assert len(git_ops.branch_commits) == 1","     record = git_ops.branch_commits[0]","     assert record.cwd == cwd","-    assert record.branch == \"planned/my-feature\"","+    assert record.branch == \"plnd/my-feature\"","     assert record.files == {\"dir/plan.md\": \"# Plan\", \"dir/ref.json\": '{\"key\": \"value\"}'}","     assert record.message == \"Add plan: My Feature\""," "]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"fb93f353-af59-49a0-aa57-dfc7720db227","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Hhb69r4Yuyg1gcJ5zoaHyF","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me verify all `planned/` references are resolved in test files:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":187,"cache_read_input_tokens":120156,"cache_creation":{"ephemeral_5m_input_tokens":187,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHzXp2Mr11vqEh1R4oj","type":"assistant","uuid":"d0ca171c-995d-477c-9942-26497a4b5051","timestamp":"2026-02-22T14:50:08.437Z"}
{"parentUuid":"d0ca171c-995d-477c-9942-26497a4b5051","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Hhb69r4Yuyg1gcJ5zoaHyF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GPAp1k2YWp5npXEQPx8Kiz","name":"Grep","input":{"pattern":"\"planned/","glob":"*.py","output_mode":"content","path":"/home/runner/work/erk/erk/tests"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":187,"cache_read_input_tokens":120156,"cache_creation":{"ephemeral_5m_input_tokens":187,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHzXp2Mr11vqEh1R4oj","type":"assistant","uuid":"b0c5674d-ea47-458b-a43a-0c6e5c566e99","timestamp":"2026-02-22T14:50:09.564Z"}
{"parentUuid":"b0c5674d-ea47-458b-a43a-0c6e5c566e99","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GPAp1k2YWp5npXEQPx8Kiz","type":"tool_result","content":"tests/tui/data/test_provider.py:322:        branch_name = \"planned/fix-auth-bug-01-15-1430\"\ntests/core/utils/test_naming.py:485:        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\ntests/core/utils/test_naming.py:486:        (\"planned/O1-add-tests-12-31-2359\", 1),\ntests/core/utils/test_naming.py:494:        (\"planned/fix-auth-bug-01-15-1430\", None),\ntests/core/utils/test_naming.py:520:        (\"planned/fix-auth-bug-01-15-1430\", None),\ntests/core/utils/test_naming.py:521:        (\"planned/O456-fix-auth-01-15-1430\", None),\ntests/core/utils/test_naming.py:543:        (\"planned/review-6214-01-15-1430\", 6214),\ntests/core/utils/test_naming.py:544:        (\"planned/review-42-01-28-0930\", 42),\ntests/core/utils/test_naming.py:545:        (\"planned/review-1-12-31-2359\", 1),\ntests/core/utils/test_naming.py:546:        (\"planned/review-99999-01-01-0000\", 99999),"}]},"uuid":"ca816450-5f5a-4b7b-a787-201c022496ac","timestamp":"2026-02-22T14:50:09.994Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"tests/tui/data/test_provider.py:322:        branch_name = \"planned/fix-auth-bug-01-15-1430\"\ntests/core/utils/test_naming.py:485:        (\"planned/O456-fix-auth-bug-01-15-1430\", 456),\ntests/core/utils/test_naming.py:486:        (\"planned/O1-add-tests-12-31-2359\", 1),\ntests/core/utils/test_naming.py:494:        (\"planned/fix-auth-bug-01-15-1430\", None),\ntests/core/utils/test_naming.py:520:        (\"planned/fix-auth-bug-01-15-1430\", None),\ntests/core/utils/test_naming.py:521:        (\"planned/O456-fix-auth-01-15-1430\", None),\ntests/core/utils/test_naming.py:543:        (\"planned/review-6214-01-15-1430\", 6214),\ntests/core/utils/test_naming.py:544:        (\"planned/review-42-01-28-0930\", 42),\ntests/core/utils/test_naming.py:545:        (\"planned/review-1-12-31-2359\", 1),\ntests/core/utils/test_naming.py:546:        (\"planned/review-99999-01-01-0000\", 99999),","numLines":10}}
{"parentUuid":"ca816450-5f5a-4b7b-a787-201c022496ac","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01PVtWLkFS8DEuUvYQLNkikS","type":"message","role":"assistant","content":[{"type":"text","text":"Good - all remaining `planned/` references in tests are intentionally there for backward compatibility testing (testing that the legacy prefix still works). The TUI test at line 322 is in the `test_legacy_planned_slash_branch_resolved_via_plan_ref_json` test, and the naming tests at lines 485-546 are legacy test cases I explicitly kept.\n\nNow let me run CI to verify everything works:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":836,"cache_read_input_tokens":120343,"cache_creation":{"ephemeral_5m_input_tokens":836,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHzrEnyWUwvngZSKMQ2","type":"assistant","uuid":"38a3729b-0bed-443a-b2a1-e1a9369c8ce2","timestamp":"2026-02-22T14:50:14.855Z"}
{"parentUuid":"38a3729b-0bed-443a-b2a1-e1a9369c8ce2","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01PVtWLkFS8DEuUvYQLNkikS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012vMiC5dNFaaf1vKwxNpwXM","name":"TodoWrite","input":{"todos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"completed","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"completed","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"completed","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"completed","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"completed","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"completed","activeForm":"Updating tests"},{"content":"Run CI checks","status":"in_progress","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":836,"cache_read_input_tokens":120343,"cache_creation":{"ephemeral_5m_input_tokens":836,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPHzrEnyWUwvngZSKMQ2","type":"assistant","uuid":"2db2a9e6-542a-441c-a7d4-c2820a566e16","timestamp":"2026-02-22T14:50:19.515Z"}
{"parentUuid":"2db2a9e6-542a-441c-a7d4-c2820a566e16","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012vMiC5dNFaaf1vKwxNpwXM","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"f1a4c86a-1516-4326-a099-b71745e76c66","timestamp":"2026-02-22T14:50:19.530Z","toolUseResult":{"oldTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"completed","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"completed","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"completed","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"completed","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"completed","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"in_progress","activeForm":"Updating tests"},{"content":"Run CI checks","status":"pending","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}],"newTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"completed","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"completed","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"completed","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"completed","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"completed","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"completed","activeForm":"Updating tests"},{"content":"Run CI checks","status":"in_progress","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}]}}
{"parentUuid":"f1a4c86a-1516-4326-a099-b71745e76c66","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01URPvPyTWd8FZQgGYt8yZtX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Kx6m1Qb8KJuHto5TmiPcNc","name":"Task","input":{"subagent_type":"devrun","prompt":"Run the fast CI checks for this Python project. Run the following commands and report results:\n\n1. Run ruff check: `ruff check src/ packages/ tests/`\n2. Run ruff format check: `ruff format --check src/ packages/ tests/`\n3. Run ty type checking: `ty check src/ packages/`\n4. Run pytest unit tests: `pytest tests/core/utils/test_naming.py tests/commands/submit/test_pr_creation.py tests/commands/submit/test_basic_submission.py tests/commands/land/test_get_objective_for_branch.py tests/commands/one_shot/test_one_shot_dispatch.py tests/unit/cli/commands/exec/scripts/test_plan_save.py tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py tests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py tests/tui/data/test_provider.py tests/unit/fakes/test_fake_git.py -x -q`\n\nReport all results.","description":"Run CI checks on modified files"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":669,"cache_read_input_tokens":121179,"cache_creation":{"ephemeral_5m_input_tokens":669,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ1Z1j8FGERb81oGaKE","type":"assistant","uuid":"cfdfeada-0540-401c-ad0c-66c259307ded","timestamp":"2026-02-22T14:50:26.755Z"}
{"parentUuid":"cfdfeada-0540-401c-ad0c-66c259307ded","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Kx6m1Qb8KJuHto5TmiPcNc","type":"tool_result","content":[{"type":"text","text":"## Summary of Fast CI Checks\n\n**ruff check (linting):** Failed\n- 1 error found in `/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py:500:101`\n- Line too long (140 > 100 characters)\n- Issue: `worktree.branch.startswith(\"planned/\")` needs wrapping\n\n**ruff format (format check):** Failed\n- 1 file would be reformatted: `/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py`\n- 1494 files already formatted\n\n**ty type checking:** Passed\n- All checks passed\n\n**pytest unit tests:** Passed\n- 344 tests passed in 0.46s\n\nThe linting and formatting failures are both in the same file (`packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py` at line 500) due to an overly long line containing the string check for `\"planned/\"` prefix."},{"type":"text","text":"agentId: a4660e2 (for resuming to continue this agent's work if needed)"}]}]},"uuid":"a47e5bea-aada-4edb-a4f3-5b308eb8696c","timestamp":"2026-02-22T14:50:53.310Z","toolUseResult":{"status":"completed","prompt":"Run the fast CI checks for this Python project. Run the following commands and report results:\n\n1. Run ruff check: `ruff check src/ packages/ tests/`\n2. Run ruff format check: `ruff format --check src/ packages/ tests/`\n3. Run ty type checking: `ty check src/ packages/`\n4. Run pytest unit tests: `pytest tests/core/utils/test_naming.py tests/commands/submit/test_pr_creation.py tests/commands/submit/test_basic_submission.py tests/commands/land/test_get_objective_for_branch.py tests/commands/one_shot/test_one_shot_dispatch.py tests/unit/cli/commands/exec/scripts/test_plan_save.py tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py tests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py tests/tui/data/test_provider.py tests/unit/fakes/test_fake_git.py -x -q`\n\nReport all results.","agentId":"a4660e2","content":[{"type":"text","text":"## Summary of Fast CI Checks\n\n**ruff check (linting):** Failed\n- 1 error found in `/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py:500:101`\n- Line too long (140 > 100 characters)\n- Issue: `worktree.branch.startswith(\"planned/\")` needs wrapping\n\n**ruff format (format check):** Failed\n- 1 file would be reformatted: `/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py`\n- 1494 files already formatted\n\n**ty type checking:** Passed\n- All checks passed\n\n**pytest unit tests:** Passed\n- 344 tests passed in 0.46s\n\nThe linting and formatting failures are both in the same file (`packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py` at line 500) due to an overly long line containing the string check for `\"planned/\"` prefix."}],"totalDurationMs":26539,"totalTokens":14403,"totalToolUseCount":5,"usage":{"input_tokens":4,"cache_creation_input_tokens":340,"cache_read_input_tokens":13807,"cache_creation":{"ephemeral_5m_input_tokens":340,"ephemeral_1h_input_tokens":0},"output_tokens":252,"service_tier":"standard","inference_geo":"not_available"}}}
{"parentUuid":"a47e5bea-aada-4edb-a4f3-5b308eb8696c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_016FW5nZBoTmRAnpsDVo8R9k","type":"message","role":"assistant","content":[{"type":"text","text":"One line is too long. Let me fix it:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":658,"cache_read_input_tokens":121848,"cache_creation":{"ephemeral_5m_input_tokens":658,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ43SpMpzYQ8F4XfPsN","type":"assistant","uuid":"782dd30b-df3b-40b7-8b87-c2459594c2e1","timestamp":"2026-02-22T14:50:55.969Z"}
{"parentUuid":"782dd30b-df3b-40b7-8b87-c2459594c2e1","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_016FW5nZBoTmRAnpsDVo8R9k","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y1BkWyPQgHjTEcXXKKNLS9","name":"Read","input":{"file_path":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py","offset":497,"limit":8},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":658,"cache_read_input_tokens":121848,"cache_creation":{"ephemeral_5m_input_tokens":658,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ43SpMpzYQ8F4XfPsN","type":"assistant","uuid":"26c465d8-3c55-43c9-890b-b6cb6b6418f4","timestamp":"2026-02-22T14:50:57.079Z"}
{"parentUuid":"26c465d8-3c55-43c9-890b-b6cb6b6418f4","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y1BkWyPQgHjTEcXXKKNLS9","type":"tool_result","content":"   497→            )\n   498→\n   499→            # Fallback for draft-PR branches: read .impl/plan-ref.json\n   500→            if issue_number is None and worktree.branch and (worktree.branch.startswith(\"plnd/\") or worktree.branch.startswith(\"planned/\")):\n   501→                impl_dir = worktree.path / \".impl\"\n   502→                plan_ref = read_plan_ref(impl_dir)\n   503→                if plan_ref is not None and plan_ref.plan_id.isdigit():\n   504→                    issue_number = int(plan_ref.plan_id)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"0e13c20f-0d62-4522-a0fb-0d1f8dc00151","timestamp":"2026-02-22T14:50:57.126Z","toolUseResult":{"type":"text","file":{"filePath":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py","content":"            )\n\n            # Fallback for draft-PR branches: read .impl/plan-ref.json\n            if issue_number is None and worktree.branch and (worktree.branch.startswith(\"plnd/\") or worktree.branch.startswith(\"planned/\")):\n                impl_dir = worktree.path / \".impl\"\n                plan_ref = read_plan_ref(impl_dir)\n                if plan_ref is not None and plan_ref.plan_id.isdigit():\n                    issue_number = int(plan_ref.plan_id)","numLines":8,"startLine":497,"totalLines":895}}}
{"parentUuid":"0e13c20f-0d62-4522-a0fb-0d1f8dc00151","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01VQiJRKQX3fzV9Y89VhS9Ja","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014J3UpxKU4b3gxLWDBykqqg","name":"Edit","input":{"file_path":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py","old_string":"            # Fallback for draft-PR branches: read .impl/plan-ref.json\n            if issue_number is None and worktree.branch and (worktree.branch.startswith(\"plnd/\") or worktree.branch.startswith(\"planned/\")):","new_string":"            # Fallback for draft-PR branches: read .impl/plan-ref.json\n            is_draft_pr_branch = worktree.branch and (\n                worktree.branch.startswith(\"plnd/\") or worktree.branch.startswith(\"planned/\")\n            )\n            if issue_number is None and is_draft_pr_branch:"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":388,"cache_read_input_tokens":122506,"cache_creation":{"ephemeral_5m_input_tokens":388,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ4KjbqVYAneRtJFv3W","type":"assistant","uuid":"d614a35d-8893-49ec-b883-82eddad8aca3","timestamp":"2026-02-22T14:51:01.674Z"}
{"parentUuid":"d614a35d-8893-49ec-b883-82eddad8aca3","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014J3UpxKU4b3gxLWDBykqqg","type":"tool_result","content":"The file /home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py has been updated successfully."}]},"uuid":"58e5d53f-6c1b-4446-9dbe-e3db3bbcda9a","timestamp":"2026-02-22T14:51:02.380Z","toolUseResult":{"filePath":"/home/runner/work/erk/erk/packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py","oldString":"            # Fallback for draft-PR branches: read .impl/plan-ref.json\n            if issue_number is None and worktree.branch and (worktree.branch.startswith(\"plnd/\") or worktree.branch.startswith(\"planned/\")):","newString":"            # Fallback for draft-PR branches: read .impl/plan-ref.json\n            is_draft_pr_branch = worktree.branch and (\n                worktree.branch.startswith(\"plnd/\") or worktree.branch.startswith(\"planned/\")\n            )\n            if issue_number is None and is_draft_pr_branch:","originalFile":"\"\"\"Real implementation of PlanDataProvider for production use.\"\"\"\n\nimport logging\nimport subprocess\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom erk.core.context import ErkContext\nfrom erk.core.display_utils import (\n    format_relative_time,\n    format_workflow_outcome,\n    format_workflow_run_id,\n    get_workflow_run_state,\n)\nfrom erk.core.pr_utils import select_display_pr\nfrom erk.core.repo_discovery import NoRepoSentinel, RepoContext, ensure_erk_metadata_dir\nfrom erk.tui.data.types import PlanFilters, PlanRowData\nfrom erk.tui.sorting.types import BranchActivity\nfrom erk_shared.gateway.browser.abc import BrowserLauncher\nfrom erk_shared.gateway.clipboard.abc import Clipboard\nfrom erk_shared.gateway.github.emoji import format_checks_cell, get_pr_status_emoji\nfrom erk_shared.gateway.github.issues.types import IssueNotFound\nfrom erk_shared.gateway.github.metadata.core import (\n    extract_objective_from_comment,\n    extract_objective_header_comment_id,\n    find_metadata_block,\n)\nfrom erk_shared.gateway.github.metadata.dependency_graph import (\n    _TERMINAL_STATUSES,\n    build_graph,\n    compute_graph_summary,\n    find_graph_next_node,\n)\nfrom erk_shared.gateway.github.metadata.plan_header import extract_plan_from_comment\nfrom erk_shared.gateway.github.metadata.roadmap import (\n    parse_roadmap,\n)\nfrom erk_shared.gateway.github.metadata.schemas import (\n    LAST_LOCAL_IMPL_AT,\n    LAST_REMOTE_IMPL_AT,\n    LEARN_PLAN_ISSUE,\n    LEARN_PLAN_PR,\n    LEARN_RUN_ID,\n    LEARN_STATUS,\n    OBJECTIVE_ISSUE,\n    PLAN_COMMENT_ID,\n    REVIEW_PR,\n    WORKTREE_NAME,\n)\nfrom erk_shared.gateway.github.types import (\n    GitHubRepoId,\n    GitHubRepoLocation,\n    PRReviewThread,\n    PullRequestInfo,\n    WorkflowRun,\n)\nfrom erk_shared.gateway.http.abc import HttpClient\nfrom erk_shared.gateway.plan_data_provider.abc import PlanDataProvider\nfrom erk_shared.gateway.plan_data_provider.lifecycle import format_lifecycle_with_status\nfrom erk_shared.impl_folder import read_plan_ref\nfrom erk_shared.naming import extract_leading_issue_number\nfrom erk_shared.plan_store.conversion import (\n    header_datetime,\n    header_int,\n    header_str,\n)\nfrom erk_shared.plan_store.types import Plan\n\nlogger = logging.getLogger(__name__)\n\n\nclass RealPlanDataProvider(PlanDataProvider):\n    \"\"\"Production implementation that wraps PlanListService.\n\n    Transforms PlanListData into PlanRowData for TUI display.\n    \"\"\"\n\n    def __init__(\n        self,\n        ctx: ErkContext,\n        *,\n        location: GitHubRepoLocation,\n        clipboard: Clipboard,\n        browser: BrowserLauncher,\n        http_client: HttpClient,\n    ) -> None:\n        \"\"\"Initialize with context and repository info.\n\n        Args:\n            ctx: ErkContext with all dependencies\n            location: GitHub repository location (local root + repo identity)\n            clipboard: Clipboard interface for copy operations\n            browser: BrowserLauncher interface for opening URLs\n            http_client: HTTP client for direct API calls (faster than subprocess)\n        \"\"\"\n        self._ctx = ctx\n        self._location = location\n        self._clipboard = clipboard\n        self._browser = browser\n        self._http_client = http_client\n\n    @property\n    def repo_root(self) -> Path:\n        \"\"\"Get the repository root path.\"\"\"\n        return self._location.root\n\n    @property\n    def clipboard(self) -> Clipboard:\n        \"\"\"Get the clipboard interface for copy operations.\"\"\"\n        return self._clipboard\n\n    @property\n    def browser(self) -> BrowserLauncher:\n        \"\"\"Get the browser launcher interface for opening URLs.\"\"\"\n        return self._browser\n\n    def fetch_plans(self, filters: PlanFilters) -> list[PlanRowData]:\n        \"\"\"Fetch plans and transform to TUI row format.\n\n        Args:\n            filters: Filter options for the query\n\n        Returns:\n            List of PlanRowData objects for display\n        \"\"\"\n        # Determine if we need workflow runs\n        needs_workflow_runs = filters.show_runs or filters.run_state is not None\n\n        # Route to the appropriate service based on the view's labels\n        if \"erk-plan\" in filters.labels:\n            plan_data = self._ctx.plan_list_service.get_plan_list_data(\n                location=self._location,\n                labels=list(filters.labels),\n                state=filters.state,\n                limit=filters.limit,\n                skip_workflow_runs=not needs_workflow_runs,\n                creator=filters.creator,\n            )\n        else:\n            # Objectives use a dedicated service that always fetches via issues,\n            # regardless of the configured plan backend (draft PR vs issue)\n            plan_data = self._ctx.objective_list_service.get_objective_list_data(\n                location=self._location,\n                state=filters.state,\n                limit=filters.limit,\n                skip_workflow_runs=not needs_workflow_runs,\n                creator=filters.creator,\n            )\n\n        # Build local worktree mapping\n        worktree_by_plan_id = self._build_worktree_mapping()\n\n        # Use pre-converted Plan objects from PlanListData\n        plans = plan_data.plans\n\n        # First pass: collect learn_plan_issue numbers for batch fetch\n        learn_issue_numbers: set[int] = set()\n        for plan in plans:\n            learn_plan_issue = header_int(plan.header_fields, LEARN_PLAN_ISSUE)\n            if learn_plan_issue is not None:\n                learn_issue_numbers.add(learn_plan_issue)\n\n        # Batch fetch learn issue states\n        learn_issue_states = self._fetch_learn_issue_states(learn_issue_numbers)\n\n        # Transform to PlanRowData\n        rows: list[PlanRowData] = []\n        use_graphite = self._ctx.global_config.use_graphite if self._ctx.global_config else False\n\n        for plan in plans:\n            plan_id = int(plan.plan_identifier)\n\n            # Get workflow run for filtering\n            workflow_run = plan_data.workflow_runs.get(plan_id)\n\n            # Apply run_state filter\n            if filters.run_state is not None:\n                if workflow_run is None:\n                    continue\n                if get_workflow_run_state(workflow_run) != filters.run_state:\n                    continue\n\n            # Build row data\n            row = self._build_row_data(\n                plan=plan,\n                plan_id=plan_id,\n                pr_linkages=plan_data.pr_linkages,\n                workflow_run=workflow_run,\n                worktree_by_plan_id=worktree_by_plan_id,\n                use_graphite=use_graphite,\n                learn_issue_states=learn_issue_states,\n            )\n            rows.append(row)\n\n        return rows\n\n    def _fetch_learn_issue_states(\n        self,\n        issue_numbers: set[int],\n    ) -> dict[int, bool]:\n        \"\"\"Batch fetch issue closed states for learn plan issues.\n\n        Args:\n            issue_numbers: Set of issue numbers to fetch\n\n        Returns:\n            Mapping of issue number to is_closed (True if closed, False if open)\n        \"\"\"\n        result: dict[int, bool] = {}\n        for issue_number in issue_numbers:\n            issue_info = self._ctx.github.issues.get_issue(self._location.root, issue_number)\n            if isinstance(issue_info, IssueNotFound):\n                # Issue not found - log and skip\n                logger.debug(\"Could not fetch learn issue %d: issue not found\", issue_number)\n                continue\n            result[issue_number] = issue_info.state == \"CLOSED\"\n        return result\n\n    def close_plan(self, plan_id: int, plan_url: str) -> list[int]:\n        \"\"\"Close a plan and its linked PRs using direct HTTP calls.\n\n        This method uses the HTTP client directly instead of subprocess calls\n        for significantly faster execution in the TUI.\n\n        Args:\n            plan_id: The plan ID to close\n            plan_url: The plan URL for PR linkage lookup\n\n        Returns:\n            List of PR numbers that were also closed\n        \"\"\"\n        # Parse owner/repo from issue URL\n        owner_repo = self._parse_owner_repo_from_url(plan_url)\n        if owner_repo is None:\n            return []\n        owner, repo = owner_repo\n\n        # Close linked PRs first\n        closed_prs = self._close_linked_prs_http(plan_id, owner, repo)\n\n        # Close the plan (issue) via HTTP\n        self._http_client.patch(\n            f\"repos/{owner}/{repo}/issues/{plan_id}\",\n            data={\"state\": \"closed\"},\n        )\n\n        return closed_prs\n\n    def _parse_owner_repo_from_url(self, url: str) -> tuple[str, str] | None:\n        \"\"\"Parse owner and repo from a GitHub URL.\n\n        Args:\n            url: GitHub URL (e.g., \"https://github.com/owner/repo/issues/123\")\n\n        Returns:\n            Tuple of (owner, repo) or None if parsing fails\n        \"\"\"\n        # URL format: https://github.com/owner/repo/...\n        if not url.startswith(\"https://github.com/\"):\n            return None\n        parts = url.split(\"/\")\n        # parts: ['https:', '', 'github.com', 'owner', 'repo', ...]\n        if len(parts) < 5:\n            return None\n        return (parts[3], parts[4])\n\n    def _close_linked_prs_http(\n        self,\n        plan_id: int,\n        owner: str,\n        repo: str,\n    ) -> list[int]:\n        \"\"\"Close all OPEN PRs linked to an issue using HTTP.\n\n        Uses the GitHub REST API via HTTP client for fast execution.\n\n        Args:\n            plan_id: The plan ID\n            owner: Repository owner\n            repo: Repository name\n\n        Returns:\n            List of PR numbers that were closed\n        \"\"\"\n        # Use the existing gateway to get PR linkages (still efficient for read)\n        location = GitHubRepoLocation(\n            root=self._location.root,\n            repo_id=GitHubRepoId(owner=owner, repo=repo),\n        )\n        pr_linkages = self._ctx.github.get_prs_linked_to_issues(location, [plan_id])\n        linked_prs = pr_linkages.get(plan_id, [])\n\n        closed_prs: list[int] = []\n        for pr in linked_prs:\n            if pr.state == \"OPEN\":\n                # Close via HTTP client for speed\n                self._http_client.patch(\n                    f\"repos/{owner}/{repo}/pulls/{pr.number}\",\n                    data={\"state\": \"closed\"},\n                )\n                closed_prs.append(pr.number)\n\n        return closed_prs\n\n    def update_objective_after_land(\n        self,\n        *,\n        objective_issue: int,\n        pr_num: int,\n        branch: str,\n    ) -> None:\n        \"\"\"Update an objective after landing a PR.\n\n        Runs 'erk exec objective-update-after-land' as a subprocess.\n\n        Args:\n            objective_issue: The objective issue number to update\n            pr_num: The PR number that was landed\n            branch: The PR head branch name\n        \"\"\"\n        result = subprocess.run(\n            [\n                \"erk\",\n                \"exec\",\n                \"objective-update-after-land\",\n                f\"--objective={objective_issue}\",\n                f\"--pr={pr_num}\",\n                f\"--branch={branch}\",\n            ],\n            cwd=self._location.root,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            stdin=subprocess.DEVNULL,\n            text=True,\n            check=False,\n        )\n        if result.returncode != 0:\n            raise RuntimeError(f\"objective-update-after-land failed: {result.stdout}\")\n\n    def submit_to_queue(self, plan_id: int, plan_url: str) -> None:\n        \"\"\"Submit a plan to the implementation queue.\n\n        Runs 'erk plan submit' as a subprocess to handle the complex workflow\n        of creating branches, PRs, and triggering GitHub Actions.\n\n        Args:\n            plan_id: The plan ID to submit\n            plan_url: The plan URL (unused, kept for interface consistency)\n        \"\"\"\n        # Run erk plan submit command from the repository root\n        # -f flag prevents blocking on existing branch prompts in TUI context\n        subprocess.run(\n            [\"erk\", \"plan\", \"submit\", str(plan_id), \"-f\"],\n            cwd=self._location.root,\n            check=True,\n            capture_output=True,\n        )\n\n    def fetch_branch_activity(self, rows: list[PlanRowData]) -> dict[int, BranchActivity]:\n        \"\"\"Fetch branch activity for plans that exist locally.\n\n        Args:\n            rows: List of plan rows to fetch activity for\n\n        Returns:\n            Mapping of plan_id to BranchActivity for plans with local worktrees.\n        \"\"\"\n        result: dict[int, BranchActivity] = {}\n\n        # Get trunk branch\n        trunk = self._ctx.git.branch.detect_trunk_branch(self._location.root)\n\n        for row in rows:\n            # Only fetch for plans with local branches\n            if not row.exists_locally or row.worktree_branch is None:\n                continue\n\n            # Get commits on branch not in trunk\n            commits = self._ctx.git.branch.get_branch_commits_with_authors(\n                self._location.root,\n                row.worktree_branch,\n                trunk,\n                limit=1,  # Only need most recent\n            )\n\n            if commits:\n                # Parse ISO timestamp from git\n                timestamp_str = commits[0][\"timestamp\"]\n                commit_at = datetime.fromisoformat(timestamp_str)\n                result[row.plan_id] = BranchActivity(\n                    last_commit_at=commit_at,\n                    last_commit_author=commits[0][\"author\"],\n                )\n            else:\n                result[row.plan_id] = BranchActivity.empty()\n\n        return result\n\n    def fetch_plan_content(self, plan_id: int, plan_body: str) -> str | None:\n        \"\"\"Fetch plan content from the first comment of an issue, or return body directly.\n\n        For issue-based plans: uses plan_comment_id from the issue body metadata to\n        fetch the specific comment containing the plan content.\n\n        For draft PR plans: plan_body IS the plan content (already extracted from the\n        PR body by DraftPRPlanListService). No metadata block is present, so return\n        plan_body directly.\n\n        Args:\n            plan_id: The GitHub issue/PR number\n            plan_body: The body text — either an issue body (with plan-header metadata\n                and plan_comment_id) or already-extracted plan content (draft PR case)\n\n        Returns:\n            The extracted plan content, or None if not found\n        \"\"\"\n        # Check for plan-header metadata block to distinguish plan types:\n        # - Draft PR plans: no metadata block; plan_body IS the extracted content\n        # - Issue-based plans: metadata block with plan_comment_id pointing to the comment\n        block = find_metadata_block(plan_body, \"plan-header\")\n        if block is None:\n            return plan_body if plan_body.strip() else None\n\n        comment_id = block.data.get(PLAN_COMMENT_ID)\n        if not isinstance(comment_id, int):\n            return None\n\n        # Fetch the comment via HTTP client\n        owner = self._location.repo_id.owner\n        repo = self._location.repo_id.repo\n        endpoint = f\"repos/{owner}/{repo}/issues/comments/{comment_id}\"\n\n        response = self._http_client.get(endpoint)\n        comment_body = response.get(\"body\", \"\")\n\n        # Extract plan content from comment\n        return extract_plan_from_comment(comment_body)\n\n    def fetch_objective_content(self, plan_id: int, plan_body: str) -> str | None:\n        \"\"\"Fetch objective content from the first comment of an issue.\n\n        Uses the objective_comment_id from the issue body metadata to fetch\n        the specific comment containing the objective content.\n\n        Args:\n            plan_id: The GitHub issue number\n            plan_body: The issue body (to extract objective_comment_id from metadata)\n\n        Returns:\n            The extracted objective content, or None if not found\n        \"\"\"\n        comment_id = extract_objective_header_comment_id(plan_body)\n        if comment_id is None:\n            return None\n\n        owner = self._location.repo_id.owner\n        repo = self._location.repo_id.repo\n        endpoint = f\"repos/{owner}/{repo}/issues/comments/{comment_id}\"\n\n        response = self._http_client.get(endpoint)\n        comment_body = response.get(\"body\", \"\")\n\n        return extract_objective_from_comment(comment_body)\n\n    def fetch_unresolved_comments(self, pr_number: int) -> list[PRReviewThread]:\n        \"\"\"Fetch unresolved review threads for a pull request.\n\n        Args:\n            pr_number: The PR number to fetch threads for\n\n        Returns:\n            List of unresolved PRReviewThread objects sorted by (path, line)\n        \"\"\"\n        return self._ctx.github.get_pr_review_threads(\n            self._location.root, pr_number, include_resolved=False\n        )\n\n    def _build_worktree_mapping(self) -> dict[int, tuple[str, str | None]]:\n        \"\"\"Build mapping of plan ID to (worktree name, branch).\n\n        Uses PXXXX prefix matching on branch names to associate worktrees\n        with issues. Branch names follow pattern: P{plan_id}-{slug}-{timestamp}\n\n        For draft-PR plan branches (plnd/{slug}-{timestamp}), falls back to\n        reading .impl/plan-ref.json from the worktree to get the plan ID,\n        since the PR number is not encoded in the branch name.\n\n        Returns:\n            Mapping of plan ID to tuple of (worktree_name, branch_name)\n        \"\"\"\n        _ensure_erk_metadata_dir_from_context(self._ctx.repo)\n        worktree_by_plan_id: dict[int, tuple[str, str | None]] = {}\n        worktrees = self._ctx.git.worktree.list_worktrees(self._location.root)\n        for worktree in worktrees:\n            issue_number = (\n                extract_leading_issue_number(worktree.branch) if worktree.branch else None\n            )\n\n            # Fallback for draft-PR branches: read .impl/plan-ref.json\n            if issue_number is None and worktree.branch and (worktree.branch.startswith(\"plnd/\") or worktree.branch.startswith(\"planned/\")):\n                impl_dir = worktree.path / \".impl\"\n                plan_ref = read_plan_ref(impl_dir)\n                if plan_ref is not None and plan_ref.plan_id.isdigit():\n                    issue_number = int(plan_ref.plan_id)\n\n            if issue_number is not None:\n                if issue_number not in worktree_by_plan_id:\n                    worktree_by_plan_id[issue_number] = (\n                        worktree.path.name,\n                        worktree.branch,\n                    )\n        return worktree_by_plan_id\n\n    def _build_row_data(\n        self,\n        *,\n        plan: Plan,\n        plan_id: int,\n        pr_linkages: dict[int, list[PullRequestInfo]],\n        workflow_run: WorkflowRun | None,\n        worktree_by_plan_id: dict[int, tuple[str, str | None]],\n        use_graphite: bool,\n        learn_issue_states: dict[int, bool],\n    ) -> PlanRowData:\n        \"\"\"Build a single PlanRowData from plan and related data.\"\"\"\n        full_title = plan.title\n\n        # Worktree info\n        worktree_name = \"\"\n        worktree_branch: str | None = None\n        exists_locally = False\n\n        if plan_id in worktree_by_plan_id:\n            worktree_name, worktree_branch = worktree_by_plan_id[plan_id]\n            exists_locally = True\n\n        # Extract from pre-parsed header fields (no repeated YAML parsing)\n        local_impl_str: str | None = None\n        remote_impl_str: str | None = None\n        learn_status: str | None = None\n        learn_plan_issue: int | None = None\n        learn_plan_pr: int | None = None\n        learn_run_id: str | None = None\n        review_pr: int | None = None\n        if plan.header_fields:\n            extracted = header_str(plan.header_fields, WORKTREE_NAME)\n            if extracted and not worktree_name:\n                worktree_name = extracted\n            local_impl_str = header_str(plan.header_fields, LAST_LOCAL_IMPL_AT)\n            remote_impl_str = header_str(plan.header_fields, LAST_REMOTE_IMPL_AT)\n            learn_status = header_str(plan.header_fields, LEARN_STATUS)\n            learn_plan_issue = header_int(plan.header_fields, LEARN_PLAN_ISSUE)\n            learn_plan_pr = header_int(plan.header_fields, LEARN_PLAN_PR)\n            learn_run_id = header_str(plan.header_fields, LEARN_RUN_ID)\n            review_pr = header_int(plan.header_fields, REVIEW_PR)\n\n        # Extract objective_issue from pre-parsed header fields\n        objective_issue = header_int(plan.header_fields, OBJECTIVE_ISSUE)\n\n        # Look up learn plan issue closed state\n        learn_plan_issue_closed: bool | None = None\n        if learn_plan_issue is not None and learn_plan_issue in learn_issue_states:\n            learn_plan_issue_closed = learn_issue_states[learn_plan_issue]\n\n        # Format learn display (full text for detail modal, icon-only for table)\n        learn_display = _format_learn_display(\n            learn_status,\n            learn_plan_issue,\n            learn_plan_pr,\n            learn_plan_issue_closed=learn_plan_issue_closed,\n        )\n        learn_display_icon = _format_learn_display_icon(\n            learn_status,\n            learn_plan_issue,\n            learn_plan_pr,\n            learn_plan_issue_closed=learn_plan_issue_closed,\n        )\n\n        # Get datetime versions for storage (already parsed by YAML)\n        last_local_impl_at = header_datetime(plan.header_fields, LAST_LOCAL_IMPL_AT)\n        last_remote_impl_at = header_datetime(plan.header_fields, LAST_REMOTE_IMPL_AT)\n\n        # Format time displays\n        local_impl = format_relative_time(local_impl_str)\n        local_impl_display = local_impl if local_impl else \"-\"\n        remote_impl = format_relative_time(remote_impl_str)\n        remote_impl_display = remote_impl if remote_impl else \"-\"\n\n        # PR info\n        pr_number: int | None = None\n        pr_url: str | None = None\n        pr_title: str | None = None\n        pr_state: str | None = None\n        pr_head_branch: str | None = None\n        pr_display = \"-\"\n        checks_display = \"-\"\n\n        # Comment counts - \"-\" when no PR\n        resolved_comment_count = 0\n        total_comment_count = 0\n        comments_display = \"-\"\n\n        # PR status fields for lifecycle enrichment\n        pr_is_draft: bool | None = None\n        pr_has_conflicts: bool | None = None\n        pr_review_decision: str | None = None\n\n        if plan_id in pr_linkages:\n            issue_prs = pr_linkages[plan_id]\n            if review_pr is not None:\n                exclude_pr_numbers: set[int] | None = {review_pr}\n            else:\n                exclude_pr_numbers = None\n            selected_pr = select_display_pr(issue_prs, exclude_pr_numbers=exclude_pr_numbers)\n            if selected_pr is not None:\n                pr_number = selected_pr.number\n                pr_title = selected_pr.title\n                pr_state = selected_pr.state\n                pr_head_branch = selected_pr.head_branch\n                graphite_url = self._ctx.graphite.get_graphite_url(\n                    GitHubRepoId(selected_pr.owner, selected_pr.repo), selected_pr.number\n                )\n                pr_url = graphite_url if use_graphite and graphite_url else selected_pr.url\n                emoji = get_pr_status_emoji(selected_pr)\n                if selected_pr.will_close_target:\n                    emoji += \"🔗\"\n                pr_display = f\"#{selected_pr.number} {emoji}\"\n                checks_display = format_checks_cell(selected_pr)\n\n                # Extract status fields for lifecycle enrichment\n                pr_is_draft = selected_pr.is_draft\n                pr_has_conflicts = selected_pr.has_conflicts\n                pr_review_decision = selected_pr.review_decision\n\n                # Get review thread counts from batched PR data\n                if selected_pr.review_thread_counts is not None:\n                    resolved_comment_count, total_comment_count = selected_pr.review_thread_counts\n                    comments_display = f\"{resolved_comment_count}/{total_comment_count}\"\n                else:\n                    comments_display = \"0/0\"\n\n        # Workflow run info\n        run_id: str | None = None\n        run_status: str | None = None\n        run_conclusion: str | None = None\n        run_id_display = \"-\"\n        run_state_display = \"-\"\n        run_url: str | None = None\n\n        if workflow_run is not None:\n            run_id = str(workflow_run.run_id)\n            run_status = workflow_run.status\n            run_conclusion = workflow_run.conclusion\n            if plan.url:\n                parts = plan.url.split(\"/\")\n                if len(parts) >= 5:\n                    owner = parts[-4]\n                    repo_name = parts[-3]\n                    run_url = (\n                        f\"https://github.com/{owner}/{repo_name}/actions/runs/{workflow_run.run_id}\"\n                    )\n            run_id_display = format_workflow_run_id(workflow_run, run_url)\n            run_state_display = format_workflow_outcome(workflow_run)\n\n        # Log entries (empty for now - will be fetched on demand in the modal)\n        log_entries: tuple[tuple[str, str, str], ...] = ()\n\n        # Build learn_run_url for pending status\n        learn_run_url: str | None = None\n        if learn_run_id is not None and plan.url is not None:\n            parts = plan.url.split(\"/\")\n            if len(parts) >= 5:\n                owner = parts[-4]\n                repo_name = parts[-3]\n                learn_run_url = (\n                    f\"https://github.com/{owner}/{repo_name}/actions/runs/{learn_run_id}\"\n                )\n\n        # Format objective display\n        objective_display = f\"#{objective_issue}\" if objective_issue is not None else \"-\"\n\n        # Parse roadmap for objective-specific fields\n        objective_done_nodes = 0\n        objective_total_nodes = 0\n        objective_progress_display = \"-\"\n        objective_next_node_display = \"-\"\n        objective_deps_display = \"-\"\n        objective_in_flight_display = \"-\"\n        if plan.body:\n            phases, _errors = parse_roadmap(plan.body)\n            if phases:\n                graph = build_graph(phases)\n                summary = compute_graph_summary(graph)\n                objective_done_nodes = summary[\"done\"]\n                objective_total_nodes = summary[\"total_nodes\"]\n                objective_progress_display = f\"{objective_done_nodes}/{objective_total_nodes}\"\n\n                # Compute in-flight count (planning + in_progress)\n                in_flight = summary[\"planning\"] + summary[\"in_progress\"]\n                objective_in_flight_display = str(in_flight) if in_flight > 0 else \"-\"\n\n                # Compute next node display with unblocked count prefix\n                pending_unblocked = graph.pending_unblocked_nodes()\n                next_node = find_graph_next_node(graph, phases)\n                if next_node is not None:\n                    step_text = f\"{next_node['id']} {next_node['description']}\"\n                    if len(pending_unblocked) > 1:\n                        step_text = f\"({len(pending_unblocked)}) {step_text}\"\n                    if len(step_text) > 60:\n                        step_text = step_text[:57] + \"...\"\n                    objective_next_node_display = step_text\n                    min_status = graph.min_dep_status(next_node[\"id\"])\n                    if min_status is None or min_status in _TERMINAL_STATUSES:\n                        objective_deps_display = \"ready\"\n                    else:\n                        objective_deps_display = min_status.replace(\"_\", \" \")\n\n        # Format updated_at display\n        updated_display = format_relative_time(plan.updated_at.isoformat()) or \"-\"\n\n        # Format created_at display\n        created_display = format_relative_time(plan.created_at.isoformat()) or \"-\"\n\n        # Determine if this is a learn plan\n        is_learn_plan = \"erk-learn\" in plan.labels\n\n        # Compute lifecycle display from header or infer from metadata\n        lifecycle_display = _compute_lifecycle_display(\n            plan, has_workflow_run=workflow_run is not None\n        )\n\n        # Enrich lifecycle display with PR status indicators\n        lifecycle_display = format_lifecycle_with_status(\n            lifecycle_display,\n            is_draft=pr_is_draft,\n            has_conflicts=pr_has_conflicts,\n            review_decision=pr_review_decision,\n        )\n\n        return PlanRowData(\n            plan_id=plan_id,\n            plan_url=plan.url,\n            pr_number=pr_number,\n            pr_url=pr_url,\n            pr_display=pr_display,\n            checks_display=checks_display,\n            worktree_name=worktree_name,\n            exists_locally=exists_locally,\n            local_impl_display=local_impl_display,\n            remote_impl_display=remote_impl_display,\n            run_id_display=run_id_display,\n            run_state_display=run_state_display,\n            run_url=run_url,\n            full_title=full_title,\n            plan_body=plan.body or \"\",\n            pr_title=pr_title,\n            pr_state=pr_state,\n            pr_head_branch=pr_head_branch,\n            worktree_branch=worktree_branch,\n            last_local_impl_at=last_local_impl_at,\n            last_remote_impl_at=last_remote_impl_at,\n            run_id=run_id,\n            run_status=run_status,\n            run_conclusion=run_conclusion,\n            log_entries=log_entries,\n            resolved_comment_count=resolved_comment_count,\n            total_comment_count=total_comment_count,\n            comments_display=comments_display,\n            learn_status=learn_status,\n            learn_plan_issue=learn_plan_issue,\n            learn_plan_issue_closed=learn_plan_issue_closed,\n            learn_plan_pr=learn_plan_pr,\n            learn_run_url=learn_run_url,\n            learn_display=learn_display,\n            learn_display_icon=learn_display_icon,\n            objective_issue=objective_issue,\n            objective_display=objective_display,\n            objective_done_nodes=objective_done_nodes,\n            objective_total_nodes=objective_total_nodes,\n            objective_progress_display=objective_progress_display,\n            objective_next_node_display=objective_next_node_display,\n            objective_deps_display=objective_deps_display,\n            objective_in_flight_display=objective_in_flight_display,\n            updated_at=plan.updated_at,\n            updated_display=updated_display,\n            created_at=plan.created_at,\n            created_display=created_display,\n            author=str(plan.metadata.get(\"author\", \"\")),\n            is_learn_plan=is_learn_plan,\n            lifecycle_display=lifecycle_display,\n        )\n\n\ndef _format_learn_display(\n    learn_status: str | None,\n    learn_plan_issue: int | None,\n    learn_plan_pr: int | None,\n    *,\n    learn_plan_issue_closed: bool | None,\n) -> str:\n    \"\"\"Format learn status for display with inline descriptions.\n\n    Args:\n        learn_status: Raw status value from plan header\n        learn_plan_issue: Issue number of generated learn plan\n        learn_plan_pr: PR number that implemented the learn plan\n        learn_plan_issue_closed: Whether the learn plan issue is closed\n\n    Returns:\n        Formatted display string based on status:\n        - None or \"not_started\" -> \"- not started\"\n        - \"pending\" -> \"⟳ in progress\"\n        - \"completed_no_plan\" -> \"∅ no insights\"\n        - \"completed_with_plan\" + closed -> \"✅ #456\" (using learn_plan_issue)\n        - \"completed_with_plan\" + open -> \"📋 #456\" (using learn_plan_issue)\n        - \"pending_review\" -> \"🚧 #789\" (using learn_plan_pr for draft PR)\n        - \"plan_completed\" -> \"✓ #12\" (using learn_plan_pr)\n    \"\"\"\n    if learn_status is None or learn_status == \"not_started\":\n        return \"- not started\"\n    if learn_status == \"pending\":\n        return \"⟳ in progress\"\n    if learn_status == \"completed_no_plan\":\n        return \"∅ no insights\"\n    if learn_status == \"completed_with_plan\" and learn_plan_issue is not None:\n        if learn_plan_issue_closed is True:\n            return f\"✅ #{learn_plan_issue}\"\n        return f\"📋 #{learn_plan_issue}\"\n    if learn_status == \"pending_review\" and learn_plan_pr is not None:\n        return f\"🚧 #{learn_plan_pr}\"\n    if learn_status == \"plan_completed\" and learn_plan_pr is not None:\n        return f\"✓ #{learn_plan_pr}\"\n    # Fallback for unknown status\n    return \"- not started\"\n\n\ndef _format_learn_display_icon(\n    learn_status: str | None,\n    learn_plan_issue: int | None,\n    learn_plan_pr: int | None,\n    *,\n    learn_plan_issue_closed: bool | None,\n) -> str:\n    \"\"\"Format learn status as icon-only for table display.\n\n    Args:\n        learn_status: Raw status value from plan header\n        learn_plan_issue: Issue number of generated learn plan\n        learn_plan_pr: PR number that implemented the learn plan\n        learn_plan_issue_closed: Whether the learn plan issue is closed\n\n    Returns:\n        Icon-only display string based on status:\n        - None or \"not_started\" -> \"-\"\n        - \"pending\" -> \"⟳\"\n        - \"completed_no_plan\" -> \"∅\"\n        - \"completed_with_plan\" + closed -> \"✅ #456\" (using learn_plan_issue)\n        - \"completed_with_plan\" + open -> \"📋 #456\" (using learn_plan_issue)\n        - \"pending_review\" -> \"🚧 #789\" (using learn_plan_pr for draft PR)\n        - \"plan_completed\" -> \"✓ #12\" (using learn_plan_pr)\n    \"\"\"\n    if learn_status is None or learn_status == \"not_started\":\n        return \"-\"\n    if learn_status == \"pending\":\n        return \"⟳\"\n    if learn_status == \"completed_no_plan\":\n        return \"∅\"\n    if learn_status == \"completed_with_plan\" and learn_plan_issue is not None:\n        if learn_plan_issue_closed is True:\n            return f\"✅ #{learn_plan_issue}\"\n        return f\"📋 #{learn_plan_issue}\"\n    if learn_status == \"pending_review\" and learn_plan_pr is not None:\n        return f\"🚧 #{learn_plan_pr}\"\n    if learn_status == \"plan_completed\" and learn_plan_pr is not None:\n        return f\"✓ #{learn_plan_pr}\"\n    # Fallback for unknown status\n    return \"-\"\n\n\ndef _compute_lifecycle_display(plan: Plan, *, has_workflow_run: bool) -> str:\n    \"\"\"Compute lifecycle stage display string for a plan.\n\n    Delegates to lifecycle.compute_lifecycle_display. This wrapper preserves\n    the module-private name used by callers within this file.\n    \"\"\"\n    from erk_shared.gateway.plan_data_provider.lifecycle import compute_lifecycle_display\n\n    return compute_lifecycle_display(plan, has_workflow_run=has_workflow_run)\n\n\ndef _ensure_erk_metadata_dir_from_context(repo: RepoContext | NoRepoSentinel) -> None:\n    \"\"\"Ensure erk metadata directory exists, handling sentinel case.\"\"\"\n    if isinstance(repo, RepoContext):\n        ensure_erk_metadata_dir(repo)\n","structuredPatch":[{"oldStart":497,"oldLines":7,"newStart":497,"newLines":10,"lines":["             )"," ","             # Fallback for draft-PR branches: read .impl/plan-ref.json","-            if issue_number is None and worktree.branch and (worktree.branch.startswith(\"plnd/\") or worktree.branch.startswith(\"planned/\")):","+            is_draft_pr_branch = worktree.branch and (","+                worktree.branch.startswith(\"plnd/\") or worktree.branch.startswith(\"planned/\")","+            )","+            if issue_number is None and is_draft_pr_branch:","                 impl_dir = worktree.path / \".impl\"","                 plan_ref = read_plan_ref(impl_dir)","                 if plan_ref is not None and plan_ref.plan_id.isdigit():"]}],"userModified":false,"replaceAll":false}}
{"parentUuid":"58e5d53f-6c1b-4446-9dbe-e3db3bbcda9a","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_016Y4i1HE57sgoY5B8kUiHH6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014wEpjNCmMAGHpXTLHH7wFu","name":"Task","input":{"subagent_type":"devrun","prompt":"Run the following commands and report results:\n\n1. `ruff check packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py`\n2. `ruff format --check packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py`\n3. `pytest tests/tui/data/test_provider.py -x -q`\n\nReport results.","description":"Verify lint fix"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":328,"cache_read_input_tokens":122894,"cache_creation":{"ephemeral_5m_input_tokens":328,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ4iESs14yYuwYAoKxD","type":"assistant","uuid":"944880fe-7adc-45a5-9375-53797e258fbc","timestamp":"2026-02-22T14:51:06.169Z"}
{"parentUuid":"944880fe-7adc-45a5-9375-53797e258fbc","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014wEpjNCmMAGHpXTLHH7wFu","type":"tool_result","content":[{"type":"text","text":"**Results:**\n\n1. **ruff check** passed: All checks passed!\n\n2. **ruff format** passed: 1 file already formatted (no formatting changes needed)\n\n3. **pytest** passed: 23 tests passed in 100%\n\nAll three commands completed successfully with no issues."},{"type":"text","text":"agentId: a71a121 (for resuming to continue this agent's work if needed)"}]}]},"uuid":"7e8a9345-2d95-4433-900e-32052f34b259","timestamp":"2026-02-22T14:51:17.222Z","toolUseResult":{"status":"completed","prompt":"Run the following commands and report results:\n\n1. `ruff check packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py`\n2. `ruff format --check packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py`\n3. `pytest tests/tui/data/test_provider.py -x -q`\n\nReport results.","agentId":"a71a121","content":[{"type":"text","text":"**Results:**\n\n1. **ruff check** passed: All checks passed!\n\n2. **ruff format** passed: 1 file already formatted (no formatting changes needed)\n\n3. **pytest** passed: 23 tests passed in 100%\n\nAll three commands completed successfully with no issues."}],"totalDurationMs":11038,"totalTokens":12853,"totalToolUseCount":3,"usage":{"input_tokens":7,"cache_creation_input_tokens":396,"cache_read_input_tokens":12381,"cache_creation":{"ephemeral_5m_input_tokens":396,"ephemeral_1h_input_tokens":0},"output_tokens":69,"service_tier":"standard","inference_geo":"not_available"}}}
{"parentUuid":"7e8a9345-2d95-4433-900e-32052f34b259","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01CGwRj6ani8Ygp4fbqYEB7p","type":"message","role":"assistant","content":[{"type":"text","text":"All checks pass. Let me also run a broader test to make sure nothing else is broken:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":292,"cache_read_input_tokens":123222,"cache_creation":{"ephemeral_5m_input_tokens":292,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ5oh8xJVdXpttcZDeF","type":"assistant","uuid":"139665e7-b976-4c3e-92f0-74c27efd46da","timestamp":"2026-02-22T14:51:20.585Z"}
{"parentUuid":"139665e7-b976-4c3e-92f0-74c27efd46da","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01CGwRj6ani8Ygp4fbqYEB7p","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016ThbWXqf2v3HTbiYzEQAeP","name":"Task","input":{"subagent_type":"devrun","prompt":"Run the full unit test suite to make sure nothing is broken:\n\n`pytest tests/ -x -q --timeout=30`\n\nReport results - total count, any failures.","description":"Run full test suite"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":292,"cache_read_input_tokens":123222,"cache_creation":{"ephemeral_5m_input_tokens":292,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ5oh8xJVdXpttcZDeF","type":"assistant","uuid":"c1e68d6a-af8c-40f9-a3af-a8246854071d","timestamp":"2026-02-22T14:51:22.034Z"}
{"parentUuid":"c1e68d6a-af8c-40f9-a3af-a8246854071d","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016ThbWXqf2v3HTbiYzEQAeP","type":"tool_result","content":[{"type":"text","text":"pytest failed: 1 issue found\n\n**File:** `/home/runner/work/erk/erk/tests/cli/commands/split/test_plan.py::test_execute_split_plan_creates_worktrees`\n\n**Error Type:** AttributeError\n\n**Message:** 'FakeGit' object has no attribute 'worktree'\n\n**Location:** Line 286 in the test, failing at line 207 in `src/erk/cli/commands/stack/split_old/plan.py`\n\nThe test is passing an incorrect fake object. The `execute_split_plan()` function expects `git_ops.worktree.add_worktree()` to exist, but the `FakeGit` class in the test only has `add_worktree()` directly on the object. The fake needs a `worktree` attribute with the `add_worktree` method."},{"type":"text","text":"agentId: a351aa1 (for resuming to continue this agent's work if needed)"}]}]},"uuid":"2fdb737b-27e5-4eb9-b141-d863f4e501b5","timestamp":"2026-02-22T14:51:41.788Z","toolUseResult":{"status":"completed","prompt":"Run the full unit test suite to make sure nothing is broken:\n\n`pytest tests/ -x -q --timeout=30`\n\nReport results - total count, any failures.","agentId":"a351aa1","content":[{"type":"text","text":"pytest failed: 1 issue found\n\n**File:** `/home/runner/work/erk/erk/tests/cli/commands/split/test_plan.py::test_execute_split_plan_creates_worktrees`\n\n**Error Type:** AttributeError\n\n**Message:** 'FakeGit' object has no attribute 'worktree'\n\n**Location:** Line 286 in the test, failing at line 207 in `src/erk/cli/commands/stack/split_old/plan.py`\n\nThe test is passing an incorrect fake object. The `execute_split_plan()` function expects `git_ops.worktree.add_worktree()` to exist, but the `FakeGit` class in the test only has `add_worktree()` directly on the object. The fake needs a `worktree` attribute with the `add_worktree` method."}],"totalDurationMs":19738,"totalTokens":13871,"totalToolUseCount":2,"usage":{"input_tokens":7,"cache_creation_input_tokens":1135,"cache_read_input_tokens":12517,"cache_creation":{"ephemeral_5m_input_tokens":1135,"ephemeral_1h_input_tokens":0},"output_tokens":212,"service_tier":"standard","inference_geo":"not_available"}}}
{"parentUuid":"2fdb737b-27e5-4eb9-b141-d863f4e501b5","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01UnP8qQyk3DPkacDVRgrWan","type":"message","role":"assistant","content":[{"type":"text","text":"That test failure is pre-existing (unrelated to my changes - it's a `FakeGit` missing attribute issue in `test_plan.py`). Let me verify by checking if it fails on master too:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":730,"cache_read_input_tokens":123514,"cache_creation":{"ephemeral_5m_input_tokens":730,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ7cheVZs1Qedqq3MMn","type":"assistant","uuid":"436f0c13-2675-47f4-8f21-3640636a7bdf","timestamp":"2026-02-22T14:51:45.561Z"}
{"parentUuid":"436f0c13-2675-47f4-8f21-3640636a7bdf","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01UnP8qQyk3DPkacDVRgrWan","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011nphMg4kdSknb1SRjhcqbY","name":"Bash","input":{"command":"git stash && pytest tests/cli/commands/split/test_plan.py::test_execute_split_plan_creates_worktrees -x -q 2>&1; git stash pop","description":"Check if test fails on master too"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":730,"cache_read_input_tokens":123514,"cache_creation":{"ephemeral_5m_input_tokens":730,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ7cheVZs1Qedqq3MMn","type":"assistant","uuid":"c5e2a904-fb75-4894-9e81-73d753b00cfb","timestamp":"2026-02-22T14:51:46.362Z"}
{"parentUuid":"c5e2a904-fb75-4894-9e81-73d753b00cfb","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011nphMg4kdSknb1SRjhcqbY","type":"tool_result","content":"Saved working directory and index state WIP on planned/shorted-planned-prefix-02-22-0934: 149f22141 Remove plan staging dirs before implementation\nF\n=================================== FAILURES ===================================\n__________________ test_execute_split_plan_creates_worktrees ___________________\n\n    def test_execute_split_plan_creates_worktrees() -> None:\n        \"\"\"Normal execution creates worktrees.\"\"\"\n    \n        # Create fake git ops\n        class FakeGit:\n            def __init__(self):\n                self.created_worktrees = []\n    \n            def add_worktree(self, repo_root, path, *, branch=None, ref=None, create_branch=True):\n                self.created_worktrees.append((repo_root, path, branch, ref, create_branch))\n    \n        plan = SplitPlan(\n            stack_branches=[\"main\", \"feat-1\", \"feat-2\"],\n            branches_to_split=[\"feat-1\", \"feat-2\"],\n            existing_worktrees=[],\n            target_paths={\n                \"feat-1\": Path(\"/repo/erks/feat-1\"),\n                \"feat-2\": Path(\"/repo/erks/feat-2\"),\n            },\n            source_worktree_path=Path(\"/repo\"),\n            repo_root=Path(\"/repo\"),\n            skipped_current=False,\n            skipped_trunk=True,\n        )\n    \n        git_ops = FakeGit()\n>       results = execute_split_plan(plan, git_ops)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests/cli/commands/split/test_plan.py:286: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nplan = SplitPlan(stack_branches=['main', 'feat-1', 'feat-2'], branches_to_split=['feat-1', 'feat-2'], existing_worktrees=[], ...2')}, source_worktree_path=PosixPath('/repo'), repo_root=PosixPath('/repo'), skipped_current=False, skipped_trunk=True)\ngit_ops = <tests.cli.commands.split.test_plan.test_execute_split_plan_creates_worktrees.<locals>.FakeGit object at 0x7ff428ef3cb0>\n\n    def execute_split_plan(\n        plan: SplitPlan,\n        git_ops,  # Type annotation omitted to avoid circular import\n    ) -> list[tuple[str, Path]]:\n        \"\"\"Execute a split plan by creating worktrees.\n    \n        The actual execution depends on the Git implementation passed in:\n        - RealGit: Actually creates the worktrees\n        - DryRunGit: No-op execution for dry-run mode\n        - PrintingGit: Prints operations (wraps either Real or Noop)\n    \n        Args:\n            plan: The split plan to execute\n            git_ops: Git instance for performing git operations\n    \n        Returns:\n            List of (branch, worktree_path) tuples indicating what was processed\n        \"\"\"\n        results = []\n    \n        for branch in plan.branches_to_split:\n            target_path = plan.target_paths[branch]\n    \n            # Create worktree for existing branch\n            # Using create_branch=False since branch already exists\n            # The actual behavior depends on the injected Git implementation\n>           git_ops.worktree.add_worktree(\n            ^^^^^^^^^^^^^^^^\n                plan.repo_root,\n                target_path,\n                branch=branch,\n                ref=None,\n                create_branch=False,\n            )\nE           AttributeError: 'FakeGit' object has no attribute 'worktree'\n\nsrc/erk/cli/commands/stack/split_old/plan.py:207: AttributeError\n=========================== short test summary info ============================\nFAILED tests/cli/commands/split/test_plan.py::test_execute_split_plan_creates_worktrees - AttributeError: 'FakeGit' object has no attribute 'worktree'\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!\nOn branch planned/shorted-planned-prefix-02-22-0934\nYour branch is up to date with 'origin/planned/shorted-planned-prefix-02-22-0934'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .claude/commands/erk/git-pr-push.md\n\tmodified:   docs/learned/erk/branch-naming.md\n\tmodified:   docs/learned/planning/branch-name-inference.md\n\tmodified:   docs/learned/planning/draft-pr-plan-backend.md\n\tmodified:   docs/learned/planning/index.md\n\tmodified:   docs/learned/planning/plan-title-prefix-system.md\n\tmodified:   docs/learned/planning/tripwires.md\n\tmodified:   packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py\n\tmodified:   packages/erk-shared/src/erk_shared/naming.py\n\tmodified:   src/erk/cli/commands/exec/scripts/plan_create_review_branch.py\n\tmodified:   src/erk/cli/commands/one_shot_dispatch.py\n\tmodified:   src/erk/cli/commands/pr/submit_pipeline.py\n\tmodified:   src/erk/cli/commands/submit.py\n\tmodified:   src/erk/cli/constants.py\n\tmodified:   tests/commands/land/test_get_objective_for_branch.py\n\tmodified:   tests/commands/one_shot/test_one_shot_dispatch.py\n\tmodified:   tests/commands/submit/test_basic_submission.py\n\tmodified:   tests/commands/submit/test_pr_creation.py\n\tmodified:   tests/core/utils/test_naming.py\n\tmodified:   tests/tui/data/test_provider.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_save.py\n\tmodified:   tests/unit/fakes/test_fake_git.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (25593ca413976e3ab18dea6861ca47d6e142b2fe)","is_error":false}]},"uuid":"f6d68a57-70bb-4a0a-8e18-96c88c87e8af","timestamp":"2026-02-22T14:51:48.508Z","toolUseResult":{"stdout":"Saved working directory and index state WIP on planned/shorted-planned-prefix-02-22-0934: 149f22141 Remove plan staging dirs before implementation\nF\n=================================== FAILURES ===================================\n__________________ test_execute_split_plan_creates_worktrees ___________________\n\n    def test_execute_split_plan_creates_worktrees() -> None:\n        \"\"\"Normal execution creates worktrees.\"\"\"\n    \n        # Create fake git ops\n        class FakeGit:\n            def __init__(self):\n                self.created_worktrees = []\n    \n            def add_worktree(self, repo_root, path, *, branch=None, ref=None, create_branch=True):\n                self.created_worktrees.append((repo_root, path, branch, ref, create_branch))\n    \n        plan = SplitPlan(\n            stack_branches=[\"main\", \"feat-1\", \"feat-2\"],\n            branches_to_split=[\"feat-1\", \"feat-2\"],\n            existing_worktrees=[],\n            target_paths={\n                \"feat-1\": Path(\"/repo/erks/feat-1\"),\n                \"feat-2\": Path(\"/repo/erks/feat-2\"),\n            },\n            source_worktree_path=Path(\"/repo\"),\n            repo_root=Path(\"/repo\"),\n            skipped_current=False,\n            skipped_trunk=True,\n        )\n    \n        git_ops = FakeGit()\n>       results = execute_split_plan(plan, git_ops)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests/cli/commands/split/test_plan.py:286: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nplan = SplitPlan(stack_branches=['main', 'feat-1', 'feat-2'], branches_to_split=['feat-1', 'feat-2'], existing_worktrees=[], ...2')}, source_worktree_path=PosixPath('/repo'), repo_root=PosixPath('/repo'), skipped_current=False, skipped_trunk=True)\ngit_ops = <tests.cli.commands.split.test_plan.test_execute_split_plan_creates_worktrees.<locals>.FakeGit object at 0x7ff428ef3cb0>\n\n    def execute_split_plan(\n        plan: SplitPlan,\n        git_ops,  # Type annotation omitted to avoid circular import\n    ) -> list[tuple[str, Path]]:\n        \"\"\"Execute a split plan by creating worktrees.\n    \n        The actual execution depends on the Git implementation passed in:\n        - RealGit: Actually creates the worktrees\n        - DryRunGit: No-op execution for dry-run mode\n        - PrintingGit: Prints operations (wraps either Real or Noop)\n    \n        Args:\n            plan: The split plan to execute\n            git_ops: Git instance for performing git operations\n    \n        Returns:\n            List of (branch, worktree_path) tuples indicating what was processed\n        \"\"\"\n        results = []\n    \n        for branch in plan.branches_to_split:\n            target_path = plan.target_paths[branch]\n    \n            # Create worktree for existing branch\n            # Using create_branch=False since branch already exists\n            # The actual behavior depends on the injected Git implementation\n>           git_ops.worktree.add_worktree(\n            ^^^^^^^^^^^^^^^^\n                plan.repo_root,\n                target_path,\n                branch=branch,\n                ref=None,\n                create_branch=False,\n            )\nE           AttributeError: 'FakeGit' object has no attribute 'worktree'\n\nsrc/erk/cli/commands/stack/split_old/plan.py:207: AttributeError\n=========================== short test summary info ============================\nFAILED tests/cli/commands/split/test_plan.py::test_execute_split_plan_creates_worktrees - AttributeError: 'FakeGit' object has no attribute 'worktree'\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!\nOn branch planned/shorted-planned-prefix-02-22-0934\nYour branch is up to date with 'origin/planned/shorted-planned-prefix-02-22-0934'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .claude/commands/erk/git-pr-push.md\n\tmodified:   docs/learned/erk/branch-naming.md\n\tmodified:   docs/learned/planning/branch-name-inference.md\n\tmodified:   docs/learned/planning/draft-pr-plan-backend.md\n\tmodified:   docs/learned/planning/index.md\n\tmodified:   docs/learned/planning/plan-title-prefix-system.md\n\tmodified:   docs/learned/planning/tripwires.md\n\tmodified:   packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py\n\tmodified:   packages/erk-shared/src/erk_shared/naming.py\n\tmodified:   src/erk/cli/commands/exec/scripts/plan_create_review_branch.py\n\tmodified:   src/erk/cli/commands/one_shot_dispatch.py\n\tmodified:   src/erk/cli/commands/pr/submit_pipeline.py\n\tmodified:   src/erk/cli/commands/submit.py\n\tmodified:   src/erk/cli/constants.py\n\tmodified:   tests/commands/land/test_get_objective_for_branch.py\n\tmodified:   tests/commands/one_shot/test_one_shot_dispatch.py\n\tmodified:   tests/commands/submit/test_basic_submission.py\n\tmodified:   tests/commands/submit/test_pr_creation.py\n\tmodified:   tests/core/utils/test_naming.py\n\tmodified:   tests/tui/data/test_provider.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_save.py\n\tmodified:   tests/unit/fakes/test_fake_git.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (25593ca413976e3ab18dea6861ca47d6e142b2fe)","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"f6d68a57-70bb-4a0a-8e18-96c88c87e8af","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Ssk4kLP3sUpTA5k4Bxgq8q","type":"message","role":"assistant","content":[{"type":"text","text":"Confirmed - that test failure is pre-existing and unrelated to my changes. Let me now verify the `.impl/` folder and submit the PR."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1885,"cache_read_input_tokens":124244,"cache_creation":{"ephemeral_5m_input_tokens":1885,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ88GtbiE82Jh2wsWGW","type":"assistant","uuid":"21664272-00dd-4f8f-933b-77849a094ab5","timestamp":"2026-02-22T14:51:51.930Z"}
{"parentUuid":"21664272-00dd-4f8f-933b-77849a094ab5","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Ssk4kLP3sUpTA5k4Bxgq8q","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SpnxPg4cgB1Wk9a7jzMrna","name":"Bash","input":{"command":"erk exec impl-verify 2>&1","description":"Verify .impl/ preserved"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1885,"cache_read_input_tokens":124244,"cache_creation":{"ephemeral_5m_input_tokens":1885,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ88GtbiE82Jh2wsWGW","type":"assistant","uuid":"092408cd-e4bc-4aea-b5fc-76f24d23abb4","timestamp":"2026-02-22T14:51:52.898Z"}
{"parentUuid":"092408cd-e4bc-4aea-b5fc-76f24d23abb4","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SpnxPg4cgB1Wk9a7jzMrna","type":"tool_result","content":"{\"valid\": true, \"impl_dir\": \"/home/runner/work/erk/erk/.impl\"}","is_error":false}]},"uuid":"908b144b-8541-4d2c-bf8f-e373fc413ca8","timestamp":"2026-02-22T14:51:53.898Z","toolUseResult":{"stdout":"{\"valid\": true, \"impl_dir\": \"/home/runner/work/erk/erk/.impl\"}","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"908b144b-8541-4d2c-bf8f-e373fc413ca8","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01F3sPt6MetjBnKAhPnG5GWQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GxW3hoDMTd5fixGWGvvh5H","name":"TodoWrite","input":{"todos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"completed","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"completed","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"completed","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"completed","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"completed","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"completed","activeForm":"Updating tests"},{"content":"Run CI checks","status":"completed","activeForm":"Running CI checks"},{"content":"Submit PR","status":"in_progress","activeForm":"Submitting PR"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":490,"cache_read_input_tokens":126129,"cache_creation":{"ephemeral_5m_input_tokens":490,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ8WUdFCAnp57Bf1tPY","type":"assistant","uuid":"c615db8e-3fa3-4502-8e05-f571f89cf07e","timestamp":"2026-02-22T14:52:01.137Z"}
{"parentUuid":"c615db8e-3fa3-4502-8e05-f571f89cf07e","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GxW3hoDMTd5fixGWGvvh5H","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"ea64691b-1c00-4de5-b297-b78e5dfc6e1e","timestamp":"2026-02-22T14:52:01.157Z","toolUseResult":{"oldTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"completed","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"completed","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"completed","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"completed","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"completed","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"completed","activeForm":"Updating tests"},{"content":"Run CI checks","status":"in_progress","activeForm":"Running CI checks"},{"content":"Submit PR","status":"pending","activeForm":"Submitting PR"}],"newTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"completed","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"completed","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"completed","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"completed","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"completed","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"completed","activeForm":"Updating tests"},{"content":"Run CI checks","status":"completed","activeForm":"Running CI checks"},{"content":"Submit PR","status":"in_progress","activeForm":"Submitting PR"}]}}
{"parentUuid":"ea64691b-1c00-4de5-b297-b78e5dfc6e1e","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Q6ct9fa5VhPfUKANMpefCs","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me signal end of implementation and submit:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":126619,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ93WfzPFKdMJgxNRkm","type":"assistant","uuid":"f5298193-1cb4-4f5d-86be-18269b03a127","timestamp":"2026-02-22T14:52:03.589Z"}
{"parentUuid":"f5298193-1cb4-4f5d-86be-18269b03a127","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Q6ct9fa5VhPfUKANMpefCs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KYGuVdLskj1j6a4scZEiGx","name":"Bash","input":{"command":"erk exec impl-signal ended --session-id \"${CLAUDE_SESSION_ID}\" 2>/dev/null || true","description":"Signal implementation ended"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":575,"cache_read_input_tokens":126619,"cache_creation":{"ephemeral_5m_input_tokens":575,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ93WfzPFKdMJgxNRkm","type":"assistant","uuid":"279a656b-967b-4256-9eaf-68d03070547b","timestamp":"2026-02-22T14:52:04.861Z"}
{"parentUuid":"279a656b-967b-4256-9eaf-68d03070547b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KYGuVdLskj1j6a4scZEiGx","type":"tool_result","content":"{\n  \"success\": true,\n  \"event\": \"ended\",\n  \"issue_number\": 7854\n}","is_error":false}]},"uuid":"dd8e4411-ee6a-42fd-bef8-0f1741189093","timestamp":"2026-02-22T14:52:07.237Z","toolUseResult":{"stdout":"{\n  \"success\": true,\n  \"event\": \"ended\",\n  \"issue_number\": 7854\n}","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"dd8e4411-ee6a-42fd-bef8-0f1741189093","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01RjBa9pSieUT77rSS84Cpjk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HnRKimN3PDvPMq6sUekDBt","name":"Bash","input":{"command":"git add -A && git status 2>&1","description":"Stage all changes"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":146,"cache_read_input_tokens":127194,"cache_creation":{"ephemeral_5m_input_tokens":146,"ephemeral_1h_input_tokens":0},"output_tokens":19,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ9VW7anqud3peJVriZ","type":"assistant","uuid":"1e5d6de0-2975-4b0a-92fc-3cce14a12536","timestamp":"2026-02-22T14:52:09.974Z"}
{"parentUuid":"1e5d6de0-2975-4b0a-92fc-3cce14a12536","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HnRKimN3PDvPMq6sUekDBt","type":"tool_result","content":"On branch planned/shorted-planned-prefix-02-22-0934\nYour branch is up to date with 'origin/planned/shorted-planned-prefix-02-22-0934'.\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tmodified:   .claude/commands/erk/git-pr-push.md\n\tmodified:   docs/learned/erk/branch-naming.md\n\tmodified:   docs/learned/planning/branch-name-inference.md\n\tmodified:   docs/learned/planning/draft-pr-plan-backend.md\n\tmodified:   docs/learned/planning/index.md\n\tmodified:   docs/learned/planning/plan-title-prefix-system.md\n\tmodified:   docs/learned/planning/tripwires.md\n\tmodified:   packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py\n\tmodified:   packages/erk-shared/src/erk_shared/naming.py\n\tmodified:   src/erk/cli/commands/exec/scripts/plan_create_review_branch.py\n\tmodified:   src/erk/cli/commands/one_shot_dispatch.py\n\tmodified:   src/erk/cli/commands/pr/submit_pipeline.py\n\tmodified:   src/erk/cli/commands/submit.py\n\tmodified:   src/erk/cli/constants.py\n\tmodified:   tests/commands/land/test_get_objective_for_branch.py\n\tmodified:   tests/commands/one_shot/test_one_shot_dispatch.py\n\tmodified:   tests/commands/submit/test_basic_submission.py\n\tmodified:   tests/commands/submit/test_pr_creation.py\n\tmodified:   tests/core/utils/test_naming.py\n\tmodified:   tests/tui/data/test_provider.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_save.py\n\tmodified:   tests/unit/fakes/test_fake_git.py","is_error":false}]},"uuid":"f58ba507-9523-4956-b56e-6817e77f1a3c","timestamp":"2026-02-22T14:52:10.896Z","toolUseResult":{"stdout":"On branch planned/shorted-planned-prefix-02-22-0934\nYour branch is up to date with 'origin/planned/shorted-planned-prefix-02-22-0934'.\n\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n\tmodified:   .claude/commands/erk/git-pr-push.md\n\tmodified:   docs/learned/erk/branch-naming.md\n\tmodified:   docs/learned/planning/branch-name-inference.md\n\tmodified:   docs/learned/planning/draft-pr-plan-backend.md\n\tmodified:   docs/learned/planning/index.md\n\tmodified:   docs/learned/planning/plan-title-prefix-system.md\n\tmodified:   docs/learned/planning/tripwires.md\n\tmodified:   packages/erk-shared/src/erk_shared/gateway/plan_data_provider/real.py\n\tmodified:   packages/erk-shared/src/erk_shared/naming.py\n\tmodified:   src/erk/cli/commands/exec/scripts/plan_create_review_branch.py\n\tmodified:   src/erk/cli/commands/one_shot_dispatch.py\n\tmodified:   src/erk/cli/commands/pr/submit_pipeline.py\n\tmodified:   src/erk/cli/commands/submit.py\n\tmodified:   src/erk/cli/constants.py\n\tmodified:   tests/commands/land/test_get_objective_for_branch.py\n\tmodified:   tests/commands/one_shot/test_one_shot_dispatch.py\n\tmodified:   tests/commands/submit/test_basic_submission.py\n\tmodified:   tests/commands/submit/test_pr_creation.py\n\tmodified:   tests/core/utils/test_naming.py\n\tmodified:   tests/tui/data/test_provider.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_create_review_branch.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_create_review_pr.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_migrate_to_draft_pr.py\n\tmodified:   tests/unit/cli/commands/exec/scripts/test_plan_save.py\n\tmodified:   tests/unit/fakes/test_fake_git.py","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"f58ba507-9523-4956-b56e-6817e77f1a3c","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01Sr2c9sCUS4BRW4Pv22Fqsb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012YcPdrHFpuNT7KUj2F1fTg","name":"Bash","input":{"command":"git commit -m \"$(cat <<'EOF'\nShorten planned/ branch prefix to plnd/ for shorter branch names\n\nChanges the draft-PR branch prefix from `planned/` (8 chars) to `plnd/`\n(5 chars), saving 3 characters in every branch name. The PR title prefix\nis also updated from `planned/` to `plnd/`.\n\nRegex patterns in extraction functions (extract_objective_number,\nextract_plan_review_issue_number) and the worktree mapping fallback\nin plan_data_provider accept both `plnd/` and legacy `planned/` for\nbackward compatibility with existing branches.\n\n🤖 Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>\nEOF\n)\"","description":"Commit all changes"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":681,"cache_read_input_tokens":127340,"cache_creation":{"ephemeral_5m_input_tokens":681,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJ9mRaBuxnLRNQCdz1G","type":"assistant","uuid":"f2d3479c-a941-4db3-bffe-6fb7a6bfb544","timestamp":"2026-02-22T14:52:18.548Z"}
{"parentUuid":"f2d3479c-a941-4db3-bffe-6fb7a6bfb544","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012YcPdrHFpuNT7KUj2F1fTg","type":"tool_result","content":"[planned/shorted-planned-prefix-02-22-0934 6c8fbc2ce] Shorten planned/ branch prefix to plnd/ for shorter branch names\n 25 files changed, 137 insertions(+), 117 deletions(-)","is_error":false}]},"uuid":"5122ca34-c300-41bc-bcfd-def14d52ac2b","timestamp":"2026-02-22T14:52:19.527Z","toolUseResult":{"stdout":"[planned/shorted-planned-prefix-02-22-0934 6c8fbc2ce] Shorten planned/ branch prefix to plnd/ for shorter branch names\n 25 files changed, 137 insertions(+), 117 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"5122ca34-c300-41bc-bcfd-def14d52ac2b","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01NrVdYfwGRVAhRg1e7ALCqi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SMeRNnvF6vifbsUzjTZyWD","name":"Bash","input":{"command":"git push origin planned/shorted-planned-prefix-02-22-0934 2>&1","description":"Push changes to remote"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":334,"cache_read_input_tokens":128021,"cache_creation":{"ephemeral_5m_input_tokens":334,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJAQ6Czvik8RiwQtMQT","type":"assistant","uuid":"17499530-8876-4c54-a9ea-6609226c17c1","timestamp":"2026-02-22T14:52:22.523Z"}
{"parentUuid":"17499530-8876-4c54-a9ea-6609226c17c1","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SMeRNnvF6vifbsUzjTZyWD","type":"tool_result","content":"remote: \nremote: GitHub found 18 vulnerabilities on dagster-io/erk's default branch (11 high, 4 moderate, 3 low). To find out more, visit:        \nremote:      https://github.com/dagster-io/erk/security/dependabot        \nremote: \nTo https://github.com/dagster-io/erk\n   149f22141..6c8fbc2ce  planned/shorted-planned-prefix-02-22-0934 -> planned/shorted-planned-prefix-02-22-0934","is_error":false}]},"uuid":"dcc47523-08ad-4828-b33f-b2f4505ec9eb","timestamp":"2026-02-22T14:52:24.986Z","toolUseResult":{"stdout":"remote: \nremote: GitHub found 18 vulnerabilities on dagster-io/erk's default branch (11 high, 4 moderate, 3 low). To find out more, visit:        \nremote:      https://github.com/dagster-io/erk/security/dependabot        \nremote: \nTo https://github.com/dagster-io/erk\n   149f22141..6c8fbc2ce  planned/shorted-planned-prefix-02-22-0934 -> planned/shorted-planned-prefix-02-22-0934","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"dcc47523-08ad-4828-b33f-b2f4505ec9eb","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_0159TuwYWiUEGkgmCcF3N4Qr","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me submit the PR:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":242,"cache_read_input_tokens":128355,"cache_creation":{"ephemeral_5m_input_tokens":242,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJAoSPxPcMdSTwe4o8N","type":"assistant","uuid":"4f60a0e5-1bfb-4ded-8493-92286d264446","timestamp":"2026-02-22T14:52:27.959Z"}
{"parentUuid":"4f60a0e5-1bfb-4ded-8493-92286d264446","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_0159TuwYWiUEGkgmCcF3N4Qr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TkVtysvCFujzhcbZJdK655","name":"Bash","input":{"command":"erk pr submit 2>&1","description":"Submit PR via erk"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":242,"cache_read_input_tokens":128355,"cache_creation":{"ephemeral_5m_input_tokens":242,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJAoSPxPcMdSTwe4o8N","type":"assistant","uuid":"ae387a97-171e-4760-94ad-609566dd9496","timestamp":"2026-02-22T14:52:28.555Z"}
{"parentUuid":"ae387a97-171e-4760-94ad-609566dd9496","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TkVtysvCFujzhcbZJdK655","type":"tool_result","content":"🚀 Submitting PR...\n\nPhase 1: Creating or Updating PR\n   PR #7854 found (already exists)\n\nPhase 2: Getting diff\n\nPhase 3: Fetching plan context\n   Incorporating plan from issue #7854\n\nPhase 4: Generating PR description\n   Reading diff file...\n   Diff loaded (48,661 chars)\n   Analyzing changes with Claude...\n   PR description generated\n\nPhase 5: Graphite enhancement\n\nPhase 6: Updating PR metadata\n   Publishing draft PR...\n   PR metadata updated\n\n✅ \u001b]8;;https://github.com/dagster-io/erk/pull/7854\u001b\\https://github.com/dagster-io/erk/pull/7854\u001b]8;;\u001b\\","is_error":false}]},"uuid":"8b34eaa7-3b91-40ce-b532-ae39ee4ee0bd","timestamp":"2026-02-22T14:52:45.173Z","toolUseResult":{"stdout":"🚀 Submitting PR...\n\nPhase 1: Creating or Updating PR\n   PR #7854 found (already exists)\n\nPhase 2: Getting diff\n\nPhase 3: Fetching plan context\n   Incorporating plan from issue #7854\n\nPhase 4: Generating PR description\n   Reading diff file...\n   Diff loaded (48,661 chars)\n   Analyzing changes with Claude...\n   PR description generated\n\nPhase 5: Graphite enhancement\n\nPhase 6: Updating PR metadata\n   Publishing draft PR...\n   PR metadata updated\n\n✅ \u001b]8;;https://github.com/dagster-io/erk/pull/7854\u001b\\https://github.com/dagster-io/erk/pull/7854\u001b]8;;\u001b\\","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"8b34eaa7-3b91-40ce-b532-ae39ee4ee0bd","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01EMthmWeuhWyERM2sMLdYNT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Xxc4vHj3ZNA7B5hMEJ9hha","name":"Bash","input":{"command":"erk exec impl-signal submitted 2>/dev/null || true","description":"Signal PR submitted"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":612,"cache_read_input_tokens":128597,"cache_creation":{"ephemeral_5m_input_tokens":612,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJCHmkyXpVfqPnCAhMj","type":"assistant","uuid":"9f91831c-faaf-486a-b300-b0b372ea2d91","timestamp":"2026-02-22T14:52:48.377Z"}
{"parentUuid":"9f91831c-faaf-486a-b300-b0b372ea2d91","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Xxc4vHj3ZNA7B5hMEJ9hha","type":"tool_result","content":"{\n  \"success\": true,\n  \"event\": \"submitted\",\n  \"issue_number\": 7854\n}","is_error":false}]},"uuid":"2fbe06d0-2a77-4cc1-9695-b827e408d41d","timestamp":"2026-02-22T14:52:51.547Z","toolUseResult":{"stdout":"{\n  \"success\": true,\n  \"event\": \"submitted\",\n  \"issue_number\": 7854\n}","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"2fbe06d0-2a77-4cc1-9695-b827e408d41d","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_011Lzj6aMUdz9v4e4redEGkk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ExiGurHWeP3vDSR3VH4bRs","name":"Bash","input":{"command":"erk pr check 2>&1","description":"Validate PR rules"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":123,"cache_read_input_tokens":129209,"cache_creation":{"ephemeral_5m_input_tokens":123,"ephemeral_1h_input_tokens":0},"output_tokens":19,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJCkz7VZjgdL63ZpTXX","type":"assistant","uuid":"12f8fb85-3a0e-422c-aefb-b8069e557ac2","timestamp":"2026-02-22T14:52:54.663Z"}
{"parentUuid":"12f8fb85-3a0e-422c-aefb-b8069e557ac2","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ExiGurHWeP3vDSR3VH4bRs","type":"tool_result","content":"Checking PR #7854 for branch planned/shorted-planned-prefix-02-22-0934...\n\n[PASS] Branch name and plan reference agree (#7854)\n[PASS] Draft PR plan — no closing reference needed\n[PASS] PR body contains checkout footer\n\nAll checks passed","is_error":false}]},"uuid":"51d376ce-0c75-4530-ae3c-4d2e21d205ea","timestamp":"2026-02-22T14:52:56.046Z","toolUseResult":{"stdout":"Checking PR #7854 for branch planned/shorted-planned-prefix-02-22-0934...\n\n[PASS] Branch name and plan reference agree (#7854)\n[PASS] Draft PR plan — no closing reference needed\n[PASS] PR body contains checkout footer\n\nAll checks passed","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"51d376ce-0c75-4530-ae3c-4d2e21d205ea","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01TpXAsQevWVuKLTKqR67wLS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01P61rAJk29vkCHZV4TGWY8L","name":"TodoWrite","input":{"todos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"completed","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"completed","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"completed","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"completed","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"completed","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"completed","activeForm":"Updating tests"},{"content":"Run CI checks","status":"completed","activeForm":"Running CI checks"},{"content":"Submit PR","status":"completed","activeForm":"Submitting PR"}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":158,"cache_read_input_tokens":129332,"cache_creation":{"ephemeral_5m_input_tokens":158,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJD6GjVRZTKkw3e22XX","type":"assistant","uuid":"79e2a846-d569-47b8-be41-1f8a10302442","timestamp":"2026-02-22T14:53:02.867Z"}
{"parentUuid":"79e2a846-d569-47b8-be41-1f8a10302442","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01P61rAJk29vkCHZV4TGWY8L","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"7a38a689-9797-4539-a906-ebfdde42ae87","timestamp":"2026-02-22T14:53:02.921Z","toolUseResult":{"oldTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"completed","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"completed","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"completed","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"completed","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"completed","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"completed","activeForm":"Updating tests"},{"content":"Run CI checks","status":"completed","activeForm":"Running CI checks"},{"content":"Submit PR","status":"in_progress","activeForm":"Submitting PR"}],"newTodos":[{"content":"Update PLANNED_PR_TITLE_PREFIX constant in constants.py","status":"completed","activeForm":"Updating PLANNED_PR_TITLE_PREFIX constant"},{"content":"Update generate_draft_pr_branch_name() in naming.py","status":"completed","activeForm":"Updating branch name generation"},{"content":"Update extract_objective_number() regex in naming.py","status":"completed","activeForm":"Updating objective number extraction regex"},{"content":"Update extract_plan_review_issue_number() in naming.py","status":"completed","activeForm":"Updating plan review issue number extraction"},{"content":"Update _add_planned_prefix() in submit.py","status":"completed","activeForm":"Updating planned prefix in submit.py"},{"content":"Update _add_planned_prefix() in submit_pipeline.py","status":"completed","activeForm":"Updating planned prefix in submit_pipeline.py"},{"content":"Update git-pr-push.md slash command","status":"completed","activeForm":"Updating git-pr-push.md command"},{"content":"Update plan_create_review_branch.py","status":"completed","activeForm":"Updating plan review branch creation"},{"content":"Update one_shot_dispatch.py comments","status":"completed","activeForm":"Updating one-shot dispatch comments"},{"content":"Update plan_data_provider/real.py branch check","status":"completed","activeForm":"Updating plan data provider branch check"},{"content":"Update documentation files","status":"completed","activeForm":"Updating documentation files"},{"content":"Update all tests","status":"completed","activeForm":"Updating tests"},{"content":"Run CI checks","status":"completed","activeForm":"Running CI checks"},{"content":"Submit PR","status":"completed","activeForm":"Submitting PR"}]}}
{"parentUuid":"7a38a689-9797-4539-a906-ebfdde42ae87","isSidechain":false,"userType":"external","cwd":"/home/runner/work/erk/erk","sessionId":"f2ece582-4fa8-414a-a225-2cf6b588b686","version":"2.0.67","gitBranch":"planned/shorted-planned-prefix-02-22-0934","slug":"dreamy-dreaming-book","message":{"model":"claude-opus-4-6","id":"msg_01RBPR1B1DL5thiBZHjjJwBs","type":"message","role":"assistant","content":[{"type":"text","text":"Implementation complete. PR submitted at https://github.com/dagster-io/erk/pull/7854\n\n## Summary\n\nChanged the `planned/` branch prefix to `plnd/` across the entire codebase (25 files):\n\n**Core changes:**\n- `PLANNED_PR_TITLE_PREFIX` constant: `\"planned/\"` → `\"plnd/\"`\n- `generate_draft_pr_branch_name()`: produces `plnd/{slug}-{timestamp}` branches\n- `plan_create_review_branch`: creates `plnd/review-{issue}-{timestamp}` branches\n- PR title prefix in both `submit.py` and `submit_pipeline.py`: `plnd/`\n- `/erk:git-pr-push` slash command: `plnd/${pr_title}`\n\n**Backward compatibility:**\n- `extract_objective_number()` regex matches `plnd/`, `planned/`, and `plan/`\n- `extract_plan_review_issue_number()` regex matches `plnd/` and `planned/`\n- `_build_worktree_mapping()` checks both `plnd/` and `planned/` prefixes\n- Tests include legacy `planned/` cases alongside new `plnd/` cases\n\n**Documentation:** Updated 6 docs files with new prefix references."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":573,"cache_read_input_tokens":129490,"cache_creation":{"ephemeral_5m_input_tokens":573,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CYPJDbdL3Udp8zFp4HrMp","type":"assistant","uuid":"12d59044-1f44-47a3-9637-3f035f53ad08","timestamp":"2026-02-22T14:53:10.760Z"}
