"""Execute deferred land operations from activation script.

This exec command performs the actual merge and cleanup operations for landing a PR.
It is called by the activation script after the user has approved the operation.

Usage:
    erk exec land-execute --pr-number=123 --branch=foo [options]

All validation happens during the validation phase (erk land). This command
executes the pre-validated operations.

Exit Codes:
    0: Success (PR merged, branch deleted)
    1: Error (merge failed, validation error)
"""

from pathlib import Path

import click

from erk.cli.commands.land_cmd import _execute_land
from erk_shared.context.helpers import require_context


@click.command(name="land-execute")
@click.option(
    "--pr-number",
    type=int,
    required=True,
    help="PR number to merge",
)
@click.option(
    "--branch",
    required=True,
    help="Branch name being landed",
)
@click.option(
    "--worktree-path",
    type=click.Path(),
    help="Path to worktree being cleaned up",
)
@click.option(
    "--is-current-branch",
    is_flag=True,
    help="Whether landing from the branch's own worktree",
)
@click.option(
    "--target-child",
    help="Target child branch for --up navigation",
)
@click.option(
    "--objective-number",
    type=int,
    help="Linked objective issue number",
)
@click.option(
    "--use-graphite",
    is_flag=True,
    help="Use Graphite for merge",
)
@click.option(
    "--pull/--no-pull",
    "pull_flag",
    default=True,
    help="Pull latest changes after landing (default: --pull)",
)
@click.option(
    "--no-delete",
    is_flag=True,
    help="Preserve the local branch and its slot assignment after landing",
)
@click.option(
    "--script",
    is_flag=True,
    help="Output activation script path (for shell integration)",
)
@click.option(
    "--up",
    "up_flag",
    is_flag=True,
    help="Navigate upstack to child branch after landing (resolves child at execution time)",
)
@click.option(
    "-f",
    "--force",
    "force_flag",
    is_flag=True,
    help="Accept flag for compatibility (execute mode always skips confirmations)",
)
@click.option(
    "--learn-plan-issue",
    "learn_plan_issue",
    type=int,
    default=None,
    help="Plan issue number for learn workflow dispatch",
)
@click.option(
    "--learn-gist-url",
    "learn_gist_url",
    type=str,
    default=None,
    help="Gist URL with preprocessed sessions for learn workflow",
)
@click.option(
    "--learn-implement",
    "learn_implement",
    is_flag=True,
    help="Auto-implement resulting docs plan from learn workflow",
)
@click.pass_context
def land_execute(
    ctx: click.Context,
    *,
    pr_number: int,
    branch: str,
    worktree_path: str | None,
    is_current_branch: bool,
    target_child: str | None,
    objective_number: int | None,
    use_graphite: bool,
    pull_flag: bool,
    no_delete: bool,
    script: bool,
    up_flag: bool,
    force_flag: bool,
    learn_plan_issue: int | None,
    learn_gist_url: str | None,
    learn_implement: bool,
) -> None:
    """Execute deferred land operations.

    This command is called by the activation script generated by `erk land`.
    All validation has already been performed - this just executes the
    merge and cleanup operations.

    Confirmations are skipped because the user already approved by sourcing
    the activation script.

    The --up flag resolves the target child branch at execution time (rather than
    baking it into the script at validation time). This allows the user to change
    their stack between validation and execution.
    """
    erk_ctx = require_context(ctx)

    # Resolve --up to target child branch at execution time
    resolved_target_child = target_child
    if up_flag and target_child is None:
        repo_root = erk_ctx.git.get_repository_root(erk_ctx.cwd)
        children = erk_ctx.branch_manager.get_child_branches(repo_root, branch)
        if not children:
            raise click.ClickException(f"Cannot use --up: branch '{branch}' has no children")
        if len(children) > 1:
            children_str = ", ".join(f"'{c}'" for c in children)
            raise click.ClickException(
                f"Cannot use --up: branch '{branch}' has multiple children: {children_str}"
            )
        resolved_target_child = children[0]

    _execute_land(
        erk_ctx,
        pr_number=pr_number,
        branch=branch,
        worktree_path=Path(worktree_path) if worktree_path else None,
        is_current_branch=is_current_branch,
        target_child_branch=resolved_target_child,
        objective_number=objective_number,
        use_graphite=use_graphite,
        pull_flag=pull_flag,
        no_delete=no_delete,
        script=script,
    )

    # Dispatch learn workflow if requested
    if learn_plan_issue is not None:
        _dispatch_learn_workflow(
            plan_issue=learn_plan_issue,
            pr_number=pr_number,
            gist_url=learn_gist_url,
            auto_implement=learn_implement,
        )


def _dispatch_learn_workflow(
    *,
    plan_issue: int,
    pr_number: int,
    gist_url: str | None,
    auto_implement: bool,
) -> None:
    """Dispatch the learn-extract-dispatch workflow.

    Args:
        plan_issue: Plan issue number
        pr_number: Merged PR number
        gist_url: Gist URL with preprocessed sessions (if any)
        auto_implement: Whether to auto-implement resulting docs plan
    """
    import subprocess

    from erk_shared.output.output import user_output

    user_output("Dispatching learn workflow...")

    cmd = [
        "erk",
        "exec",
        "dispatch-learn-workflow",
        "--plan-issue",
        str(plan_issue),
        "--pr-number",
        str(pr_number),
    ]

    if gist_url is not None:
        cmd.extend(["--gist-url", gist_url])

    if auto_implement:
        cmd.append("--auto-implement")

    result = subprocess.run(cmd, capture_output=True, text=True, check=False)

    if result.returncode == 0:
        user_output("Learn workflow dispatched successfully")
    else:
        user_output(f"Warning: Failed to dispatch learn workflow: {result.stderr.strip()}")
