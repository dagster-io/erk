---
title: Branch Name Inference
last_audited: "2026-02-08 00:00 PT"
audit_result: clean
tripwires:
  - action: "changing branch naming convention (P{issue}- or plan- prefix)"
    warning: "The P{issue}- prefix (issue-based) and plan- prefix (draft-PR) are cross-cutting contracts used by branch creation, extraction functions, and PR recovery. Changing either prefix format requires updating all consumers."
  - action: "adding branch_name to plan-header at creation time"
    warning: "branch_name is intentionally omitted at creation because the branch doesn't exist yet. The plan-save → branch-create → impl-signal lifecycle requires this gap. See the temporal gap section below."
read_when:
  - "debugging missing branch_name in plan issues"
  - "implementing PR lookup from plan issues"
  - "modifying branch creation or naming conventions"
---

# Branch Name Inference

## The Temporal Gap Problem

Plan metadata (`plan-header` block) intentionally omits `branch_name` at creation time because of a temporal gap in the plan lifecycle:

1. **Plan saved** → GitHub issue created (no branch exists yet)
2. **Branch created** → User runs `erk br co --for-plan {issue}` (branch now exists)
3. **Implementation starts** → `impl-signal started` writes `branch_name` into the plan-header

The gap between steps 1 and 2 is unavoidable: the plan must exist before the branch can be named after it (the branch name contains the issue number). Attempting to set `branch_name` during save would require either predicting the branch name (fragile — the user might choose a custom name) or creating the branch immediately (wrong — the user hasn't started work yet).

## Two-Layer Resolution

When code needs to look up a PR from a plan issue, `branch_name` may be missing from metadata. The system uses two layers:

<!-- Source: src/erk/cli/commands/exec/scripts/get_pr_for_plan.py, get_pr_for_plan -->

**Layer 1 — Metadata lookup**: Read `branch_name` from the `plan-header` block. This succeeds when `impl-signal started` ran successfully.

**Layer 2 — Git context inference**: If `branch_name` is missing, check whether the current git branch matches the `P{issue_number}-` prefix. If it does, use it. This is a fail-open recovery that handles two scenarios:

- `impl-signal` never ran (user created branch manually following the naming convention)
- `impl-signal` failed (command errored but user continued working)

If neither layer produces a match, the command fails with an actionable error.

## Branch Prefix Contracts

The inference recovery depends on **cross-cutting naming contracts**. There are two branch patterns:

### Issue-Based Branches: `P{issue}-`

Branches for issue-based plans start with `P{issue_number}-`. This prefix is generated by two independent code paths that must stay in sync:

<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_issue_branch_name -->

- **Branch creation**: `generate_issue_branch_name()` produces `P{issue}-{slug}-{timestamp}` format (with optional `O{objective_id}` segment)

<!-- Source: src/erk/cli/commands/exec/scripts/get_pr_for_plan.py, get_pr_for_plan -->

- **PR recovery**: `get_pr_for_plan` checks `current_branch.startswith(f"P{issue_number}-")`

The prefix is the stable part of the contract. The slug and timestamp segments after the prefix vary, but inference only needs the prefix to establish the plan-to-branch mapping.

### Draft-PR Branches: `plan-`

Branches for draft-PR plans start with `plan-` and follow the pattern `plan-{slug}-{timestamp}` (with optional `O{objective_id}` segment). These branches have **no extractable plan ID** from the branch name alone.

<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_draft_pr_branch_name -->

- **Branch creation**: `generate_draft_pr_branch_name()` produces `plan-{slug}-{timestamp}`
- **Plan ID resolution**: `DraftPRPlanBackend.resolve_plan_id_for_branch()` uses an API call, not regex
- **Source of truth**: `plan-ref.json` is the sole source of plan ID for draft-PR branches
- **Extraction functions**: `extract_leading_issue_number()` returns `None` for `plan-` branches; `extract_objective_number()` handles both `P{issue}-O{obj}-` and `plan-O{obj}-` patterns

## When Inference Fails

Common failure scenarios and their fixes:

| Symptom                                | Cause                                                | Fix                                                                     |
| -------------------------------------- | ---------------------------------------------------- | ----------------------------------------------------------------------- |
| "plan-header has no branch_name field" | On wrong branch (e.g., `master`)                     | Switch to the plan's feature branch                                     |
| "plan-header has no branch_name field" | Branch uses non-standard name (e.g., `feature/1234`) | Rename branch to `P{issue}-...` or manually update plan-header metadata |
| "No PR found for branch"               | Branch exists but no PR was created                  | Push branch and create PR first                                         |

## Relationship to Fail-Open Pattern

This is an instance of the [fail-open pattern](../architecture/fail-open-patterns.md) with defense-in-depth:

- **Primary mechanism**: `impl-signal started` explicitly writes `branch_name` into metadata (reliable when the full workflow runs)
- **Fallback mechanism**: Pattern matching against git context (enables manual workflows and recovers from signal failures)
- **Key distinction**: The fallback isn't just error recovery — it actively enables workflows where `impl-signal` was never intended to run (e.g., implementing a plan created by another developer, or plans created before `impl-signal` existed)

## Related Documentation

- [Fail-Open Patterns](../architecture/fail-open-patterns.md) — Defense-in-depth design pattern
