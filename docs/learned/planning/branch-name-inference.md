---
title: Branch Name Inference
last_audited: "2026-02-08"
audit_result: regenerated
tripwires:
  - action: "changing branch naming convention (P{issue}- prefix)"
    warning: "The P{issue}- prefix is a cross-cutting contract used by both branch creation (naming.generate_issue_branch_name) and PR recovery (get_pr_for_plan). Changing the prefix format requires updating both sides."
  - action: "adding branch_name to plan-header at creation time"
    warning: "branch_name is intentionally omitted at creation because the branch doesn't exist yet. The plan-save → branch-create → impl-signal lifecycle requires this gap. See the temporal gap section below."
read_when:
  - "debugging missing branch_name in plan issues"
  - "implementing PR lookup from plan issues"
  - "modifying branch creation or naming conventions"
---

# Branch Name Inference

## The Temporal Gap Problem

Plan metadata (`plan-header` block) intentionally omits `branch_name` at creation time because of a temporal gap in the plan lifecycle:

1. **Plan saved** → GitHub issue created (no branch exists yet)
2. **Branch created** → User runs `erk br create --for-plan {issue}` (branch now exists)
3. **Implementation starts** → `impl-signal started` writes `branch_name` into the plan-header

The gap between steps 1 and 2 is unavoidable: the plan must exist before the branch can be named after it (the branch name contains the issue number). Attempting to set `branch_name` during save would require either predicting the branch name (fragile — the user might choose a custom name) or creating the branch immediately (wrong — the user hasn't started work yet).

## Two-Layer Resolution

When code needs to look up a PR from a plan issue, `branch_name` may be missing from metadata. The system uses two layers:

<!-- Source: src/erk/cli/commands/exec/scripts/get_pr_for_plan.py, get_pr_for_plan -->

**Layer 1 — Metadata lookup**: Read `branch_name` from the `plan-header` block. This succeeds when `impl-signal started` ran successfully.

**Layer 2 — Git context inference**: If `branch_name` is missing, check whether the current git branch matches the `P{issue_number}-` prefix. If it does, use it. This is a fail-open recovery that handles two scenarios:

- `impl-signal` never ran (user created branch manually following the naming convention)
- `impl-signal` failed (command errored but user continued working)

If neither layer produces a match, the command fails with an actionable error.

## The P{issue}- Prefix Contract

The inference recovery depends on a **cross-cutting naming contract**: branches for plan issues always start with `P{issue_number}-`. This prefix is generated by two independent code paths that must stay in sync:

<!-- Source: packages/erk-shared/src/erk_shared/naming.py, generate_issue_branch_name -->

- **Branch creation**: `generate_issue_branch_name()` produces `P{issue}-{slug}-{timestamp}` format (with optional `O{objective_id}` segment)

<!-- Source: src/erk/cli/commands/exec/scripts/get_pr_for_plan.py, get_pr_for_plan -->

- **PR recovery**: `get_pr_for_plan` checks `current_branch.startswith(f"P{issue_number}-")`

The prefix is the stable part of the contract. The slug and timestamp segments after the prefix vary, but inference only needs the prefix to establish the plan-to-branch mapping.

## When Inference Fails

Common failure scenarios and their fixes:

| Symptom | Cause | Fix |
|---|---|---|
| "plan-header has no branch_name field" | On wrong branch (e.g., `master`) | Switch to the plan's feature branch |
| "plan-header has no branch_name field" | Branch uses non-standard name (e.g., `feature/1234`) | Rename branch to `P{issue}-...` or manually update plan-header metadata |
| "No PR found for branch" | Branch exists but no PR was created | Push branch and create PR first |

## Relationship to Fail-Open Pattern

This is an instance of the [fail-open pattern](../architecture/fail-open-patterns.md) with defense-in-depth:

- **Primary mechanism**: `impl-signal started` explicitly writes `branch_name` into metadata (reliable when the full workflow runs)
- **Fallback mechanism**: Pattern matching against git context (enables manual workflows and recovers from signal failures)
- **Key distinction**: The fallback isn't just error recovery — it actively enables workflows where `impl-signal` was never intended to run (e.g., implementing a plan created by another developer, or plans created before `impl-signal` existed)

## Related Documentation

- [Fail-Open Patterns](../architecture/fail-open-patterns.md) — Defense-in-depth design pattern
